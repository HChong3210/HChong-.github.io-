<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- 代码块的高亮 -->
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- <link<! rel="stylesheet" href="/path/to/styles/default.css"> -->
  <!-- <script src="/path/to/highlight.pack.js"></script> -->
  <!-- <script>hljs.initHighlightingOnLoad();</script> -->


  <meta charset="utf-8">
  
  <title>KVO用法与自定义实现 | HChong的博客地址</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="基础知识,Runtime," />
  

  <meta name="description" content="KVO用法与自定义实现KVO用法KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知. KVO的用法在这里不做叙述, 十分简单. 首先注册, 添加一个观察者: - (void)addO">
<meta name="keywords" content="基础知识,Runtime">
<meta property="og:type" content="article">
<meta property="og:title" content="KVO用法与自定义实现">
<meta property="og:url" content="http://hchong.net/2018/01/24/KVO详解/index.html">
<meta property="og:site_name" content="HChong的博客地址">
<meta property="og:description" content="KVO用法与自定义实现KVO用法KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知. KVO的用法在这里不做叙述, 十分简单. 首先注册, 添加一个观察者: - (void)addObserver:(NSObject *)observer         for">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-03T09:54:51.007Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KVO用法与自定义实现">
<meta name="twitter:description" content="KVO用法与自定义实现KVO用法KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知. KVO的用法在这里不做叙述, 十分简单. 首先注册, 添加一个观察者: - (void)addObserver:(NSObject *)observer         for">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=d671a41f" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">戳我</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">戳我</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#KVO用法与自定义实现"><span class="toc-text">KVO用法与自定义实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO用法"><span class="toc-text">KVO用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO的原理"><span class="toc-text">KVO的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现带block回调的KVO"><span class="toc-text">如何实现带block回调的KVO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现系统自带的KVO"><span class="toc-text">如何实现系统自带的KVO</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-KVO详解" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">KVO用法与自定义实现</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.01.24</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>HChong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/基础知识/">基础知识</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="KVO用法与自定义实现"><a href="#KVO用法与自定义实现" class="headerlink" title="KVO用法与自定义实现"></a>KVO用法与自定义实现</h1><h2 id="KVO用法"><a href="#KVO用法" class="headerlink" title="KVO用法"></a>KVO用法</h2><p>KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知. KVO的用法在这里不做叙述, 十分简单. 首先注册, 添加一个观察者:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)addObserver:(NSObject *)observer</div><div class="line">         forKeyPath:(NSString *)keyPath</div><div class="line">            options:(NSKeyValueObservingOptions)options</div><div class="line">            context:(void *)context</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>observer: 观察者，负责处理监听事件的对象, 注册 KVO 通知的对象。观察者必须实现 key-value observing 方法 observeValueForKeyPath:ofObject:change:context:</p>
</li>
<li><p>keyPath: 要监听的属性, 观察者的属性的 keypath，相对于接受者，值不能是 nil。</p>
</li>
<li><p>options: 观察的选项(观察新、旧值，也可以都观察), NSKeyValueObservingOptions 的组合，它指定了观察通知中包含了什么，可以查看 “NSKeyValueObservingOptions”。</p>
</li>
<li><p>context: 上下文，用于传递数据，可以利用上下文区分不同的监听, 在 observeValueForKeyPath:ofObject:change:context: 传给 observer 参数的随机数据</p>
</li>
</ul>
</blockquote>
<p>当 keyPath 的值改变的时候这个方法会被调用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>keyPath 监听的属性名</p>
</li>
<li><p>object  属性所属的对象</p>
</li>
<li><p>change  属性的修改情况（属性原来的值<code>oldValue</code>、属性最新的值<code>newValue</code>）</p>
</li>
<li><p>context 传递的上下文数据，与监听的时候传递的一致，可以利用上下文区分不同的监听</p>
</li>
</ul>
</blockquote>
<p>当一个观察者完成了监听一个对象的改变, 经常在 <code>-observeValueForKeyPath:ofObject:change:context:</code>，或者 <code>-dealloc</code> 中调用注销监听的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)removeObserver:(NSObject *)anObserver</div><div class="line">            forKeyPath:(NSString *)keyPath</div></pre></td></tr></table></figure>
<hr>
<p>这里有几个特殊的方法需要着重说明一下, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)willChangeValueForKey:(NSString *)key;</div><div class="line">- (void)didChangeValueForKey:(NSString *)key;</div><div class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;</div></pre></td></tr></table></figure>
<p><code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>默认是在setter方法中实现的, 用KVO做键值观察后, 系统会在运行时重写属性的set方法, 并且在赋值前后分别调用.</p>
<p><code>automaticallyNotifiesObserversForKey:</code>控制是否自动发送通知, 如果返回NO, KVO无法自动运作, 需手动触发.</p>
<h2 id="KVO的原理"><a href="#KVO的原理" class="headerlink" title="KVO的原理"></a>KVO的原理</h2><p>KVO 的实现也依赖于 Objective-C 强大的 Runtime. Apple 的文档有简单提到过 KVO 的实现: </p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>概述下KVO的实现就是: </p>
<p>当你观察一个对象时, 会动态创建一个新的类. 这个类继承自该对象的原本的类, 并重写了被观察属性的 setter 方法. 自然, 重写的 setter 方法会负责在调用原 setter 方法之前和之后, 通知所有观察对象值的更改. 最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类, 对象就神奇的变成了新创建的子类的实例. 这个中间类, 继承自原本的那个类. 不仅如此, Apple 还重写了 -class 方法, 企图欺骗我们这个类没有变, 就是原本那个类.</p>
<h2 id="如何实现带block回调的KVO"><a href="#如何实现带block回调的KVO" class="headerlink" title="如何实现带block回调的KVO"></a>如何实现带block回调的KVO</h2><p> 根据Apple的官方文档, 我们不难发现自定义KVO需要的几个步骤:</p>
<ol>
<li><p>创建注册子类, 重写子类的class方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//1.创建注册子类</div><div class="line">//1.1获取被监听对象的类名称</div><div class="line">Class class = object_getClass(self);</div><div class="line">NSString *className = NSStringFromClass(class);</div><div class="line">//1.2检查被检测对象的class的前缀是否被替换过(通过检查前缀来判断), 如果被替换过就说明正在被观测</div><div class="line">if (![className hasPrefix:kHCKVOClassPrefix]) &#123;</div><div class="line">    class = [self makeKvoClassWithOriginalClassName:className];</div><div class="line">    //为观测的对象设置一个指定的类</div><div class="line">    object_setClass(self, class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>为新的子类添加set方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> //2.为新的子类添加set方法</div><div class="line">//2.1得到Setter方法</div><div class="line">SEL setterSelector = NSSelectorFromString(setterForGetter(key));</div><div class="line">//2.2得到指定类的实例方法</div><div class="line">Method setterMethod = class_getInstanceMethod([self class], setterSelector);</div><div class="line">if (!setterMethod) &#123;</div><div class="line">    @throw @&quot;没有对应的Setter方法&quot;;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">//2.3为新类添加set方法</div><div class="line">if (![self hasSelector:setterSelector]) &#123;</div><div class="line">    const char *types = method_getTypeEncoding(setterMethod);</div><div class="line">    class_addMethod(class, setterSelector, (IMP)kvo_setter, types);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>改变isa指针, 指向新的子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//3改变isa指针，指向子类</div><div class="line">object_setClass(self, class);</div></pre></td></tr></table></figure>
</li>
<li><p>保存set, get方法, 保存block</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//保存set、get方法名</div><div class="line">    objc_setAssociatedObject(self, kHCKVO_getter_key, key, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(self, kHCKVO_setter_key, setterForGetter(key), OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    //保存block</div><div class="line">    objc_setAssociatedObject(self, kHCKVO_block_key, block, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里面主要的难点在重写属性的set方法, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//新类的set方法</div><div class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</div><div class="line">    //包括调用父类的set方法，获取旧值、新值，获取observer并通知observer</div><div class="line">    NSString *setterName = NSStringFromSelector(_cmd);</div><div class="line">    NSString *getterName = getterForSetter(setterName);</div><div class="line">    </div><div class="line">    if (!getterName) &#123;</div><div class="line">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have getter %@&quot;, self, setterName];</div><div class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class="line">                                       reason:reason</div><div class="line">                                     userInfo:nil];</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /*</div><div class="line">     //使用objc_msgSendSuper向父类发消息, 调用父类set方法</div><div class="line">    id oldValue = [self valueForKey:getterName];</div><div class="line">    </div><div class="line">    //superclass</div><div class="line">    struct objc_super superclazz = &#123;</div><div class="line">        .receiver = self,</div><div class="line">        .super_class = class_getSuperclass(object_getClass(self))</div><div class="line">    &#125;;</div><div class="line">    // cast our pointer so the compiler won&apos;t complain</div><div class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper;</div><div class="line">    // call super&apos;s setter, which is original class&apos;s setter method</div><div class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</div><div class="line">     */</div><div class="line">    </div><div class="line">    </div><div class="line">    //保存子类类型</div><div class="line">    Class class = [self class];</div><div class="line">    //isa指向原类</div><div class="line">    object_setClass(self, class_getSuperclass(class));</div><div class="line">    //调用原类get方法，获取oldValue</div><div class="line">    id oldValue = objc_msgSend(self, NSSelectorFromString(getterName));</div><div class="line">    //调用原类set方法</div><div class="line">    objc_msgSend(self, _cmd, newValue);</div><div class="line">    //isa改回子类类型</div><div class="line">    object_setClass(self, class);</div><div class="line"></div><div class="line">    </div><div class="line">    //取出block</div><div class="line">    HCObservingBlock block = objc_getAssociatedObject(self, kHCKVO_block_key);</div><div class="line">    block(self, getterName, oldValue, newValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中, 关于调用父类的set方法有两种方式. 一种是直接向新类的superClass发送消息, 另外一种是先改变isa指向superclass, 调用完set方法后重新再改变isa指向新类.</p>
<h2 id="如何实现系统自带的KVO"><a href="#如何实现系统自带的KVO" class="headerlink" title="如何实现系统自带的KVO"></a>如何实现系统自带的KVO</h2><p>系统自带KVO的实现方法和自定义带block回调的KVO的实现方法一样, 不同的是我们在重写新类的set方法中不是调用父类的set方法, 而是调用父类的<code>observeValueForKeyPath: ofObject: change: context:</code>方法.</p>
<hr>
<p>完整代码查看<a href="https://github.com/HChong3210/HCKVO" target="_blank" rel="noopener">这里</a></p>
<hr>
<p>参考资料:<br>1.<a href="http://nshipster.cn/key-value-observing/" target="_blank" rel="noopener">Key-Value Observing</a></p>
<p>2.<a href="https://draveness.me/kvocontroller" target="_blank" rel="noopener">如何优雅地使用 KVO</a></p>
<p>3.<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a></p>
<p>4.<a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="noopener">如何自己动手实现 KVO</a></p>

    
  </div>
  
    
<!-- Gitalk评论插件通用代码 -->
<div id="git"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '46ee1ac76ef8ec89628d',
  clientSecret: '504604af3c2054d744fef5c3932174d1c29a4d5b',
  repo: 'MyBlogComment',
  owner: 'HChong210',
  admin: ['HChong210'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('git')
</script>
<!-- Gitalk代码结束 -->

  
</article>

</div>








  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
