<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- 代码块的高亮 -->
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- <link<! rel="stylesheet" href="/path/to/styles/default.css"> -->
  <!-- <script src="/path/to/highlight.pack.js"></script> -->
  <!-- <script>hljs.initHighlightingOnLoad();</script> -->


  <meta charset="utf-8">
  
  <title>iOS开发基础-Category &amp; Extension | HChong的博客地址</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="基础知识,">
  

  <meta name="description" content="Category和Extension是iOS开发中常见的两种语言特性. 下面就介绍一下. 1 CategoryCategory是Objective-C 2.0之后添加的语言特性, Category的主要使用场景有下面几种:  为已经存在的类添加方法, 属性, 协议等 可以把类的实现分开在几个不同的文件里面. 这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的C">
<meta name="keywords" content="基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发基础-Category &amp; Extension">
<meta property="og:url" content="http://hchong.net/2018/10/24/iOS开发基础-Category-Extension/index.html">
<meta property="og:site_name" content="HChong的博客地址">
<meta property="og:description" content="Category和Extension是iOS开发中常见的两种语言特性. 下面就介绍一下. 1 CategoryCategory是Objective-C 2.0之后添加的语言特性, Category的主要使用场景有下面几种:  为已经存在的类添加方法, 属性, 协议等 可以把类的实现分开在几个不同的文件里面. 这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的C">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://img.souche.com/f2e/22b0bc484d5bb5354c7dd580b3e5a0ab.png">
<meta property="og:image" content="http://img.souche.com/f2e/f8ad0648bbbc7ef5c35d4a684544c1d5.png">
<meta property="og:updated_time" content="2019-07-25T12:08:17.010Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发基础-Category &amp; Extension">
<meta name="twitter:description" content="Category和Extension是iOS开发中常见的两种语言特性. 下面就介绍一下. 1 CategoryCategory是Objective-C 2.0之后添加的语言特性, Category的主要使用场景有下面几种:  为已经存在的类添加方法, 属性, 协议等 可以把类的实现分开在几个不同的文件里面. 这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的C">
<meta name="twitter:image" content="http://img.souche.com/f2e/22b0bc484d5bb5354c7dd580b3e5a0ab.png">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-143601576-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?fbe237c14d5a4a92186f32fb70f9d87d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>
</html>
<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">戳我</span>
  

  <div class="post-header LEFT">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">戳我</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Category"><span class="toc-text">1 Category</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-category特点"><span class="toc-text">1.1 category特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-调用优先级"><span class="toc-text">1.2 调用优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-为什么category不能添加成员变量"><span class="toc-text">1.3 为什么category不能添加成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-category中能添加属性吗"><span class="toc-text">1.4 category中能添加属性吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-category的加载"><span class="toc-text">1.5 category的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-同名category优先级"><span class="toc-text">1.5 同名category优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-load和initialize的调用顺序"><span class="toc-text">1.6 load和initialize的调用顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-category和方法覆盖"><span class="toc-text">1.7 category和方法覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-category和关联对象"><span class="toc-text">1.7 category和关联对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Extension"><span class="toc-text">2 Extension</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Category-vs-Extension"><span class="toc-text">3 Category vs Extension</span></a></li></ol>
  </div>



<div class="content content-post LEFT">
   <article id="post-iOS开发基础-Category-Extension" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">iOS开发基础-Category &amp; Extension</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.10.24</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>HChong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/iOS开发-基础/">iOS开发-基础</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
    </div>
  </header>

  <div class="article-content">
    
      <p>Category和Extension是iOS开发中常见的两种语言特性. 下面就介绍一下.</p>
<h1 id="1-Category"><a href="#1-Category" class="headerlink" title="1 Category"></a>1 Category</h1><p>Category是Objective-C 2.0之后添加的语言特性, Category的主要使用场景有下面几种:</p>
<ul>
<li>为已经存在的类添加方法, 属性, 协议等</li>
<li>可以把类的实现分开在几个不同的文件里面. 这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的Category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的Category 等等</li>
<li>声明私有方法(只在需要的地方引入分类，即可调用分类中的方法，不引用该分类的就无法调用（重写原类方法的除外))</li>
<li>模拟多继承(分类中声明别的类中的方法，不实现，通过消息转发实现调用)</li>
<li>把framework的私有方法公开(只要知道Framework中私有方法的声明，那么可以在分类中声明Framework中的私有方法，这样可以在需要的地方引入这个分类，就可以调用到Framework中的私有方法了)</li>
</ul>
<h2 id="1-1-category特点"><a href="#1-1-category特点" class="headerlink" title="1.1 category特点"></a>1.1 category特点</h2><ul>
<li>category只能给某个已有的类扩充方法，不能扩充成员变量。</li>
<li>category中也可以添加属性，只不过@property只会生成setter和getter的声明，不会生成setter和getter的实现以及成员变量。</li>
<li>如果category中的方法和类中原有方法同名，运行时会优先调用category中的方法。也就是，category中的方法会覆盖掉类中原有的方法。所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同。避免出现这种情况的解决方案是给分类的方法名统一添加前缀。比如category_。</li>
<li>如果多个category中存在同名的方法，运行时到底调用哪个方法由编译器决定，最后一个参与编译的方法会被调用</li>
</ul>
<h2 id="1-2-调用优先级"><a href="#1-2-调用优先级" class="headerlink" title="1.2 调用优先级"></a>1.2 调用优先级</h2><p>分类(category) &gt; 本类 &gt; 父类。即，优先调用cateory中的方法，然后调用本类方法，最后调用父类方法. </p>
<p>注意：category是在运行时加载的，不是在编译时.</p>
<h2 id="1-3-为什么category不能添加成员变量"><a href="#1-3-为什么category不能添加成员变量" class="headerlink" title="1.3 为什么category不能添加成员变量"></a>1.3 为什么category不能添加成员变量</h2><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p>
<pre><code>typedef struct objc_class *Class;
</code></pre><p>objc_class结构体的定义如下：</p>
<pre><code>struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;
    #if !__OBJC2__
    Class super_class                       OBJC2_UNAVAILABLE;  // 父类
    const char *name                        OBJC2_UNAVAILABLE;  // 类名
    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小
    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表
    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表
    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表
    #endif
} OBJC2_UNAVAILABLE;
</code></pre><p>在上面的objc_class结构体中，ivars是objc_ivar_list（成员变量列表）指针；methodLists是指向objc_method_list指针的指针。在Runtime中，objc_class结构体大小是固定的，不可能往这个结构体中添加数据，只能修改。所以ivars指向的是一个固定区域，只能修改成员变量值，不能增加成员变量个数。methodList是一个二维数组，所以可以修改*methodLists的值来增加成员方法，虽没办法扩展methodLists指向的内存区域，却可以改变这个内存区域的值（存储的是指针）。因此，可以动态添加方法，不能添加成员变量。</p>
<h2 id="1-4-category中能添加属性吗"><a href="#1-4-category中能添加属性吗" class="headerlink" title="1.4 category中能添加属性吗?"></a>1.4 category中能添加属性吗?</h2><p>Category不能添加成员变量（instance variables），那到底能不能添加属性（property）呢? 这个我们要从Category的结构体开始分析: </p>
<pre><code>typedef struct category_t {
    const char *name;  //类的名字
    classref_t cls;  //类
    struct method_list_t *instanceMethods;  //category中所有给类添加的实例方法的列表
    struct method_list_t *classMethods;  //category中所有添加的类方法的列表
    struct protocol_list_t *protocols;  //category实现的所有协议的列表
    struct property_list_t *instanceProperties;  //category中添加的所有属性
} category_t;
</code></pre><p>从Category的定义也可以看出Category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>
<p>但是为什么网上很多人都说Category不能添加属性呢? 实际上，Category实际上允许添加属性的，同样可以使用@property，但是不会生成_变量（带下划线的成员变量），也不会生成添加属性的getter和setter方法的实现，所以，尽管添加了属性，也无法使用点语法调用getter和setter方法(实际上，点语法是可以写的，只不过在运行时调用到这个方法时候会报方法找不到的错误). 但实际上可以使用runtime去实现Category为已有的类添加新的属性并生成getter和setter方法</p>
<h2 id="1-5-category的加载"><a href="#1-5-category的加载" class="headerlink" title="1.5 category的加载"></a>1.5 category的加载</h2><p>Objective-C的运行是依赖OC的runtime的, 而OC的runtime和其他系统库一样, 是OS X和iOS通过dyld动态加载的.</p>
<p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法. 在_read_images方法的结尾:</p>
<ul>
<li>会把category的实例方法、协议以及属性添加到类上(category的各种列表是怎么最终添加到类上的, 以实例方法列表来说: 在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的方法) </li>
<li>把category的类方法和协议添加到类的metaclass上(对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法. attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法)</li>
</ul>
<p>综上我们可以发现: </p>
<ul>
<li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA.</li>
<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法</li>
</ul>
<h2 id="1-5-同名category优先级"><a href="#1-5-同名category优先级" class="headerlink" title="1.5 同名category优先级"></a>1.5 同名category优先级</h2><ul>
<li>如果同名方法只存在在category中, 后编译的先被访问.</li>
<li>原类的方法和category中的方法同名, 原类的方法会被category的直接”覆盖”, 如果存在于多个category中则参考第一条.</li>
</ul>
<h2 id="1-6-load和initialize的调用顺序"><a href="#1-6-load和initialize的调用顺序" class="headerlink" title="1.6 load和initialize的调用顺序"></a>1.6 load和initialize的调用顺序</h2><p>关于load和initialize的相关信息, 可以看<a href="http://hchong.net/2019/07/24/iOS%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-load-initialize/">这里</a>. 在MyClass及其分类中都添加这两个方法，只不过打印不同. </p>
<pre><code>+(void)load {
    NSLog(@&quot;MyClass:%s&quot;,__func__);
}
+(void)initialize {
    NSLog(@&quot;MyClass:%s&quot;,__func__);
}
</code></pre><p><img src="http://img.souche.com/f2e/22b0bc484d5bb5354c7dd580b3e5a0ab.png" alt="load"><br>load方法，文件镜像被读取时调用，直观的表现是程序刚运行就会看到打印结果. 从上图可以看到, load的执行顺序是先类，后category, 而category的+load执行顺序是根据编译顺序决定的.</p>
<p>附加category到类的工作会先于+load方法的执行. 因为category被附加到类上面是在map_images的时候发生的.</p>
<p><img src="http://img.souche.com/f2e/f8ad0648bbbc7ef5c35d4a684544c1d5.png" alt="initialize"><br>从上图可以看到, initialize函数后编译的先被访问, 原类的方法会被分类的”覆盖”.(因为initialize只有在第一次被使用是会调用一次且仅一次，所以其他与普通方法相同).</p>
<h2 id="1-7-category和方法覆盖"><a href="#1-7-category和方法覆盖" class="headerlink" title="1.7 category和方法覆盖"></a>1.7 category和方法覆盖</h2><p>category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法:</p>
<pre><code>Class currentClass = [MyClass class];
MyClass *my = [[MyClass alloc] init];

if (currentClass) {
    unsigned int methodCount;
    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);
    IMP lastImp = NULL;
    SEL lastSel = NULL;
    for (NSInteger i = 0; i &lt; methodCount; i++) {
        Method method = methodList[i];
        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) 
                                        encoding:NSUTF8StringEncoding];
        if ([@&quot;printName&quot; isEqualToString:methodName]) {
            lastImp = method_getImplementation(method);
            lastSel = method_getName(method);
        }
    }
    typedef void (*fn)(id,SEL);

    if (lastImp != NULL) {
        fn f = (fn)lastImp;
        f(my,lastSel);
    }
    free(methodList);
}
</code></pre><h2 id="1-7-category和关联对象"><a href="#1-7-category和关联对象" class="headerlink" title="1.7 category和关联对象"></a>1.7 category和关联对象</h2><p>category里面是无法为category添加实例变量的. 但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现. 因为在分类中 @property 并不会自动生成实例变量以及存取方法，所以一般使用关联对象为已经存在的类添加属性, 这样我们通过category新增的属性就会存在与之对应的实例变量和存取方法.</p>
<p>对象关联详解可以看<a href="https://draveness.me/ao" target="_blank" rel="noopener">这里</a>;</p>
<p>MyClass+Category1.h:</p>
<pre><code>#import &quot;MyClass.h&quot;

@interface MyClass (Category1)

@property(nonatomic,copy) NSString *name;

@end
</code></pre><p>MyClass+Category1.m:</p>
<pre><code>#import &quot;MyClass+Category1.h&quot;
#import &lt;objc/runtime.h&gt;

@implementation MyClass (Category1)

+ (void)load
{
    NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);
}

- (void)setName:(NSString *)name
{
    objc_setAssociatedObject(self,
                             &quot;name&quot;,
                             name,
                             OBJC_ASSOCIATION_COPY);
}

- (NSString*)name
{
    NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);
    return nameObject;
}

@end
</code></pre><p>对象销毁时候如何处理关联对象呢? </p>
<p>所有的关联对象都由AssociationsManager管理. AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对.</p>
<p>runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作.</p>
<h1 id="2-Extension"><a href="#2-Extension" class="headerlink" title="2 Extension"></a>2 Extension</h1><p>Extension被开发者称之为扩展、延展、匿名分类。Extension看起来很像一个匿名的Category，但是Extension和Category几乎完全是两个东西. Extension的主要使用场景有下面几种:</p>
<ul>
<li>声明私有属性</li>
<li>声明私有方法</li>
<li>声明私有成员变量</li>
</ul>
<h1 id="3-Category-vs-Extension"><a href="#3-Category-vs-Extension" class="headerlink" title="3 Category vs Extension"></a>3 Category vs Extension</h1><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension. 除非创建子类再添加extension。而category不需要有类的源码，我们可以给系统提供的类添加category.</p>
<p>但是category则完全不一样，它是在运行期决议的。 就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的(因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的).</p>
<p>extension和category都可以添加属性，但是category的属性不能生成成员变量和getter、setter方法的实现.</p>
<table>
<thead>
<tr>
<th>扩展的特点</th>
<th>分类的特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>编译时决议</td>
<td>运行时决议</td>
</tr>
<tr>
<td>只能以声明的形式存在，多数情况下寄生于宿主类的.m中</td>
<td>分类有声明也有实现</td>
</tr>
<tr>
<td>不能为系统类添加扩展</td>
<td>可以为系统类添加分类</td>
</tr>
<tr>
<td>可以添加实例变量</td>
<td>不可以添加实例变量(因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的)</td>
</tr>
</tbody>
</table>
<hr>
<p>参考资料:<br>1.<a href="http://www.cocoachina.com/articles/19163" target="_blank" rel="noopener">【iOS】Category VS Extension 原理详解</a><br>2.<a href="http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/" target="_blank" rel="noopener">巧用 Class Extension 分离接口依赖</a><br>3.<a href="https://tech.meituan.com/2015/03/03/diveintocategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a><br>4.<a href="https://leoliuyt.github.io/2018/05/20/%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">运行时之二：分类</a><br>5.<a href="https://draveness.me/ao" target="_blank" rel="noopener">关联对象 AssociatedObject 完全解析</a><br>6.<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p>

    
    <span class="asdf">
      <style type="text/css">
      asdf{margin-top:20}
      </style>
      </span>
  </div>
  
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/09/13/iOS开发基础-hash-isEqual/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/11/08/iOS开发基础-load-initialize/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




  
    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '46ee1ac76ef8ec89628d',
  clientSecret: '504604af3c2054d744fef5c3932174d1c29a4d5b',
  repo: 'HChong3210.github.io',
  owner: 'HChong3210',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: decodeURI(location.pathname),
  admin: 'HChong3210',
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  
</article>


   

</div>





  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '46ee1ac76ef8ec89628d',
  clientSecret: '504604af3c2054d744fef5c3932174d1c29a4d5b',
  repo: 'HChong3210.github.io',
  owner: 'HChong3210',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: decodeURI(location.pathname),
  admin: 'HChong3210',
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
