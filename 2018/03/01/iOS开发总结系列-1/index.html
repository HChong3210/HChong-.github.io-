<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- 代码块的高亮 -->
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- <link<! rel="stylesheet" href="/path/to/styles/default.css"> -->
  <!-- <script src="/path/to/highlight.pack.js"></script> -->
  <!-- <script>hljs.initHighlightingOnLoad();</script> -->


  <meta charset="utf-8">
  
  <title>iOS开发总结系列-1 | 我的博客地址</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="基础知识," />
  

  <meta name="description" content="常见的问题, 在这里做一个汇总. 只讲结论, 内部细节, 慢慢填坑. 什么情况使用 weak 关键字，相比 assign 有什么不同weak常用在有可能出现循环引用的地方, 他表示一种非拥有关系, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 与assign类似, 但是不同的是当属性所指的对象被释放时">
<meta name="keywords" content="基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发总结系列-1">
<meta property="og:url" content="http://hchong.net/2018/03/01/iOS开发总结系列-1/index.html">
<meta property="og:site_name" content="我的博客地址">
<meta property="og:description" content="常见的问题, 在这里做一个汇总. 只讲结论, 内部细节, 慢慢填坑. 什么情况使用 weak 关键字，相比 assign 有什么不同weak常用在有可能出现循环引用的地方, 他表示一种非拥有关系, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 与assign类似, 但是不同的是当属性所指的对象被释放时, 属性值会被置为nil, 而assign只执行基础类型的简单赋值操作.  we">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-27T10:09:01.336Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发总结系列-1">
<meta name="twitter:description" content="常见的问题, 在这里做一个汇总. 只讲结论, 内部细节, 慢慢填坑. 什么情况使用 weak 关键字，相比 assign 有什么不同weak常用在有可能出现循环引用的地方, 他表示一种非拥有关系, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 与assign类似, 但是不同的是当属性所指的对象被释放时, 属性值会被置为nil, 而assign只执行基础类型的简单赋值操作.  we">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=d671a41f" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">戳我</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">戳我</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么情况使用-weak-关键字，相比-assign-有什么不同"><span class="toc-text">什么情况使用 weak 关键字，相比 assign 有什么不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么用-copy-关键字"><span class="toc-text">怎么用 copy 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的copy与mutableCopy"><span class="toc-text">对象的copy与mutableCopy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime-如何实现-weak-属性"><span class="toc-text">runtime 如何实现 weak 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><span class="toc-text">@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#protocol-和-category-中如何使用-property"><span class="toc-text">@protocol 和 category 中如何使用 @property</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><span class="toc-text">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synthesize和-dynamic分别有什么作用"><span class="toc-text">@synthesize和@dynamic分别有什么作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block-vs-weak"><span class="toc-text">block vs weak</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用nonatomic线程不安全"><span class="toc-text">使用nonatomic线程不安全</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-iOS开发总结系列-1" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">iOS开发总结系列-1</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.03.01</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>HChong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/基础知识/">基础知识</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://www.hchong.net/2018/03/01/iOS开发总结系列-1/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>常见的问题, 在这里做一个汇总. 只讲结论, 内部细节, 慢慢填坑.</p>
<h2 id="什么情况使用-weak-关键字，相比-assign-有什么不同"><a href="#什么情况使用-weak-关键字，相比-assign-有什么不同" class="headerlink" title="什么情况使用 weak 关键字，相比 assign 有什么不同"></a>什么情况使用 weak 关键字，相比 assign 有什么不同</h2><p>weak常用在有可能出现循环引用的地方, 他表示一种非拥有关系, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 与assign类似, 但是不同的是当属性所指的对象被释放时, 属性值会被置为nil, 而assign只执行基础类型的简单赋值操作. </p>
<p>weak必须用于OC对象类型, assign可以用于基础类型.</p>
<h2 id="怎么用-copy-关键字"><a href="#怎么用-copy-关键字" class="headerlink" title="怎么用 copy 关键字"></a>怎么用 copy 关键字</h2><ol>
<li>NSString, NSArray, NSDictionary 等等经常使用copy关键字, 是因为他们有对应的可变类型: NSMutableString, NSMutableArray, NSMutableDictionary. </li>
<li>若想令自己所写的对象具有拷贝功能要实现NSCopying. 如果自定义的对象分为可变版本与不可变版本, 那么就要同时实现 NSCopying 与 NSMutableCopying 协议.</li>
<li>block 也经常使用 copy 关键字. </li>
</ol>
<p>对可变对象进行copy, 返回的会是一个不可变对象, 并不是一般意义上的copy行为, 因为copy后的对象类型不同了.<br>对可变对象进行mutableCopy, 返回的是另一个可变对象, 这种才是copy行为, 两个对象内容一样, 类型一样, 地址不同.<br>对不可变对象进行copy, 系统不会再创建对象, 而是直接返回源对象地址.<br>对不可变对象进行mutableCopy则返回一个可变对象, 同样不是一般意义上的copy.</p>
<p>block使用关键字copy是MRC时代的产物, 因为Block有三种类型, _NSConcreteStackBlock, _NSConcreteGlobalBlock, _NSConcreteMallocBlock. 由于_NSConcreteStackBlock存储在栈上面, 一旦返回之后所属的变量域一旦结束, 就被系统销毁了, 所以他是不安全的, 我们通过copy属性可以把它存储在堆上面, 生命周期我们就可以控制了. 在 MRC 中, 方法内部的 block 是在栈区的, 使用 copy 可以把它放到堆区. 在 ARC 中写不写都行: 对于 block 使用 copy 还是 strong 效果是一样的. 可以参考<a href="http://hchong.net/2017/07/04/Block%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">这里</a>.</p>
<h2 id="对象的copy与mutableCopy"><a href="#对象的copy与mutableCopy" class="headerlink" title="对象的copy与mutableCopy"></a>对象的copy与mutableCopy</h2><p>在集合类对象中, 对不可变对象进行 copy, 是指针复制(浅copy), mutableCopy 是内容复制(深copy); 对可变对象进行 copy 和 mutableCopy 都是内容复制(深copy). 但是集合对象的内容复制仅限于对象本身, 对象元素仍然是指针复制. </p>
<p>可以参考<a href="http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/">这里</a>.</p>
<h2 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h2><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship). 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 此特质同 assign 类似, 然而在属性所指的对象遭到摧毁时, 属性值也会清空(nil out).</p>
<p>Runtime维护了一个weak表, 用于存储指向某个对象的所有weak指针. weak表其实是一个hash表, Key是所指对象的地址, Value是weak指针的地址(这个地址的值是所指对象的地址)数组. 当此对象的引用计数为0的时候会 dealloc, 假如 weak 指向的对象内存地址是a, 那么就会以a为键, 在这个 weak 表中搜索, 找到所有以a为键的 weak 对象, 从而设置为 nil. </p>
<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil, ARC 会自动帮我们处理.</p>
<p>详细的可以看<a href="http://www.cocoachina.com/ios/20170328/18962.html" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><a href="#property中有哪些属性关键字？-property-后面可以有哪些修饰符？" class="headerlink" title="@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？"></a>@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h2><ol>
<li>原子性: nonatomic, atomic(默认值).</li>
<li>读/写权限: readwrite(默认值), readonly.</li>
<li>内存管理: assign, strong, weak, unsafe_unretained, copy.</li>
<li>方法名: getter, setter.</li>
<li>其他: nonnull, null_resettable, nullable.</li>
</ol>
<p>基本数据类型默认关键字: atomic, assign, readwrite. 对象类型默认关键字: atomic, strong, readwrite.</p>
<p>atomic 会加一个@synchronized()锁, 并且引用计数会 +1, 来向调用者保证这个对象会一直存在, 但是这个锁并不能保证线程安全. </p>
<h2 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="@protocol 和 category 中如何使用 @property"></a>@protocol 和 category 中如何使用 @property</h2><p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明, 我们使用属性的目的, 是希望遵守我协议的对象能实现该属性.</p>
<p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明, 如果我们真的需要给 category 增加属性的实现, 需要借助于运行时的两个函数<code>objc_setAssociatedObject</code>和<br><code>objc_getAssociatedObject</code>.</p>
<h2 id="property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h2><p>@property的本质是 ivar(实例变量) + getter + setter.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef struct objc_property *objc_property_t;</div><div class="line"></div><div class="line">struct property_t &#123;</div><div class="line">    const char *name;</div><div class="line">    const char *attributes;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef struct &#123;</div><div class="line">    const char *name;           /**&lt; The name of the attribute */</div><div class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>
<p>attributes的具体内容包含: 类型, 原子性, 内存语义和对应的实例变量.</p>
<p>我们每次在增加一个属性, 系统都会在 ivar_list 中添加一个成员变量的描述, 在 method_list 中增加 setter 与 getter 方法的描述, 在属性列表中增加一个属性的描述, 然后计算该属性在对象中的偏移量, 然后给出 setter 与 getter 方法对应的实现, 在 setter 方法中从偏移量的位置开始赋值, 在 getter 方法中从偏移量开始取值, 为了能够读取正确字节数, 系统对象偏移量的指针类型进行了类型强转.</p>
<p>详见<a href="http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/">Runtime用法与分析</a></p>
<h2 id="synthesize和-dynamic分别有什么作用"><a href="#synthesize和-dynamic分别有什么作用" class="headerlink" title="@synthesize和@dynamic分别有什么作用"></a>@synthesize和@dynamic分别有什么作用</h2><p>@property有两个关键词, @synthesize(默认值)和@dynamic. </p>
<p>@synthesize表示系统会默认添加一个@syntheszie var = _var的实例变量, 并且自动生成setter和getter方法. @synthesize 合成实例变量有以下几点规则:</p>
<ol>
<li>如果指定了成员变量的名称, 会生成一个指定的名称的成员变量.</li>
<li>如果这个成员已经存在就不再生成了.</li>
<li>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量.</li>
</ol>
<p>@synthesize的使用场景: </p>
<ol>
<li>同时重写了setter和getter时</li>
<li>重写了只读属性的getter时</li>
<li>在使用了@dynamic时</li>
<li>在@Protocol和category中定义属性时</li>
<li>重载父类的属性时, 来手动合成Ivar(实例变量/成员变量).</li>
</ol>
<p>@dynamic表示我们不需要系统自动生成, 由用户自己实现, 如果没有手动生成的话, 在使用过程中是会奔溃的.</p>
<h2 id="block-vs-weak"><a href="#block-vs-weak" class="headerlink" title="block vs weak"></a><strong>block vs </strong>weak</h2><p><strong>weak主要是用来避免循环引用的. </strong>weak修饰的变量, 在block内部被捕获后, 和外部的实际不是用一个变量. 他是对外部<strong>weak修饰的对象进行了一个弱引用. 当我们在block外部把</strong>weak修饰的变量释放后, block内部夜读不到这个变量. 如果外部被__weak修饰的变量被置为nil, 那么内部的对象实际上也是nil, 就会被释放掉. </p>
<p><strong>block实际上是提升了变量的作用域, 我们在block内外, 用</strong>block修饰的变量实际上不是同一个, 在block内部使用相当于被强引用了一份. <strong>block 本身无法避免循环引用的问题, 但是我们可以通过在 block 内部手动把 blockObj 赋值为 nil 的方式来避免循环引用的问题.<br>这里需要注意, 我们只能在堆上面block对象使用</strong>block修饰的对象, ARC下一旦block赋值就会触发copy, block就会被复制到堆上因此可以直接使用, 但是MRC下我们则需要手动调用copy, 否则会编译报错.<br>MRC下<strong>block修饰的变量在block中使用是不會retain的, ARC下是会retain的. 可以使用</strong>weak(ARC下使用, 但只支持iOS5以后)或是__unsafe_unretained来代替.</p>
<h2 id="使用nonatomic线程不安全"><a href="#使用nonatomic线程不安全" class="headerlink" title="使用nonatomic线程不安全"></a>使用nonatomic线程不安全</h2><p>atomic: 原子操作, 系统会为setter方法加锁(@synchronized), 线程安全, 需要消耗大量系统资源来为属性加锁.<br>nonatomic: 不会为setter方法加锁, 非线程安全, 适合内存较小的移动设备.</p>

    
  </div>
</article>

</div>








  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://hchong.net/2018/03/01/iOS开发总结系列-1/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
