[{"title":"iOS内存泄漏检查&原理","url":"http://hchong.net/2020/03/11/iOS内存泄漏检查-原理/","content":"<h1 id=\"iOS内存泄漏检查-amp-原理\"><a href=\"#iOS内存泄漏检查-amp-原理\" class=\"headerlink\" title=\"iOS内存泄漏检查&amp;原理\"></a>iOS内存泄漏检查&amp;原理</h1><p>前面罗列了<a href=\"http://hchong.net/2018/04/04/iOS%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/\">iOS中常见的会导致内存泄漏的场景</a>, 这篇文章主要说一下内存泄漏的常见检测方式和原理.</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Crash的捕获与处理","url":"http://hchong.net/2020/03/04/Crash的捕获与处理/","content":"<h1 id=\"Crash的捕获与处理\"><a href=\"#Crash的捕获与处理\" class=\"headerlink\" title=\"Crash的捕获与处理\"></a>Crash的捕获与处理</h1><p>前面写过一篇<a href=\"http://hchong.net/2018/04/05/iOS%E5%BC%80%E5%8F%91%E7%9A%84%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/\">iOS开发的崩溃日志分析与异常类型</a>, 这里来聊一下Crash的类型以及如何捕获Crash.</p>\n<p>对于常见的Crash而言, 可以分为两类, 一类是Objective-C异常, 另一类是Mach异常.</p>\n<h2 id=\"1-Objective-C异常\"><a href=\"#1-Objective-C异常\" class=\"headerlink\" title=\"1 Objective-C异常\"></a>1 Objective-C异常</h2><p>Objective-C异常就是指在OC层面（iOS库、第三方库出现错误时）出现的异常. 如何捕获Objective-C异常之前我们先来看下常见的Objective-C异常包括哪些.</p>\n<h3 id=\"1-1-常见的Objective-C异常\"><a href=\"#1-1-常见的Objective-C异常\" class=\"headerlink\" title=\"1.1 常见的Objective-C异常\"></a>1.1 常见的Objective-C异常</h3><p>Objective-C异常又称为应用级异常, 常见的Objective-C异常包括以下几种:</p>\n<ol>\n<li>NSInvalidArgumentException（非法参数异常） 这类异常的主要原因是没有对于参数的合法性进行校验，最常见的就是传入nil作为参数。例如，NSMutableDictionary添加key为nil的对象，测试代码如下</li>\n<li>NSRangeException（越界异常） 这类异常的主要原因是没有对于索引进行合法性的检查，导致索引落在集合数据的合法范围之外。例如，索引超出数组的范围从而导致数组越界的问题</li>\n<li>NSGenericException（通用异常） 这类异常最容易出现在foreach操作中，主要原因是在遍历过程中进行了元素的修改。例如，在for in循环中如果修改所遍历的数组则会导致该问题</li>\n<li>NSMallocException（内存分配异常） 这类异常的主要原因是无法分配足够的内存空间。例如，分配一块超大的内存空间就会导致此类的异常</li>\n<li>NSFileHandleOperationException（文件处理异常） 这类异常的主要原因是对文件进行相关操作时产生了异常，如手机没有足够的存储空间，文件读写权限问题等。例如，对于一个只有读权限的文件进行写操作</li>\n</ol>\n<h3 id=\"1-2-捕获Objective-C异常\"><a href=\"#1-2-捕获Objective-C异常\" class=\"headerlink\" title=\"1.2 捕获Objective-C异常\"></a>1.2 捕获Objective-C异常</h3><p>在开发过程中，通过添加全局断点, Objective-C异常导致的Crash会在Xcode的控制台输出异常的类型、原因以及调用堆栈.</p>\n<p>其他条件下, 可以使用<code>try catch</code>或者<code>NSSetUncaughtExceptionHandler()</code>来捕获.</p>\n<pre><code>// 记录之前的崩溃回调函数(防止多个Crash收集工具冲突)\nstatic NSUncaughtExceptionHandler *previousUncaughtExceptionHandler = NULL;\n\n+ (void)registerHandler {\n    // Backup original handler\n    previousUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();\n    NSSetUncaughtExceptionHandler(&amp;DoraemonUncaughtExceptionHandler);\n}\n\n// 崩溃时的回调函数\nstatic void DoraemonUncaughtExceptionHandler(NSException * exception) {\n    // 异常的堆栈信息\n    NSArray * stackArray = [exception callStackSymbols];\n    // 出现异常的原因\n    NSString * reason = [exception reason];\n    // 异常名称\n    NSString * name = [exception name];\n\n    NSString * exceptionInfo = [NSString stringWithFormat:@&quot;========uncaughtException异常错误报告========\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@&quot;, name, reason, [stackArray componentsJoinedByString:@&quot;\\n&quot;]];\n\n    // 保存崩溃日志到沙盒cache目录\n    [DoraemonCrashTool saveCrashLog:exceptionInfo fileName:@&quot;Crash(Uncaught)&quot;];\n\n    // 调用之前崩溃的回调函数(防止多个Crash收集工具冲突)\n    if (previousUncaughtExceptionHandler) {\n        previousUncaughtExceptionHandler(exception);\n    }\n}\n</code></pre><h2 id=\"2-Mach异常\"><a href=\"#2-Mach异常\" class=\"headerlink\" title=\"2 Mach异常\"></a>2 Mach异常</h2><p>iOS操作系统的内核部分都是XNU，而Mach就是XNU的微内核核心. Mach的职责主要是进程和线程抽象、虚拟内存管理、任务调度、进程间通信和消息传递机制等.</p>\n<h3 id=\"2-1-Mach与Unix信号\"><a href=\"#2-1-Mach与Unix信号\" class=\"headerlink\" title=\"2.1 Mach与Unix信号\"></a>2.1 Mach与Unix信号</h3><p>相信大家一定见过这样的错误提示:</p>\n<pre><code>Exception Type:         EXC_BAD_ACCESS (SIGSEGV)    \nException Subtype:      KERN_INVALID_ADDRESS at 0x041a6f3\n</code></pre><p>Apple’s Crash Reporter 记录在设备中的 Crash 日志, Exception Type 项通常会包含两个元素: Mach 异常 和 Unix 信号.</p>\n<p>Mach 是一个 XNU 的微内核核心，Mach 异常是指最底层的内核级异常，被定义在 &lt;mach/exception_types.h&gt;下 。每个 thread，task，host 都有一个异常端口数组，Mach 的部分 API 暴露给了用户态，用户态的开发者可以直接通过 Mach API 设置 thread，task，host 的异常端口，来捕获 Mach 异常，抓取 Crash 事件. Mach 异常允许在进程里或进程外处理，处理程序通过Mach RPC调用.</p>\n<p>所以, 上面代码里面的异常提醒就代表: Mach 层的EXC_BAD_ACCESS异常，在 host 层被转换成 SIGSEGV 信号投递到出错的线程.</p>\n<p>Mach 异常是指最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常.</p>\n<h3 id=\"2-2-Unix信号\"><a href=\"#2-2-Unix信号\" class=\"headerlink\" title=\"2.2 Unix信号\"></a>2.2 Unix信号</h3><p>Unix 信号又称BSD 信号，如果开发者没有捕获Mach异常，则会被host层的方法ux_exception()将异常转换为对应的UNIX信号，并通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获single.</p>\n<p>Unix信号有很多种，详细的定义可以在&lt;sys/signal.h&gt;中找到.<br>常见的信号的释义可以参考<a href=\"http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html\" target=\"_blank\" rel=\"noopener\">《iOS异常捕获》</a>.</p>\n<h3 id=\"2-3-Mach异常捕获\"><a href=\"#2-3-Mach异常捕获\" class=\"headerlink\" title=\"2.3 Mach异常捕获\"></a>2.3 Mach异常捕获</h3><p>捕获 Mach 异常或者 Unix 信号都可以抓到 crash 事件, 这两种方式哪个更好呢？优选 Mach 异常，因为 Mach 异常处理会先于 Unix 信号处理发生，如果 Mach 异常的 handler 让程序 exit 了，那么 Unix 信号就永远不会到达这个进程了。转换 Unix 信号是为了兼容更为流行的 POSIX 标准 (SUS 规范)，这样不必了解 Mach 内核也可以通过 Unix 信号的方式来兼容开发.</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz/Oib5VlxS0YmI5lfHjqxmAPxHeib2zIIOiavFqNQ4pwrxvG34jaia7dDKXqBlSeYCoXpQ2kxLWsRf0074TsuvBCPicag/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"Mach异常捕获\"></p>\n<h3 id=\"2-4-Unix信号捕获\"><a href=\"#2-4-Unix信号捕获\" class=\"headerlink\" title=\"2.4 Unix信号捕获\"></a>2.4 Unix信号捕获</h3><p>因为硬件产生的信号 (通过 CPU 陷阱) 被 Mach 层捕获，然后才转换为对应的 Unix 信号；苹果为了统一机制，于是操作系统和用户产生的信号 (通过调用kill和pthread_kill) 也首先沉下来被转换为 Mach 异常，再转换为 Unix 信号</p>\n<p>参考捕获Objective-C异常时处理覆盖问题的思路，我们也可以先将已有的异常处理函数进行保存，然后在我们的异常处理函数执行之后，再调用之前保存的异常处理函数.</p>\n<pre><code>//注册异常捕获\nInstallSignalHandler();\n\nvoid SignalExceptionHandler(int signal)\n{\n    NSMutableString *mstr = [[NSMutableString alloc] init];\n    [mstr appendString:@&quot;Stack:\\n&quot;];\n    void* callstack[128];\n    int i, frames = backtrace(callstack, 128);\n    char** strs = backtrace_symbols(callstack, frames);\n    for (i = 0; i &lt;frames; ++i) {\n        [mstr appendFormat:@&quot;%s\\n&quot;, strs[i]];\n    }\n    [SignalHandler saveCreash:mstr];\n\n}\n\nvoid InstallSignalHandler(void)\n{\n    signal(SIGHUP, SignalExceptionHandler);\n    signal(SIGINT, SignalExceptionHandler);\n    signal(SIGQUIT, SignalExceptionHandler);\n\n    signal(SIGABRT, SignalExceptionHandler);\n    signal(SIGILL, SignalExceptionHandler);\n    signal(SIGSEGV, SignalExceptionHandler);\n    signal(SIGFPE, SignalExceptionHandler);\n    signal(SIGBUS, SignalExceptionHandler);\n    signal(SIGPIPE, SignalExceptionHandler);\n}\n</code></pre><h3 id=\"2-5-Mach-异常-Unix-信号\"><a href=\"#2-5-Mach-异常-Unix-信号\" class=\"headerlink\" title=\"2.5 Mach 异常 + Unix 信号\"></a>2.5 Mach 异常 + Unix 信号</h3><p>捕获Mach异常或者Unix信号都可以抓到Crash事件, 通常使用了Unix信号方式进行捕获. 主要原因如下:</p>\n<ol>\n<li>Mach异常没有比较便利的捕获方式，既然它最终会转化成信号，我们也可以通过捕获信号来捕获Crash事件。</li>\n<li>转换Unix信号是为了兼容更为流行的POSIX标准(SUS规范)，这样不必了解Mach内核也可以通过Unix信号的方式来兼容开发。</li>\n</ol>\n<p>Unix信号捕获可以参考上一章节内容.</p>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h1><ol>\n<li>异常分为应用级异常(Obj-C异常)和Mach异常</li>\n<li>Obj-C异常使用<code>NSSetUncaughtExceptionHandler()</code>捕获</li>\n<li>Mach异常通过Mach API设置thread，task，host的异常端口，来捕获Mach异常</li>\n<li>未被捕获的Mach异常会被转换为Unix信号异常, 苹果将操作系统和用户产生的信号 (通过调用kill和pthread_kill) 也首先沉下来被转换为 Mach 异常, 再转换为 Unix 信号.</li>\n<li>Unix异常通过<code>signal(SIGSEGV,signalHandler);</code>方式来捕获</li>\n<li>其他操作系统优选Mach异常, 防止未被转化为Unix信号程序就结束.</li>\n<li>iOS基本上都会被转化为Unix异常, 优先考虑通过Unix 信号捕获异常.</li>\n<li>多个crash收集, 注意异常捕获的传递</li>\n</ol>\n<hr>\n<p>1.<a href=\"https://juejin.im/post/5cf769eb6fb9a07ea567dd9d\" target=\"_blank\" rel=\"noopener\">iOS开发中crash常用处理</a><br>2.<a href=\"https://juejin.im/post/5d76184ce51d4561d106cc65\" target=\"_blank\" rel=\"noopener\">DoKit支持iOS本地crash查看功能</a><br>3.<a href=\"http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html\" target=\"_blank\" rel=\"noopener\">iOS异常捕获</a><br>4.<a href=\"https://toutiao.io/posts/r9ztjc/preview\" target=\"_blank\" rel=\"noopener\">关于 iOS App 的 Crash 捕获简述</a><br>5.<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208483273&amp;idx=1&amp;sn=37ee88e06e7426f59f3074c536370317&amp;scene=21\" target=\"_blank\" rel=\"noopener\">漫谈 iOS Crash 收集框架</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"ffmpeg与ijkplayer在iOS中的应用指南","url":"http://hchong.net/2019/10/16/ffmpeg在iOS中的应用指南/","content":"<h1 id=\"1-ffmpeg与ijkplayer的介绍\"><a href=\"#1-ffmpeg与ijkplayer的介绍\" class=\"headerlink\" title=\"1 ffmpeg与ijkplayer的介绍\"></a>1 ffmpeg与ijkplayer的介绍</h1><h2 id=\"1-1-ffmpeg\"><a href=\"#1-1-ffmpeg\" class=\"headerlink\" title=\"1.1 ffmpeg\"></a>1.1 ffmpeg</h2><p>ffmpeg 理解成一套音视频解决方案，使用 C语言 开发的开源程序，并且免费、开源、跨平台，它提供了录制、转换以及流化音视频，编码，特效，视音频操作等功能，包含了非常先进的音频/视频编解码库. </p>\n<p>可以实现播放歌曲、视频, 甚至通过命令实现对 视频文件的转码、混合、剪辑, 采集等各<br>种复杂处理.</p>\n<h2 id=\"1-2-ijkplayer\"><a href=\"#1-2-ijkplayer\" class=\"headerlink\" title=\"1.2 ijkplayer\"></a>1.2 ijkplayer</h2><p>ijkplayer是业内很知名的音视频播放框架, 由B站开发并在GitHub开源, 底层使用ffmpeg来进行音视频的编解码处理. 市面上第三方的播放器的播放内核均使用的ijkplayer.</p>\n<h1 id=\"2-ffmpeg的使用\"><a href=\"#2-ffmpeg的使用\" class=\"headerlink\" title=\"2 ffmpeg的使用\"></a>2 ffmpeg的使用</h1>","categories":["ffmpeg","ijkplayer","音视频开发"],"tags":["ffmpeg","ijkplayer","音视频开发"]},{"title":"UINavigationController对布局的影响","url":"http://hchong.net/2019/08/13/UINavigationController对布局的影响/","content":"<p>iOS7 之后，所有的 UINavigationBar 默认都是透明的了，同时 View Controller 全部都使用全屏的 layout。为了提供更多调整 view 的选项，苹果又引入了 edgesForExtendedLayout， extendedLayoutIncludesOpaqueBars，automaticallyAdjustsScrollViewInsets 这几个属性用于控制 VC 的 view layout. 下面就来详细说一下他们对页面布局的影响.</p>\n<h1 id=\"1-新建一个空工程\"><a href=\"#1-新建一个空工程\" class=\"headerlink\" title=\"1. 新建一个空工程\"></a>1. 新建一个空工程</h1><p>创建一个 Single View 的工程，设置 Navigation Controller 和 rootViewController, 运行结果可以看到:</p>\n<ul>\n<li>导航栏式透明的, 这就是iOS 7之后的毛玻璃效果</li>\n<li>View 是在全屏幕范围内进行布局的.</li>\n</ul>\n<p>这就导致: </p>\n<ul>\n<li>我们可以透过导航栏看到下层的背景色</li>\n<li>如果我们添加一个控件的frame为<code>CGRectMake(0, 0, 100, 40)</code>就会导致完全被导航栏挡住. 想解决这个问题，最简单的办法就是调整 Label 的 frame. 但是Apple已经提供了解决方案.</li>\n</ul>\n<h1 id=\"2-Apple的解决方案\"><a href=\"#2-Apple的解决方案\" class=\"headerlink\" title=\"2. Apple的解决方案\"></a>2. Apple的解决方案</h1><p>针对这种情况, Apple提供了下面几个属性来解决这种问题.</p>\n<h2 id=\"2-1-edgesForExtendedLayout\"><a href=\"#2-1-edgesForExtendedLayout\" class=\"headerlink\" title=\"2.1 edgesForExtendedLayout\"></a>2.1 edgesForExtendedLayout</h2><p>edgesForExtendedLayout属性指示了下层 view 扩展 layout 的方向, 系统默认值为<code>UIRectEdgeAll</code>, 就是会向各个方向扩展(其实在这里能扩展的方向也只有上方). 我们可以通过更改这个属性解决上面的问题.</p>\n<ul>\n<li>在navigationBar透明的情况下, 控制器的根View会向四周延伸, 我们可以通过设置<code>edgesForExtendedLayout</code>来控制延伸情况.</li>\n<li>在navigationBar不透明的情况下, 控制器的根View不会向四周延伸.</li>\n</ul>\n<h2 id=\"2-2-navigationBar-translucent\"><a href=\"#2-2-navigationBar-translucent\" class=\"headerlink\" title=\"2.2 navigationBar.translucent\"></a>2.2 navigationBar.translucent</h2><p>translucent属性值会决定导航栏是否有半透明效果. translucent为NO, 意味着导航栏为非透明. 我们可以通过更改这个属性解决问题.</p>\n<p>translucent会受navigationBar的backgroudImage属性的影响。也就是说当你使用了一张自定义图片作为navigationBar的背景图时，translucent的值将由系统根据该图片是否颜色值透明，来推断translucent是YES还是NO.</p>\n<pre><code class=\"OC\">UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:vc];\nnav.navigationBar.translucent = NO;\n</code></pre>\n<p>当navigationBar.translucent = NO时，两种方式给NavigationBar设置颜色:</p>\n<pre><code class=\"OC\">self.navigationController.navigationBar.tintColor = [UIColor redColor];\n\n[self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@&quot;1.png&quot;] forBarMetrics:(UIBarMetricsDefault)];\n</code></pre>\n<h2 id=\"2-3-extendedLayoutIncludesOpaqueBars\"><a href=\"#2-3-extendedLayoutIncludesOpaqueBars\" class=\"headerlink\" title=\"2.3 extendedLayoutIncludesOpaqueBars\"></a>2.3 extendedLayoutIncludesOpaqueBars</h2><p>该属性的意思为在bar不透明的情况下根View是否进行延伸, 该属性只能使用在bar不透明的情况下, 在navgationBar透明的情况下, 设置无效.</p>\n<p>在navgationBar不透明的情况下edgesForExtendedLayout与extendedLayoutIncludesOpaqueBars需要配合使用才可以达到想要的效果.</p>\n<ul>\n<li>UIRectEdgeNone + YES, view不会向四周延伸</li>\n<li>UIRectEdgeAll + NO, view不会向四周延伸 </li>\n<li>UIRectEdgeAll + YES, view会向四周延伸 </li>\n<li>UIRectEdgeNone + NO, view不会向四周延伸</li>\n</ul>\n<h2 id=\"2-4-automaticallyAdjustsScrollViewInsets\"><a href=\"#2-4-automaticallyAdjustsScrollViewInsets\" class=\"headerlink\" title=\"2.4 automaticallyAdjustsScrollViewInsets\"></a>2.4 automaticallyAdjustsScrollViewInsets</h2><p>scrollView和其子类是否有系统自动调整子控件位置(即如果scrollView被bar遮挡时, 子控件自动下移一定距离, 保证内容不会被覆盖).</p>\n<ul>\n<li>scrollView与其子类必须放在控制器的根View上并且automaticallyAdjustsScrollViewInsets设置为YES时, 系统才会为我们自动调整</li>\n<li>在iOS11中automaticallyAdjustsScrollViewInsets已经失效了, 被替换成需scrollView中的contentInsetAdjustmentBehavior参数</li>\n<li>以tableView为例，当你使用默认的创建方式，也就是UIRectEdgeAll+导航栏半透明的情况下，首行cell的位置将处于导航栏下方，也就是屏幕坐标系的(0, 64)位置处，但是此时上滑将会形成穿透效果导航栏的效果.</li>\n</ul>\n<h2 id=\"2-5-坑\"><a href=\"#2-5-坑\" class=\"headerlink\" title=\"2.5 坑\"></a>2.5 坑</h2><p>对于导航控制器中的各个childViewController，是共用同一个的navigationBar。当你在一个childViewController中自定义了navigationBar的背景图片，或是直接改变了translucent属性，此时再push或pop到另一个childViewController时，更改导航栏的半透明效果可能会影响到页面的布局起始位置，从而发生视图发生跳动，出现“意外”的上下偏移.</p>\n<p>例如: 从一个设置了导航栏不透明的控制器A, pop回到一个原本设置了导航栏透明的控制器B时, B页面发生了下移.</p>\n<p>为避免该情况, 应该将控制器B的extendedLayoutIncludesOpaqueBars设置为YES; 或是当B页面viewWillAppear:时, 再度将导航栏设置为半透明效果.</p>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><pre><code class=\"OC\">self.navigationController.navigationBar.translucent = NO;\nself.extendedLayoutIncludesOpaqueBars = NO;\nself.edgesForExtendedLayout = UIRectEdgeNone;\n</code></pre>\n<ul>\n<li>NO + NO + UIRectEdgeNone, 从导航栏下开始计算</li>\n<li>NO + NO + UIRectEdgeAll, 从导航栏下开始计算</li>\n<li>NO + YES + UIRectEdgeNone, 从导航栏下开始计算</li>\n<li>NO + YES + UIRectEdgeAll, 从屏幕顶端开始计算, 导航栏不透明</li>\n<li>YES + NO + UIRectEdgeNone, 从导航栏下开始计算, 但是导航栏是透明色, 会显示底色(黑色)</li>\n<li>YES + NO + UIRectEdgeAll, 从屏幕顶端开始计算, 导航栏是透明色, 显示页面背景色</li>\n<li>YES + YES + UIRectEdgeNone, 从导航栏下开始计算, 导航栏是透明色, 会显示底色(黑色)</li>\n<li>YES + YES + UIRectEdgeAll, 从屏幕顶端开始计算, 导航栏是透明色, 显示页面背景色</li>\n</ul>\n<p>总结效果如下:</p>\n<ol>\n<li><code>navigationBar.translucent = NO</code>时, 导航栏不透明, <code>extendedLayoutIncludesOpaqueBars</code>属性生效, 当<code>extendedLayoutIncludesOpaqueBars = YES &amp;&amp; UIRectEdgeAll</code>时从屏幕下开始计算, 其他均是从导航栏下开始计算</li>\n<li><code>navigationBar.translucent = YES</code>时, <code>extendedLayoutIncludesOpaqueBars</code>属性不生效, 只有当<code>UIRectEdgeAll</code>时从屏幕顶端开始计算, 其他均从导航栏下开始计算.</li>\n</ol>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.cnblogs.com/Zp3sss/p/9108613.html\" target=\"_blank\" rel=\"noopener\">屏幕适配</a><br>2.<a href=\"https://skyline75489.github.io/post/2015-11-27_uinavigation_bar_frame_affect.html\" target=\"_blank\" rel=\"noopener\">UINavigationBar 透明设置以及对 frame 的影响</a><br>3.<a href=\"https://youshaoduo.com/2017/12/13/26/\" target=\"_blank\" rel=\"noopener\">影响导航控制器中页面布局的几个属性</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"点击图标到启动都做了什么","url":"http://hchong.net/2019/08/01/点击图标到启动都做了什么/","content":"<p>一般情况下, App 的启动分为冷启动和热启动.</p>\n<ul>\n<li>冷启动是指, App 点击启动前, 它的进程不在系统里, 需要系统新创建一个进程分配给它启动的情况. 这是一次完整的启动过程.</li>\n<li>热启动是指, App 在冷启动后用户将 App 退后台, 在 App 的进程还在系统里的情况下, 用户重新启动进入 App 的过程, 这个过程做的事情非常少. </li>\n</ul>\n<p>一般而言, App 的启动时间, 指的是从用户点击 App 开始到用户看到第一个界面之间的时间, 总结来说, App的启动主要包括三个阶段:</p>\n<ul>\n<li>main()函数执行前</li>\n<li>main()函数</li>\n<li>首屏渲染</li>\n</ul>\n<h1 id=\"1-main-函数执行前\"><a href=\"#1-main-函数执行前\" class=\"headerlink\" title=\"1 main()函数执行前\"></a>1 main()函数执行前</h1><p>主要工作是操作系统加载App可执行文件到内存, 然后执行一系列的加载&amp;链接等工作，最后执行至App的main()函数.</p>\n<ol>\n<li>真正的加载过程从exec()函数开始, exec()是一个系统调用. 用fork()函数新建立一个进程,  再为进程分配一段内存空间, 然后让进程去执行exec调用.</li>\n<li>把App对应的可执行文件（Mach-O格式）加载到内存空间.</li>\n<li>读取dyld路径, 加载动态链接库dyld到内存, 运行dyld动态连接器.</li>\n<li>dyld 加载程序所需的动态库(load dylibs image)</li>\n<li>dyld 对所有 image 进行 rebase 以及 bind 操作</li>\n<li>ObjC SetUp</li>\n<li>Run initializers</li>\n</ol>\n<p>整个事件由dyld主导, 完成运行环境的初始化后, 配合ImageLoader 将二进制文件按格式加载到内存, 动态链接依赖库, 并由runtime负责加载成objc 定义的结构, 所有初始化工作结束后, dyld调用真正的main函数.</p>\n<h2 id=\"1-1-Mach-O\"><a href=\"#1-1-Mach-O\" class=\"headerlink\" title=\"1.1 Mach-O\"></a>1.1 Mach-O</h2><p>Mach-O 是针对不同运行时可执行文件的文件类型. Mach-O的文件格式是 OS X 与 iOS 系统上的可执行文件格式, 类似于windows的 PE格式, linux上的elf格式. 我们编译产生的.o文件、程序可执行文件和各种库等都是Mach-O文件. mach-o文件类型主要为:</p>\n<ul>\n<li>Executable: 应用的主要二进制</li>\n<li>Dylib Library: 动态链接库(又称DSO或DLL), 例如.so文件. .so文件是linux的可执行文件, 可以用于多个进程的共享使用.</li>\n<li>Static Library: 静态链接库, 例如.a文件. .a文件实质上就是.o文件打了个包, 一般把它叫做静态库文件</li>\n<li>Bundle: 不能被链接的Dylib, 只能在运行时使用dlopen( )加载, 可当做macOS的插件</li>\n<li>Relocatable Object File: 可重定向文件类型, 例如.o文件. .o文件是源码编译出的二进制文件</li>\n</ul>\n<p>两个特殊的名词解释:</p>\n<ul>\n<li>image: 镜像, 指的是executable, dylib 或 bundle</li>\n<li>Framework: 包含Dylid以及资源文件和头文件的文件夹</li>\n</ul>\n<p>Mach-O文件主要有3部分组成: </p>\n<ul>\n<li>Header: 保存了一些基本信息，包括了该文件运行的平台、文件类型、LoadCommands的个数等等。Headers的主要作用就是帮助系统迅速的定位Mach-O文件的运行环境，文件类型。保存了一些dyld重要的加载参数</li>\n<li>LoadCommands: 可以理解为加载命令，在加载Mach-O文件时会使用这里的数据来确定内存的分布以及相关的加载命令。比如我们的main函数的加载地址，程序所需的dyld的文件路径，以及相关依赖库的文件路径。</li>\n<li>Data: 每一个segment的具体数据都保存在这里, 这里包含了具体的代码、数据等等.</li>\n</ul>\n<h2 id=\"1-2-dyld\"><a href=\"#1-2-dyld\" class=\"headerlink\" title=\"1.2 dyld\"></a>1.2 dyld</h2><p>dyld(the dynamic link editor) Apple的动态链接器, 系统内核做好启动程序的初始准备后, 交给 dyld 负责, dyld 在应用进程中运行的工作是加载应用依赖的所有动态链接库, 准备好运行所需的一切. 对 dyld 作用顺序的概括如下: </p>\n<ol>\n<li>从内核留下的原始调用栈引导和启动自己</li>\n<li>将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制</li>\n<li>non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li>\n<li>Runs static initializers for the executable</li>\n<li>找到可执行文件的 main 函数，准备参数并调用</li>\n<li>程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li>\n<li>程序main函数 return 后执行 static terminator</li>\n<li>某些场景下 main 函数结束后调 libSystem 的 _exit 函数</li>\n</ol>\n<h2 id=\"1-2-1-load-dylibs\"><a href=\"#1-2-1-load-dylibs\" class=\"headerlink\" title=\"1.2.1 load dylibs\"></a>1.2.1 load dylibs</h2><p>这一阶段dyld会分析应用依赖的dylib. 从主执行文件的 header 获取到需要加载的所依赖动态库列表, 而 header 早就被内核映射过, 然后它需要找到每个dylib, 然后打开文件读取文件起始位置. 找到其mach-o文件, 打开和读取这些文件并验证其有效性, 接着会找到代码签名注册到内核. 最后对dylib的每一个segment调用mmap(), 应用所依赖的 dylib 文件可能会再依赖其他 dylib, 所以 dyld 所需要加载的是动态库列表一个递归依赖的集合.</p>\n<h2 id=\"1-2-2-rebase-amp-amp-bind\"><a href=\"#1-2-2-rebase-amp-amp-bind\" class=\"headerlink\" title=\"1.2.2 rebase &amp;&amp; bind\"></a>1.2.2 rebase &amp;&amp; bind</h2><p>传统方式下，进程每次启动采用的都是固定可预见的方式，这意味着一个给定的程序在给定的架构上的进程初始虚拟内存都是基本一致的，而且在进程正常运行的生命周期中，内存中的地址分布具有非常强的可预测性，这给了黑客很大的施展空间, 所以采用了ASLR(Address Space Layout Randomization)技术.</p>\n<p>采用ASLR, 地址空间布局随机化, 镜像会在随机的地址上加载. 进程每次启动, 地址空间都会被简单地随机化. 在加载所有的动态链接库之后, 它们只是处在相互独立的状态, 需要将它们绑定起来，这就是 Fix-ups. Fix-up 有两种类型, rebasing 和 binding.</p>\n<p>Rebasing: 在镜像内部调整指针的指向, 针对mach-o在加载到内存中不是固定的首地址（ASLR）这一现象做数据修正的过程.<br>Binding: 将指针指向镜像外部的内容, binding就是将这个二进制调用的外部符号进行绑定的过程. 这些指向外部的指针被符号(symbol)名称绑定, dyld需要去符号表里查找, 找到symbol对应的实现</p>\n<p>Objective-C 中有很多数据结构都是靠 Rebasing 和 Binding 来修正（fix-up）的, 比如 Class 中指向父类的指针和指向方法的指针.</p>\n<h2 id=\"1-2-3-ObjC-SetUp\"><a href=\"#1-2-3-ObjC-SetUp\" class=\"headerlink\" title=\"1.2.3 ObjC SetUp\"></a>1.2.3 ObjC SetUp</h2><p>objc prepare images, 通知 runtime 准备镜像, 这里做的事情比较多，主要是 runtime 的初始化</p>\n<ul>\n<li>此时大部分的ObjC初始化已经完成, 读取二进制文件的 DATA 段内容, 找到与 objc 相关的信息</li>\n<li>注册所有的objc_class, ObjC 是个动态语言, 可以用类的名字来实例化一个类的对象. 这意味着 ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个 dylib 时, 其定义的所有的类都需要被注册到这个全局表中</li>\n<li>更新ivars的偏移量</li>\n<li>把分类的方法插入到方法列表</li>\n<li>检查selector的唯一性</li>\n</ul>\n<h2 id=\"1-2-4-initializers\"><a href=\"#1-2-4-initializers\" class=\"headerlink\" title=\"1.2.4 initializers\"></a>1.2.4 initializers</h2><p>到了这一阶段，dyld开始运行程序的初始化函数:</p>\n<ul>\n<li>调用每个Objc类和分类的+load方法，</li>\n<li>调用C/C++ 中的构造器函数（用attribute((constructor))修饰的函数), </li>\n<li>创建非基本类型的C++静态全局变量（通常是类或结构体). </li>\n</ul>\n<p>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库</p>\n<ul>\n<li>dyld开始将程序二进制文件初始化</li>\n<li>交由ImageLoader读取image，其中包含了我们的类、方法等各种符号</li>\n<li>由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理</li>\n<li>runtime接手后调用mapimages做解析和处理，接下来loadimages中调用 callloadmethods方法，遍历所有加载进来的Class，按继承层级依次调用Class的+load方法和其 Category的+load方法.</li>\n</ul>\n<p>Initializers阶段执行完后，dyld开始调用main()函数.</p>\n<h1 id=\"2-main-函数\"><a href=\"#2-main-函数\" class=\"headerlink\" title=\"2 main()函数\"></a>2 main()函数</h1><p>main()函数之后指的是从main()开始，到appDelegate的<code>didFinishLaunchingWithOptions</code>方法执行完毕.<br><img src=\"https://upload-images.jianshu.io/upload_images/1671052-82ba5c165b37a789.png\" alt=\"iOS APP launch sequence\"></p>\n<h1 id=\"3-首屏渲染\"><a href=\"#3-首屏渲染\" class=\"headerlink\" title=\"3 首屏渲染\"></a>3 首屏渲染</h1><p>此处就是APP启动后的业务逻辑, 有可能有定位, 网络请求, I/O操作, 性能监控, 基础配置, 自定义配置, 统计上报等功能.</p>\n<h1 id=\"4-启动优化\"><a href=\"#4-启动优化\" class=\"headerlink\" title=\"4 启动优化\"></a>4 启动优化</h1><p>启动优化要结合上面启动时的特点来按步骤, 分阶段优化.</p>\n<h2 id=\"4-1-load-dylibs阶段\"><a href=\"#4-1-load-dylibs阶段\" class=\"headerlink\" title=\"4.1 load dylibs阶段\"></a>4.1 load dylibs阶段</h2><p>该阶段主要做了分析依赖的动态库, 找到动态库的mach-o, 打开并验证, 加载. 所以针对的优化措施是:</p>\n<ul>\n<li>减少非系统库的依赖</li>\n<li>使用静态库而不是动态库</li>\n<li>合并非系统动态库为一个动态库</li>\n</ul>\n<h2 id=\"4-2-Rebase-amp-amp-Binding\"><a href=\"#4-2-Rebase-amp-amp-Binding\" class=\"headerlink\" title=\"4.2 Rebase &amp;&amp; Binding\"></a>4.2 Rebase &amp;&amp; Binding</h2><p>这里主要是对内存地址的Fix-ups, 所以可以采用下面的优化措施:</p>\n<ul>\n<li>减少Objc类数量, 减少selector数量, 把未使用的类和函数都可以删掉.</li>\n<li>减少C++虚函数数量</li>\n<li>转而使用swift stuct（其实本质上就是为了减少符号的数量，使用swift语言来开发?）</li>\n</ul>\n<h2 id=\"4-3-ObjC-SetUp\"><a href=\"#4-3-ObjC-SetUp\" class=\"headerlink\" title=\"4.3 ObjC SetUp\"></a>4.3 ObjC SetUp</h2><p>这里主要是对Rebase &amp;&amp; Binding后的结果进行处理, 所以没什么可以优化的</p>\n<h2 id=\"4-4-initializers\"><a href=\"#4-4-initializers\" class=\"headerlink\" title=\"4.4 initializers\"></a>4.4 initializers</h2><p>这里主要做了load, C++静态全局变量的创建等. 所以优化措施主要有:</p>\n<ul>\n<li>使用 +initialize 来替代 +load</li>\n<li>不要使用 atribute((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行. 比如使用 dispatch_once(),pthread_once() 或 std::once()。也就是在第一次使用时才初始化，推迟了一部分工作耗时. 也尽量不要用到C++的静态对象</li>\n</ul>\n<h2 id=\"4-5-main\"><a href=\"#4-5-main\" class=\"headerlink\" title=\"4.5 main()\"></a>4.5 main()</h2><p>总体原则无非就是减少启动的时候的步骤, 以及每一步骤的时间消耗. main阶段的优化大致有如下几个点:</p>\n<ul>\n<li>减少启动初始化的流程，能懒加载的就懒加载，能放后台初始化的就放后台，<br>能够延时初始化的就延时，不要卡主线程的启动时间，已经下线的业务直接删掉； </li>\n<li>优化代码逻辑，去除一些非必要的逻辑和代码，减少每个流程所消耗的时间； </li>\n<li>启动阶段使用多线程来进行初始化，把CPU的性能尽量发挥出来； </li>\n<li>使用纯代码而不是xib或者storyboard来进行UI框架的搭建，尤其是主UI框架比如TabBarController这种, 尽量避免使用xib和storyboard，因为xib和storyboard也还是要解析成代码来渲染页面，多了一些步骤. </li>\n</ul>\n<h2 id=\"4-6-首屏渲染\"><a href=\"#4-6-首屏渲染\" class=\"headerlink\" title=\"4.6 首屏渲染\"></a>4.6 首屏渲染</h2><p>这里主要针对具体耗时的业务做优化. </p>\n<ul>\n<li>推迟&amp;减少I/O操作, 减少动画图片组的数量，替换大图资源等。因为相比于内存操作，硬盘I/O是非常耗时的操作</li>\n<li>发现隐晦的耗时操作</li>\n<li>推迟执行的一些任务, 如一些资源的I/O，一些布局逻辑，对象的创建时机等</li>\n</ul>\n<h1 id=\"5-优化实践\"><a href=\"#5-优化实践\" class=\"headerlink\" title=\"5. 优化实践\"></a>5. 优化实践</h1><h2 id=\"5-1-pre-main阶段的优化实践\"><a href=\"#5-1-pre-main阶段的优化实践\" class=\"headerlink\" title=\"5.1 pre-main阶段的优化实践\"></a>5.1 pre-main阶段的优化实践</h2><ul>\n<li>减少依赖不必要的库，不管是动态库还是静态库；如果可以的话，把动态库改造成静态库；<br>如果必须依赖动态库，则把多个非系统的动态库合并成一个动态库；</li>\n<li>检查下 framework应当设为optional和required, 如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional, 因为optional会有些额外的检查； </li>\n<li>合并或者删减一些OC类和函数；关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类（也可以用根据linkmap文件来分析，但是准确度不算很高); 有一个叫做<a href=\"https://github.com/dblock/fui\" target=\"_blank\" rel=\"noopener\">FUI</a>的开源项目能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。</li>\n<li>删减一些无用的静态变量，</li>\n<li>删减没有被调用到或者已经废弃的方法，<br>方法见<a href=\"http://stackoverflow.com/questions/35233564/how-to-find-unused-code-in-xcode-7\" target=\"_blank\" rel=\"noopener\">这里</a>和<a href=\"https://developer.Apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/CheckingCodeCoverage.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</li>\n<li>将不必须在+load方法中做的事情延迟到+initialize中，尽量不要用C++虚函数(创建虚函数表有开销)</li>\n<li>类和方法名不要太长：iOS每个类和方法名都在__cstring段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的. 因还是object-c的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c对象模型会把类/方法名字符串都保存下来；</li>\n<li>用dispatch_once()代替所有的 attribute((constructor)) 函数、C++静态对象初始化、ObjC的+load函数；</li>\n<li>在设计师可接受的范围内压缩图片的大小，会有意外收获. 压缩图片为什么能加快启动速度呢？因为启动的时候大大小小的图片加载个十来二十个是很正常的, 图片小了，IO操作量就小了，启动当然就会快了，比较靠谱的压缩算法是TinyPNG。</li>\n</ul>\n<h2 id=\"5-2-业务优化\"><a href=\"#5-2-业务优化\" class=\"headerlink\" title=\"5.2 业务优化\"></a>5.2 业务优化</h2><ul>\n<li>把启动时RN包的删除和拷贝操作，仅在APP安装后第一次启动时才做，之后的启动不再做这操作，<br>而是等到网络请求RN数据回来，根据是否需要更新RN包的判断，再去做这些IO操作从而避免启动的耗时。</li>\n<li>打点统计模块里的定位服务权限请求改成异步</li>\n<li>友盟的分享服务，没有必要在启动的时候去初始化，初始化任务丢到后台线程解决，大概600-800ms</li>\n<li>UserAgentManager里对于webview是否为UIWebview的判断，以前是新创建一个对象使用对象方法来判断，</li>\n<li>修改为直接使用类方法，避免创建对象的消耗, 否则子线程消耗的时间太长了；</li>\n<li>采用两个线程来进行启动流程的初始化. 但是要针对业务区分开，并不是把一部分业务拆分到子线程，就可以让整体的启动速度更快；因为如果子线程有一些操作是要在主线程做的，有可能会出现等待主线程空闲再继续的情况；</li>\n<li>或者当两个线程的耗时操作都是IO时，拆开到两个线程，并不一定比单个线程去做IO操作要快。</li>\n<li>主UI框架tabBarController的viewDidLoad函数里，去掉一些不必要的函数调用。</li>\n<li>NSUserDefaults的synchronize函数尽量不要在启动流程中去调用，统一在APP进入后台，<br>willTerminate和完全进入前台后把数据落地；</li>\n</ul>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://blog.sunnyxx.com/2014/08/30/objc-pre-main/\" target=\"_blank\" rel=\"noopener\">iOS 程序 main 函数之前发生了什么</a><br>2.<a href=\"https://juejin.im/post/5a687e2cf265da3e4f0a579b\" target=\"_blank\" rel=\"noopener\">iOS开发 APP启动main()调用之前的加载过程</a><br>3.<a href=\"http://www.narutoyq.cc/ios-launch/\" target=\"_blank\" rel=\"noopener\">iOS App 启动流程</a><br>4.<a href=\"http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/\" target=\"_blank\" rel=\"noopener\">优化 App 的启动时间</a><br>5.<a href=\"https://techblog.toutiao.com/2017/07/05/session413/\" target=\"_blank\" rel=\"noopener\">App 启动时间：过去，现在和未来</a><br>6.<a href=\"https://www.jianshu.com/p/bf9684a2a35f\" target=\"_blank\" rel=\"noopener\">深入理解iOS App的启动过程</a><br>7.<a href=\"https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html\" target=\"_blank\" rel=\"noopener\">美团外卖iOS App冷启动治理</a><br>8.<a href=\"https://www.jianshu.com/p/229dd6190b95\" target=\"_blank\" rel=\"noopener\">iOS-APP的启动流程和生命周期</a><br>9.<a href=\"https://juejin.im/post/5a687e2cf265da3e4f0a579b\" target=\"_blank\" rel=\"noopener\">iOS 程序启动流程解密</a><br>10.<a href=\"https://blog.csdn.net/hello_hwc/article/details/78317863\" target=\"_blank\" rel=\"noopener\">深入理解iOS App的启动过程</a><br>11.<a href=\"https://www.jianshu.com/p/71c75c287d26\" target=\"_blank\" rel=\"noopener\">从Mach-O到iOS Library</a><br>12.<a href=\"https://www.jianshu.com/p/229dd6190b95\" target=\"_blank\" rel=\"noopener\">iOS-APP的启动流程和生命周期</a><br>13.<a href=\"https://segmentfault.com/a/1190000007769327\" target=\"_blank\" rel=\"noopener\">dyld 加载 Mach-O</a><br>14.<a href=\"http://www.zoomfeng.com/blog/launch-time.html\" target=\"_blank\" rel=\"noopener\">iOS启动时间优化</a><br>15.<a href=\"https://developer.apple.com/videos/play/wwdc2016/406/\" target=\"_blank\" rel=\"noopener\">2016WWDC-Optimizing App Startup Time</a><br>16.<a href=\"https://www.jianshu.com/p/ef3415255808\" target=\"_blank\" rel=\"noopener\">深入iOS系统底层之静态库</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS编译原理","url":"http://hchong.net/2019/07/30/iOS编译原理/","content":"<h1 id=\"1-编译器\"><a href=\"#1-编译器\" class=\"headerlink\" title=\"1 编译器\"></a>1 编译器</h1><p>把一种编程语言(原始语言)转换为另一种编程语言(目标语言)的程序叫做编译器. 大多数编译器由两部分组成: 前端和后端.</p>\n<ul>\n<li>前端负责词法分析，语法分析，生成中间代码；</li>\n<li>后端以中间代码作为输入，进行行架构无关的代码优化，接着针对不同架构生成不同的机器码。</li>\n</ul>\n<p>前后端依赖统一格式的中间代码(IR), 使得前后端可以独立的变化. 新增一门语言只需要修改前端, 而新增一个CPU架构只需要修改后端即可. Objective C/C/C++使用的编译器前端是clang, swift是swift, 后端都是LLVM.</p>\n<h2 id=\"1-1-LLVM\"><a href=\"#1-1-LLVM\" class=\"headerlink\" title=\"1.1 LLVM\"></a>1.1 LLVM</h2><p>LLVM的核心库提供了现代化的source-target-independent优化器和支持诸多流行CPU架构的代码生成器. Clang 和 LLDB都是基于LLVM衍生的子项目.</p>\n<h2 id=\"1-2-Clang\"><a href=\"#1-2-Clang\" class=\"headerlink\" title=\"1.2 Clang\"></a>1.2 Clang</h2><p>Clang是C语言家族的编译器前端，诞生之初是为了替代GCC，提供更快的编译速度。一张图了解clang编译的大致流程:<br><img src=\"http://img.souche.com/f2e/37ed1e0d8177f88af9dea23eb6061f5c.png\" alt=\"Clang流程\"></p>\n<p>大致看来, Clang可以分为一下几个步骤: 预处理 -&gt; 词法分析 -&gt; 语法分析 -&gt; 静态分析 -&gt; 生成中间代码和优化 -&gt; 汇编 -&gt; 链接</p>\n<h3 id=\"1-2-1-预处理-preprocessor\"><a href=\"#1-2-1-预处理-preprocessor\" class=\"headerlink\" title=\"1.2.1 预处理(preprocessor)\"></a>1.2.1 预处理(preprocessor)</h3><p>预处理会进行如下操作:</p>\n<ul>\n<li>头文件引入, 递归将头文件引用替换为头文件中的实际内容, 所以尽量减少头文件中的#import, 使用@class替代, 把#import放到.m文件中.</li>\n<li>宏替换, 在源码中使用的宏定义会被替换为对应#define的内容, 不要在需要预处理的代码中加入太多的内联代码逻辑</li>\n<li>注释处理, 在预处理的时候, 注释被删除</li>\n<li>条件编译, (#if, #else, #endif)</li>\n</ul>\n<h3 id=\"1-2-2-词法分析-lexical-anaysis\"><a href=\"#1-2-2-词法分析-lexical-anaysis\" class=\"headerlink\" title=\"1.2.2 词法分析(lexical anaysis)\"></a>1.2.2 词法分析(lexical anaysis)</h3><p>这一步把源文件中的代码转化为特殊的标记流. 词法分析器读入源文件的字符流, 将他们组织称有意义的词素(lexeme)序列，对于每个词素，此法分析器产生词法单元（token）作为输出.</p>\n<p>源码被分割成一个一个的字符和单词, 在行尾Loc中都标记出了源码所在的对应源文件和具体行数, 方便在报错时定位问题. 类似于下面:</p>\n<pre><code class=\"C\">int &#39;int&#39;     [StartOfLine]    Loc=&lt;main.m:14:1&gt;\nidentifier &#39;main&#39;     [LeadingSpace]    Loc=&lt;main.m:14:5&gt;\nl_paren &#39;(&#39;        Loc=&lt;main.m:14:9&gt;\nint &#39;int&#39;        Loc=&lt;main.m:14:10&gt;\nidentifier &#39;argc&#39;     [LeadingSpace]    Loc=&lt;main.m:14:14&gt;\ncomma &#39;,&#39;        Loc=&lt;main.m:14:18&gt;\nchar &#39;char&#39;     [LeadingSpace]    Loc=&lt;main.m:14:20&gt;\nstar &#39;*&#39;     [LeadingSpace]    Loc=&lt;main.m:14:25&gt;\n</code></pre>\n<h3 id=\"1-2-3-语法分析-semantic-analysis\"><a href=\"#1-2-3-语法分析-semantic-analysis\" class=\"headerlink\" title=\"1.2.3 语法分析(semantic analysis)\"></a>1.2.3 语法分析(semantic analysis)</h3><p>词法分析的Token流会被解析成一颗抽象语法树(abstract syntax tree - AST). 在这里面每一节点也都标记了其在源码中的位置.</p>\n<p>有了抽象语法树，clang就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或Objective C中向target发送了一个未实现的消息.</p>\n<p>AST是开发者编写clang插件主要交互的数据结构，clang也提供很多API去读取AST.<a href=\"https://clang.llvm.org/docs/IntroductionToTheClangAST.html\" target=\"_blank\" rel=\"noopener\">Introduction to the Clang AST</a></p>\n<h3 id=\"1-2-4-静态分析-CodeGen\"><a href=\"#1-2-4-静态分析-CodeGen\" class=\"headerlink\" title=\"1.2.4 静态分析(CodeGen)\"></a>1.2.4 静态分析(CodeGen)</h3><p>把源码转化为抽象语法树之后，编译器就可以对这个树进行分析处理。静态分析会对代码进行错误检查，如出现方法被调用但是未定义、定义但是未使用的变量等，以此提高代码质量. 也可以使用 Xcode 自带的静态分析工具（Product -&gt; Analyze).</p>\n<p>常见的操作有:</p>\n<ul>\n<li><p>当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查. 最常见的是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正常函数。如果你给一个单纯的 NSObject* 对象发送了一个 hello 消息，那么 clang 就会报错，同样，给属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告.</p>\n<blockquote>\n<p>一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。</p>\n</blockquote>\n<blockquote>\n<p>至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。</p>\n</blockquote>\n</li>\n<li>检查是否有定义了，但是从未使用过的变量</li>\n<li>检查在 你的初始化方法中中调用 self 之前, 是否已经调用 [self initWith…] 或 [super init] 了</li>\n</ul>\n<p>此处遍历语法树，最终生成LLVM IR代码。<em>LLVM IR是前端的输出，后端的输入. Objective C代码在这一步会进行runtime的桥接：property合成，ARC处理等</em></p>\n<p>LLVM 会去做些优化工作, 在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass. </p>\n<p>如果开启了 Bitcode 苹果会做进一步的优化. 虽然Bitcode仅仅只是一个中间码不能在任何平台上运行, 但是它可以转化为任何被支持的CPU架构, 包括现在还没被发明的CPU架构. iOS Apps中Enable Bitcode 为可选项, WatchOS和tvOS, Bitcode必须开启. 如果你的App支持Bitcode, App Bundle（项目中所有的target）中的所有的 Apps 和 frameworks 都需要支持Bitcode.</p>\n<h3 id=\"1-2-5-生成汇编指令\"><a href=\"#1-2-5-生成汇编指令\" class=\"headerlink\" title=\"1.2.5 生成汇编指令\"></a>1.2.5 生成汇编指令</h3><p>LLVM对IR进行优化后，会对代码进行编译优化例如针对全局变量优化、循环优化、尾递归优化等, 然后会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出.</p>\n<h3 id=\"1-2-6-汇编\"><a href=\"#1-2-6-汇编\" class=\"headerlink\" title=\"1.2.6 汇编\"></a>1.2.6 汇编</h3><p>在这一阶段，汇编器将上一步生成的可读的汇编代码转化为机器代码。最终产物就是 以 .o 结尾的目标文件。使用Xcode构建的程序会在DerivedData目录中找到这个文件</p>\n<p>Tips：什么是符号(Symbols)? 符号就是指向一段代码或者数据的名称。还有一种叫做WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如iOS 12特有的API，在iOS11上就没有.</p>\n<h3 id=\"1-2-7-链接\"><a href=\"#1-2-7-链接\" class=\"headerlink\" title=\"1.2.7 链接\"></a>1.2.7 链接</h3><p>目标文件(.o)和引用的库(dylib,a,tbd)链接起来, 最终生成可执行文件(mach-o), 链接器解决了目标文件和库之间的链接.</p>\n<p>这时可执行文件的符号表信息已经有了, 会在运行时动态绑定. </p>\n<h3 id=\"1-2-8-Mach-O文件\"><a href=\"#1-2-8-Mach-O文件\" class=\"headerlink\" title=\"1.2.8 Mach-O文件\"></a>1.2.8 Mach-O文件</h3><p>Mach-O是OS X中二进制文件的原生可执行格式，是传送代码的首选格式。可执行格式决定了二进制文件中的代码和数据读入内存的顺序。代码和数据的顺序会影响内存使用和分页活动，从而直接影响程序的性能. </p>\n<p>Mach-O是记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改.</p>\n<p>Mach-O 文件包含三个区域: </p>\n<ul>\n<li>Mach-O Header: 包含字节顺序，magic，cpu 类型，加载指令的数量等.</li>\n<li>Load Commands: 包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等.</li>\n<li>Data: 最大的部分，包含了代码，数据，比如符号表，动态符号表等.</li>\n</ul>\n<p><a href=\"https://www.desgard.com/iOS-Source-Probe/C/mach-o/Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%B4%A2.html\" target=\"_blank\" rel=\"noopener\">Mach-O 文件格式探索</a><br><a href=\"https://www.jianshu.com/p/8498cec10a41\" target=\"_blank\" rel=\"noopener\">趣探 Mach-O：加载过程</a></p>\n<h3 id=\"1-2-9-dyld动态链接\"><a href=\"#1-2-9-dyld动态链接\" class=\"headerlink\" title=\"1.2.9 dyld动态链接\"></a>1.2.9 dyld动态链接</h3><p>生成可执行文件后就是在启动时进行动态链接了, 进行符号和地址的绑定. 首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数.</p>\n<h3 id=\"1-2-10-dSYM\"><a href=\"#1-2-10-dSYM\" class=\"headerlink\" title=\"1.2.10 dSYM\"></a>1.2.10 dSYM</h3><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化</p>\n<p>当release的版本 crash的时候,会有一个日志文件,包含出错的内存地址, 使用symbolicatecrash工具能够把日志和dSYM文件转换成可以阅读的log信息,也就是将内存地址,转换成程序里的函数或变量和所属于的 文件名.</p>\n<p><a href=\"https://www.jianshu.com/p/0b6f5148dab8\" target=\"_blank\" rel=\"noopener\">这里</a>是一篇通过dsym来解析crash文件的教程.</p>\n<h1 id=\"2-Xcode编译\"><a href=\"#2-Xcode编译\" class=\"headerlink\" title=\"2 Xcode编译\"></a>2 Xcode编译</h1><p>按下Command+B, 在XCode的Report Navigator模块中, 可以找到编译的详细日志:</p>\n<ul>\n<li>创建Product.app的文件夹</li>\n<li>把Entitlements.plist写入到DerivedData里，处理打包的时候需要的信息（比如application-identifier）. Entitlements.plist保存了App需要使用的特殊权限，比如iCloud，远程通知，Siri等</li>\n<li>创建一些辅助文件，比如各种.hmap，这是headermap文件，具体作用下文会讲解。</li>\n<li>执行CocoaPods的编译前脚本：检查Manifest.lock文件。</li>\n<li>编译.m文件，生成.o文件。</li>\n<li>链接动态库，o文件，生成一个mach o格式的可执行文件。</li>\n<li>编译assets，编译storyboard，链接storyboard</li>\n<li>拷贝动态库Logger.framework，并且对其签名</li>\n<li>执行CocoaPods编译后脚本：拷贝CocoaPods Target生成的Framework</li>\n<li>对Demo.App签名，并验证（validate）</li>\n<li>生成Product.app</li>\n</ul>\n<h1 id=\"3-编译顺序\"><a href=\"#3-编译顺序\" class=\"headerlink\" title=\"3 编译顺序\"></a>3 编译顺序</h1><p>XCode是根据下面的依赖关系, 尽可能的利用多核性能, 多Target并发编译: </p>\n<ul>\n<li>Target Dependencies - 显式声明的依赖关系</li>\n<li>Linked Frameworks and Libraries - 隐式声明的依赖关系</li>\n<li>Build Phase - 定义了编译一个Target的每一步</li>\n</ul>\n<p>XCode会对每一个Task生成一个哈希值, 只有哈希值改变的时候才会重新编译. 所以是<em>增量编译</em>速度很快, </p>\n<h1 id=\"4-头文件\"><a href=\"#4-头文件\" class=\"headerlink\" title=\"4 头文件\"></a>4 头文件</h1><p>头文件对于编译器来说就是一个promise. 头文件里的声明, 编译会认为有对应实现, 在链接的时候再解决具体实现的位置. 当只有声明，没有实现的时候，链接器就会报错。</p>\n<p>Objective C的方法要到运行时才会报错，因为Objective C是一门动态语言，编译器无法确定对应的方法名(SEL)在运行时到底有没有实现(IMP).</p>\n<p>日常开发中，两种常见的头文件引入方式:</p>\n<pre><code class=\"OC\">#include &quot;CustomClass.h&quot; //自定义\n#include &lt;Foundation/Foundation.h&gt; //系统或者内部framework\n</code></pre>\n<p>这里有个文件类型叫做heademap, headermap是帮助编译器找到头文件的辅助文件: 存储这头文件到其物理路径的映射关系.</p>\n<ul>\n<li>clang发现#import “TestView.h”的时候, 先在headermap(Demo-generated-files.hmap,Demo-project-headers.hmap)里查找, 如果headermap文件找不到，接着在own target的framework里找</li>\n<li>系统的头文件查找的时候也是优先headermap，headermap查找不到会查找own target framework，最后查找SDK目录</li>\n<li>以#import &lt;Foundation/Foundation.h&gt;为例，在SDK目录查找时首先查找framework是否存在, 如果framework存在，再在headers目录里查找头文件是否存在</li>\n</ul>\n<p><a href>#import””与#import&lt;&gt;的区别</a></p>\n<h1 id=\"5-Clang-Module\"><a href=\"#5-Clang-Module\" class=\"headerlink\" title=\"5 Clang Module\"></a>5 Clang Module</h1><p>传统的#include/#import都是文本语义: 预处理器在处理的时候会把这一行替换成对应头文件的文本, 这样就导致:</p>\n<ul>\n<li>大量的预处理消耗。假如有N个头文件，每个头文件又#include了M个头文件，那么整个预处理的消耗是N*M。</li>\n<li>文件导入后，宏定义容易出现问题。因为是文本导入，并且按照include依次替换，当一个头文件定义了#define std hello_world，而第另一个头文件刚好又是C++标准库，那么include顺序不同，可能会导致所有的std都会被替换。</li>\n<li>边界不明显。拿到一组.a和.h文件，很难确定.h是属于哪个.a的，需要以什么样的顺序导入才能正确编译</li>\n</ul>\n<p>clang module不再使用文本模型, 而是采用更高效的语义模型。clang module提供了一种新的导入方式:@import，module会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从M*N变成了M+N.</p>\n<p>XCode创建的Target是Framework的时候，默认define module会设置为YES，从而支持module，当然像Foundation等系统的framwork同样支持module. </p>\n<p><code>#import &lt;Foundation/NSString.h&gt;</code>的时候，编译器会检查NSString.h是否在一个module里，如果是的话，这一行会被替换成<code>@import Foundation</code>.</p>\n<p>modulemap文件描述了一组头文件如何转换为一个module. swift是可以直接import一个clang module的，比如你有一些C库，需要在Swift中使用，就可以用modulemap的方式.</p>\n<h1 id=\"6-Swift编译\"><a href=\"#6-Swift编译\" class=\"headerlink\" title=\"6 Swift编译\"></a>6 Swift编译</h1><p>编译一个Swift头文件，需要解析module中所有的Swift文件，找到对应的声明. 这也就是swift没有头文件又是怎么找到声明的原因.</p>\n<h2 id=\"6-1-Swift调用OC\"><a href=\"#6-1-Swift调用OC\" class=\"headerlink\" title=\"6.1 Swift调用OC\"></a>6.1 Swift调用OC</h2><p>Swift的编译器内部使用了clang，所以swift可以直接使用clang module，从而支持直接import Objective C编写的framework. swift编译器会从objective c头文件里查找符号，头文件的来源分为两大类: </p>\n<ul>\n<li>Bridging-Header.h中暴露给swfit的头文件</li>\n<li>framework中公开的头文件，根据编写的语言不同，可能从modulemap或者umbrella header查找</li>\n</ul>\n<p>XCode提供了宏定义NS_SWIFT_NAME来让开发者定义Objective C =&gt; Swift的符号映射，可以通过Related Items -&gt; Generate Interface来查看转换后的结果</p>\n<h2 id=\"6-2-OC调用Swift\"><a href=\"#6-2-OC调用Swift\" class=\"headerlink\" title=\"6.2 OC调用Swift\"></a>6.2 OC调用Swift</h2><p>xcode会以module为单位，为swift自动生成头文件，供Objective C引用，通常这个文件命名为ProductName-Swift.h</p>\n<p>swift提供了关键词@objc来把类型暴露给Objective C和Objective C Runtime.</p>\n<h1 id=\"7-深入理解链接-Linker\"><a href=\"#7-深入理解链接-Linker\" class=\"headerlink\" title=\"7 深入理解链接(Linker)\"></a>7 深入理解链接(Linker)</h1><p>链接器会把编译器编译生成的多个文件，链接成一个可执行文件。链接并不会产生新的代码，只是在现有代码的基础上做移动和补丁.</p>\n<p>链接器的输入可能是以下几种文件: </p>\n<ul>\n<li>object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。</li>\n<li>动态库(.dylib)，mach o类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到app里，运行时加载</li>\n<li>静态库(.a)，由ar命令打包的一组.o文件，链接的时候会把具体的代码拷贝到最后的mach-o</li>\n<li>tbd，只包含符号的库文件</li>\n</ul>\n<p>以打印<code>hello world</code>为例, 在.o文件中字符串”hello world\\n”作为一个符号(l_.str)被引用，汇编代码读取的时候按照l_.str所在的页加上偏移量的方式读取，然后调用printf符号。到这一步，CPU还不知道怎么执行，因为还有两个问题没解决:</p>\n<ul>\n<li>l_.str在可执行文件的哪个位置？</li>\n<li>printf函数来自哪里</li>\n</ul>\n<p>但是链接之后的mach o文件中确可以正常执行, 是因为: </p>\n<ul>\n<li>链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了l_.str的位置问题。</li>\n<li>链接后，不再是调用符号_printf，而是在DATA段上创建了一个函数指针_printf$ptr，初始值为0x0(null)，代码直接调用这个函数指针。启动的时候，dyld会把DATA段上的指针进行动态绑定，绑定到具体虚拟内存中的_printf地址</li>\n</ul>\n<p>Mach-O有一个区域叫做LINKEDIT，这个区域用来存储启动的时dyld需要动态修复的一些数据: 比如刚刚提到的printf在内存中的地址.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://juejin.im/post/5c22eaf1f265da611b5863b2\" target=\"_blank\" rel=\"noopener\">深入浅出iOS编译</a><br>2.<a href=\"https://juejin.im/post/5c17720af265da615304adc0\" target=\"_blank\" rel=\"noopener\">iOS编译过程</a><br>3.<a href=\"https://blog.csdn.net/Hello_Hwc/article/details/78317863\" target=\"_blank\" rel=\"noopener\">深入理解iOS App的启动过程</a><br>4.<a href=\"https://www.jianshu.com/p/0b6f5148dab8\" target=\"_blank\" rel=\"noopener\">命令行工具解析Crash文件,dSYM文件进行符号化</a><br>5.<a href=\"https://www.desgard.com/iOS-Source-Probe/C/mach-o/Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%B4%A2.html\" target=\"_blank\" rel=\"noopener\">Mach-O 文件格式探索</a><br>6.<a href=\"https://www.jianshu.com/p/8498cec10a41\" target=\"_blank\" rel=\"noopener\">趣探 Mach-O：加载过程</a><br>7.<a href=\"https://juejin.im/post/5ab47ca1518825611a406a39\" target=\"_blank\" rel=\"noopener\">探秘 Mach-O 文件</a><br>8.<a href=\"https://developerdoc.com/essay/LLDB/LLVM%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">iOS编译过程</a><br>9.<a href=\"https://objccn.io/issue-6-2/\" target=\"_blank\" rel=\"noopener\">编译器</a><br>10.<a href=\"https://objccn.io/issue-6-3/\" target=\"_blank\" rel=\"noopener\">Mach-O可执行文件</a><br>11.<a href=\"https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8.md\" target=\"_blank\" rel=\"noopener\">iOS编译过程的原理和应用</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发工程化-cocoapods详解","url":"http://hchong.net/2019/07/29/iOS开发工程化-cocoapods详解/","content":"<p>本文主要讲解cocoapods的相关知识, 关于cocoapods的实践, 可以参考<a href=\"http://hchong.net/2017/05/24/Cocoapods%E5%AE%9E%E8%B7%B5/\">这里</a>.</p>\n<h1 id=\"1-源码分析\"><a href=\"#1-源码分析\" class=\"headerlink\" title=\"1 源码分析\"></a>1 源码分析</h1><p>pod的使用主要在 <code>pod install</code> 和 <code>pod update</code>, 我们可以在cocoapods的1.7.5版本中查看入口的<a href=\"https://github.com/CocoaPods/CocoaPods/blob/1.7.5/lib/cocoapods/installer.rb\" target=\"_blank\" rel=\"noopener\">源码</a>.</p>\n<pre><code class=\"ruby\">def install!\n  prepare\n  resolve_dependencies\n  download_dependencies\n  validate_targets\n  generate_pods_project\n  if installation_options.integrate_targets?\n    integrate_user_project\n  else\n    UI.section &#39;Skipping User Project Integration&#39;\n  end\n  perform_post_install_actions\nend\n</code></pre>\n<p>分析源码可以发现, install的执行分为如下几个步骤: <em>准备阶段, 查找依赖库, 下载依赖文件, 检验target, 生成pod工程, 整合project文件, 执行安装后操作</em>, 下面会逐步讲解一下.</p>\n<h2 id=\"1-1-准备阶段\"><a href=\"#1-1-准备阶段\" class=\"headerlink\" title=\"1.1 准备阶段\"></a>1.1 准备阶段</h2><pre><code class=\"ruby\">def prepare\n  # Raise if pwd is inside Pods\n  if Dir.pwd.start_with?(sandbox.root.to_path)\n    message = &#39;Command should be run from a directory outside Pods directory.&#39;\n    message &lt;&lt; &quot;\\n\\n\\tCurrent directory is #{UI.path(Pathname.pwd)}\\n&quot;\n    raise Informative, message\n  end\n  UI.message &#39;Preparing&#39; do\n    deintegrate_if_different_major_version\n    sandbox.prepare\n    ensure_plugins_are_installed!\n    run_plugins_pre_install_hooks\n  end\nend\n</code></pre>\n<p>我们可以看到, 准备阶段(prepare)主要做了以下事情:</p>\n<ul>\n<li>检查podfile.lock的写入的cocoapods版本和当前cocoapods版本是否一致，如果不一致将会重塑工程，将除了Podfile、Podfile.lock、Workspace以外的其他关联和依赖全部重置</li>\n<li>沙盒的准备 - 一些文件以及目录的删除以及创建</li>\n<li>迁移沙盒中部分文件(区分Pods版本迁移地址不同)</li>\n<li>确保Podfile指定的插件都已经安装(不然抛错)</li>\n<li>执行pre_install的Hook</li>\n</ul>\n<h2 id=\"1-2-查找依赖库\"><a href=\"#1-2-查找依赖库\" class=\"headerlink\" title=\"1.2 查找依赖库\"></a>1.2 查找依赖库</h2><pre><code class=\"ruby\">def resolve_dependencies\n  plugin_sources = run_source_provider_hooks\n  analyzer = create_analyzer(plugin_sources)\n\n  UI.section &#39;Updating local specs repositories&#39; do\n    analyzer.update_repositories\n  end if repo_update?\n\n  UI.section &#39;Analyzing dependencies&#39; do\n    analyze(analyzer)\n    validate_build_configurations\n  end\n\n  UI.section &#39;Verifying no changes&#39; do\n    verify_no_podfile_changes!\n    verify_no_lockfile_changes!\n  end if deployment?\n\n  analyzer\nend\n</code></pre>\n<p>我们可以看到, 查找依赖库(resolve_dependencies)主要做了以下事情:</p>\n<ul>\n<li>遍历注册的所有插件，其中通过HooksManager.register方法注册name为:source_provider的插件</li>\n<li>执行create_analyzer方法创建安装分析器</li>\n<li>如果我们在执行pod install时附加了–repo-updateflag, 则刚才创建的analyzer实例将执行update_repositories方法去更新本地repo仓库的所有pod spec文件.</li>\n<li>验证Build Configurations参数的有效性</li>\n<li>验证podfile的变化</li>\n<li>验证lockfile的变化</li>\n</ul>\n<h2 id=\"1-3-下载依赖文件\"><a href=\"#1-3-下载依赖文件\" class=\"headerlink\" title=\"1.3 下载依赖文件\"></a>1.3 下载依赖文件</h2><pre><code class=\"ruby\">def download_dependencies\n  UI.section &#39;Downloading dependencies&#39; do\n    install_pod_sources\n    run_podfile_pre_install_hooks\n    clean_pod_sources\n  end\nend\n</code></pre>\n<p>我们可以看到, 下载依赖文件(download_dependencies)主要做了以下事情:</p>\n<ul>\n<li>下载安装Pods依赖库源文件</li>\n<li>执行Podfile中pre_install钩子方法</li>\n<li>根据Config和Installers参数清理Pods的源文件</li>\n</ul>\n<h2 id=\"1-4-检验target\"><a href=\"#1-4-检验target\" class=\"headerlink\" title=\"1.4 检验target\"></a>1.4 检验target</h2><pre><code class=\"ruby\">def validate_targets\n  validator = Xcode::TargetValidator.new(aggregate_targets, pod_targets)\n  validator.validate!\nend\n</code></pre>\n<p>检验target(validate_targets), 主要做了以下事情:</p>\n<ul>\n<li>检测是否有多重引用 framework 或者 library 的情况(Framework的名字是否冲突, 如果冲突会抛出<code>frameworks with conflicting names</code>异常)</li>\n<li>处理静态库传递依赖问题(静态库的传递依赖如果形成会主动抛出<code>transitive dependencies that include static binaries</code>异常)</li>\n<li>校验不同 target 所引用的代码中, 如果包含 swift, 所使用的 swift 版本是否相同</li>\n<li>检查是否引用了Switf书写的framework(Podfile中没有指定use framework!。如果验证不通过, 主动抛出异常)</li>\n</ul>\n<h2 id=\"1-5-生成Pods工程\"><a href=\"#1-5-生成Pods工程\" class=\"headerlink\" title=\"1.5 生成Pods工程\"></a>1.5 生成Pods工程</h2><pre><code class=\"ruby\">def generate_pods_project\n  stage_sandbox(sandbox, pod_targets)\n\n  cache_analysis_result = analyze_project_cache\n  pod_targets_to_generate = cache_analysis_result.pod_targets_to_generate\n  aggregate_targets_to_generate = cache_analysis_result.aggregate_targets_to_generate\n\n  clean_sandbox(pod_targets_to_generate)\n\n  create_and_save_projects(pod_targets_to_generate, aggregate_targets_to_generate,\n                           cache_analysis_result.build_configurations, cache_analysis_result.project_object_version)\n  SandboxDirCleaner.new(sandbox, pod_targets, aggregate_targets).clean!\n\n  update_project_cache(cache_analysis_result, target_installation_results)\n  write_lockfiles\nend\n</code></pre>\n<p>生成Pods工程(generate_pods_project), 主要做了:</p>\n<ul>\n<li>调用Podfile中post_install钩子方法</li>\n<li>生成Pods/目录下面的所有工程</li>\n<li>生成Podfile.lock文件和Manifest.lock文件</li>\n</ul>\n<h2 id=\"1-6-整合project文件\"><a href=\"#1-6-整合project文件\" class=\"headerlink\" title=\"1.6 整合project文件\"></a>1.6 整合project文件</h2><pre><code class=\"ruby\">def integrate_user_project\n  UI.section &quot;Integrating client #{&#39;project&#39;.pluralize(aggregate_targets.map(&amp;:user_project_path).uniq.count)}&quot; do\n    installation_root = config.installation_root\n    integrator = UserProjectIntegrator.new(podfile, sandbox, installation_root, aggregate_targets, generated_aggregate_targets,\n                                           :use_input_output_paths =&gt; !installation_options.disable_input_output_paths?)\n    integrator.integrate!\n  end\nend\n</code></pre>\n<p>整合project文件(integrate_user_project), 主要做了:</p>\n<ul>\n<li>创建.xcworkspace文件</li>\n<li>集成Target</li>\n<li>警告检查</li>\n<li>保存.xcworkspace文件到目录</li>\n</ul>\n<h2 id=\"1-7-执行安装后操作\"><a href=\"#1-7-执行安装后操作\" class=\"headerlink\" title=\"1.7 执行安装后操作\"></a>1.7 执行安装后操作</h2><pre><code class=\"ruby\">def perform_post_install_actions\n  run_plugins_post_install_hooks\n  warn_for_deprecations\n  warn_for_installed_script_phases\n  print_post_install_message\nend\n</code></pre>\n<p>执行安装后操作(perform_post_install_actions), 主要做了以下操作:</p>\n<ul>\n<li>unLock Pods库下的文件</li>\n<li>调用plugin的post_install钩子方法</li>\n<li>打印所有被废弃的pods警告信息</li>\n<li>打印所有pods中脚本的警告信息</li>\n<li>打印install中的所有信息</li>\n</ul>\n<h2 id=\"1-8-总结\"><a href=\"#1-8-总结\" class=\"headerlink\" title=\"1.8 总结\"></a>1.8 总结</h2><ul>\n<li>准备阶段<ul>\n<li>检查podfile.lock的写入的cocoapods版本和当前cocoapods版本是否一致，如果不一致将会重塑工程，将除了Podfile、Podfile.lock、Workspace以外的其他关联和依赖全部重置</li>\n<li>沙盒的准备 - 一些文件以及目录的删除以及创建</li>\n<li>迁移沙盒中部分文件(区分Pods版本迁移地址不同)</li>\n<li>确保Podfile指定的插件都已经安装(不然抛错)</li>\n<li>执行pre_install的Hook</li>\n</ul>\n</li>\n<li>查找依赖库<ul>\n<li>遍历注册的所有插件，其中通过HooksManager.register方法注册name为:source_provider的插件</li>\n<li>执行create_analyzer方法创建安装分析器</li>\n<li>如果我们在执行pod install时附加了–repo-updateflag, 则刚才创建的analyzer实例将执行update_repositories方法去更新本地repo仓库的所有pod spec文件.</li>\n<li>验证Build Configurations参数的有效性</li>\n<li>验证podfile的变化</li>\n<li>验证lockfile的变化   </li>\n</ul>\n</li>\n<li>下载依赖文件<ul>\n<li>下载安装Pods依赖库源文件</li>\n<li>执行Podfile中pre_install钩子方法</li>\n<li>根据Config和Installers参数清理Pods的源文件* </li>\n</ul>\n</li>\n<li>检验target<ul>\n<li>检测是否有多重引用 framework 或者 library 的情况(Framework的名字是否冲突, 如果冲突会抛出<code>frameworks with conflicting names</code>异常)</li>\n<li>处理静态库传递依赖问题(静态库的传递依赖如果形成会主动抛出<code>transitive dependencies that include static binaries</code>异常)</li>\n<li>校验不同 target 所引用的代码中, 如果包含 swift, 所使用的 swift 版本是否相同</li>\n<li>检查是否引用了Switf书写的framework(Podfile中没有指定use framework!。如果验证不通过, 主动抛出异常)</li>\n</ul>\n</li>\n<li>生成pod工程<ul>\n<li>调用Podfile中post_install钩子方法<ul>\n<li>生成Pods/目录下面的所有工程</li>\n<li>生成Podfile.lock文件和Manifest.lock文件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>整合project文件<ul>\n<li>创建.xcworkspace文件</li>\n<li>集成Target</li>\n<li>警告检查</li>\n<li>保存.xcworkspace文件到目录 </li>\n</ul>\n</li>\n<li>执行安装后操作<ul>\n<li>unLock Pods库下的文件</li>\n<li>调用plugin的post_install钩子方法</li>\n<li>打印所有被废弃的pods警告信息</li>\n<li>打印所有pods中脚本的警告信息</li>\n<li>打印install中的所有信息  </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"2-实践-amp-私有Pod\"><a href=\"#2-实践-amp-私有Pod\" class=\"headerlink\" title=\"2 实践 &amp; 私有Pod\"></a>2 实践 &amp; 私有Pod</h1><p>可以参考之前的<a href=\"http://hchong.net/2017/05/24/Cocoapods%E5%AE%9E%E8%B7%B5/\">总结</a></p>\n<h1 id=\"3-二进制方案\"><a href=\"#3-二进制方案\" class=\"headerlink\" title=\"3 二进制方案\"></a>3 二进制方案</h1><p><a href=\"https://dmanager.github.io/ios/2019/01/21/%E5%9F%BA%E4%BA%8ECocoaPods%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p><a href=\"https://www.jianshu.com/p/5338bc626eaf\" target=\"_blank\" rel=\"noopener\">这里</a>是业界比较完善的解决方案</p>\n<ul>\n<li>主要的思路就是在创建pod的时候会同时存在源码和framework两种形态的包(可以通过新建target或者新建工程两种方式) </li>\n<li>在podspec中根据传入的参数来指定如何在源码和二进制中切换.</li>\n</ul>\n<h1 id=\"4-常见问题\"><a href=\"#4-常见问题\" class=\"headerlink\" title=\"4 常见问题\"></a>4 常见问题</h1><hr>\n<p>参考资料:<br>1.<a href=\"https://draveness.me/cocoapods\" target=\"_blank\" rel=\"noopener\">CocoaPods 都做了什么?</a><br>2.<a href=\"http://silentcat.top/2018/09/04/Cocoapods%E6%BA%90%E7%A0%81%E6%B5%85%E8%B0%88/\" target=\"_blank\" rel=\"noopener\">Cocoapods源码浅谈</a><br>3.<a href=\"http://blog.startry.com/2015/09/29/Something-about-Pod-Install-And-Pod-Update/\" target=\"_blank\" rel=\"noopener\">pod install和pod update背后那点事</a><br>4.<a href=\"https://github.com/CocoaPods/CocoaPods/blob/1.7.5/lib/cocoapods/installer.rb\" target=\"_blank\" rel=\"noopener\">cocoapods源码</a><br>5.<a href=\"https://juejin.im/post/5cbec5fb5188250aa21919d0\" target=\"_blank\" rel=\"noopener\">Cocoapods 二进制</a><br>6.<a href=\"https://dmanager.github.io/ios/2019/01/21/%E5%9F%BA%E4%BA%8ECocoaPods%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/\" target=\"_blank\" rel=\"noopener\">基于 CocoaPods 的组件二进制化实践</a><br>7.<a href=\"https://www.jianshu.com/p/5338bc626eaf\" target=\"_blank\" rel=\"noopener\">iOS CocoaPods组件平滑二进制化解决方案</a><br>8.<a href=\"https://www.jianshu.com/p/85c97dc9ab83\" target=\"_blank\" rel=\"noopener\">iOS CocoaPods组件平滑二进制化解决方案及详细教程二之subspecs篇</a></p>\n","categories":["iOS开发-工程化"],"tags":["基础知识"]},{"title":"iOS开发基础-生命周期","url":"http://hchong.net/2019/07/27/iOS开发基础-生命周期/","content":"<p>这里主要总结一下iOS开发中一些声明周期相关的知识</p>\n<h1 id=\"1-UIView的生命周期\"><a href=\"#1-UIView的生命周期\" class=\"headerlink\" title=\"1 UIView的生命周期\"></a>1 UIView的生命周期</h1><p>当创建View的时: </p>\n<ol>\n<li><code>initWithFrame:</code>, initWithFrame进行初始化时, 当rect的值不为CGRectZero时会触发layoutSubviews. init初始化不会触发layoutSubviews.</li>\n<li><code>willMoveToSuperview:</code></li>\n<li><code>didMoveToSuperview</code></li>\n<li><code>willMoveToWindow:</code></li>\n<li><code>didMoveToWindow</code></li>\n<li><code>layoutSubviews</code>, 在子视图布局变动时会多次调用.</li>\n</ol>\n<p>当View销毁时:</p>\n<ol>\n<li><code>willMoveToWindow:</code></li>\n<li><code>didMoveToWindow</code></li>\n<li><code>willMoveToSuperview:</code></li>\n<li><code></code>didMoveToSuperview`</li>\n<li><code>removeFromSuperview</code></li>\n<li><code>dealloc</code></li>\n</ol>\n<p>如果View中有子View的话, 创建时除了上面的顺序之外, 还会调用:</p>\n<ol>\n<li><code>layoutSubviews</code>, 这是因为子视图的布局变动, 所以会触发.</li>\n<li><code>didAddSubview:</code></li>\n<li><code>drawRect:</code>.</li>\n</ol>\n<p>移除时, 除了上面的顺序之外, 还会调用:</p>\n<ol>\n<li><code>willRemoveSubview:</code>, 是在dealloc后面执行的. 如果有多个子视图, willRemoveSubview会循环执行, 直到移除所有子视图.</li>\n</ol>\n<h1 id=\"2-UIViewController声明周期\"><a href=\"#2-UIViewController声明周期\" class=\"headerlink\" title=\"2 UIViewController声明周期\"></a>2 UIViewController声明周期</h1><ol>\n<li><code>initWithCoder: 或 initWithNibName:bundle:</code>, 首先从归档文件中加载UIViewController对象. 非StoryBoard创建调用<code>initWithNibName:bundle:</code>, 如果使用StoryBoard进行视图管理, 从nib中加载对象实例时, 程序不会直接初始化一个UIViewController, StoryBoard会自动初始化或在segue被触发时自动初始化<code>initWithCoder:</code>.</li>\n<li><code>awakeFromNib</code>, 从xib或者storyboard加载完毕就会调用.</li>\n<li><code>loadView</code>, 每次访问UIViewController的view(比如controller.view, self.view)而且view为nil, loadView方法就会被调用. loadView方法是用来负责创建UIViewController的view. 如果在初始化UIViewController指定了xib文件名, 就会根据传入的xib文件名加载对应的xib文件, 如果没有明显地传xib文件名, 就会加载跟UIViewController同名的xib文件. 如果没有找到相关联的xib文件, 就会创建一个空白的UIView, 然后赋值给UIViewController的view属性. 苹果设计这个方法就是给我们自定义UIViewController的view用的, 我们直接在该方法中指定UIViewController的View.</li>\n<li><code>viewDidLoad</code>, 无论你是通过xib文件还是重写loadView方法创建UIViewController的view, 在view创建完毕后, 最终都会调用viewDidLoad方法. 在这里视图层次已经加载到内存中. 通常, 我们对于各种初始化数据的载入, 初始设定, 修改约束, 移除视图等很多操作都可以这个方法中实现.</li>\n<li><code>viewWillAppear:</code>, 系统在载入所有的数据后, 将会在屏幕上显示视图, 这时会先调用这个方法, 通常我们会在这个方法对即将显示的视图做进一步的设置.</li>\n<li><code>viewWillLayoutSubviews</code>, view 即将布局其Subviews. 比如view的bounds改变了(例如:状态栏从不显示到显示,视图方向变化), 要调整Subviews的位置, 在调整之前要做的工作可以放在该方法中实现.</li>\n<li><code>viewDidLayoutSubviews</code>, view已经布局其Subviews, 这里可以放置调整完成之后需要做的工作.</li>\n<li><code>viewDidAppear:</code>, 在view被添加到视图层级中以及多视图上下级视图切换时调用这个方法, 可以对正在显示的视图做进一步的设置.</li>\n<li><code>viewWillDisappear:</code>, 当前视图在即将被移除, 或被覆盖时, 会调用该方法. 此时还没有调用removeFromSuperview.</li>\n<li><code>viewDidDisappear:</code>, view已经消失或被覆盖,视图已经被从屏幕上移除, 用户看不到这个视图了, 此时已经调用removeFromSuperView.</li>\n<li><code>viewWillUnload</code>, 如果当前有能被释放的view，系统会调用viewWillUnload方法来释放view</li>\n<li><code>dealloc</code>, UIViewController被销毁时调用, 此次需要对你在init和viewDidLoad中创建的对象进行释放.</li>\n<li><code>didReceiveMemoryWarning</code>, 内存不够时, 系统会自动调用这个方法. 默认实现是如果当前UIViewController的view不在应用程序的视图层次结构(View Hierarchy)中, 即view的superview为nil的时候, 就会将view释放, 并且调用viewDidUnload方法.</li>\n<li><code>viewDidUnload</code>, 收到内存警告时, 如果当前UIViewController的View的superView为nil时, 就会将View释放, 并且调用viewDidUnload. 从 iOS 6 开始, viewDidUnload 方法被废弃掉了</li>\n</ol>\n<h2 id=\"2-1-push-pop\"><a href=\"#2-1-push-pop\" class=\"headerlink\" title=\"2.1 push pop\"></a>2.1 push pop</h2><p>假设现在有一个 AViewController(简称 Avc) 和 BViewController (简称 Bvc)，通过 navigationController 的 push 实现 Avc 到 Bvc 的跳转，下面是各个方法的执行执行顺序：</p>\n<ol>\n<li>A loadView</li>\n<li>A viewDidLoad</li>\n<li>A viewWillAppear</li>\n<li>A viewWillLayoutSubviews</li>\n<li>A viewDidLayoutSubviews</li>\n<li>A viewDidAppear</li>\n<li>B loadView(开始跳转)</li>\n<li>B viewDidLoad</li>\n<li>A viewWillDisappear</li>\n<li>B viewWillAppear</li>\n<li>B viewWillLayoutSubviews</li>\n<li>B viewDidLayoutSubviews</li>\n<li>A viewDidDisappear</li>\n<li>B viewDidAppear</li>\n</ol>\n<p>如果再从 Bvc pop到 Avc，会产生下面的执行顺序：</p>\n<ol>\n<li>B viewWillDisappear  </li>\n<li>A viewWillAppear  </li>\n<li>B viewDidDisappear  </li>\n<li>A viewDidAppear</li>\n</ol>\n<h2 id=\"2-2-present-dismiss\"><a href=\"#2-2-present-dismiss\" class=\"headerlink\" title=\"2.2 present dismiss\"></a>2.2 present dismiss</h2><p>假设现在有一个 AViewController(简称 Avc) 和 BViewController (简称 Bvc)，通过 present 实现 Avc 到 Bvc 的跳转，下面是各个方法的执行执行顺序：</p>\n<ol>\n<li>A loadView</li>\n<li>A viewDidLoad</li>\n<li>A viewWillAppear</li>\n<li>A viewWillLayoutSubviews</li>\n<li>A viewDidLayoutSubviews</li>\n<li>A viewDidAppear</li>\n<li>B loadView(开始跳转)</li>\n<li>B viewDidLoad</li>\n<li>A viewWillDisappear</li>\n<li>B viewWillAppear</li>\n<li>B viewWillLayoutSubviews</li>\n<li>B viewDidLayoutSubviews</li>\n<li>B viewDidAppear</li>\n<li>A viewDidDisappear </li>\n</ol>\n<p>如果再从 Bvc dismiss Avc，会产生下面的执行顺序：</p>\n<ol>\n<li>B viewWillDisappear</li>\n<li>A viewWillAppear</li>\n<li>A viewDidAppear</li>\n<li>B viewDidDisappear</li>\n</ol>\n<p>总结:<br>加载的顺序是一样的, push和present的不同点:</p>\n<ul>\n<li>push时总是A先消失, B后出现. pop时总是B先消失, A再出现.</li>\n<li>present时总是B先出现, A再消失. dismiss时总是A先出现, B再消失.</li>\n</ul>\n<h1 id=\"3-AppDelegate生命周期\"><a href=\"#3-AppDelegate生命周期\" class=\"headerlink\" title=\"3 AppDelegate生命周期\"></a>3 AppDelegate生命周期</h1><ol>\n<li>进入main函数, 设置AppDelegate称为函数的代理.</li>\n<li>程序加载完成, -[AppDelegate application:didFinishLaunchingWithOptions:].</li>\n<li>创建window窗口</li>\n<li><code>applicationWillResignActive:</code>, 将进入后台. 当应用程序从活动状态(active)变到非活动状态(inactive)时被触发调用, 这可能发生在一些临时中断下(例如: 来电话, 来短信)又或者程序退出时, 他会先过渡到后台. 然后使用这方法去暂停正在进行的任务, 禁用计时器, 节流OpenGL ES 帧率. 在游戏中应该在这个方法里面暂停游戏.</li>\n<li><code>applicationDidEnterBackground:</code>, 已经进入后台. 使用这种方法来释放共享资源, 保存用户数据, 无效计时器, 存储足够多的应用程序状态信息来恢复您的应用程序的当前状态, 以防它终止丢失数据. 如果你的程序支持后台运行, 那么当用户退出时不会调用.</li>\n<li><code>applicationWillEnterForeground</code>, 将进入前台. 先从后台切换到非活动状态, 然后进入活动状态.</li>\n<li><code>applicationDidBecomeActive</code>, 已经进入前台. 重启所有的任务, 不管是从非活动状态还是刚启动程序, 还是后台状态.</li>\n<li><code>applicationWillTerminate</code>, 程序即将退出. 当应用将要终止时, 调用这个方法, 在这里我们可以做一些数据的保存.</li>\n</ol>\n<h1 id=\"4-APP启动生命周期\"><a href=\"#4-APP启动生命周期\" class=\"headerlink\" title=\"4 APP启动生命周期\"></a>4 APP启动生命周期</h1><ol>\n<li>系统先读取APP的可执行文件(Mach-O)文件, 从里面获取dyld的路径, 然后加载dyld, dyld去初始化运行环境. </li>\n<li>开启缓存策略, 加载程序相关依赖库(其中也包含我们的可执行文件)到内存中, 调用每个依赖库的初始化方法, 动态链接依赖库. 在这一步Runtime会被初始化.</li>\n<li>当所有依赖库的初始化后, 轮到最后一位(程序可执行文件)进行初始化, 在这时runtime会对项目中所有类进行类结构初始化, 然后调用所有的load方法.</li>\n<li>最后dyld返回main函数地址, main函数被调用, 我们就进入了程序的入口.</li>\n</ol>\n<p>Mach-O文件格式是 OS X 与 iOS 系统上的可执行文件格式, 像我们编译过程产生的.O文件, 以及程序的可执行文件, 动态库等都是Mach-O文件. 有如下几个部分组成:</p>\n<ul>\n<li>Header: 保存了一些基本信息, 包括了该文件运行的平台, 文件类型, LoadCommands的个数等等.</li>\n<li>LoadCommands: 可以理解为加载命令, 在加载Mach-O文件时会使用这里的数据来确定内存的分布以及相关的加载命令. 比如我们的main函数的加载地址, 程序所需的dyld的文件路径, 以及相关依赖库的文件路径.</li>\n<li>Data: 这里包含了具体的代码, 数据等等.</li>\n</ul>\n<p>dyld: (the dynamic link editor)动态链接器, 系统 kernel 做好启动程序的初始准备后，交给 dyld 负责.<br>ImageLoader: ImageLoader 作用是将这些文件加载进内存, 且每一个文件对应一个ImageLoader实例来负责加载. 在程序运行时它先将动态链接的 image(二进制文件) 递归加载,<br>再从可执行文件 image 递归加载所有符号.</p>\n<p>dyld 担当了 runtime 和 ImageLoader 中间的协调者, 当新 image 加载进来后交由 runtime 去解析这个二进制文件的符号表和代码.<br>整个调用栈顺序是这样的:</p>\n<ol>\n<li>dyld 开始将程序二进制文件初始化.</li>\n<li>交由 ImageLoader 读取 image, 其中包含了我们的类, 方法等各种符号.</li>\n<li>由于 runtime 向 dyld 绑定了回调, 当 image 加载到内存后, dyld 会通知 runtime 进行处理.</li>\n<li>runtime 接手后调用 map_images 做解析和处理. 接下来 load_images 中调用 call_load_methods 方法, 遍历所有加载进来的 Class, 按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法.</li>\n<li>至此, 可执行文件中和动态库所有的符号 (Class, Protocol, Selector, IMP, …) 都已经按格式成功加载到内存中, 被 runtime 所管理, 再这之后, runtime 的那些方法（动态添加 Class, swizzle 等等才能生效.</li>\n</ol>\n","categories":["iOS开发-基础"],"tags":["基础知识"]},{"title":"iOS开发基础-NSDictionary & NSMutableArray内部实现","url":"http://hchong.net/2019/07/25/iOS开发基础-NSDictionary-NSMutableArray内部实现/","content":"<p>dictionary(map)和array是常见的数据结构, 下面我们来看下iOS中NSDictionary和NSMutableArray的内部实现. <a href=\"https://blog.csdn.net/Deft_MKJing/article/details/82732833\" target=\"_blank\" rel=\"noopener\">这里</a>讲解的十分详细, 此处我们对主要流程做一个概述.</p>\n<h1 id=\"1-NSDictionary\"><a href=\"#1-NSDictionary\" class=\"headerlink\" title=\"1 NSDictionary\"></a>1 NSDictionary</h1><p>Foundation框架下提供了很多高级数据结构, 这些都是对Core Foundation下的封装, 例如NSDictionary就是对_CFDictionary的封装.</p>\n<pre><code class=\"C\">struct __CFDictionary {\n    CFRuntimeBase _base;\n    CFIndex _count;\n    CFIndex _capacity;\n    CFIndex _bucketsNum;\n    uintptr_t _marker;\n    void *_context;\n    CFIndex _deletes;\n    CFOptionFlags _xflags;\n    const void **_keys;    \n    const void **_values;\n};\n</code></pre>\n<p>根据数据结构可以发现dictionary内部使用了两个指针数组分别来保存keys和values, dictionary采用的是连续存储的方式存储键值对. Apple给的查询复杂度可以快至O(1), 下面我们就来分析下是如何做到的. </p>\n<h1 id=\"1-1-原理分析\"><a href=\"#1-1-原理分析\" class=\"headerlink\" title=\"1.1 原理分析\"></a>1.1 原理分析</h1><p>创建N个空桶，N为排序数组中最大值加一。然后遍历排序数组，以元素值为下标，将其放入对应的桶中. 如果少量数据，可以根据数组里面的最大值+1创建出那么多空桶，然后遍历，根据索引在空桶的值上累加，最后遍历空桶（已装载），根据值遍历出对应的下标.</p>\n<p>虽然这样做效率非常高，但是如果数据过大，内存吃不消，这样就有了哈希排序的介绍。例如一组数据，我们可以根据hash算法后取模的值进行空桶排列，但是如果两个值例如 101和11 % 10都是余1，会被放入同一个桶里面，这样就会有需要二次排列。虽然这个排序效率并不高，因此哈希化就变成了数据存储的一种设计.</p>\n<p>从dictionary的结构中可以看到keys大概率是一个数组, 那么当对象完成hash化运算, 这个计算结果要如何和数组实现位置匹配. 由于是两个数组分别存储, 因此, key哈希出来的数组下标地址, 同样这个地址对应到values数组的下标, 就是匹配到的值. 但是hash过程中必定会出现冲突，如何来处理冲突？</p>\n<h2 id=\"1-2-hash碰撞\"><a href=\"#1-2-hash碰撞\" class=\"headerlink\" title=\"1.2 hash碰撞\"></a>1.2 hash碰撞</h2><p>解决hash碰撞的方式是将发生碰撞的多个元素放到一个容器中，这个容器通常使用链表结构，这种解决方案被称作拉链法. 这个方案能够解决hash碰撞的匹配问题。但拉链法会将key和value包装成一个结构存储，而dictionary的结构拥有keys和values这两个数组，说明了这两个数据是被分开存储的，所以使用这个方案的可能性不高。而且拉链法存在一个问题：桶数量不多的情况下，拉链衍生出来的链表会非常庞大，需要二次遍历，匹配损耗一样很大, 官方都说了查找算法接近O(1),因此肯定不是拉链法，下面就有了开放定址法.</p>\n<p>使用开放定址法的结构通常允许在通列表的数量达到了某个阈值，通常是通列表长度的80%使用量时，对通列表进行一次扩充grow，然后重新计算数据的keyHash放入新桶中. 开放定址法可以通过动态扩充通列表长度解决了满桶无法插入的问题，也符合O(1)的查询速度，但同样随着数据量的增加，数据会明显的集中在某一段连续区域，称作堆积现象</p>\n<p>除了上述提到的拉链和开放定址，还有再哈希以及建立公共溢出区域来解决冲突.</p>\n<h1 id=\"1-2-总结\"><a href=\"#1-2-总结\" class=\"headerlink\" title=\"1.2 总结\"></a>1.2 总结</h1><p>NSDictionary是使用hash表来实现key和value的映射和存储. 可以看到，NSDictionary设置的key和value，key值会根据特定的hash函数算出建立的空桶数组，keys和values同样多，然后存储数据的时候，根据hash函数算出来的值，找到对应的index下标，如果下标已有数据，开放定址法后移动插入，如果空桶数组到达数据阀值，这个时候就会把空桶数组扩容，然后重新哈希插入。这样把一些不连续的key-value值插入到了能建立起关系的hash表中，当我们查找的时候，key根据哈希值算出来，然后根据索引，直接index访问hash表keys和hash表values，这样查询速度就可以和连续线性存储的数据一样接近O(1)了，只是占用空间有点大，性能就很强悍。如果删除的时候，也会根据_maker标记逻辑上的删除，除非NSDictionary（NSDictionary本体的hash值就是count）内存被移除。我们也会根据dictionary之所以采用这种设计，其一出于查询性能的考虑；其二dictionary在使用过程中总是会很快的被释放，不会长期占用内存.</p>\n<h1 id=\"2-NSMutableArray\"><a href=\"#2-NSMutableArray\" class=\"headerlink\" title=\"2 NSMutableArray\"></a>2 NSMutableArray</h1><p><a href=\"http://blog.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/\" target=\"_blank\" rel=\"noopener\">这里</a>讲解的十分详细.</p>\n<p>普通c数组，归根接地就是一段能被方便读写的连续内存控件. 使用一段线性内存空间的一个最明显的缺点是，在下标 0 处插入一个元素时，需要移动其它所有的元素. 同样地，假如想要保持相同的内存指针作为首个元素的地址，移除第一个元素需要进行相同的动作. </p>\n<p>当数组非常大时，这样很快会成为问题。显而易见，直接指针存取在数组的世界里必定不是最高级的抽象。C 风格的数组通常很有用，但 Obj-C 程序员每天的主要工作使得它们需要 NSMutableArray 这样一个可变的、可索引的容器</p>\n<h2 id=\"2-1-ivars\"><a href=\"#2-1-ivars\" class=\"headerlink\" title=\"2.1 ivars\"></a>2.1 ivars</h2><p>我们来概括下每个 ivar 的意思：</p>\n<ul>\n<li>_used 是计数的意思</li>\n<li>_list 是缓冲区指针</li>\n<li>_size 是缓冲区的大小</li>\n<li>_offset 是在缓冲区里的数组的第一个元素索引</li>\n</ul>\n<h2 id=\"2-2-内存布局\"><a href=\"#2-2-内存布局\" class=\"headerlink\" title=\"2.2 内存布局\"></a>2.2 内存布局</h2><p>最关键的部分是决定 realOffset 应该等于 fetchOffset（减去 0）还是 fetchOffset 减 _size。看着纯代码不一定能画出完美的图画，我们设想一下两个关于如何获取对象的例子.</p>\n<p>_size &gt; fetchOffset这个例子中，偏移量相对较小:<br><img src=\"http://blog.joyingx.me/images/20150503/4.jpg\" alt=\"_size &gt; fetchOffset\"><br>为了获取 0 处的对象，我们计算出 fetchOffset 等于 3 + 0。因为 _size 大于 fetchOffset，realOffset 也等于 3。代码返回 _list[3] 的值。而获取 4 处的对象时，fetchOffset 等于 3 + 4，代码返回 _list[7]。</p>\n<p>_size &lt;= fetchOffset, 当偏移量比较大时:<br><img src=\"http://blog.joyingx.me/images/20150503/5.jpg\" alt=\"_size &lt;= fetchOffset\"><br>获取 0 处的对象，使得 fetchOffset 等于 7 + 0，调用方法后如期望的返回 _list[7]。然而，获取 4 处的对象时，fetchOffset 等于 7 + 4 = 11，要大于 _size。获得的 realOffset 要从 fetchOffset 减去 _size，即 11 - 10 = 1，方法返回 list[1].</p>\n<h2 id=\"2-3-总结\"><a href=\"#2-3-总结\" class=\"headerlink\" title=\"2.3 总结\"></a>2.3 总结</h2><p>__NSArrayM 用了环形缓冲区 (circular buffer)。这个数据结构相当简单，只是比常规数组或缓冲区复杂点。环形缓冲区的内容能在到达任意一端时绕向另一端。</p>\n<p>环形缓冲区有一些非常酷的属性。尤其是，除非缓冲区满了(每当缓冲区满了，它会重新分配1.625倍大小的空间.)，否则在任意一端插入或删除均不会要求移动任何内存。我们来分析这个类如何充分利用环形缓冲区来使得自身比 C 数组强大得多。在任意一端插入或者删除，只是修改offset参数，不需要移动内存，我们访问的时候只是不和普通的数组一样index多少就是多少，这里会计算加上offset之后处理的值取数据，而不是插入头和尾巴的时候，环形结构会根据最少移动内存指针的方式插入，例如要在A和B之间插入，按照C的数组，我们需要把B到E的元素移动内存，但是环形缓冲区的设计，我们只要把A的值向前移动一个单位内存，即可，同时修改offset偏移量，就能保证最小的移动单元来完成中间插入.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://blog.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/\" target=\"_blank\" rel=\"noopener\">NSMutableArray原理揭露</a><br>2.<a href=\"https://blog.csdn.net/Deft_MKJing/article/details/82732833\" target=\"_blank\" rel=\"noopener\">NSDictionary和NSMutableArray底层原理（哈希表和环形缓冲区）</a><br>3.<a href=\"https://juejin.im/post/59bce186f265da065a63ad8d\" target=\"_blank\" rel=\"noopener\">如何设计并实现一个线程安全的 Map ？(上篇)</a><br>4.<a href=\"https://juejin.im/post/59d8d7cc6fb9a00a496e93b2\" target=\"_blank\" rel=\"noopener\">如何设计并实现一个线程安全的 Map ？(下篇)</a><br>5.<a href></a></p>\n","categories":["iOS开发-基础"],"tags":["基础知识"]},{"title":"iOS开发基础-内存管理","url":"http://hchong.net/2019/07/25/iOS开发基础-内存管理/","content":"<p>内存管理是开发的基本功之一, 下面将从以下几个方面来聊一下iOS开发的内存管理.</p>\n<h1 id=\"1-内存分配\"><a href=\"#1-内存分配\" class=\"headerlink\" title=\"1 内存分配\"></a>1 内存分配</h1><p>关于内存分配可以看<a href=\"http://hchong.net/2016/09/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/\">之前的总结</a>;</p>\n<h1 id=\"2-引用计数原理\"><a href=\"#2-引用计数原理\" class=\"headerlink\" title=\"2 引用计数原理\"></a>2 引用计数原理</h1><p>ARC是编译器（时）特性，而不是运行时特性，更不是垃圾回收器(GC). Objc是通过引用计数来管理内存, Cocoa为我们提供了这些内存管理的准则:</p>\n<ul>\n<li>自己生成的对象, 自己持有.</li>\n<li>非自己生成的对象, 自己也能持有.</li>\n<li>不在需要自己持有对象的时候, 释放.</li>\n<li>非自己持有的对象无需释放.</li>\n</ul>\n<p><a href=\"http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/\" target=\"_blank\" rel=\"noopener\">Objective-C 引用计数原理</a>详细讲解了引用计数的原理. 简单来说就是ARC在代码编译阶段, 会自动在代码的上下文中成对插入retain以及release, 保证引用计数能够正确管理内存. 如果对象不是强引用类型, 那么ARC的处理也会进行相应的改变.</p>\n<h2 id=\"2-1-引用计数如何存储\"><a href=\"#2-1-引用计数如何存储\" class=\"headerlink\" title=\"2.1 引用计数如何存储\"></a>2.1 引用计数如何存储</h2><ul>\n<li>有些对象如果支持使用 TaggedPointer, 苹果会直接将其指针值作为引用计数返回.</li>\n<li>如果当前设备是 64 位环境并且使用 Objective-C 2.0, 那么”一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数.</li>\n<li>否则 Runtime 会使用一张散列表(哈希表)来管理引用计数.</li>\n</ul>\n<p>后面的改变引用计数和获取引用计数, 都是以存储引用计数为基础的.</p>\n<h3 id=\"2-1-1-TaggedPointer\"><a href=\"#2-1-1-TaggedPointer\" class=\"headerlink\" title=\"2.1.1 TaggedPointer\"></a>2.1.1 TaggedPointer</h3><p>判断当前对象是否在使用 TaggedPointer 是看标志位是否为 1. </p>\n<pre><code>#if SUPPORT_MSB_TAGGED_POINTERS\n#   define TAG_MASK (1ULL&lt;&lt;63)\n#else\n#   define TAG_MASK 1\n\ninline bool \nobjc_object::isTaggedPointer() \n{\n#if SUPPORT_TAGGED_POINTERS\n    return ((uintptr_t)this &amp; TAG_MASK);\n#else\n    return false;\n#endif\n}\n</code></pre><p>id 其实就是 <code>objc_object *</code> 的简写（<code>typedef struct objc_object *id;</code>），它的 <code>isTaggedPointer()</code> 方法经常会在操作引用计数时用到, 因为这决定了存储引用计数的策略.</p>\n<h3 id=\"2-1-2-isa指针\"><a href=\"#2-1-2-isa指针\" class=\"headerlink\" title=\"2.1.2 isa指针\"></a>2.1.2 isa指针</h3><p>用 64 bit 存储一个内存地址显然是种浪费，毕竟很少有那么大内存的设备。于是可以优化存储方案，用一部分额外空间存储其他内容。isa 指针第一位为 1 即表示使用优化的 isa 指针.</p>\n<p>在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数. has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中，后面会详细讲.</p>\n<h3 id=\"2-1-3-散列表-哈希表\"><a href=\"#2-1-3-散列表-哈希表\" class=\"headerlink\" title=\"2.1.3 散列表(哈希表)\"></a>2.1.3 散列表(哈希表)</h3><p>散列表（Hash table，也叫哈希表), 是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表.</p>\n<p>散列表(哈希表)来存储引用计数具体是用 DenseMap 类来实现，这个类中包含好多映射实例到其引用计数的键值对，并支持用 DenseMapIterator 迭代器快速查找遍历这些键值对.</p>\n<h2 id=\"2-2-引用计数表\"><a href=\"#2-2-引用计数表\" class=\"headerlink\" title=\"2.2 引用计数表\"></a>2.2 引用计数表</h2><p>引用计数表就是个是个散列表(哈希表).</p>\n<h3 id=\"2-2-1-SideTable\"><a href=\"#2-2-1-SideTable\" class=\"headerlink\" title=\"2.2.1 SideTable\"></a>2.2.1 SideTable</h3><p>再介绍下 SideTable 这个类，它用于管理引用计数表(哈希表)和 weak 表，并使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable 实例。并提供三个公有属性:</p>\n<pre><code class=\"C\">spinlock_t slock;//保证原子操作的自选锁\nRefcountMap refcnts;//保存引用计数的散列表\nweak_table_t weak_table;//保存 weak 引用的全局散列表\n</code></pre>\n<p>还提供了一个工厂方法，用于根据对象的地址在 buffer 中寻找对应的 SideTable 实例:</p>\n<pre><code class=\"C\">static SideTable *tableForPointer(const void *p)\n</code></pre>\n<h3 id=\"2-2-2-weak表\"><a href=\"#2-2-2-weak表\" class=\"headerlink\" title=\"2.2.2 weak表\"></a>2.2.2 weak表</h3><p>weak 表的作用是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。</p>\n<p>这是 weak 表的结构:</p>\n<pre><code>struct weak_table_t {\n    weak_entry_t *weak_entries;\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\n</code></pre><h2 id=\"2-3-获取引用计数\"><a href=\"#2-3-获取引用计数\" class=\"headerlink\" title=\"2.3 获取引用计数\"></a>2.3 获取引用计数</h2><p>在非 ARC 环境可以使用 retainCount 方法获取某个对象的引用计数，其会调用 objc_object 的 rootRetainCount() 方法.</p>\n<p>在 ARC 时代除了使用 Core Foundation 库的 CFGetRetainCount() 方法，也可以使用 Runtime 的 _objc_rootRetainCount(id obj) 方法来获取引用计数，此时需要引入 &lt;objc/runtime.h&gt; 头文件。这个函数也是调用 objc_object 的 rootRetainCount() 方法.</p>\n<p>rootRetainCount()的内部实现也是参考引用计数的存储:</p>\n<ul>\n<li>TaggedPointer 直接通过对象内存地址获取引用计数.</li>\n<li>64 位环境优化的存储在 isa 指针中</li>\n<li>其他的是从从 SideTable 的静态方法获取当前实例对应的 SideTable 对象, 然后在引用计数表中用迭代器查找当前实例对应的键值对，获取引用计数值，并在此基础上 +1 并将结果返回.</li>\n</ul>\n<h2 id=\"2-4-修改引用计数\"><a href=\"#2-4-修改引用计数\" class=\"headerlink\" title=\"2.4 修改引用计数\"></a>2.4 修改引用计数</h2><h3 id=\"2-4-1-retain-和-release\"><a href=\"#2-4-1-retain-和-release\" class=\"headerlink\" title=\"2.4.1 retain 和 release\"></a>2.4.1 retain 和 release</h3><p>在非 ARC 环境下可以使用 retain 和 release 方法对引用计数进行加一减一操作, 它们分别调用了 _objc_rootRetain(id obj) 和 _objc_rootRelease(id obj) 函数. ARC 环境下是使用_objc_rootRetain(id obj) 和 _objc_rootRelease(id obj) 函数.</p>\n<p>实现跟获取引用计数类似，先是看是否支持 TaggedPointer（毕竟数据存在栈指针而不是堆中，栈的管理本来就是自动的），否则去操作 SideTable 中的 refcnts 属性，这与获取引用计数策略类似。sidetable_retain() 将 引用计数加一后返回对象，sidetable_release() 返回是否要执行 dealloc 方法.</p>\n<h3 id=\"2-4-2-alloc-new-copy-mutableCopy\"><a href=\"#2-4-2-alloc-new-copy-mutableCopy\" class=\"headerlink\" title=\"2.4.2 alloc, new, copy, mutableCopy\"></a>2.4.2 alloc, new, copy, mutableCopy</h3><p>根据编译器的约定，这以这四个单词开头的方法都会使引用计数加一。而 new 相当于调用 alloc 后再调用 init.</p>\n<p>alloc 和 new 最终都会调用 callAlloc，默认使用 Objective-C 2.0 且忽视垃圾回收和 NSZone，那么后续的调用顺序依次是为：</p>\n<pre><code class=\"C\">class_createInstance()\n_class_createInstanceFromZone()\ncalloc()\n</code></pre>\n<p>calloc() 函数相比于 malloc() 函数的优点是它将分配的内存区域初始化为0，相当于 malloc() 后再用 memset() 方法初始化一遍。</p>\n<p>copy 和 mutableCopy 都是基于 NSCopying 和 NSMutableCopying 方法约定，分别调用各类自己实现的 copyWithZone: 和 mutableCopyWithZone: 方法。这些方法无论实现方式是深拷贝还是浅拷贝，都会增加引用计数。（有些类的策略是懒拷贝，只增加引用计数但并不真的拷贝，等对象内容发生变化时再拷贝一份出来，比如 NSArray）。</p>\n<p>retain 方法加符号断点会发现 alloc, new, copy, mutableCopy 这四个方法都会通过 Core Foundation 的 CFBasicHashAddValue() 函数来调用 retain 方法。其实 CF 有个修改和查看引用计数的入口函数 __CFDoExternRefOperation.</p>\n<h2 id=\"2-5-Autorelease\"><a href=\"#2-5-Autorelease\" class=\"headerlink\" title=\"2.5 Autorelease\"></a>2.5 Autorelease</h2><p><a href=\"http://hchong.net/2018/03/12/Autoreleasepool%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/\">这里</a>可以看到之前关于AutoreleasePool的总结.</p>\n<p><a href=\"https://www.jianshu.com/p/32265cbb2a26\" target=\"_blank\" rel=\"noopener\">这里</a>有一篇Draveness大神关于AutoreleasePool的剖析, 十分详细.</p>\n<p><a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">这里</a>是sunny大神的黑幕背后的Autorelease.</p>\n<p>Autorelease: 向一个对象发送延迟释放信息，使得这个对象可以在作用域意外范围被使用；典型的例子就是将一个对象作为返回值给调用者，如果不延迟释放，这个返回值在出了所在函数范围就被立即释放，调用者拿到的永远是nil，因为iOS的内存遵循谁申请谁释放的原则，当向一个对象发送了autorelease消息，实际上就是将该对象放入autoreleasePool池子动，等到延迟到适当的时机（通常是在NSRunloop即将进入休眠或者退出时）进行释放（对池子中的每个对象发送release消息）.</p>\n<p>使用new/alloc/copy/mutablecopy等函数实例化的对象不会放入自动释放池，相反，用其他简便构造器获（如+(NSMutableArray *)array）得到的实例则会放入自动释放池.</p>\n<p>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop.</p>\n<ul>\n<li>自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的</li>\n<li>当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中</li>\n<li>调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息</li>\n</ul>\n<h1 id=\"3-对象的内存分布\"><a href=\"#3-对象的内存分布\" class=\"headerlink\" title=\"3 对象的内存分布\"></a>3 对象的内存分布</h1><p><code>Person *p1 = [Person new]</code>这行代码主要做了下面的事: </p>\n<ul>\n<li>在堆内存中申请1块合适大小的空间</li>\n<li>在这块内存上根据类模版创建对象。类模版中定义了什么属性就依次把这些属性声明在对象中；对象中还存在一个属性叫做isa，是一个指针，指向对象所属的类在代码段中地址</li>\n<li>初始化对象的属性。这里初始化有几个原则：a、如果属性的数据类型是基本数据类型则赋值为0；b、如果属性的数据类型是C语言的指针类型则赋值为NULL；c、如果属性的数据类型为OC的指针类型则赋值为nil。</li>\n<li>返回堆空间上对象的地址</li>\n</ul>\n<p>上面程序的内存分配, 如下所示:<br><img src=\"https://user-gold-cdn.xitu.io/2017/5/22/e92671eed683172d1f957822f184a559?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"内存分配图\"></p>\n<p>静定的isa指向图:<br><img src=\"https://upload-images.jianshu.io/upload_images/2752872-8bfac339e72aeded.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp\" alt=\"分析图\"></p>\n<blockquote>\n<p>程序运行时，运行时系统通过自身的库函数在内存中（推测是代码区或静态区）为源代码中的每个类创建了类对象即meta-class（元类）的实例对象，类对象（类的代表）包含有类函数列表等。<br>如果我们要创建某个类的实例对象，对象的isa指针指向类对象（类的代表），类对象（类的代表）的isa指针指向根类（NSObject）的类对象（根类的代表），根类的isa指针指向根类的元类，而根类的元类是自身（NSObject）。 根元类的超类是NSObject，而isa指向了自己，而NSObject的超类为nil，也就是它没有超类。</p>\n</blockquote>\n<p>OC的对象内存布局:<br><img src=\"http://img.souche.com/f2e/b1ae662279e9e867861ccbea3b5f116f.png\" alt=\"OC的对象内存布局\"></p>\n<p>当添加一个Method的时候，变化为:<br><img src=\"http://img.souche.com/f2e/646ffe9d22d99bb4abced117da06548b.png\" alt=\"当添加一个Method的时候，变化为\"></p>\n<h1 id=\"4-内存泄漏\"><a href=\"#4-内存泄漏\" class=\"headerlink\" title=\"4 内存泄漏\"></a>4 内存泄漏</h1><p>之前总结过关于内存泄漏的文章, 可以看<a href=\"http://hchong.net/2018/04/04/iOS%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/\">这里</a>.</p>\n<p>常见的有Block下的循环引用, delegate循环引用问题, NSTimer的循环引用, 非OC对象内存处理(free), 地图类处理, 大次数循环内存暴涨问题.</p>\n<h2 id=\"4-1-内存泄漏的排查\"><a href=\"#4-1-内存泄漏的排查\" class=\"headerlink\" title=\"4.1 内存泄漏的排查\"></a>4.1 内存泄漏的排查</h2><p>内存泄漏(memory leak): 是指申请的内存空间使用完毕之后未回收。 一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现</p>\n<p>内存溢出(out of memory): 是指程序在申请内存时，没有足够的内存空间供其使用。<br>通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash.</p>\n<p>目前比较常用的内存泄漏的排查方法有两种，都在Xcode中可以直接使用：</p>\n<ul>\n<li>静态分析方法（Analyze)</li>\n<li>动态分析方法（Instrument工具库里的Leaks）。一般推荐使用第二种.</li>\n</ul>\n<p>静态内存泄漏分析方法: </p>\n<ol>\n<li>通过Xcode打开项目，然后点击Product-&gt;Analyze，开始进入静态内存泄漏分析</li>\n<li>等待分析结果</li>\n<li>根据分析的结果对可能造成内存泄漏的代码进行排查</li>\n</ol>\n<p>动态内存泄漏分析方法:</p>\n<p>动态分析法主要使用Instruments工具中的Leaks. 可以参开之前的<a href=\"http://hchong.net/2017/04/13/Xcode%E7%A5%9E%E5%99%A8-Instruments%E5%A4%A7%E6%B3%95/\">总结</a>.</p>\n<h1 id=\"5-循环引用\"><a href=\"#5-循环引用\" class=\"headerlink\" title=\"5 循环引用\"></a>5 循环引用</h1><p>对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）的问题. 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题.</p>\n<h2 id=\"5-1-解决方案\"><a href=\"#5-1-解决方案\" class=\"headerlink\" title=\"5.1 解决方案\"></a>5.1 解决方案</h2><ul>\n<li>我明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收.(主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中, 主动释放对于 block 的持有，以便打破循环引用).</li>\n<li>弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用</li>\n</ul>\n<p>注意: CAAnimation的delegate代理是强引用, 因为CAAnimation动画是异步的，如果动画的代理是弱应用不是强应用的话，会导致其随时都可能被释放掉.</p>\n<h2 id=\"5-2-弱引用的实现原理\"><a href=\"#5-2-弱引用的实现原理\" class=\"headerlink\" title=\"5.2 弱引用的实现原理\"></a>5.2 弱引用的实现原理</h2><p>弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。</p>\n<h2 id=\"5-3-循环引用检测\"><a href=\"#5-3-循环引用检测\" class=\"headerlink\" title=\"5.3 循环引用检测\"></a>5.3 循环引用检测</h2><p>Xcode 的 Instruments 工具集可以很方便的检测循环引用. Instruments -&gt; leaks.</p>\n<h1 id=\"6-Other\"><a href=\"#6-Other\" class=\"headerlink\" title=\"6 Other\"></a>6 Other</h1><p>这里是内存管理中其他一些常见的基本概念.</p>\n<h2 id=\"6-1-Thread-Local-Storage\"><a href=\"#6-1-Thread-Local-Storage\" class=\"headerlink\" title=\"6.1 Thread Local Storage\"></a>6.1 Thread Local Storage</h2><p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写.</p>\n<p>在返回值身上调用objc_autoreleaseReturnValue方法时，runtime将这个返回值object储存在TLS中，然后直接返回这个object（不调用autorelease）；同时，在外部接收这个返回值的objc_retainAutoreleasedReturnValue里，发现TLS中正好存了这个对象，那么直接返回这个object（不调用retain）。</p>\n<p>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理</p>\n<h2 id=\"6-2-Tagged-Pointer\"><a href=\"#6-2-Tagged-Pointer\" class=\"headerlink\" title=\"6.2 Tagged Pointer\"></a>6.2 Tagged Pointer</h2><p><a href=\"http://blog.devtang.com/2014/05/30/understand-tagged-pointer/\" target=\"_blank\" rel=\"noopener\">这里</a>有一篇文章写的很详细. </p>\n<p>为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升.</p>\n<p>我们先看看原有的对象为什么会浪费内存。假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。</p>\n<p>所以一个普通的 iOS 程序，如果没有Tagged Pointer对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示:<br><img src=\"http://blog.devtang.com/images/tagged_pointer_before.jpg\" alt=\"内存图\"></p>\n<p>由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节. 拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：2^31=2147483648，另外 1 位作为符号位). 所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了Tagged Pointer对象之后64 位 CPU 下 NSNumber 的内存图变成了以下这样：<br><img src=\"http://blog.devtang.com/images/tagged_pointer_after.jpg\" alt=\"Tagged Pointer 内存图\"></p>\n<p>总结:<br>由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节. 当 8 字节可以承载用于表示的数值时，系统就会以Tagged Pointer的方式生成指针，如果 8 字节承载不了时，则又用以前的方式来生成普通的指针.</p>\n<p>Tagged Pointer通过在其最后一个 bit 位设置一个特殊标记，用于将数据直接保存在指针本身中。因为Tagged Pointer并不是真正的对象，我们在使用时需要注意不要直接访问其 isa 变量.</p>\n<h2 id=\"6-3-Toll-Free-Bridge\"><a href=\"#6-3-Toll-Free-Bridge\" class=\"headerlink\" title=\"6.3 Toll-Free Bridge\"></a>6.3 Toll-Free Bridge</h2><p><a href=\"http://hchong.net/2018/05/07/OC%E4%B8%AD%E7%9A%84%E6%A1%A5%E6%8E%A5Toll-Free%20Bridging/\">这里</a>可以看到之前总结的关于OC中内存管理的桥接机制.</p>\n<ul>\n<li><strong>bridge: 通过 </strong>bridge 桥接，id 和 void * 就能够相互转换. __bridge 为直接转换, 不会对引用计数做特殊处理.</li>\n<li>__bridge_retained &amp; CFBridgingRetain: 表示将指针类型转变的同时, 将内存管理的责任由原来的Objective-C交给Core Foundation来处理.</li>\n<li><p>bridge_transfer &amp; CFBridgingRelease: 与上面的__bridge_retained相反, 它表示将管理的责任由Core Foundation转交给Objective-C, 即将管理方式由MRC转变为ARC.</p>\n<pre><code>  id obj = (id)p;\n  [obj retain];\n  [(id)p release];\n</code></pre></li>\n</ul>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/32265cbb2a26\" target=\"_blank\" rel=\"noopener\">自动释放池的前世今生 —- 深入解析 Autoreleasepool</a><br>2.<a href=\"http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/\" target=\"_blank\" rel=\"noopener\">Objective-C 引用计数原理</a><br>3.<a href=\"http://sindrilin.com/runtime/2016/12/23/%E9%97%B2%E8%81%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\" target=\"_blank\" rel=\"noopener\">闲聊内存管理</a><br>4.<a href=\"https://blog.devtang.com/2016/07/30/ios-memory-management/\" target=\"_blank\" rel=\"noopener\">理解 iOS 的内存管理</a><br>5.<a href=\"https://juejin.im/post/5abe543bf265da23784064dd\" target=\"_blank\" rel=\"noopener\">iOS内存管理详解</a><br>6.<a href=\"http://zhoulingyu.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/\" target=\"_blank\" rel=\"noopener\">iOS进阶——iOS（Objective-C）内存管理·二</a><br>7.<a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">黑幕背后的Autorelease</a><br>8.<a href=\"http://blog.devtang.com/2014/05/30/understand-tagged-pointer/\" target=\"_blank\" rel=\"noopener\">深入理解Tagged Pointer</a><br>9.<a href=\"http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/\" target=\"_blank\" rel=\"noopener\">Objective-C Autorelease Pool 的实现原理</a><br>10.<a href=\"http://blog.tracyone.com/tags/ARC/\" target=\"_blank\" rel=\"noopener\">深入浅出ARC(上,中,下)</a><br>11.<a href=\"https://solacode.github.io/2015/10/20/iOS%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AToll-Free-Bridging/\" target=\"_blank\" rel=\"noopener\">iOS渐入佳境之内存管理机制（三）：Toll-Free Bridging</a></p>\n","categories":["iOS开发-基础"],"tags":["基础知识"]},{"title":"iOS开发基础-Notification & KVC & KVO & delegate","url":"http://hchong.net/2019/07/22/iOS开发基础-Notification-KVC-KVO-delegate/","content":"<p>KVC是Key-Value Coding的简称，它是一种可以直接通过字符串的名字(key)来访问类属性的机制。而不是通过调用Setter、Getter方法访问.<br>KVO是Key-Value Observing的简称. 它是一种键值观察的机制，在更改一个对象的指定属性时, 另外的指定对象能够得到通知.<br>KVC/KVO是观察者模式的一种实现, 而delegate是代理模式和通知模式在iOS中的具体实现, NSNotification则是发布-订阅模式的一种实现. 网上有很多人说，观察者模式和发布-订阅模式是两种不同的设计模式，它们压根就是两码事，不能混为一谈。也有很多人说，两者其实都是观察者模式，只是实现手段有点不一样罢了，本质是一样的。我认为发布-订阅模式只是观察者模式的一种实现手段, 它本质还是观察者模式. </p>\n<h1 id=\"1-kVC\"><a href=\"#1-kVC\" class=\"headerlink\" title=\"1 kVC\"></a>1 kVC</h1><p>全称是Key-value coding, 翻译成键值编码。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制. KVC 机制是由 NSKeyValueCoding 协议定义的.</p>\n<p>KVC中以字符串的形式向对象发送消息, 这个字符串是我们关注的属性的关键. 常见的的基本调用如下:</p>\n<pre><code>**设置值**\n// value的值为OC对象，如果是基本数据类型要包装成NSNumber\n- (void)setValue:(id)value forKey:(NSString *)key;\n// keyPath键路径，类型为xx.xx\n- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;\n// 它的默认实现是抛出异常，可以重写这个函数做错误处理。\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key;\n\n**获取值**\n- (id)valueForKey:(NSString *)key;\n- (id)valueForKeyPath:(NSString *)keyPath;\n// 如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常\n- (id)valueForUndefinedKey:(NSString *)key;\n\n**其他**\n// 允许直接访问实例变量，默认返回YES。如果某个类重写了这个方法，且返回NO，则KVC不可以访问该类。\n+ (BOOL)accessInstanceVariablesDirectly;\n// 这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回\n- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;\n// 如果你在setValue方法时面给Value传nil，则会调用这个方法\n- (void)setNilValueForKey:(NSString *)key;\n// 输入一组key，返回该组key对应的Value，再转成字典返回，用于将Model转到字典。\n- (NSDictionary *)dictionaryWithValuesForKeys:(NSArray *)keys;\n// KVC提供属性值确认的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。\n- (BOOL)validateValue:(id)ioValue forKey:(NSString *)inKey error:(NSError)outError;\n</code></pre><p>keyPath方法是集成了key的所有功能，也就是说对一个对象的一般属性进行赋值、取值，两个方法是通用的，都可以实现。但是对对象中的对象进的属性行赋值，只有keyPath能够实现.</p>\n<h2 id=\"1-1-KVC内部原理\"><a href=\"#1-1-KVC内部原理\" class=\"headerlink\" title=\"1.1 KVC内部原理\"></a>1.1 KVC内部原理</h2><p>比如说如下的一行KVC的代码：</p>\n<pre><code>[site setValue:@&quot;sitename&quot; forKey:@&quot;name&quot;];\n</code></pre><p>就会被编译器处理成：</p>\n<pre><code>SEL sel = sel_get_uid (&quot;setValue:forKey:&quot;);\nIMP method = objc_msg_lookup (site-&gt;isa,sel);\nmethod(site, sel, @&quot;sitename&quot;, @&quot;name&quot;);\n</code></pre><p>这下KVC内部的实现就很清楚的清楚了, 一个对象在调用setValue的时候:</p>\n<ol>\n<li>首先根据方法名找到运行方法的时候所需要的环境参数.</li>\n<li>他会从自己isa指针结合环境参数, 找到具体的方法实现的接口.</li>\n<li>再直接查找得来的具体的方法实现.</li>\n</ol>\n<p>下面我们再看一下KVC中设置值和获取值的流程:</p>\n<h3 id=\"1-1-1-KVC设置值的流程\"><a href=\"#1-1-1-KVC设置值的流程\" class=\"headerlink\" title=\"1.1.1 KVC设置值的流程\"></a>1.1.1 KVC设置值的流程</h3><ol>\n<li>首先搜索同名的setter方法(无@synthsize情况下, 因为@synthsize告诉编译器生成set<key>:格式的setter方法).</key></li>\n<li>上面的setter方法没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按_<key>，_is<key>，<key>，is<key>的顺序在类中查找实例变量。（NSKeyValueCodingCatogery中实现的类方法，默认实现为返回YES）</key></key></key></key></li>\n<li>如果找到设置成员的值, 如果没有调用<code>setValue:forUndefinedKey:</code>.</li>\n</ol>\n<p>注意: 通常情况下，KVC不允许在调用setValue：属性值 forKey：(或者keyPath)时对非对象传递一个nil的值。很简单，因为值类型是不能为nil的。如果你不小心传了，KVC会调用setNilValueForKey:方法。这个方法默认是抛出异常，所以一般而言最好还是重写这个方法。</p>\n<h3 id=\"1-1-2-KVC取值的流程\"><a href=\"#1-1-2-KVC取值的流程\" class=\"headerlink\" title=\"1.1.2 KVC取值的流程\"></a>1.1.2 KVC取值的流程</h3><ol>\n<li>首先按get<key>、<key>、is<key>的顺序查找getter方法(无@synthsize情况下, 因为@synthsize告诉编译器自动生成key:格式的getter方法). 如果是bool、int等基础数据类型，会做NSNumber的转换.</key></key></key></li>\n<li>上面的getter没有找到，查找countOf<key>、objectIn<key>AtIndex:、<key>AtIndexes格式的方法。</key></key></key></li>\n<li>如果countOf<key>和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合(collection proxy object)。发送给这个代理集合(collection proxy object)的NSArray消息方法，就会以countOf<key>、objectIn<key>AtIndex:、<key>AtIndexes这几个方法组合的形式调用。还有一个可选的get<key>:range:方法</key></key></key></key></key></li>\n<li>还没查到，那么查找countOf<key>、enumeratorOf<key>、memberOf<key>:格式的方法</key></key></key></li>\n<li>如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合(collection proxy object)。发送给这个代理集合(collection proxy object)的NSSet消息方法，就会以countOf<key>、enumeratorOf<key>、memberOf<key>:组合的形式调用</key></key></key></li>\n<li>还是没查到，那么如果类方法accessInstanceVariablesDirectly返回YES，那么按_<key>，_is<key>，<key>，is<key>的顺序直接搜索成员名</key></key></key></key></li>\n<li>再没查到，调用valueForUndefinedKey:。</li>\n</ol>\n<h2 id=\"1-2-KVC常见实践\"><a href=\"#1-2-KVC常见实践\" class=\"headerlink\" title=\"1.2 KVC常见实践\"></a>1.2 KVC常见实践</h2><p>这里是一些常见的KVC的实践.</p>\n<h3 id=\"1-2-1-修改和访问私有属性私有变量\"><a href=\"#1-2-1-修改和访问私有属性私有变量\" class=\"headerlink\" title=\"1.2.1 修改和访问私有属性私有变量\"></a>1.2.1 修改和访问私有属性私有变量</h3><p>对于类里的私有属性，Objective-C是无法直接访问的，但是KVC可以通过key, keypath做到.</p>\n<h3 id=\"1-2-2-动态取值和设置值\"><a href=\"#1-2-2-动态取值和设置值\" class=\"headerlink\" title=\"1.2.2 动态取值和设置值\"></a>1.2.2 动态取值和设置值</h3><p>利用KVC动态的取值和设值是最基本的用途.</p>\n<h3 id=\"1-2-3-Model和字典转换\"><a href=\"#1-2-3-Model和字典转换\" class=\"headerlink\" title=\"1.2.3 Model和字典转换\"></a>1.2.3 Model和字典转换</h3><p>利用runtime来获取成员属性, 通过KVC来赋值. 下面是一个简单的Demo.</p>\n<pre><code>+ (instancetype)modelWithDict:(NSDictionary *)dict {\n    id objc = [[self alloc] init];\n    /*\n     遍历模型中所有成员属性，去字典中查找\n     属性定义在类中，类有个属性列表（数组）\n     */\n\n    //遍历模型所有成员属性\n    /*ivar表示成员属性\n     {\n     _ID;//这个才叫成员属性，成员属性对应属性\n     }\n     class_copyIvarList：把成员属性列表复制一份\n     Ivar * 表示指向Ivar数组的指针\n     */\n    unsigned int count;\n    Ivar *ivarList = class_copyIvarList([self class], &amp;count);\n    for (int i = 0; i &lt; count; i ++) {\n        Ivar ivar = ivarList[i];\n        NSString *propertyName = [NSString stringWithUTF8String:ivar_getName(ivar)];\n        NSString *propertyType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        NSString *key = [propertyName substringFromIndex:1];\n        id value = dict[key];\n        //也有存在类型是NSDictionary但是不想转成模型的情况\n        //二级转换\n        //值是字典，并且成员属性不是字典的时候需要转模型\n        if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![propertyType containsString:@&quot;NS&quot;]) {\n            //转换成哪个类型\n\n            //得到的propertyType是@&quot;User&quot;这样的一个字符串，所以需要先做截取\n            NSString *typeString = [propertyType substringFromIndex:2];\n            typeString = [typeString substringToIndex:typeString.length - 1];\n            //获取需要转换类的类对象\n            Class modelClass = NSClassFromString(typeString);\n            if (modelClass) {\n                value = [modelClass modelWithDict:value];\n            }\n        }\n        if (value) {\n            [objc setValue:value forKey:key];\n        }   \n    }\n    return objc;\n}\n</code></pre><h3 id=\"1-2-4-操作集合\"><a href=\"#1-2-4-操作集合\" class=\"headerlink\" title=\"1.2.4 操作集合\"></a>1.2.4 操作集合</h3><p>Apple对KVC的valueForKey:方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法。所以可以用KVC很方便地操作集合.</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000013476170\" alt=\"集合运算符\"><br>上面表达式主要分为三部分，left部分是要操作的集合对象，如果调用KVC的对象本来就是集合对象，则left可以为空。中间部分是表达式，表达式一般以@符号开头。后面是进行运算的属性。</p>\n<p>集合运算符主要分为三类：</p>\n<ul>\n<li>集合操作符：处理集合包含的对象，并根据操作符的不同返回不同的类型，返回值以NSNumber为主。</li>\n<li>数组操作符：根据操作符的条件，将符合条件的对象包含在数组中返回。</li>\n<li>嵌套操作符：处理集合对象中嵌套其他集合对象的情况，返回结果也是一个集合对象。</li>\n</ul>\n<p><a href=\"https://segmentfault.com/a/1190000013476163#articleHeader4\" target=\"_blank\" rel=\"noopener\">这里</a>有一个很好的操作集合的例子.</p>\n<h3 id=\"1-2-5-利用KVC高阶消息传递\"><a href=\"#1-2-5-利用KVC高阶消息传递\" class=\"headerlink\" title=\"1.2.5 利用KVC高阶消息传递\"></a>1.2.5 利用KVC高阶消息传递</h3><p>当对容器类使用KVC时，valueForKey:将会被传递给容器中的每一个对象，而不是容器本身进行操作。结果会被添加进返回的容器中，这样，开发者可以很方便的操作集合来返回另一个集合.</p>\n<pre><code>int main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n       NSArray* arrStr = @[@&quot;english&quot;,@&quot;franch&quot;,@&quot;chinese&quot;];\n       NSArray* arrCapStrLength = [arrStr valueForKeyPath:@&quot;capitalizedString.length&quot;];\n        for (NSNumber* length  in arrCapStrLength) {\n            NSLog(@&quot;%ld&quot;,(long)length.integerValue);\n        }\n\n    }\n    return 0;\n}\n\n//打印结果\n7\n6\n7\n</code></pre><h1 id=\"2-KVO\"><a href=\"#2-KVO\" class=\"headerlink\" title=\"2 KVO\"></a>2 KVO</h1><p>之前总结过关于KVO的相关, 可以看<a href=\"http://hchong.net/2018/01/24/KVO%E8%AF%A6%E8%A7%A3/\">这里</a></p>\n<p>通过KVC修改属性会触发KVO, 是因为内部触发了setter方法. </p>\n<p>通过KVC修改成员变量也会触发KVO, 是因为通过KVC修改成员变量的值, 系统内部帮助我们调用了willChangeValueForKey和didChangeValueForKey这两个方法, 并且在didChangeValueForKey 内部调用了 observeValueForKeyPath:方法.</p>\n<h1 id=\"3-Notification\"><a href=\"#3-Notification\" class=\"headerlink\" title=\"3 Notification\"></a>3 Notification</h1><ul>\n<li>1对N （多）</li>\n<li>不关心返回值，单向的传值</li>\n<li>NSNotificationCenter单例统一处理发通知</li>\n<li>通过不同的唯一的通知标识名NotificationName区分不同通知</li>\n<li>被观察者主动发出通知</li>\n<li>使用Notification一定要谨慎，由于1对多的缘故，避免滥用，不好查问题。</li>\n<li>其次就是在Controller销毁时，一定要注销掉通知.</li>\n<li>最好保证观察者和被观察者的事件都在同一个线程中来处理, 否则可能会出现一些奇怪的Bug.</li>\n</ul>\n<h1 id=\"4-delegate\"><a href=\"#4-delegate\" class=\"headerlink\" title=\"4 delegate\"></a>4 delegate</h1><p>在 iOS 中，代理(delegate)的本质是 protocol.</p>\n<ul>\n<li>一般用来处理 一对一 的关系. </li>\n<li>支持正向与反向传值(参数, 返回值). </li>\n<li>可以用require和optional来修饰的</li>\n</ul>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/\" target=\"_blank\" rel=\"noopener\">Objective-C中的KVC和KVO</a><br>2.<a href=\"https://blog.csdn.net/omegayy/article/details/7381301\" target=\"_blank\" rel=\"noopener\">Objective-C KVC机制</a><br>3.<a href=\"https://www.jianshu.com/p/8b2a98a8808a\" target=\"_blank\" rel=\"noopener\">KVC内部执行过程分析</a><br>4.<a href=\"https://swiftcafe.io/2016/01/03/kvc\" target=\"_blank\" rel=\"noopener\">swift中的 KVC 与 KVO</a><br>5.<a href=\"https://blog.csdn.net/qq_18505715/article/details/80205796\" target=\"_blank\" rel=\"noopener\">iOS KVC实现原理</a><br>6.<a href=\"https://juejin.im/post/5aef18b76fb9a07aa34a28e6\" target=\"_blank\" rel=\"noopener\">iOS KVC和KVO详解</a><br>7.<a href=\"https://segmentfault.com/a/1190000013476163\" target=\"_blank\" rel=\"noopener\">KVC原理剖析</a></p>\n","categories":["iOS开发-基础"],"tags":["基础知识"]},{"title":"iOS开发UI-UIView相关","url":"http://hchong.net/2019/06/11/iOS开发UI-UIView相关/","content":"<p>这些事之前的总结, 基本上囊括了UIView的常见用法: </p>\n<p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a></p>\n<p><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a></p>\n<p><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a></p>\n<p><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n","categories":["iOS开发-UI"],"tags":["基础知识"]},{"title":"iOS开发UI-UI绘制原理","url":"http://hchong.net/2019/05/11/iOS开发UI-UI绘制原理/","content":"<p>本文将从下面几个方面来阐述iOS上面的UI绘制过程, 以及UI性能优化的技巧.</p>\n<h1 id=\"1-渲染过程中硬件相关\"><a href=\"#1-渲染过程中硬件相关\" class=\"headerlink\" title=\"1 渲染过程中硬件相关\"></a>1 渲染过程中硬件相关</h1><p>这篇文章讲解的非常详细<a href=\"http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/\" target=\"_blank\" rel=\"noopener\">渲染过程中硬件</a>, 下面就只大概讲解一下常用的概念.</p>\n<h2 id=\"1-1-CPU-amp-GPU\"><a href=\"#1-1-CPU-amp-GPU\" class=\"headerlink\" title=\"1.1 CPU &amp; GPU\"></a>1.1 CPU &amp; GPU</h2><p>可视化应用程序都是由 CPU 和 GPU 协作执行的. CPU 内部采用的是流水线结构, 使其拥有一定程度的并行计算能力. GPU 是一种可进行绘图运算工作的专用微处理器, 是一个被高度优化设计的用来并发计算的硬件单元. 硬件设计的模式差异就决定了两者在图像显示中的不同定位. CPU擅长分支预测等复杂操作, GPU擅长对大量数据进行简单操作. 一个是复杂的劳动, 一个是大量并行的工作. 其实GPU可以看作是一种专用的CPU, 专为单指令在大块数据上工作而设计, 这些数据都是进行相同的操作.</p>\n<p>关于GPU和CPU, 在知乎上看到一个<a href=\"https://www.zhihu.com/question/22219245/answer/365354011\" target=\"_blank\" rel=\"noopener\">很形象的比喻</a>:</p>\n<blockquote>\n<p>CPU的核心是大学生，4核就是4个大学生GPU的核心是小学生，上千个就处理器就是上千个小学生他们一起参加一场考试，试卷是一百万道四则运算和四道高数. 两个小时过后大学生奔溃了，这一百万道四则运算太特么多了再看小学生全都懵逼了，四则运算都做完了，剩下的数学题里面怎么全是字母 ？？</p>\n</blockquote>\n<p>GPU 增加了处理器指令和存储器硬件, 以支持通用编程语言, 并创立了一种编程环境, 从而允许使用熟悉的语言（包括 C/C++）对 GPU 进行编程. GPU 及其相关驱动实现了图形处理中的 OpenGL 和 DirectX 模型, 从而允许开发者能够轻易地操作硬件.</p>\n<p>图像想显示到屏幕上使人肉眼可见都需借助像素的力量. 简单地说, 每个像素由红，绿，蓝三种颜色组成, 它们密集的排布在手机屏幕上, 将任何图形通过不同的色值表现出来. 计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上. 计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为渲染. 渲染过程中最常用的技术就是光栅化, 光栅化就是从矢量的点线面的描述, 变成像素的描述.</p>\n<h2 id=\"1-2-GPU-图形渲染流水线\"><a href=\"#1-2-GPU-图形渲染流水线\" class=\"headerlink\" title=\"1.2 GPU 图形渲染流水线\"></a>1.2 GPU 图形渲染流水线</h2><p>GPU 图形渲染流水线的主要工作可以被划分为两个部分: </p>\n<ol>\n<li>把 3D 坐标转换为 2D 坐标</li>\n<li>把 2D 坐标转变为实际的有颜色的像素</li>\n</ol>\n<p>GPU 图形渲染流水线的具体实现可分为六个阶段，如下图所示</p>\n<ul>\n<li>顶点着色器（Vertex Shader）</li>\n<li>形状装配（Shape Assembly），又称 图元装配</li>\n<li>几何着色器（Geometry Shader）</li>\n<li>光栅化（Rasterization）</li>\n<li>片段着色器（Fragment Shader）</li>\n<li>测试与混合（Tests and Blending）<br><a href=\"https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/opengl-graphics-pipeline.png\" target=\"_blank\" rel=\"noopener\">OpenGL渲染示意图</a></li>\n</ul>\n<h2 id=\"1-3-CPU-GPU-异构系统\"><a href=\"#1-3-CPU-GPU-异构系统\" class=\"headerlink\" title=\"1.3 CPU-GPU 异构系统\"></a>1.3 CPU-GPU 异构系统</h2><p>实际应用中 CPU 和 GPU 通过下面两种常见的 CPU-GPU 异构架构来协同工作<br><a href=\"https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cpu-gpu-architecture.png\" target=\"_blank\" rel=\"noopener\">常见的 CPU-GPU 异构架构</a></p>\n<p>左图是分离式的结构，CPU 和 GPU 拥有各自的存储系统，两者通过 PCI-e 总线进行连接。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p>\n<p>右图是耦合式的结构，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p>\n<p>在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 GPU 共享系统内存，由 MMU 进行存储管理。</p>\n<p>图形应用程序调用 OpenGL 或 Direct3D API 功能，将 GPU 作为协处理器使用。API 通过面向特殊 GPU 优化的图形设备驱动向 GPU 发送命令、程序、数据。</p>\n<h2 id=\"1-4-CPU-GPU-工作流\"><a href=\"#1-4-CPU-GPU-工作流\" class=\"headerlink\" title=\"1.4 CPU-GPU 工作流\"></a>1.4 CPU-GPU 工作流</h2><p>CPU-GPU 异构系统的工作流, 当 CPU 遇到图像处理的需求时，会调用 GPU 进行处理，主要流程可以分为以下四步: </p>\n<ol>\n<li>将主存的处理数据复制到显存中</li>\n<li>CPU 指令驱动 GPU</li>\n<li>GPU 中的每个运算单元并行处理</li>\n<li>GPU 将显存结果传回主存</li>\n</ol>\n<h1 id=\"2-屏幕显示图像原理\"><a href=\"#2-屏幕显示图像原理\" class=\"headerlink\" title=\"2 屏幕显示图像原理\"></a>2 屏幕显示图像原理</h1><h2 id=\"2-1-屏幕图像显示原理\"><a href=\"#2-1-屏幕图像显示原理\" class=\"headerlink\" title=\"2.1 屏幕图像显示原理\"></a>2.1 屏幕图像显示原理</h2><p>图像想显示到屏幕上使人肉眼可见都需借助像素的力量. 简单地说, 每个像素由红，绿，蓝三种颜色组成, 它们密集的排布在手机屏幕上, 将任何图形通过不同的色值表现出来. 计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上.</p>\n<p>介绍屏幕图像显示的原理，需要先从 CRT 显示器原理说起，如下图所示。CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致, 如下图所示:<br><img src=\"https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png\" alt=\"扫描图\"></p>\n<h2 id=\"2-2-CPU、GPU、显示器工作方式\"><a href=\"#2-2-CPU、GPU、显示器工作方式\" class=\"headerlink\" title=\"2.2 CPU、GPU、显示器工作方式\"></a>2.2 CPU、GPU、显示器工作方式</h2><p>CPU 计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示. 下图所示为常见的 CPU、GPU、显示器工作方式:<br><img src=\"https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png\" alt=\"协同工作图\"></p>\n<h2 id=\"2-3-帧缓冲-amp-垂直同步\"><a href=\"#2-3-帧缓冲-amp-垂直同步\" class=\"headerlink\" title=\"2.3 帧缓冲 &amp; 垂直同步\"></a>2.3 帧缓冲 &amp; 垂直同步</h2><p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 双缓冲机制。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。<br>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：<br><img src=\"https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg\" alt=\"画面撕裂\"><br>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>\n<p>iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</p>\n<h1 id=\"3-iOS图像渲染原理\"><a href=\"#3-iOS图像渲染原理\" class=\"headerlink\" title=\"3 iOS图像渲染原理\"></a>3 iOS图像渲染原理</h1><p>这里主要介绍 iOS 开发过程中图形渲染原理. 首先介绍几个概念.</p>\n<blockquote>\n<p>UIKit Framework 正如Apple官方文档对UIKit Framework的介绍，它主要提供了：界面呈现能力、事件响应能力、驱动RunLoop运行和与系统内核通信的数据。简单来说就是：主要负责界面展示、事件响应以及是RunLoop的需求方。UIView当然是属于UIKit Framework。</p>\n</blockquote>\n<blockquote>\n<p>QuartzCore Framework 与 CoreAnimation 正如Apple官方文档对Quarz Core Framework的介绍，它提供了图形处理和视频图像处理的能力。简单来说就是：QuartzCore Framework负责把图形图像最终显示到屏幕上，这里我觉得应该是特指CoreAnimation。不要从字面上去理解CoreAnimation的职责，因为它的核心工作不单是负责动画的创建和执行，它还负责把我们用代码构建的界面显示到屏幕上，实际上是CoreAnimation通过OpenGLES做的。（别急，虽然这里面的机理很复杂，但是在后面会提到）。CALayer是属于QuarzCore Framework下的CoreAnimation</p>\n</blockquote>\n<blockquote>\n<p>CoreGraphics Framework 如Apple官方文档对Core Graphics Framework的介绍。CoreGraphics Framework一个基于C库函数的高级绘画引擎，它提供了非常强大的轻量级2D渲染能力。可以使用CoreGraphics处理基于path的绘图工作(如，CGPath)、变形操作(如，CGAffineTransform)、颜色管理(如，CGColor)、离屏渲染(如，CGBitmapContextCreateImage)、渲染模式(patterns)、渐变(gradients)、阴影效果、图形数据管理、图形创建、蒙版以及PDF文档的创建、显示和解析。 千万别和QuartzCore混淆，CoreGraphics负责创建显示到屏幕上的数据模型，QuartzCore(CoreAnimation –&gt; OpenGLES)负责把CoreGraphics创建的数据模型真正显示到屏幕上。 CG打头的类都是属于CoreGraphics Framework</p>\n</blockquote>\n<blockquote>\n<p>以上三者的关系 三者的关系是通过界面展示以及动画的创建、执行关联起来的，所以它们之间是协作而不是从属的关系。在接下来的部分我会从几个方面来阐述以上几个Framework是怎样游游走与UIView与CALayer之间的</p>\n</blockquote>\n<p>App 使用 Core Graphics、Core Animation、Core Image 等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系。这些框架都需要通过 OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上.<br><img src=\"https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-rendering-framework-relationship.png\" alt=\"图形渲染\"></p>\n<h2 id=\"3-1-UIView-amp-CALayer\"><a href=\"#3-1-UIView-amp-CALayer\" class=\"headerlink\" title=\"3.1 UIView &amp; CALayer\"></a>3.1 UIView &amp; CALayer</h2><p>二者的区别和联系在<a href=\"https://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">这里</a>介绍的很详细, 摘要说一下. </p>\n<blockquote>\n<p>UIView是继承自UIResponder的，UIView是可以响应事件的，而CALayer不能<br>UIView负责处理用户交互，负责绘制内容的则是它持有的那个CALayer，我们访问和设置UIView的这些负责显示的属性实际上访问和设置的都是这个CALayer对应的属性，UIView只是将这些操作封装起来. 一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer的 frame，同样 View 的 center和 bounds 也是返回 Layer 的一些属性.<br>一个UIView只有一个相关联的CALayer（自动创建），同时它也可以支持添加无数多个子CALayer<br>UIView主要是对显示内容的管理而 CALayer 主要侧重显示内容的绘制. 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display<br>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)<br>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</p>\n</blockquote>\n<h2 id=\"3-2-UIView与CALayer的界面渲染\"><a href=\"#3-2-UIView与CALayer的界面渲染\" class=\"headerlink\" title=\"3.2 UIView与CALayer的界面渲染\"></a>3.2 UIView与CALayer的界面渲染</h2><p>关于界面的渲染流程, <a href=\"http://blog.handy.wang/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/\" target=\"_blank\" rel=\"noopener\">这里</a>讲解的很详细.</p>\n<ol>\n<li>通过在loadView过程中debug子view的drawRect:方法得知：RunLoop处于kCFRunLoopBeforeWaiting状态时会回调CoreAnimation中监听kCFRunLoopBeforeWaiting状态的RunLoopObserver，从而通过RunLoopObserver来进一步调用CoreAnimation内部的CA::Transaction::commit() ();方法，进而一步一步地调用到drawRect方法</li>\n<li>通过在VC里给一个按钮添加点击事件，并在事件对应的selector中修改子view的背景色，debug子view的drawRect:方法得知：RunLoop被iOS系统传递来的点击事件唤醒并由source1处理(__IOHIDEventSystemClientQueueCallback)，并且在下一个runloop里由source0转发给UIApplication(_UIApplicationHandleEventQueue)，从而能过source0里的事件队列来调用CoreAnimation内部的CA::Transaction::commit() ();方法，进而一步一步的调用drawRect方法</li>\n<li>上面两种情况都是触发CoreAnimation的CA::Transaction::commit() ();方法来达到触发CALayer/UIView的渲染，所以这个CA::Transaction机制很关键</li>\n<li>CA::Transaction已经进入到了Quarz Core的内部(Core Animation)，即调用CA::Transaction::commit() ();来创建CATrasaction，然后进一步调用<code>-[CALayer drawInContext:] ()</code></li>\n<li>在drawRect:方法里可以通过CoreGraphics函数或UIKit中对CoreGraphics封装的方法进行画图操作，这些画图的操作内容都是以Off-Screen离屏(广义的离屏，因为没有在GPU中进行)方式进行画图。在这里可以了解离屏绘图及CPU/GPU的工作</li>\n<li>无论是有UIView参与的或是直接采用CALayer渲染的操作都会体现在CALayer上(在没有CoreGraphics参与的情况下，UIView或CALayer本身也有一些在业务层面需要显示的内容，所以这里说的“体现在CALayer上”，是泛指UIViewr的子视图或CALaye的子图层以及CoreGraphics参与的内容)。</li>\n<li>CoreAnimation(CALayer)把它的内容转成位图(纹理)，然后通过OpenGLES把位图内容传送到GPU的帧缓冲区</li>\n<li>等到由iOS显示屏时钟信号驱动的VSync信号来临时，则把GPU帧缓冲区里的内容显示到iOS显示屏上。在这里的iOS 渲染过程一节可以了解得更详细。</li>\n</ol>\n<h2 id=\"3-3-Core-Animation-流水线\"><a href=\"#3-3-Core-Animation-流水线\" class=\"headerlink\" title=\"3.3 Core Animation 流水线\"></a>3.3 Core Animation 流水线</h2><p>app 本身并不负责渲染，渲染则是由一个独立的进程负责，即 Render Server 进程. App 通过 IPC 将渲染任务及相关数据提交给 Render Server。Render Server 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。</p>\n<p>Core Animation 流水线的详细过程如下：</p>\n<ul>\n<li>首先，由 app 处理事件（Handle Events），如：用户的点击操作，在此过程中 app 可能需要更新 视图树，相应地，图层树 也会被更新。</li>\n<li>其次，app 通过 CPU 完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app 对图层进行打包，并在下一次 RunLoop 时将其发送至 Render Server，即完成了一次 Commit Transaction 操作。</li>\n<li>Render Server 主要执行 Open GL、Core Graphics 相关程序，并调用 GPU</li>\n<li>GPU 则在物理层上完成了对图像的渲染。</li>\n<li>最终，GPU 通过 Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上</li>\n</ul>\n<p>在 Core Animation 流水线中，app 调用 Render Server 前的最后一步 Commit Transaction 其实可以细分为 4 个步骤：</p>\n<ul>\n<li>Layout: Layout 阶段主要进行视图构建，包括：LayoutSubviews 方法的重载，addSubview: 方法填充子视图等</li>\n<li>Display: Display 阶段主要进行视图绘制，这里仅仅是设置最要成像的图元数据。重载视图的 drawRect: 方法可以自定义 UIView 的显示，其原理是在 drawRect: 方法内部绘制寄宿图，该过程使用 CPU 和内存。</li>\n<li>Prepare: Prepare 阶段属于附加步骤，一般处理图像的解码和转换等操作。</li>\n<li>Commit: Commit 阶段主要将图层进行打包，并将它们发送至 Render Server。该过程会递归执行，因为图层和视图都是以树形结构存在.</li>\n</ul>\n<p>iOS 动画的渲染也是基于上述 Core Animation 流水线完成的。这里我们重点关注 app 与 Render Server 的执行流程。日常开发中，如果不是特别复杂的动画，一般使用 UIView Animation 实现，iOS 将其处理过程分为如下三部阶段：</p>\n<ul>\n<li>调用 animationWithDuration:animations: 方法</li>\n<li>在 Animation Block 中进行 Layout，Display，Prepare，Commit 等步骤。</li>\n<li>Render Server 根据 Animation 逐帧进行渲染</li>\n</ul>\n<h1 id=\"4-绘制流程总结\"><a href=\"#4-绘制流程总结\" class=\"headerlink\" title=\"4 绘制流程总结\"></a>4 绘制流程总结</h1><ol>\n<li>计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号，逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示.</li>\n<li>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。从上图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</li>\n<li>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示.</li>\n<li>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 标记，并通过 CATransaction 提交到一个中间状态去。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 Core Animation 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，通过 DisplayLink 稳定的刷新机制会不断的唤醒runloop，使得不断的有机会触发observer回调，从而根据时间来不断更新这个动画的属性值并绘制出来。为了不阻塞主线程，Core Animation 的核心是 OpenGL ES 的一个抽象物，所以大部分的渲染是直接提交给GPU来处理。 而Core Graphics/Quartz 2D的大部分绘制操作都是在主线程和CPU上同步完成的，比如自定义UIView的drawRect里用CGContext来画图</li>\n<li>Core Animation 在 RunLoop 中注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件 。当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。当Oberver监听的事件到来时，回调执行函数中会遍历所有待处理的UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</li>\n</ol>\n<h1 id=\"5-CPU-和-GPU渲染\"><a href=\"#5-CPU-和-GPU渲染\" class=\"headerlink\" title=\"5 CPU 和 GPU渲染\"></a>5 CPU 和 GPU渲染</h1><h2 id=\"5-1-GPU渲染\"><a href=\"#5-1-GPU渲染\" class=\"headerlink\" title=\"5.1 GPU渲染\"></a>5.1 GPU渲染</h2><p>OpenGL中，GPU屏幕渲染有以下两种方式:</p>\n<ul>\n<li>On-Screen Rendering<br>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li>\n<li>Off-Screen Rendering<br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br>按照这样的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式-CPU渲染.</li>\n</ul>\n<h2 id=\"5-2-CPU渲染\"><a href=\"#5-2-CPU渲染\" class=\"headerlink\" title=\"5.2 CPU渲染\"></a>5.2 CPU渲染</h2><p>CPU渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>\n<h2 id=\"5-3-离屏渲染\"><a href=\"#5-3-离屏渲染\" class=\"headerlink\" title=\"5.3 离屏渲染\"></a>5.3 离屏渲染</h2><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，<a href=\"http://sonnewilling.com/blog/2016/10/19/iostu-xing-yuan-li-yu-chi-ping-xuan-ran/#anchor1.4.2\" target=\"_blank\" rel=\"noopener\">这里</a>和<a href=\"https://imlifengfeng.github.io/article/593/\" target=\"_blank\" rel=\"noopener\">这里</a>介绍的很详细, 主要体现在两个方面: </p>\n<ul>\n<li>创建新缓冲区<br>要想进行离屏渲染，首先要创建一个新的缓冲区。</li>\n<li>上下文切换<br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</li>\n</ul>\n<p>设置了以下属性时，都会触发离屏绘制：</p>\n<ul>\n<li>shouldRasterize（光栅化）</li>\n<li>masks（遮罩）</li>\n<li>shadows（阴影）</li>\n<li>edge antialiasing（抗锯齿）</li>\n<li>group opacity（不透明） </li>\n</ul>\n<p>需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。</p>\n<p>在开发时需要根据实际情况来选择最优的实现方式，尽量使用On-Screen Rendering。简单的Off-Screen Rendering可以考虑使用Core Graphics让CPU来渲染。</p>\n<h1 id=\"6-保持界面流畅的技巧\"><a href=\"#6-保持界面流畅的技巧\" class=\"headerlink\" title=\"6 保持界面流畅的技巧\"></a>6 保持界面流畅的技巧</h1><p>上面介绍了绘制的流程, 这里结合上面的内容介绍下如果保持界面的流畅.</p>\n<p>关于卡顿的原因和分析这里讲解的十分详细<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">iOS 保持界面流畅的技巧</a>.</p>\n<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>\n<p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>\n<h2 id=\"6-1-CPU-资源消耗原因和解决方案\"><a href=\"#6-1-CPU-资源消耗原因和解决方案\" class=\"headerlink\" title=\"6.1 CPU 资源消耗原因和解决方案\"></a>6.1 CPU 资源消耗原因和解决方案</h2><p>CPU 中主要用来计算显示内容, CPU 将计算好的内容提交到 GPU 去.</p>\n<h3 id=\"6-1-1-对象创建\"><a href=\"#6-1-1-对象创建\" class=\"headerlink\" title=\"6.1.1 对象创建\"></a>6.1.1 对象创建</h3><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>\n<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>\n<h3 id=\"6-1-2-对象调整\"><a href=\"#6-1-2-对象调整\" class=\"headerlink\" title=\"6.1.2 对象调整\"></a>6.1.2 对象调整</h3><p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>\n<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>\n<h3 id=\"6-1-3-对象销毁\"><a href=\"#6-1-3-对象销毁\" class=\"headerlink\" title=\"6.1.3 对象销毁\"></a>6.1.3 对象销毁</h3><p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>\n<pre><code>NSArray *tmp = self.array;\nself.array = nil;\ndispatch_async(queue, ^{\n    [tmp class];\n});\n</code></pre><h3 id=\"6-1-4-布局计算\"><a href=\"#6-1-4-布局计算\" class=\"headerlink\" title=\"6.1.4 布局计算\"></a>6.1.4 布局计算</h3><p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>\n<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>\n<h3 id=\"6-1-5-Autolayout\"><a href=\"#6-1-5-Autolayout\" class=\"headerlink\" title=\"6.1.5 Autolayout\"></a>6.1.5 Autolayout</h3><p>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href=\"http://pilky.me/36/。\" target=\"_blank\" rel=\"noopener\">http://pilky.me/36/。</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>\n<h3 id=\"6-1-6-文本计算\"><a href=\"#6-1-6-文本计算\" class=\"headerlink\" title=\"6.1.6 文本计算\"></a>6.1.6 文本计算</h3><p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>\n<p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>\n<h3 id=\"6-1-7-文本渲染\"><a href=\"#6-1-7-文本渲染\" class=\"headerlink\" title=\"6.1.7 文本渲染\"></a>6.1.7 文本渲染</h3><p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>\n<h3 id=\"6-1-8-图片的解码\"><a href=\"#6-1-8-图片的解码\" class=\"headerlink\" title=\"6.1.8 图片的解码\"></a>6.1.8 图片的解码</h3><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>\n<h3 id=\"6-1-9-图像的绘制\"><a href=\"#6-1-9-图像的绘制\" class=\"headerlink\" title=\"6.1.9 图像的绘制\"></a>6.1.9 图像的绘制</h3><p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>\n<pre><code>- (void)display {\n    dispatch_async(backgroundQueue, ^{\n        CGContextRef ctx = CGBitmapContextCreate(...);\n        // draw in context...\n        CGImageRef img = CGBitmapContextCreateImage(ctx);\n        CFRelease(ctx);\n        dispatch_async(mainQueue, ^{\n            layer.contents = img;\n        });\n    });\n}\n</code></pre><h2 id=\"6-2-GPU-资源消耗原因和解决方案\"><a href=\"#6-2-GPU-资源消耗原因和解决方案\" class=\"headerlink\" title=\"6.2 GPU 资源消耗原因和解决方案\"></a>6.2 GPU 资源消耗原因和解决方案</h2><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类</p>\n<h3 id=\"6-2-1-纹理的渲染\"><a href=\"#6-2-1-纹理的渲染\" class=\"headerlink\" title=\"6.2.1 纹理的渲染\"></a>6.2.1 纹理的渲染</h3><p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>\n<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p>\n<h3 id=\"6-2-2-视图的混合-Composing\"><a href=\"#6-2-2-视图的混合-Composing\" class=\"headerlink\" title=\"6.2.2 视图的混合 (Composing)\"></a>6.2.2 视图的混合 (Composing)</h3><p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>\n<h3 id=\"6-2-3-图形的生成。\"><a href=\"#6-2-3-图形的生成。\" class=\"headerlink\" title=\"6.2.3 图形的生成。\"></a>6.2.3 图形的生成。</h3><p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://juejin.im/post/5adf0e7af265da0b814b32da\" target=\"_blank\" rel=\"noopener\">iOS UI绘制原理</a><br>2.<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">iOS 保持界面流畅的技巧</a><br>3.<a href=\"http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina\" target=\"_blank\" rel=\"noopener\">谈谈 iOS 中图片的解压缩</a><br>4.<a href=\"https://leoliuyt.github.io/2018/05/26/UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/\" target=\"_blank\" rel=\"noopener\">UI绘制原理</a><br>5.<a href=\"http://www.chuquan.me/2018/09/25/ios-graphics-render-principle/\" target=\"_blank\" rel=\"noopener\">iOS 图像渲染原理</a><br>6.<a href=\"http://sonnewilling.com/blog/2016/10/19/iostu-xing-yuan-li-yu-chi-ping-xuan-ran/\" target=\"_blank\" rel=\"noopener\">iOS图形原理与离屏渲染</a><br>7.<a href=\"https://segmentfault.com/a/1190000000390012\" target=\"_blank\" rel=\"noopener\">iOS 开发：绘制像素到屏幕</a><br>8.<a href=\"https://www.zybuluo.com/qidiandasheng/note/494700\" target=\"_blank\" rel=\"noopener\">iOS界面渲染流程</a><br>9.<a href=\"http://blog.handy.wang/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/\" target=\"_blank\" rel=\"noopener\">界面渲染的整体流程</a><br>10.<a href=\"https://www.jianshu.com/p/748f9abafff8\" target=\"_blank\" rel=\"noopener\">iOS开发-视图渲染与性能优化</a><br>11.<a href=\"https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=4#wechat_redirect\" target=\"_blank\" rel=\"noopener\">iOS 事件处理机制与图像渲染过程</a><br>12.<a href=\"http://sonnewilling.com/blog/2016/10/19/iostu-xing-yuan-li-yu-chi-ping-xuan-ran/#anchor1.4.2\" target=\"_blank\" rel=\"noopener\">iOS图形原理与离屏渲染</a></p>\n","categories":["iOS开发-UI"],"tags":["基础知识"]},{"title":"Git内部原理","url":"http://hchong.net/2019/02/24/Git内部原理/","content":"<h1 id=\"git基本原理\"><a href=\"#git基本原理\" class=\"headerlink\" title=\"git基本原理\"></a>git基本原理</h1><p>常见的git工作流如下, 来分解下看常见的工作流背后的逻辑.</p>\n<ol>\n<li><code>git hash-object -w ${要保存的文件}</code> =&gt; 生成要保存的文件(Git对象)的HASH值</li>\n<li><code>git update-index --add --cacheinfo 100644 ${Git对象的HASH值} ${要保存的文件}</code> =&gt; 向暂存区保存文件</li>\n<li><code>git write-tree</code> =&gt; 生成目录对象(Tree对象)的HASH值</li>\n<li><code>echo &quot;first commit&quot; | git commit-tree ${目录对象(Tree对象)的HASH值}</code> =&gt; 包含元数据和目录树的对象HASH值(最终的commit对象)</li>\n<li><code>echo ${commit对象的HASH值} &gt; .git/refs/heads/${要commit的分支名称}</code> 表示指定分支指针指向该快照.</li>\n</ol>\n<h2 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h2><p>在项目根目录下创建一个.git子目录, 用来保存版本信息. objects 目录存储所有数据内容，refs 目录存储指向数据 (分支) 的提交对象的指针，HEAD 文件指向当前分支，index 文件保存了暂存区域信息</p>\n<h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add .\"></a>git add .</h2><p>该命令实际可以拆分为<code>保存对象</code>和<code>更新暂存区</code>两部分操作.</p>\n<h3 id=\"保存文件为二进制文件-Git对象\"><a href=\"#保存文件为二进制文件-Git对象\" class=\"headerlink\" title=\"保存文件为二进制文件(Git对象)\"></a>保存文件为二进制文件(Git对象)</h3><ol>\n<li><code>git hash-object -w test.txt</code>命令实际分为两步: 第一步把test.txt文件压缩为二进制文件(Git对象), 保存在.git/objects目录下. 第二步计算test.txt的HASH值, 作为二进制文件的名称. 最终输出 <strong>Git对象的HASH值</strong></li>\n</ol>\n<h3 id=\"二进制文件存放到”暂存区”\"><a href=\"#二进制文件存放到”暂存区”\" class=\"headerlink\" title=\"二进制文件存放到”暂存区”\"></a>二进制文件存放到”暂存区”</h3><p>文件保存成二进制对象以后, 需要通知 Git 哪些文件发生了变动. 所有变动的文件, Git 都记录在”暂存区”.</p>\n<ol>\n<li><code>git update-index --add --cacheinfo 100644 ${Git对象的HASH值} test.txt</code>. 向暂存区写入文件名test.txt, 二进制对象名（哈希值）和<a href=\"文件权限\">https://stackoverflow.com/questions/737673/how-to-read-the-mode-field-of-git-ls-trees-output</a>(100代表regular file，644代表文件权限.).</li>\n<li><code>git ls-files --stage</code>. 用来查看暂存区的文件.</li>\n</ol>\n<h2 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h2><p><code>git status</code>实际就是检查暂存区的内容.</p>\n<h2 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h2><p>仅仅记录单个文件的变化是不够的, 我们还需要记录文件之间的目录关系.</p>\n<ol>\n<li><code>git write-tree</code>也是分两步. 第一步从当前索引创建一个树形对象, 保存为二进制文件(Git对象), 保存在.git/objects目录下. 第二步计算HASH值, 作为二进制文件的名称. 最终输出<strong>Tree对象的HASH值</strong></li>\n<li><code>echo &quot;commit说明&quot; | git commit-tree ${Tree对象的HASH值}</code>. 该命令实际也是分两步. 第一步给出commit的备注. 第二部将元数据和目录树一起生成一个Git对象. 最终输出<strong>Commit对象的HASH值</strong></li>\n<li>此时使用<code>git log</code>是看不到内容的, 因为没有branch信息.</li>\n<li><code>echo ${Commit对象的HASH值} &gt; .git/refs/heads/master</code> 表示master指针指向该快照.</li>\n</ol>\n<h2 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h2><p>分支（branch）就是指向某个快照的指针, 分支名就是指针名, 但是HASH值不便于记忆, 所以我们概念中的branch就是分支名的别名. 分支还会自动更新, 如果当前分支有新的快照, 指针就会自动指向它. 比如, master 分支就是有一个叫做 master 指针, 它指向的快照就是 master 分支的当前快照.<br>Git 有一个特殊指针HEAD, 总是指向当前分支的最近一次快照. 另外, Git 还提供简写方式, <code>HEAD^</code>指向 HEAD的前一个快照(父节点). <code>HEAD~6</code>则是HEAD之前的第6个快照.<br>每一个分支指针都是一个文本文件, 保存在.git/refs/heads/目录, 该文件的内容就是它所指向的快照的二进制对象名(哈希值).</p>\n<h2 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h2><p><strong>Tag对象</strong>是一种对象, Tag 对象指向一个 commit 而不是一个 tree. 它就像是一个分支引用, 但是不会变化——永远指向同一个 commit, 仅仅是提供一个更加友好的名字.</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li><code>git add -all(git add .)</code>相当于对目录下的所有文件遍历并且做了上面的操作.</li>\n<li><code>git cat-file -p ${Git对象的HASH值}</code>用来查看二进制文件的原始内容.</li>\n<li>每次生成Git对象, 实际是对有变动的文件做的全量的快照(当前的目录结构, 以及每个文件对应的二进制对象).</li>\n<li>通过<code>git config user.name ${用户名}</code>, <code>git config user.email ${Email 地址}</code>来设置是谁提交的记录.</li>\n<li><code>git log --stat ${Git对象的HASH值}</code>, 也可以查看快照在当前分支上的变动信息.</li>\n<li><code>git checkout ${Git对象的HASH值}</code>, 用于切换到某个快照.</li>\n<li><code>git show ${Git对象的HASH值}</code>, 用于展示某个快照的所有代码变动.</li>\n<li><code>git commit-tree ${目录结构Git对象的HASH} -p ${基于本次结构Git对象的HASH值}</code>. -p参数用来指定父节点, 也就是本次快照所基于的快照.</li>\n<li>100  644, 表明这是一个普通文件. 其他可用的模式有：100 755 表示可执行文件, 120 000 表示符号链接. 文件模式是从常规的 UNIX 文件模式中参考来的.</li>\n<li><p>Git的对象存储大致如下, 是通过Ruby脚本来实现的</p>\n<pre><code>content = &quot;what is up, doc?&quot;\nheader = &quot;blob(数据对象) #{content.length}\\0&quot;\n\nstore = header + content\nsha1 = Digest::SHA1.hexdigest(store)\nzlib_content = Zlib::Deflate.deflate(store)\n将zlib_content写入磁盘, 命名为sha1\n</code></pre></li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p><a href=\"1\">http://wiki.jikexueyuan.com/project/pro-git/git-internals.html</a><br><a href=\"2\">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a><br><a href=\"3\">https://medium.com/@shalithasuranga/how-does-git-work-internally-7c36dcb1f2cf</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS进程间通信","url":"http://hchong.net/2019/01/09/iOS进程间通信/","content":"<p>iOS系统是相对封闭的系统, App各自在各自的沙盒（sandbox）中运行, 每个App都只能读取iPhone上iOS系统为该应用程序程序创建的文件夹AppData下的内容, 不能随意跨越自己的沙盒去访问别的App沙盒中的内容. 所以iOS 的系统中进行App间通信的方式也比较固定, 常见的app间通信方式以及使用场景总结如下.</p>\n<h1 id=\"1-URL-Scheme\"><a href=\"#1-URL-Scheme\" class=\"headerlink\" title=\"1. URL Scheme\"></a>1. URL Scheme</h1><p>这个是iOS app通信最常用到的通信方式, App1通过openURL的方法跳转到App2, 并且在URL中带上想要的参数, 有点类似http的get请求那样进行参数传递.</p>\n<p>典型的使用场景就是各开放平台SDK的分享功能, 如分享到微信朋友圈微博等. 或者是支付场景, 比如从滴滴打车结束行程跳转到微信进行支付.</p>\n<p>使用方法也很简单只需要源App1在info.plist中配置<code>LSApplicationQueriesSchemes</code>, 指定目标App2的scheme; 然后在目标App2的info.plist中配置好URL types, 表示该app接受何种URL scheme的唤起.</p>\n<h1 id=\"2-Keychain\"><a href=\"#2-Keychain\" class=\"headerlink\" title=\"2 Keychain\"></a>2 Keychain</h1><p>OS系统的Keychain是一个安全的存储容器, 它本质上就是一个sqllite数据库, 它的位置存储在/private/var/Keychains/keychain-2.db，不过它所保存的所有数据都是经过加密的，可以用来为不同的app保存敏感信息，比如用户名，密码等。iOS系统自己也用keychain来保存VPN凭证和Wi-Fi密码。它是独立于每个App的沙盒之外的，所以即使App被删除之后，Keychain里面的信息依然存在. </p>\n<p>基于安全和独立于app沙盒的两个特性，Keychain主要用于给app保存登录和身份凭证等敏感信息，这样只要用户登录过，即使用户删除了app重新安装也不需要重新登录</p>\n<p>典型的使用场景就是就是统一账户登录平台. 一般开放平台都会提供登录SDK，在这个SDK内部就可以把登录相关的信息都写到keychain中，这样如果多个app都集成了这个SDK，那么就可以实现统一账户登录了.</p>\n<p>Keychain的使用比较简单，使用iOS系统提供的类KeychainItemWrapper，并通过keychain access groups就可以在应用之间共享keychain中的数据的数据了</p>\n<h1 id=\"3-UIPasteboard\"><a href=\"#3-UIPasteboard\" class=\"headerlink\" title=\"3 UIPasteboard\"></a>3 UIPasteboard</h1><p>UIPasteboard是剪切板功能，因为iOS的原生控件UITextView, UITextField, UIWebView, 我们在使用时如果长按，就会出现复制、剪切、选中、全选、粘贴等功能，这个就是利用了系统剪切板功能来实现的。而每一个App都可以去访问系统剪切板，所以就能够通过系统剪贴板进行App间的数据传输了. </p>\n<p>典型的使用场景就是阿里的淘口令.</p>\n<p>UIPasteboard的使用很简单, 通过<code>[UIPasteboard generalPasteboard]</code>直接写入和读取就可以了.</p>\n<h1 id=\"4-UIDocumentInteractionController\"><a href=\"#4-UIDocumentInteractionController\" class=\"headerlink\" title=\"4 UIDocumentInteractionController\"></a>4 UIDocumentInteractionController</h1><p>UIDocumentInteractionController主要是用来实现同设备上app之间的共享文档，以及文档预览、打印、发邮件和复制等功能.</p>\n<p>它的使用非常简单. 首先通过调用它唯一的类方法 <code>interactionControllerWithURL:</code>, 并传入一个<code>URL(NSURL)</code>为你想要共享的文件来初始化一个实例对象。然后设置<code>UIDocumentInteractionControllerDelegate</code>，然后通过<code>presentPreviewAnimated:</code>显示菜单和预览窗口.</p>\n<h1 id=\"5-local-socket\"><a href=\"#5-local-socket\" class=\"headerlink\" title=\"5 local socket\"></a>5 local socket</h1><p>一个App1在本地的端口port1234进行TCP的bind和listen，另外一个App2在同一个端口port1234发起TCP的connect连接，这样就可以建立正常的TCP连接，进行TCP通信了，那么就想传什么数据就可以传什么数据了.</p>\n<p>这种方式最大的特点就是灵活, 只要连接保持着, 随时都可以传任何相传的数据，而且带宽足够大。它的缺点就是因为iOS系统在任意时刻只有一个app在前台运行，那么就要通信的另外一方具备在后台运行的权限，像导航或者音乐类app.</p>\n<p>常见的使用场景就是某个App1具有特殊的能力，比如能够跟硬件进行通信，在硬件上处理相关数据。而App2则没有这个能力，但是它能给App1提供相关的数据，这样APP2跟App1建立本地socket连接，传输数据到App1，然后App1在把数据传给硬件进行处理。</p>\n<h1 id=\"6-AirDrop\"><a href=\"#6-AirDrop\" class=\"headerlink\" title=\"6 AirDrop\"></a>6 AirDrop</h1><p>通过AirDrop实现不同设备的App之间文档和数据的分享</p>\n<h1 id=\"7-UIActivityViewController\"><a href=\"#7-UIActivityViewController\" class=\"headerlink\" title=\"7 UIActivityViewController\"></a>7 UIActivityViewController</h1><p>iOS SDK中封装好的类在App之间发送数据、分享数据和操作数据.</p>\n<p>常见的使用场景就是选中多张图片分享到微信. 不过现在接口貌似被封了.</p>\n<h1 id=\"8-App-Groups\"><a href=\"#8-App-Groups\" class=\"headerlink\" title=\"8 App Groups\"></a>8 App Groups</h1><p>App Group用于同一个开发团队开发的App之间，包括App和Extension之间共享同一份读写空间，进行数据共享。同一个团队开发的多个应用之间如果能直接数据共享，大大提高用户体验</p>\n<h1 id=\"9-CFMessagePort\"><a href=\"#9-CFMessagePort\" class=\"headerlink\" title=\"9. CFMessagePort\"></a>9. CFMessagePort</h1><p>可以参考<a href=\"http://foggry.com/blog/2014/06/04/iosjin-cheng-jian-tong-xin-zhi-cfmessageport/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>, 不过在iOS7及以后系统中, CFMessagePort的通信机制不再可用.</p>\n<h1 id=\"10-其他\"><a href=\"#10-其他\" class=\"headerlink\" title=\"10 其他\"></a>10 其他</h1><p>如果是越狱设备的话, 可以参考<a href=\"http://nirvan.360.cn/blog/?p=723\" target=\"_blank\" rel=\"noopener\">这篇文章</a>的实现思路.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://foggry.com/blog/2014/06/04/iosjin-cheng-jian-tong-xin-zhi-cfmessageport/\" target=\"_blank\" rel=\"noopener\">iOS进程间通信之CFMessagePort</a><br>2.<a href=\"https://blog.csdn.net/kuangdacaikuang/article/details/78891379\" target=\"_blank\" rel=\"noopener\">iOS (APP)进程间8中常用通信方式总结</a><br>3.<a href=\"http://nirvan.360.cn/blog/?p=723\" target=\"_blank\" rel=\"noopener\">iOS进程通讯安全和利用</a></p>\n","categories":["多线程"],"tags":["基础知识"]},{"title":"iOS开发基础-load & initialize","url":"http://hchong.net/2018/11/08/iOS开发基础-load-initialize/","content":"<p>Objective-C 中绝大部分的类都继承自 NSObject 类, 而在 NSObject 类中有两个非常特殊的类方法 +load 和 +initialize, 用于类的初始化. 下面我们就来了解一下这两个方法.</p>\n<h1 id=\"1-load\"><a href=\"#1-load\" class=\"headerlink\" title=\"1 load\"></a>1 load</h1><p><a href=\"https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc\" target=\"_blank\" rel=\"noopener\">NSObject Class Reference</a>中是这样描述<code>+ (void)load</code>的:</p>\n<blockquote>\n<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>\n</blockquote>\n<blockquote>\n<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>\n</blockquote>\n<blockquote>\n<p>The order of initialization is as follows:</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>All initializers in any framework you link to.</li>\n<li>All +load methods in your image.</li>\n<li>All C++ static initializers and C/C++ attribute(constructor) functions in your image.</li>\n<li>All initializers in frameworks that link to you.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>In addition:</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>A class’s +load method is called after all of its superclasses’ +load methods.</li>\n<li>A category +load method is called after the class’s own +load method.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet</p>\n</blockquote>\n<p>从这段描述中, 我们可以看出如下几点:</p>\n<ul>\n<li>load方法在这个文件被程序装载时调用, 只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关.</li>\n<li>在一个程序（main 函数）运行之前，所用到的库被加载到 runtime 之后, 被添加到的 runtime 系统的各种类和 category 的+load方法就被调用. </li>\n<li>如果父类和子类的+load方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类+load中没必要显式调用[super load];</li>\n<li>如果子类没有实现 +load 方法, 那么当它被加载时 runtime 是不会去调用父类的 +load 方法的.</li>\n<li>若某个类由一个主类和多个 category 组成, 则允许主类和 category 中各自有自己的+load方法，只是 category 中的+load的执行在主类的+load之后.</li>\n<li>当有多个类别(Category)都实现了load方法, 这几个load方法都会执行, 执行顺序与Compile Sources中出现的顺序(编译顺序)一致.</li>\n<li>有多个不同的类的时候, 每个类load 执行顺序与其在Compile Sources出现的顺序一致.</li>\n</ul>\n<p>下面我们来看一下, load方法常见的使用方式:</p>\n<h2 id=\"1-1-load在method-swizzling中的实践\"><a href=\"#1-1-load在method-swizzling中的实践\" class=\"headerlink\" title=\"1.1 load在method swizzling中的实践\"></a>1.1 load在method swizzling中的实践</h2><p><a href=\"https://tech.glowing.com/cn/method-swizzling-aop/\" target=\"_blank\" rel=\"noopener\">Method Swizzling 和 AOP 实践</a>这篇文章关于Method Swizzling讲解的比较详细, 可以参考这里.</p>\n<h2 id=\"1-2-Notification-Once\"><a href=\"#1-2-Notification-Once\" class=\"headerlink\" title=\"1.2 Notification Once\"></a>1.2 Notification Once</h2><p>可以参考<a href=\"http://blog.sunnyxx.com/2015/03/09/notification-once/\" target=\"_blank\" rel=\"noopener\">这里</a><br>写在<code>- application:didFinishLaunchingWithOptions:</code>中的代码都只是为了在程序启动时获得一次调用机会, 多为某些模块的初始化工作, 可以通过load来巧妙的解决:</p>\n<pre><code>+ (void)load {\n    __block id observer =\n    [[NSNotificationCenter defaultCenter]\n     addObserverForName:UIApplicationDidFinishLaunchingNotification\n     object:nil\n     queue:nil\n     usingBlock:^(NSNotification *note) {\n         [self setup]; // Do whatever you want\n         [[NSNotificationCenter defaultCenter] removeObserver:observer];\n     }];\n}\n</code></pre><ul>\n<li><ul>\n<li>load方法在足够早的时间点被调用</li>\n</ul>\n</li>\n<li>block 版本的通知注册会产生一个__NSObserver *对象用来给外部 remove 观察者</li>\n<li>block 对 observer 对象的捕获早于函数的返回，所以若不加__block，会捕获到 nil</li>\n<li>在 block 执行结束时移除 observer，无需其他清理工作</li>\n<li>这样，在模块内部就完成了在程序启动点代码的挂载.</li>\n</ul>\n<p>注意: 通知是在<code>- application:didFinishLaunchingWithOptions:</code>调用完成后才发送的.</p>\n<h1 id=\"1-3-load的调用时机\"><a href=\"#1-3-load的调用时机\" class=\"headerlink\" title=\"1.3 load的调用时机\"></a>1.3 load的调用时机</h1><p>在APP的启动过程中, 在系统内核做好程序准备工作之后, 会交由 dyld 来负责余下的工作. 大致的流程如下:</p>\n<ul>\n<li>加载dyld到App进程</li>\n<li>加载动态库（包括所依赖的所有动态库）</li>\n<li>Rebase</li>\n<li>Bind</li>\n<li>初始化Objective C Runtime</li>\n<li>其它的初始化代码</li>\n</ul>\n<p>当 Objective-C 运行时初始化的时候,在每次有新的镜像加入运行时的时候, 会通过 dyld_register_image_state_change_handler进行回调. 执行 load_images 将所有包含 load 方法的文件加入列表 loadable_classes , 然后从这个列表中找到对应的 load 方法的实现, 调用 load 方法.</p>\n<p>ObjC 对于加载的管理, 主要使用了两个列表, 分别是 loadable_classes 和 loadable_categories. 方法的调用过程也分为两个部分, 准备 load 方法和调用 load 方法.</p>\n<p><a href=\"https://draveness.me/load\" target=\"_blank\" rel=\"noopener\">这篇文章</a>关于load讲解的十分详细.</p>\n<h1 id=\"2-initialize\"><a href=\"#2-initialize\" class=\"headerlink\" title=\"2 initialize\"></a>2 initialize</h1><p><a href=\"https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize?preferredLanguage=occ\" target=\"_blank\" rel=\"noopener\">NSObject Class Reference</a>中是这样描述<code>+initialize</code>方法:</p>\n<blockquote>\n<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</p>\n</blockquote>\n<blockquote>\n<p>The runtime sends the initialize message to classes in a thread-safe manner. That is, initialize is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize completes.</p>\n</blockquote>\n<blockquote>\n<p>The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>\n</blockquote>\n<blockquote>\n<pre><code>+ (void)initialize {\n  if (self == [ClassName self]) {\n    // ... do the initialization ...\n  }\n}\n</code></pre><p>Because initialize is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore, you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p>\n<p><em>Special Considerations</em><br>initialize is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load methods.</p>\n</blockquote>\n<p>关于上面这段话, 我们可以看出:</p>\n<ul>\n<li>+initialize方法是在 runtime 时被调用的</li>\n<li>对于某个类型，其+initialize方法都会在该类型接受其他任何消息（类型方法）之前被调用，包括+alloc</li>\n<li>initialize方法实际上是一种惰性调用, 也就是说如果一个类一直没被用到, 那它的initialize方法也不会被调用.</li>\n<li>如果父类和子类的+initialize方法都被调用，父类的调用一定在子类之前，这是系统自动完成的，子类+initialize中没必要显式调用[super initialize]</li>\n<li>runtime 系统处理+initialize消息的方式是线程安全的，所以没必要在+initialize中为了保证线程安全而使用 lock、mutex 之类的线程安全工具</li>\n<li>某个类的+initialize的方法不一定只被调用一次，至少有两种情况会被调用多次：<ul>\n<li>子类显式调用[super initialize]</li>\n<li>子类没有实现+initialize方法</li>\n</ul>\n</li>\n<li>不要在+initialize中处理复杂的逻辑, 可以做一些简单的初始化工作. </li>\n</ul>\n<p>注意: 因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的initialize方法，然后创建子类时，尽管自己没有实现initialize方法，但还是会调用到父类的方法.</p>\n<p>虽然initialize方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的姿势如下</p>\n<pre><code>+ (void)initialize {\n    if (self == [Parent class]) {\n        NSLog(@&quot;Initialize Parent, caller Class %@&quot;, [self class]);\n    }\n}\n</code></pre><h2 id=\"2-1-initialize的使用场景\"><a href=\"#2-1-initialize的使用场景\" class=\"headerlink\" title=\"2.1 initialize的使用场景\"></a>2.1 initialize的使用场景</h2><p>initialize方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如NSMutableArray这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化.</p>\n<pre><code>// In Parent.m\nstatic int someNumber = 0;     // int类型可以在编译期赋值  \nstatic NSMutableArray *someObjects;\n\n+ (void)initialize {\n    if (self == [Parent class]) {\n        // 不方便编译期复制的对象在这里赋值\n        someObjects = [[NSMutableArray alloc] init];\n    }\n}\n</code></pre><h1 id=\"3-load-vs-initialize\"><a href=\"#3-load-vs-initialize\" class=\"headerlink\" title=\"3 load vs initialize\"></a>3 load vs initialize</h1><ul>\n<li>load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们.</li>\n<li>load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类.</li>\n<li>load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量.</li>\n<li>load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>+load</th>\n<th>+initialize</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>调用时机</td>\n<td>被添加到 runtime 时</td>\n<td>收到第一条消息前，可能永远不调用</td>\n</tr>\n<tr>\n<td>调用顺序</td>\n<td>父类-&gt;子类-&gt;分类</td>\n<td>父类-&gt;子类</td>\n</tr>\n<tr>\n<td>调用次数</td>\n<td>1次</td>\n<td>多次</td>\n</tr>\n<tr>\n<td>是否需要显式调用父类实现</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否沿用父类的实现</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>分类中的实现</td>\n<td>类和分类都执行</td>\n<td>覆盖类中的方法，只执行分类的实现</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://bestswifter.com/load-and-initialize/#initialize\" target=\"_blank\" rel=\"noopener\">细说OC中的load和initialize方法</a><br>2.<a href=\"http://blog.sunnyxx.com/2015/03/09/notification-once/\" target=\"_blank\" rel=\"noopener\">Notification Once</a><br>3.<a href=\"https://zhangbuhuai.com/post/initialize-and-load-in-objective-c.html\" target=\"_blank\" rel=\"noopener\">Objective-C 中的+initialize 和+load</a><br>4.<a href=\"http://blog.sunnyxx.com/2015/03/09/notification-once/\" target=\"_blank\" rel=\"noopener\">Notification once</a><br>5.<a href=\"http://liumh.com/2015/07/29/ios-load-and-initialize/\" target=\"_blank\" rel=\"noopener\">iOS初探+load和+initialize</a><br>6.<a href=\"http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/\" target=\"_blank\" rel=\"noopener\">Objective-C +load vs +initialize</a><br>7.<a href=\"https://draveness.me/load\" target=\"_blank\" rel=\"noopener\">你真的了解 load 方法么？</a></p>\n","categories":["iOS开发-基础"],"tags":["基础知识"]},{"title":"iOS开发基础-Category & Extension","url":"http://hchong.net/2018/10/24/iOS开发基础-Category-Extension/","content":"<p>Category和Extension是iOS开发中常见的两种语言特性. 下面就介绍一下.</p>\n<h1 id=\"1-Category\"><a href=\"#1-Category\" class=\"headerlink\" title=\"1 Category\"></a>1 Category</h1><p>Category是Objective-C 2.0之后添加的语言特性, Category的主要使用场景有下面几种:</p>\n<ul>\n<li>为已经存在的类添加方法, 属性, 协议等</li>\n<li>可以把类的实现分开在几个不同的文件里面. 这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的Category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的Category 等等</li>\n<li>声明私有方法(只在需要的地方引入分类，即可调用分类中的方法，不引用该分类的就无法调用（重写原类方法的除外))</li>\n<li>模拟多继承(分类中声明别的类中的方法，不实现，通过消息转发实现调用)</li>\n<li>把framework的私有方法公开(只要知道Framework中私有方法的声明，那么可以在分类中声明Framework中的私有方法，这样可以在需要的地方引入这个分类，就可以调用到Framework中的私有方法了)</li>\n</ul>\n<h2 id=\"1-1-category特点\"><a href=\"#1-1-category特点\" class=\"headerlink\" title=\"1.1 category特点\"></a>1.1 category特点</h2><ul>\n<li>category只能给某个已有的类扩充方法，不能扩充成员变量。</li>\n<li>category中也可以添加属性，只不过@property只会生成setter和getter的声明，不会生成setter和getter的实现以及成员变量。</li>\n<li>如果category中的方法和类中原有方法同名，运行时会优先调用category中的方法。也就是，category中的方法会覆盖掉类中原有的方法。所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同。避免出现这种情况的解决方案是给分类的方法名统一添加前缀。比如category_。</li>\n<li>如果多个category中存在同名的方法，运行时到底调用哪个方法由编译器决定，最后一个参与编译的方法会被调用</li>\n</ul>\n<h2 id=\"1-2-调用优先级\"><a href=\"#1-2-调用优先级\" class=\"headerlink\" title=\"1.2 调用优先级\"></a>1.2 调用优先级</h2><p>分类(category) &gt; 本类 &gt; 父类。即，优先调用cateory中的方法，然后调用本类方法，最后调用父类方法. </p>\n<p>注意：category是在运行时加载的，不是在编译时.</p>\n<h2 id=\"1-3-为什么category不能添加成员变量\"><a href=\"#1-3-为什么category不能添加成员变量\" class=\"headerlink\" title=\"1.3 为什么category不能添加成员变量\"></a>1.3 为什么category不能添加成员变量</h2><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p>\n<pre><code>typedef struct objc_class *Class;\n</code></pre><p>objc_class结构体的定义如下：</p>\n<pre><code>struct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n    #if !__OBJC2__\n    Class super_class                       OBJC2_UNAVAILABLE;  // 父类\n    const char *name                        OBJC2_UNAVAILABLE;  // 类名\n    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表\n    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存\n    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表\n    #endif\n} OBJC2_UNAVAILABLE;\n</code></pre><p>在上面的objc_class结构体中，ivars是objc_ivar_list（成员变量列表）指针；methodLists是指向objc_method_list指针的指针。在Runtime中，objc_class结构体大小是固定的，不可能往这个结构体中添加数据，只能修改。所以ivars指向的是一个固定区域，只能修改成员变量值，不能增加成员变量个数。methodList是一个二维数组，所以可以修改*methodLists的值来增加成员方法，虽没办法扩展methodLists指向的内存区域，却可以改变这个内存区域的值（存储的是指针）。因此，可以动态添加方法，不能添加成员变量。</p>\n<h2 id=\"1-4-category中能添加属性吗\"><a href=\"#1-4-category中能添加属性吗\" class=\"headerlink\" title=\"1.4 category中能添加属性吗?\"></a>1.4 category中能添加属性吗?</h2><p>Category不能添加成员变量（instance variables），那到底能不能添加属性（property）呢? 这个我们要从Category的结构体开始分析: </p>\n<pre><code>typedef struct category_t {\n    const char *name;  //类的名字\n    classref_t cls;  //类\n    struct method_list_t *instanceMethods;  //category中所有给类添加的实例方法的列表\n    struct method_list_t *classMethods;  //category中所有添加的类方法的列表\n    struct protocol_list_t *protocols;  //category实现的所有协议的列表\n    struct property_list_t *instanceProperties;  //category中添加的所有属性\n} category_t;\n</code></pre><p>从Category的定义也可以看出Category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>\n<p>但是为什么网上很多人都说Category不能添加属性呢? 实际上，Category实际上允许添加属性的，同样可以使用@property，但是不会生成_变量（带下划线的成员变量），也不会生成添加属性的getter和setter方法的实现，所以，尽管添加了属性，也无法使用点语法调用getter和setter方法(实际上，点语法是可以写的，只不过在运行时调用到这个方法时候会报方法找不到的错误). 但实际上可以使用runtime去实现Category为已有的类添加新的属性并生成getter和setter方法</p>\n<h2 id=\"1-5-category的加载\"><a href=\"#1-5-category的加载\" class=\"headerlink\" title=\"1.5 category的加载\"></a>1.5 category的加载</h2><p>Objective-C的运行是依赖OC的runtime的, 而OC的runtime和其他系统库一样, 是OS X和iOS通过dyld动态加载的.</p>\n<p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法. 在_read_images方法的结尾:</p>\n<ul>\n<li>会把category的实例方法、协议以及属性添加到类上(category的各种列表是怎么最终添加到类上的, 以实例方法列表来说: 在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的方法) </li>\n<li>把category的类方法和协议添加到类的metaclass上(对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法. attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法)</li>\n</ul>\n<p>综上我们可以发现: </p>\n<ul>\n<li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA.</li>\n<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法</li>\n</ul>\n<h2 id=\"1-5-同名category优先级\"><a href=\"#1-5-同名category优先级\" class=\"headerlink\" title=\"1.5 同名category优先级\"></a>1.5 同名category优先级</h2><ul>\n<li>如果同名方法只存在在category中, 后编译的先被访问.</li>\n<li>原类的方法和category中的方法同名, 原类的方法会被category的直接”覆盖”, 如果存在于多个category中则参考第一条.</li>\n</ul>\n<h2 id=\"1-6-load和initialize的调用顺序\"><a href=\"#1-6-load和initialize的调用顺序\" class=\"headerlink\" title=\"1.6 load和initialize的调用顺序\"></a>1.6 load和initialize的调用顺序</h2><p>关于load和initialize的相关信息, 可以看<a href=\"http://hchong.net/2019/07/24/iOS%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-load-initialize/\">这里</a>. 在MyClass及其分类中都添加这两个方法，只不过打印不同. </p>\n<pre><code>+(void)load {\n    NSLog(@&quot;MyClass:%s&quot;,__func__);\n}\n+(void)initialize {\n    NSLog(@&quot;MyClass:%s&quot;,__func__);\n}\n</code></pre><p><img src=\"http://img.souche.com/f2e/22b0bc484d5bb5354c7dd580b3e5a0ab.png\" alt=\"load\"><br>load方法，文件镜像被读取时调用，直观的表现是程序刚运行就会看到打印结果. 从上图可以看到, load的执行顺序是先类，后category, 而category的+load执行顺序是根据编译顺序决定的.</p>\n<p>附加category到类的工作会先于+load方法的执行. 因为category被附加到类上面是在map_images的时候发生的.</p>\n<p><img src=\"http://img.souche.com/f2e/f8ad0648bbbc7ef5c35d4a684544c1d5.png\" alt=\"initialize\"><br>从上图可以看到, initialize函数后编译的先被访问, 原类的方法会被分类的”覆盖”.(因为initialize只有在第一次被使用是会调用一次且仅一次，所以其他与普通方法相同).</p>\n<h2 id=\"1-7-category和方法覆盖\"><a href=\"#1-7-category和方法覆盖\" class=\"headerlink\" title=\"1.7 category和方法覆盖\"></a>1.7 category和方法覆盖</h2><p>category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法:</p>\n<pre><code>Class currentClass = [MyClass class];\nMyClass *my = [[MyClass alloc] init];\n\nif (currentClass) {\n    unsigned int methodCount;\n    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);\n    IMP lastImp = NULL;\n    SEL lastSel = NULL;\n    for (NSInteger i = 0; i &lt; methodCount; i++) {\n        Method method = methodList[i];\n        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) \n                                        encoding:NSUTF8StringEncoding];\n        if ([@&quot;printName&quot; isEqualToString:methodName]) {\n            lastImp = method_getImplementation(method);\n            lastSel = method_getName(method);\n        }\n    }\n    typedef void (*fn)(id,SEL);\n\n    if (lastImp != NULL) {\n        fn f = (fn)lastImp;\n        f(my,lastSel);\n    }\n    free(methodList);\n}\n</code></pre><h2 id=\"1-7-category和关联对象\"><a href=\"#1-7-category和关联对象\" class=\"headerlink\" title=\"1.7 category和关联对象\"></a>1.7 category和关联对象</h2><p>category里面是无法为category添加实例变量的. 但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现. 因为在分类中 @property 并不会自动生成实例变量以及存取方法，所以一般使用关联对象为已经存在的类添加属性, 这样我们通过category新增的属性就会存在与之对应的实例变量和存取方法.</p>\n<p>对象关联详解可以看<a href=\"https://draveness.me/ao\" target=\"_blank\" rel=\"noopener\">这里</a>;</p>\n<p>MyClass+Category1.h:</p>\n<pre><code>#import &quot;MyClass.h&quot;\n\n@interface MyClass (Category1)\n\n@property(nonatomic,copy) NSString *name;\n\n@end\n</code></pre><p>MyClass+Category1.m:</p>\n<pre><code>#import &quot;MyClass+Category1.h&quot;\n#import &lt;objc/runtime.h&gt;\n\n@implementation MyClass (Category1)\n\n+ (void)load\n{\n    NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);\n}\n\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self,\n                             &quot;name&quot;,\n                             name,\n                             OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString*)name\n{\n    NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);\n    return nameObject;\n}\n\n@end\n</code></pre><p>对象销毁时候如何处理关联对象呢? </p>\n<p>所有的关联对象都由AssociationsManager管理. AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对.</p>\n<p>runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作.</p>\n<h1 id=\"2-Extension\"><a href=\"#2-Extension\" class=\"headerlink\" title=\"2 Extension\"></a>2 Extension</h1><p>Extension被开发者称之为扩展、延展、匿名分类。Extension看起来很像一个匿名的Category，但是Extension和Category几乎完全是两个东西. Extension的主要使用场景有下面几种:</p>\n<ul>\n<li>声明私有属性</li>\n<li>声明私有方法</li>\n<li>声明私有成员变量</li>\n</ul>\n<h1 id=\"3-Category-vs-Extension\"><a href=\"#3-Category-vs-Extension\" class=\"headerlink\" title=\"3 Category vs Extension\"></a>3 Category vs Extension</h1><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension. 除非创建子类再添加extension。而category不需要有类的源码，我们可以给系统提供的类添加category.</p>\n<p>但是category则完全不一样，它是在运行期决议的。 就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的(因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的).</p>\n<p>extension和category都可以添加属性，但是category的属性不能生成成员变量和getter、setter方法的实现.</p>\n<table>\n<thead>\n<tr>\n<th>扩展的特点</th>\n<th>分类的特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编译时决议</td>\n<td>运行时决议</td>\n</tr>\n<tr>\n<td>只能以声明的形式存在，多数情况下寄生于\b宿主类的.m中</td>\n<td>分类有声明也有实现</td>\n</tr>\n<tr>\n<td>不能为系统类\b添加扩展</td>\n<td>可以为系统类添加分类</td>\n</tr>\n<tr>\n<td>可以\b添加实例变量</td>\n<td>不可以添加实例变量(因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的)</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://www.cocoachina.com/articles/19163\" target=\"_blank\" rel=\"noopener\">【iOS】Category VS Extension 原理详解</a><br>2.<a href=\"http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/\" target=\"_blank\" rel=\"noopener\">巧用 Class Extension 分离接口依赖</a><br>3.<a href=\"https://tech.meituan.com/2015/03/03/diveintocategory.html\" target=\"_blank\" rel=\"noopener\">深入理解Objective-C：Category</a><br>4.<a href=\"https://leoliuyt.github.io/2018/05/20/%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%88%86%E7%B1%BB/\" target=\"_blank\" rel=\"noopener\">运行时之二：分类</a><br>5.<a href=\"https://draveness.me/ao\" target=\"_blank\" rel=\"noopener\">关联对象 AssociatedObject 完全解析</a><br>6.<a href=\"http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/\" target=\"_blank\" rel=\"noopener\">Objective-C Associated Objects 的实现原理</a></p>\n","categories":["iOS开发-基础"],"tags":["基础知识"]},{"title":"iOS开发基础-hash & isEqual","url":"http://hchong.net/2018/09/13/iOS开发基础-hash-isEqual/","content":"<p><code>+ (NSUInteger)hash;</code>和<code>- (BOOL)isEqual:(id)object;</code>都是NSObject类中的方法, 所有继承自NSObject的类都可以调用这两个方法来实现相应的功能, 下面我们开始一起研究一下他们两个的功能和深层次原理.</p>\n<h1 id=\"1-isEqual\"><a href=\"#1-isEqual\" class=\"headerlink\" title=\"1 isEqual\"></a>1 isEqual</h1><h2 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.1 ==\"></a>1.1 ==</h2><p>对于基本类型, ==运算符比较的是值; 对于对象类型, ==运算符比较的是对象的地址(即是否为同一对象). isEqual只能用来比较对象类型.</p>\n<p>==运算符只是简单地判断是否是同一个对象, 而isEqual方法可以判断对象是否相同.</p>\n<h2 id=\"isEqual\"><a href=\"#isEqual\" class=\"headerlink\" title=\"isEqual\"></a>isEqual</h2><p>两个 NSObject 如果指向了同一个内存地址，那它们就被认为是相同的.</p>\n<p>在 Foundation 框架中，下面这些 NSObject 的子类都有自己的相等性检查实现，分别使用下面这些方法:</p>\n<ul>\n<li>NSAttributedString -isEqualToAttributedString:</li>\n<li>NSData -isEqualToData:</li>\n<li>NSDate -isEqualToDate:</li>\n<li>NSDictionary -isEqualToDictionary:</li>\n<li>NSHashTable -isEqualToHashTable:</li>\n<li>NSIndexSet -isEqualToIndexSet:</li>\n<li>NSNumber -isEqualToNumber:</li>\n<li>NSOrderedSet -isEqualToOrderedSet:</li>\n<li>NSSet -isEqualToSet:</li>\n<li>NSString -isEqualToString:</li>\n<li>NSTimeZone -isEqualToTimeZone:</li>\n</ul>\n<h2 id=\"NSArray的内部伪实现\"><a href=\"#NSArray的内部伪实现\" class=\"headerlink\" title=\"NSArray的内部伪实现\"></a>NSArray的内部伪实现</h2><pre><code class=\"OC\">@implementation NSArray (Approximate)\n- (BOOL)isEqualToArray:(NSArray *)array {\n  if (!array || [self count] != [array count]) {\n    return NO;\n  }\n\n  for (NSUInteger idx = 0; idx &lt; [array count]; idx++) {\n      if (![self[idx] isEqual:array[idx]]) {\n          return NO;\n      }\n  }\n\n  return YES;\n}\n\n- (BOOL)isEqual:(id)object {\n  if (self == object) {\n    return YES;\n  }\n\n  if (![object isKindOfClass:[NSArray class]]) {\n    return NO;\n  }\n\n  return [self isEqualToArray:(NSArray *)object];\n}\n@end\n</code></pre>\n<h2 id=\"自定义类型的isEqual\"><a href=\"#自定义类型的isEqual\" class=\"headerlink\" title=\"自定义类型的isEqual\"></a>自定义类型的isEqual</h2><p>Person.h</p>\n<pre><code class=\"OC\">@interface Person : NSObject\n\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, strong) NSDate *birthday;\n\n@end\n</code></pre>\n<p>Person.m</p>\n<pre><code class=\"OC\">- (BOOL)isEqual:(id)object \n{\n    if (self == object) {\n        return YES;\n    }\n\n    if (![object isKindOfClass:[Person class]]) {\n        return NO;\n    }\n\n    return [self isEqualToPerson:(Person *)object];\n}\n\n- (BOOL)isEqualToPerson:(Person *)person \n{\n    if (!person) {\n        return NO;\n    }\n\n    BOOL haveEqualNames = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name];\n    BOOL haveEqualBirthdays = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday];\n\n    return haveEqualNames &amp;&amp; haveEqualBirthdays;\n}\n</code></pre>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><pre><code class=\"OC\">NSString *a = @&quot;Hello&quot;;\nNSString *b = @&quot;Hello&quot;;\nBOOL wtf = (a == b); // YES\n</code></pre>\n<p>比较 NSString 对象正确的方法是 -isEqualToString:. 任何情况下都不要直接使用 == 来对 NSString 进行比较. </p>\n<p>上面的结果返回YES是因为一种称为字符串驻留的优化技术，它把一个不可变字符串对象的值拷贝给各个不同的指针。NSString <em>a 和 </em>b都指向同样一个驻留字符串值 @”Hello”。 注意所有这些针对的都是静态定义的不可变字符串.</p>\n<h1 id=\"2-hash\"><a href=\"#2-hash\" class=\"headerlink\" title=\"2 hash\"></a>2 hash</h1><p>hash 方法的存在，是因为将对象加到 NSSet 等集合中时，当成员被加入到Hash Table中时, 会给它分配一个hash值, 以标识该成员在集合中的位置, 通过这个位置标识可以将查找的时间复杂度优化到O(1), 当然如果多个成员都是同一个位置标识, 那么查找就不能达到O(1)了. 对于 Hash 值，系统默认是返回该对象的内存地址.</p>\n<h2 id=\"2-1-hash-Table\"><a href=\"#2-1-hash-Table\" class=\"headerlink\" title=\"2.1 hash Table\"></a>2.1 hash Table</h2><p>分配的这个hash值(即用于查找集合中成员的位置标识), 就是通过hash方法计算得来的, 且hash方法返回的hash值最好唯一.</p>\n<p>和数组相比, 基于hash值索引的Hash Table查找某个成员的过程就是: </p>\n<ul>\n<li>通过hash值直接找到查找目标的位置</li>\n<li>如果目标位置上有多个相同hash值得成员, 此时再按照数组方式进行查找</li>\n</ul>\n<p>NSSet添加新成员时, 需要根据hash值来快速查找成员, 以保证集合中是否已经存在该成员.<br>NSDictionary在查找key时, 也利用了key的hash值来提高查找的效率.</p>\n<h2 id=\"2-2-如何重写hash\"><a href=\"#2-2-如何重写hash\" class=\"headerlink\" title=\"2.2 如何重写hash\"></a>2.2 如何重写hash</h2><p>Person类中, 我们重写他的hash方法, 直接返回<code>[super hash]</code>是有问题的. 下面我们举例来来说明问题.</p>\n<pre><code class=\"OC\">Person *person1 = [Person personWithName:kName1 birthday:self.date1];\nPerson *person2 = [Person personWithName:kName1 birthday:self.date1];\nNSLog(@&quot;[person1 isEqual:person2] = %@&quot;, [person1 isEqual:person2] ? @&quot;YES&quot; : @&quot;NO&quot;);\n\nNSMutableSet *set = [NSMutableSet set];\n[set addObject:person1];\n[set addObject:person2];\nNSLog(@&quot;set count = %ld&quot;, set.count);\n</code></pre>\n<p>打印结果如下:</p>\n<pre><code class=\"OC\">[person1 isEqual:person2] = YES\nset count = 2\n</code></pre>\n<p>说明isEqual相同的两个对象都被加入到了同一个NSSet中. 所以直接返回[super hash]是不正确的.</p>\n<blockquote>\n<p>In reality, a simple XOR over the hash values of critical properties is sufficient 99% of the time(对关键属性的hash值进行位或运算作为hash值).</p>\n</blockquote>\n<p>对于上面Person类的hash方法实现如下:</p>\n<pre><code class=\"OC\">- (NSUInteger)hash {\n    return [self.name hash] ^ [self.birthday hash];\n}\n</code></pre>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h1><ul>\n<li>对于基本类型, ==运算符比较的是值; 对于对象类型, ==运算符比较的是对象的地址(即是否为同一对象). isEqual只能用来比较对象类型.</li>\n<li>==运算符只是简单地判断是否是同一个对象, 而isEqual方法可以判断对象是否相同.</li>\n<li>由于字符串驻留技术的存在, 静态定义的不可变字符串对象, ==的结果是YES.</li>\n<li>如果两个对象相等, 它们的 hash 值也一定是相等的. 反过来则不然. hash值是对象判等的必要非充分条件.</li>\n<li></li>\n</ul>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/915356e280fc\" target=\"_blank\" rel=\"noopener\">iOS开发 之 不要告诉我你真的懂isEqual与hash!</a><br>2.<a href=\"https://juejin.im/entry/587e0d5e61ff4b00650df3d1\" target=\"_blank\" rel=\"noopener\">iOS - isEqual &amp; hash</a><br>3.<a href=\"https://nshipster.cn/equality/\" target=\"_blank\" rel=\"noopener\"></a></p>\n","categories":["iOS开发-基础"],"tags":["基础知识"]},{"title":"OC中的桥接机制 - Toll-Free Bridging","url":"http://hchong.net/2018/05/07/OC中的桥接Toll-Free Bridging/","content":"<p>Core Foundation框架(CoreFoundation.framework)具有一系列概念性的基于Objective-C的基础框架, 以C语言实现了编程的接口, 它们为iOS应用程序提供基本数据管理和服务功能. Core Foundation可以访问低级函数, 原始数据类型和各种集合类型, 并与Foundation框架无缝桥接. 而Toll-free bridging 就是ARC下OC对象和Core Foundation对象之间的桥梁.</p>\n<p>在开发iOS应用程序时我们有时会用到Core Foundation对象, 下面简称CF. 例如Core Graphics, Core Text, 并且我们可能需要将CF对象和OC对象进行相互转化.</p>\n<p>MRC 下的 Toll－Free Bridging 因为不涉及内存管理的转移, 相互之间可以直接交换使用. 当使用 ARC 时, 由于 ARC 能够管理 Objective-C 对象的内存, 却不能管理 CF 对象, 此时编译器不知道该如何处理这个同时有 ObjC 指针和 CFTypeRef 指向的对象, 所以除了转换类型, 还需要指定内存管理所有权的改变, 我们需要使用<strong>bridge, </strong>bridge_retained, __bridge_transfer 修饰符来告诉编译器该如何去做.</p>\n<h2 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"__bridge\"></a>__bridge</h2><p>使用<code>__bridge</code>意味着告诉编译器不做任何内存管理的事情, 编译器负责管理ARC下 ObjC 端的引用计数的事情, 开发者继续管理好 CF 端的事情.</p>\n<ol>\n<li><p>如果OC创建的对象要给CF使用, 那么CF只管自己使用, OC会处理好所有的内存管理相关的东西. 如果OC中创建的对象被销毁, 那么意味着CF所指向的对象也被销毁了.</p>\n<pre><code> NSString *nsStr = [self createSomeNSString];\n CFStringRef cfStr = (__bridge CFStringRef)nsStr;\n CFUseCFString(cfStr);\n // CFRelease(cfStr); 不需要\n</code></pre></li>\n<li><p>如果是CF创建的对象给OC使用, 那么我们需要在CF端处理好内存管理的相关事情, 需要在bridge之后release对象.</p>\n<pre><code> CFStringRef hello = CFStringCreateWithCString(kCFAllocatorDefault, &quot;hello&quot;, kCFStringEncodingUTF8);\n NSString *world = (__bridge NSString *)(hello);\n CFRelease(hello); // 需要\n [self useNSString:world];\n</code></pre></li>\n</ol>\n<h2 id=\"bridge-retained\"><a href=\"#bridge-retained\" class=\"headerlink\" title=\"__bridge_retained\"></a>__bridge_retained</h2><p>以OC创建的对象给CF使用为例: 如果我们创建了一个OC的对象给CF使用, 我们是不需要在CF中管理对象的内存. 当OC的对象被释放之后, 我们仍然使用这个对象的话, 就有可能造成崩溃. 那么如果我们使用<code>__bridge_retained</code>, 就相当于CF也copy了一个对象, 在bridge的时候编译器会去retain对象. 因此, 我们如果使用<code>__bridge_retained</code>的话, 在CF中我们也是要考虑对象的内存管理.</p>\n<h2 id=\"bridge-transfer\"><a href=\"#bridge-transfer\" class=\"headerlink\" title=\"__bridge_transfer\"></a>__bridge_transfer</h2><p><code>__bridge_transfer</code>主要用来告诉编译过期, 转交对象的所有权, 内存由使用方管理. <code>CFBridgingRetain</code>的作用类似. 我们以CF创建的对象给OC使用为例: 在使用__bridge_transfer修饰符转换后CF指针不再持有对象.</p>\n<pre><code>//写法一\nCFStringRef hello = CFStringCreateWithCString(kCFAllocatorDefault, &quot;hello&quot;, kCFStringEncodingUTF8);\nNSString *world = (__bridge_transfer NSString *)(hello);\n// CFRelease(hello); 不需要\n[self useNSString:world];\n\n//写法二\nNSString *world = (__bridge_transfer NSString *)CFStringCreateWithCString(kCFAllocatorDefault, &quot;hello&quot;, kCFStringEncodingUTF8);\n[self useNSString:world];\n</code></pre><hr>\n<p>参考资料:<br>1.<a href=\"http://gracelancy.com/blog/2014/04/21/toll-free-bridging/\" target=\"_blank\" rel=\"noopener\">Toll-Free Bridging</a></p>\n<p>2.<a href=\"https://www.jianshu.com/p/bec56131eaeb\" target=\"_blank\" rel=\"noopener\">Toll-Free Bridging</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Aspects源码分析","url":"http://hchong.net/2018/05/02/Aspects源码分析/","content":"<p>Aspects 是一个轻量型的提供面向切面编程方案的框架, 我们项目中的统计埋点就是使用这个框架, 减少了对工程结构的入侵. Aspects 提供的API十分简单, Aspects 是基于 Method Swizzling 来实现的, 他的大致实现思路如下.</p>\n<p>OC 中, 每个类是一个结构体, 里面存储了类的一些基本信息, 其中 methodList 方法链表里面存储的是 Method 类型. Method 保存了一个方法的全部信息, 包括 SEL 方法名, method_types 各参数的返回值类型, IMP 该方法具体实现的函数指针. Method Swizzling 的核心实际上只做了两件事情: </p>\n<ol>\n<li><code>class_addMethod</code> 添加一个新的方法, 可能是把其它类中实现的方法添加到目标类中, 也可能是把父类实现的方法添加一份在子类中, 可能是添加的实例方法, 也可能是添加的类方法, 总之就是添加了方法.</li>\n<li>交换IMP 交换方法的实现IMP, 完成这个步骤除了使用<code>method_exchangeImplementations</code>这个方法外, 也可以是调用了<code>method_setImplementation</code>方法来单独修改某个方法的IMP, 或者是采用在调用<code>class_addMethod</code>方法中设定了IMP而直接就完成了IMP的交换, 总之就是对IMP的交换.</li>\n</ol>\n<p>OC 是一门动态语言, 我们执行一个函数时, 其实是在发一条消息: <code>[receiver message]</code>. 我们在 receiver 中找到 selector -&gt; message 的 IMP执行, 如果没找到IMP就执行 <code>objc_msgForward</code>进行消息转发. 那么这个查找的过程我们就可以动态的改变 selector 和 IMP 的对应关系, 从而使原来的消息转发到新的函数实现. </p>\n<p>在消息转发的时候, 如果 selector 有对应的IMP, 则直接执行. 如果没有, 还有三次补救机会, 依次是: </p>\n<ol>\n<li><code>resolveInstanceMethod</code>, 适合给类/对象动态添加一个相应的实现.</li>\n<li><code>forwardingTargetForSelector</code>, 适合将消息转发给其他对象处理.</li>\n<li><code>forwardInvocation</code>, 消息的重定向, 在此可以获得该次调用的所有参数和调用对象, 并随意重新组装, 十分灵活.</li>\n</ol>\n<p>Aspects 的方案就是, 对于待Hook的 selector, 将其指向 <code>objc_msgForward / _objc_msgForward_stret</code>, 同时生成一个新的 <code>aliasSelector</code> 指向原来的 IMP. 并且 hook 住 <code>forwardInvocation</code> 函数, 使他指向自己的实现. 当被 hook 的 selector 被执行的时候, 原 selector 的IMP则会统一指向 <code>objc_msgForward / _objc_msgForward_stret</code>, 启动消息转发流程, 从而进入 forwardInvocation. 同时由于 forwardInvocation 的指向也被修改了, 因此会转入新的 forwardInvocation 函数, 在里面执行需要嵌入的附加代码, 完成之后, 再转回原来的 IMP. 下面是相应的代码:  </p>\n<h2 id=\"添加一个aspect\"><a href=\"#添加一个aspect\" class=\"headerlink\" title=\"添加一个aspect\"></a>添加一个aspect</h2><pre><code class=\"OC\">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {\n    NSCParameterAssert(self);\n    NSCParameterAssert(selector);\n    NSCParameterAssert(block);\n\n    __block AspectIdentifier *identifier = nil;\n    aspect_performLocked(^{\n        //判断能否被Hook\n        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {\n            //记录相关的数据结构\n            AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);\n            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];\n            if (identifier) {\n                [aspectContainer addAspect:identifier withOptions:options];\n\n                // Modify the class to allow message interception. Hook的核心方法\n                aspect_prepareClassAndHookSelector(self, selector, error);\n            }\n        }\n    });\n    return identifier;\n}\n</code></pre>\n<p>所有的核心方法都被封装到这个核心的static方法里面, 这里面主要做了三个操作: </p>\n<ol>\n<li>判断能否Hook. 这里是有一个类似于黑名单和是否已经被Hook过的判断, 例如<code>retain</code>, <code>dealloc</code>等. 对于类对象还要确保同一个类继承关系层级中, 只能被 hook 一次, 因此这里需要判断子类, 父类有没有被 hook, 之所以做这样的实现, 主要是为了避免出现死循环的出现.</li>\n<li>记录数据结构.</li>\n<li>swizzling的核心. 一个是对对象的 forwardInvocation 进行 swizzling, 另一个是对传入的 selector 进行 swizzling. swizzling forwardInvocation主要在 <code>aspect_hookClass</code>方法中进行. swizzling selector主要在 <code>aspect_getMsgForwardIMP</code>方法中进行.</li>\n</ol>\n<h2 id=\"swizzling-forwardInvocation\"><a href=\"#swizzling-forwardInvocation\" class=\"headerlink\" title=\"swizzling forwardInvocation\"></a>swizzling forwardInvocation</h2><pre><code>static Class aspect_hookClass(NSObject *self, NSError **error) {\n    NSCParameterAssert(self);\n    Class statedClass = self.class;\n    Class baseClass = object_getClass(self);\n    NSString *className = NSStringFromClass(baseClass);\n\n    // Already subclassed\n    if ([className hasSuffix:AspectsSubclassSuffix]) {\n        return baseClass;\n\n        // We swizzle a class object, not a single object.\n    }else if (class_isMetaClass(baseClass)) {\n        return aspect_swizzleClassInPlace((Class)self);\n        // Probably a KVO&#39;ed class. Swizzle in place. Also swizzle meta classes in place.\n    }else if (statedClass != baseClass) {\n        return aspect_swizzleClassInPlace(baseClass);\n    }\n\n    // Default case. Create dynamic subclass.\n    const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;\n    Class subclass = objc_getClass(subclassName);\n\n    if (subclass == nil) {\n        subclass = objc_allocateClassPair(baseClass, subclassName, 0);\n        if (subclass == nil) {\n            NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName];\n            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);\n            return nil;\n        }\n\n        aspect_swizzleForwardInvocation(subclass);\n        aspect_hookedGetClass(subclass, statedClass);\n        aspect_hookedGetClass(object_getClass(subclass), statedClass);\n        objc_registerClassPair(subclass);\n    }\n\n    object_setClass(self, subclass);\n    return subclass;\n}\n</code></pre><p>源代码中并没有直接 swizzling 对象的 forwardInvocation 方法, 而是动态生成一个当前对象的子类, 并将当前对象与子类关联, 然后替换子类的 forwardInvocation 方法(这里具体方法就是调用了 object_setClass(self, subclass), 将当前对象 isa 指针指向了 subclass, 同时修改了 subclass 以及其 subclass metaclass 的 class 方法, 使他返回当前对象的 class, 类似于 kvo 的实现. </p>\n<p>将当前对象变成一个 subclass 的实例, 同时对于外部使用者而言, 又能把它继续当成原对象在使用, 而且所有的 swizzling 操作都发生在子类, 这样做的好处是你不需要去更改对象本身的类, 也就是, 当你在 remove aspects 的时候, 如果发现当前对象的 aspect 都被移除了, 那么, 你可以将 isa 指针重新指回对象本身的类, 从而消除了该对象的 swizzling, 同时也不会影响到其他该类的不同对象). 对于每一个对象而言, 这样的动态对象只会生成一次, 这里 aspect_swizzlingForwardInvocation 将使得 forwardInvocation 方法指向 aspects 自己的实现逻辑.</p>\n<h2 id=\"swizzling-selector\"><a href=\"#swizzling-selector\" class=\"headerlink\" title=\"swizzling selector\"></a>swizzling selector</h2><pre><code class=\"OC\">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {\n    NSCParameterAssert(selector);\n    //swizzling forwardInvocation\n    Class klass = aspect_hookClass(self, error);\n    Method targetMethod = class_getInstanceMethod(klass, selector);\n    IMP targetMethodIMP = method_getImplementation(targetMethod);\n    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {\n        // Make a method alias for the existing method implementation, it not already copied.\n        const char *typeEncoding = method_getTypeEncoding(targetMethod);\n        SEL aliasSelector = aspect_aliasForSelector(selector);\n        if (![klass instancesRespondToSelector:aliasSelector]) {\n            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);\n            NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);\n        }\n\n        // swizzling selector\n        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);\n        AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));\n    }\n}\n</code></pre>\n<p>当 forwradInvocation 被 hook 之后，接下来, 将对传入的 selector 进行 hook, 这里的做法是, 将 selector 指向了转发 IMP, 同时生成一个 aliasSelector, 指向了原来的 IMP, 同时为了放在重复 hook, 做了一个判断, 如果发现 selector 已经指向了转发 IMP, 那就就不需要进行交换了.</p>\n<h2 id=\"被Hook的ForwardInvocation的处理\"><a href=\"#被Hook的ForwardInvocation的处理\" class=\"headerlink\" title=\"被Hook的ForwardInvocation的处理\"></a>被Hook的ForwardInvocation的处理</h2><p>在<code>aspect_swizzleForwardInvocation</code> -&gt; <code>aspect_swizzleForwardInvocation</code>可以发现, 最终 ForwardInvocation 被指向 <code>__ASPECTS_ARE_BEING_CALLED__</code>. </p>\n<pre><code class=\"OC\">static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {\n    NSCParameterAssert(self);\n    NSCParameterAssert(invocation);\n    SEL originalSelector = invocation.selector;\n    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);\n    invocation.selector = aliasSelector;\n    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);\n    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);\n    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];\n    NSArray *aspectsToRemove = nil;\n\n    // Before hooks.\n    aspect_invoke(classContainer.beforeAspects, info);\n    aspect_invoke(objectContainer.beforeAspects, info);\n\n    // Instead hooks.\n    BOOL respondsToAlias = YES;\n    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {\n        aspect_invoke(classContainer.insteadAspects, info);\n        aspect_invoke(objectContainer.insteadAspects, info);\n    }else {\n        Class klass = object_getClass(invocation.target);\n        do {\n            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {\n                [invocation invoke];\n                break;\n            }\n        }while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));\n    }\n\n    // After hooks.\n    aspect_invoke(classContainer.afterAspects, info);\n    aspect_invoke(objectContainer.afterAspects, info);\n\n    // If no hooks are installed, call original implementation (usually to throw an exception)\n    if (!respondsToAlias) {\n        invocation.selector = originalSelector;\n        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);\n        if ([self respondsToSelector:originalForwardInvocationSEL]) {\n            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);\n        }else {\n            [self doesNotRecognizeSelector:invocation.selector];\n        }\n    }\n\n    // Remove any hooks that are queued for deregistration.\n    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];\n}\n</code></pre>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://www.tanhao.me/code/160723.html/\" target=\"_blank\" rel=\"noopener\">Method Swizzling的各种姿势</a></p>\n<p>2.<a href=\"http://wereadteam.github.io/2016/06/30/Aspects/\" target=\"_blank\" rel=\"noopener\">面向切面编程之 Aspects 源码解析及应用</a></p>\n","categories":["源码解析"],"tags":["源码解析"]},{"title":"React Native源码解析","url":"http://hchong.net/2018/04/17/React Native源码解析/","content":"<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><p>前端大致的开发流程就是:</p>\n<ul>\n<li>用 HTML 创建 DOM, 构建整个网页的布局, 结构</li>\n<li>用 CSS 控制 DOM 的样式, 比如字体, 字号, 颜色, 居中等</li>\n<li>用 JavaScript 接受用户事件, 动态的操控 DOM</li>\n</ul>\n<p>在React中, 我们使用JSX语法, 它是一种 JavaScript 语法拓展. JSX 允许我们写 HTML 标签或 React 标签, 它们终将被转换成原生的 JavaScript 并创建 DOM. 我们也可以在里面写CSS.</p>\n<p>React 独创了 Virtual DOM 机制. Virtual DOM 是一个存在于内存中的 JavaScript 对象, 它与 DOM 是一一对应的关系, 也就是说只要有 Virtual DOM, 我们就能渲染出 DOM. 当界面发生变化时, 得益于高效的 DOM Diff 算法, 我们能够知道 Virtual DOM 的变化, 从而高效的改动 DOM, 避免了重新绘制 DOM.</p>\n<p>React Native我们可以理解为Native 版本的 React. 即使使用了 React Native, 我们依然需要 UIKit 等框架, 调用的是 Objective-C 代码. JavaScript 只是辅助, 它只是提供了配置信息和逻辑的处理结果. 它只是以 JavaScript 的形式告诉 Objective-C 该执行什么代码. </p>\n<h1 id=\"React-Native启动流程\"><a href=\"#React-Native启动流程\" class=\"headerlink\" title=\"React Native启动流程\"></a>React Native启动流程</h1><p><img src=\"http://img.souche.com/f2e/bfb53a0a04e1c7a9ca7c99d9440e0972.png\" alt=\"RN整体结构\"></p>\n<p>RN的整体结构如图所示, RCTRootView 是RN的根视图, 它内部持有了 RCTBridge. RCTBridge 内部持有了 RCTBatchBridge 对象, 这个对象里面有着大部分的业务逻辑和核心代码.</p>\n<p>RCTBatchBridge 对象会持有一个 RCTDisplayLink对象, 这个对象主要用于一些Timer, Navigator的Module需要按着屏幕渲染频率回调JS用的. </p>\n<p>RCTModuleXXX 表示所有的RN的Module组件都是 RCTModuleData, 无论是RN的核心系统组件还是扩展的UI组件, API组件. </p>\n<p>RCTJSExecutor 是一个特殊的 RCTModuleData. 他是系统组件的核心, 负责单独开一个线程, 执行JS代码, 处理JS回调, 是bridge的核心通道.</p>\n<p>RCTEventDispatcher 也是一个特殊的 RCTModuleData. 各个业务模块通过它主动调起JS, 他封装了eventDispatcher得API来方便业务Module使用.</p>\n<p><img src=\"http://img.souche.com/f2e/f0aa996dd91edbb43c65963064be0fae.png\" alt=\"源码加载顺序\"></p>\n<ul>\n<li>创建RCTRootView -&gt; 设置窗口根控制器的View, 把RN的View添加到窗口上显示.</li>\n<li>在RCTRootView中创建RCTBridge -&gt; 桥接对象, 管理JS和OC交互, 做中转. </li>\n<li>在RCTBridge中创建RCTBatchedBridge -&gt; 批量桥接对象, JS和OC的交互基本都在这里. <ul>\n<li>创建一个Displaylink, 以设备屏幕渲染的频率触发一个timer, 判断是否有个别module需要按着timer去回调js, 如果没有module, 这个模块其实就是空跑一个displaylink.</li>\n</ul>\n</li>\n<li>RCTBatchedBridge对象 -&gt; start<ul>\n<li>创建一个dispatchQueue, 后面的操作都在这个队列里面, 保证顺序执行.</li>\n<li>RCTBatchedBridge -&gt; loadSource, 从本地或者远端拉取jsbundle.</li>\n<li>RCTBatchedBridge -&gt; initModulesWithDispatchGroup, 创建OC的模块表<ul>\n<li>RCTJavaScriptExecutor -&gt; setUp, Asynchronously initialize the JS executor, 异步初始化JS的桥接对象, 通过JSContext设置桥接.</li>\n<li>RCTBatchedBridge -&gt; moduleConfig, Asynchronously gather the module config, 异步获取moduleConfig.</li>\n<li>上面两个完成后, 执行RCTJSCExecutor -&gt; injectJSONText, 向JS中插入OC的模块表</li>\n</ul>\n</li>\n<li>上面几个执行完后, 执行RCTBatchedBridge -&gt; executeSourceCode, 确保在JSExecutor专属的Thread内执行jsbundle代码. 把前面创建的RCTDisplayLink添加在在JSExecutor的Thread所在的runloop上.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"React-Native源码加载\"><a href=\"#React-Native源码加载\" class=\"headerlink\" title=\"React Native源码加载\"></a>React Native源码加载</h1><p>源码加载, 也就是JS代码加载的过程, 主要是APP启动流程中RCTBatchedBridge -&gt; loadSource这一步骤. </p>\n<ul>\n<li>RCTJavaScriptLoader -&gt; loadBundleAtURL, 加载JS代码, 这个URL可以是本地的文件路径也可以是服务器地址.</li>\n<li>RCTJavaScriptLoader -&gt; attemptAsynchronousLoadOfBundleAtURL, 异步加载JS文件, 里面的判断较多, 对本地URL和远端URL有做区分对待.</li>\n<li>上面下载完成后, 会把源代码通过block回调给外面来处理. RCTBatchedBridge -&gt; executeSourceCode. 在这里会调用RCTJSCExecutor -&gt; executeApplicationScript, 把JS代码交给RCTJSCExecutor对象然后在JS专用线程中来处理JS代码</li>\n<li>处理结束后在回调中注册RCTDisplayLink到JS专用线程对应的RunLoop中. 然后发送 RCTJavaScriptDidLoadNotification 通知.</li>\n<li>接收通知的地方有三个, 分别是隐藏self.window, 同步所有的设置, 新建一个RCTRootContentView.</li>\n<li>在创建RCTRootContentView对象时, 会通过通知传过来的参数获取前面我们创建的RCTBridge中的RCTUIManager(管理UI组件). 并且把RCTRootContentView对象注册为RootView. 并且把它添加到_viewRegistry中去(这是一个字典, 所有注册过的View都在这里面, key是一个reactTag). </li>\n<li>在创建RCTRootContentView对象时, 也会创建一个RCTTouchHandler, 用来处理事件. 详见<a href=\"#React Native事件处理\">这里</a>.</li>\n<li>RCTRootContentView对象创建完成后, 执行RCTRootContentView -&gt; runApplication方法. 通知JS运行APP, 来渲染控件. 详见<a href=\"#React Native页面渲染\">这里</a>.</li>\n<li>RCTBridge -&gt; enqueueJSCall, 通过桥接对象让JS调用 APPRegistry. </li>\n<li>RCTBatchedBridge -&gt; _actuallyInvokeAndProcessModule, 通过批量桥架让JS执行AppRegistry方法.</li>\n<li>RCTJSCExecutor -&gt; _executeJSCall, 让JS执行者调用JS代码.</li>\n<li>执行完JS代码后, 会返回一个数组, 这个数组里面是OC要执行的操作(包含 RCTBridgeFieldRequestModuleIDs = 0, RCTBridgeFieldMethodIDs,  RCTBridgeFieldParams, RCTBridgeFieldCallID). 然后把数组传递给RCTBatchedBridge -&gt; _processResponse. </li>\n<li>在这里面执行RCTBatchedBridge -&gt; handleBuffer方法, 这个方法最终会便利数组依次调用RCTBatchedBridge -&gt; callNativeModule方法.</li>\n</ul>\n<h1 id=\"React-Native页面渲染\"><a href=\"#React-Native页面渲染\" class=\"headerlink\" title=\"React Native页面渲染\"></a><span id=\"React Native页面渲染\">React Native页面渲染</span></h1><p><em>每一个 js render() 方法中的 component 都对应于 native 中的一个 RCTView. 在渲染前, js 会循环取出各个 component. 然后通过 UIManager (NativeModules 中的一项) 的 createView 方法, 通过 BatchedBridge 调用 native 端的 RCTUIManager 的同名方法, 创建与 component 相对应的类. 对于触摸事件也是类似的. native 端通过 bridge 将触摸事件传给 js, js 在找到对应 component 后, 响应各个触摸事件.</em></p>\n<ul>\n<li>RCTRootContentView -&gt; runApplication, 通知JS运行APP.</li>\n<li>在 native 调用 <code>-enqueueJSCall:method:args:completion</code> 后, 我们最终调用JS中 AppRegistry 的 runApplication方法. 下面这些都是JS线程中JS调用OC的方法.<ul>\n<li>RCTUIManager -&gt; createView:viewName:rootTag:props: </li>\n<li>这里使用了 RCT_EXPORT_METHOD 宏标记了该方法, 所以可以在JS中调用. </li>\n<li>每创建一个 UIView 就会 创建一个 RCTShadowView, 与UIView一一对应. 保存对应UIView的布局和子控件, 管理UIView的加载.</li>\n<li>把设置好的 view 保存到 _viewRegistry 中. js 和 native 端都会保存好这个 tag 和 view 的映射表. 这里的 _viewRegistry 就是 native 端保存的字典.</li>\n<li>最终在 ReactNativeBaseComponent.js 中调用了 UIManager.createView(). 这里实际调用的是原生中 RCTUIManager 暴露出来的 createView 方法.</li>\n<li>此时又调用到JS代码中的RCTUIManager -&gt; setChildren:reactTags: 给RCTRootView对应的RCTRootShadowView设置子控件. 继续调用RCTRootShadowView -&gt; insertReactSubview方法, 遍历子控件给RCTRootShadowView插入所有子控件.</li>\n</ul>\n</li>\n<li>RCTBatchedBridge -&gt; _processResponse:error:, 处理完执行JS代码返回的对象.</li>\n<li>RCTBatchedBridge -&gt; handleBuffer, 其中调用了RCTUIManager -&gt; batchDidComplete方法. </li>\n<li>在上面的方法中又调用了RCTUIManager -&gt; _layoutAndMount方法, 布局RCTRootView和增加子控件.<ul>\n<li>会遍历所有的View, 调用 RCTShadowView -&gt; processUpdatedProperties:处理保存在RCTShadowView中属性, 布局RCTShadowView对应UIView的所有子控件, 给原生View添加子控件</li>\n</ul>\n</li>\n<li>完成UI渲染.</li>\n</ul>\n<h1 id=\"React-Native事件处理\"><a href=\"#React-Native事件处理\" class=\"headerlink\" title=\"React Native事件处理\"></a><span id=\"React Native事件处理\">React Native事件处理</span></h1><ul>\n<li>在创建 RCTRootContentView 时内部会 创建一个 RCTTouchHandler. RCTTouchHandler继承于 UIGestureRecognizer 内部实现了touchBegin等触摸方法, 用来处理触摸事件. RCTTouchHandler被添加到 RCTRootContentView 上面.</li>\n<li>创建 RCTTouchHandler 时, 内部会创建 RCTEventDispatcher. </li>\n<li>当原生的Touchs事件被触发, 会在里面调用 RCTEventDispatcher -&gt; sendEvent. 让事件分发对象调用发送事件对象, 并且内部会把事件保存到_eventQueue.</li>\n<li>再调用 RCTEventDispatcher -&gt; flushEventsQueue, 遍历获取事件队列中所有事件执行 RCTEventDispatcher -&gt; dispatchEvent.</li>\n<li>在 RCTEventDispatcher -&gt; dispatchEvent 中我们可以看到又调用了 RCTBatchedBridge -&gt; enqueueJSCall:args:方法, 又进入了桥接对象执行JS的步骤.</li>\n<li>总的来说, 就是原生响应触摸事件, 通过 RCTEventDispatcher 传递到桥接对象, 最终还是调用JS的代码处理.</li>\n</ul>\n<h1 id=\"React-Native通信机制\"><a href=\"#React-Native通信机制\" class=\"headerlink\" title=\"React Native通信机制\"></a>React Native通信机制</h1><p>React Native用iOS自带的JavaScriptCore作为JS的解析引擎, 并没有用到JavaScript提供的一些可以让JS与OC互调的特性, 而是自己实现了一套机制, 这套机制可以通用于所有JS引擎上.</p>\n<p>首先我们要介绍两个宏:</p>\n<pre><code>#define RCT_EXPORT_MODULE(js_name) \\\nRCT_EXTERN void RCTRegisterModule(Class); \\\n+ (NSString *)moduleName { return @#js_name; } \\\n+ (void)load { RCTRegisterModule(self); }\n</code></pre><p>可以看到添加 RCT_EXPORT_MODULE 宏, 相当定义了load, moduleName方法. 正是在load方法中调用了 RCTRegisterModule 方法注册 Module. 注意过多的load方法是会影响APP的启动速度的. RCTRegisterModule 只是简单收集所有需要曝露给 JS 的类. </p>\n<pre><code>#define RCT_EXPORT_METHOD(method) \\\n  RCT_REMAP_METHOD(, method)\n\n#define RCT_REMAP_METHOD(js_name, method) \\\n  RCT_EXTERN_REMAP_METHOD(js_name, method) \\\n  - (void)method\n\n#define RCT_EXTERN_REMAP_METHOD(js_name, method) \\\n  + (NSArray&lt;NSString *&gt; *)RCT_CONCAT(__rct_export__, \\\n    RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) { \\\n    return @[@#js_name, @#method]; \\\n  }  \n</code></pre><p>可以看到通过宏添加了一个新方法, 其命名规则: <code>__rct_export__ + __LINE__ + __COUNTER__</code>. 同时注意到, 所有曝露给 JS 的方法返回值都是 void, 要返回结果时, 需通过 callback 方式实现.</p>\n<p>在RN初始化过程中会调用 RCTBatchedBridge -&gt; -initModulesWithDispatchGroup:方法, 这个方法中会调用如下代码: </p>\n<pre><code>  for (Class moduleClass in RCTGetModuleClasses()) {\n    NSString *moduleName = RCTBridgeModuleNameForClass(moduleClass);\n\n    // Check for module name collisions\n    RCTModuleData *moduleData = moduleDataByName[moduleName];\n    if (moduleData) {\n      if (moduleData.hasInstance) {\n        // Existing module was preregistered, so it takes precedence\n        continue;\n      } else if ([moduleClass new] == nil) {\n        // The new module returned nil from init, so use the old module\n        continue;\n      } else if ([moduleData.moduleClass new] != nil) {\n        // Both modules were non-nil, so it&#39;s unclear which should take precedence\n        RCTLogError(@&quot;Attempted to register RCTBridgeModule class %@ for the &quot;\n                    &quot;name &#39;%@&#39;, but name was already registered by class %@&quot;,\n                    moduleClass, moduleName, moduleData.moduleClass);\n      }\n    }\n\n    // Instantiate moduleData (TODO: can we defer this until config generation?)\n    moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass\n                                                     bridge:self];\n    moduleDataByName[moduleName] = moduleData;\n    [moduleClassesByID addObject:moduleClass];\n    [moduleDataByID addObject:moduleData];\n  }\n\n//查找所有响应 RCTBridgeModule 的class.\nvoid RCTRegisterModule(Class moduleClass)\n{\n  static dispatch_once_t onceToken;\n  dispatch_once(&amp;onceToken, ^{\n    RCTModuleClasses = [NSMutableArray new];\n  });\n\n  RCTAssert([moduleClass conformsToProtocol:@protocol(RCTBridgeModule)],\n            @&quot;%@ does not conform to the RCTBridgeModule protocol&quot;,\n            moduleClass);\n\n  // Register module\n  [RCTModuleClasses addObject:moduleClass];\n}\n</code></pre><p>暴露给 JS 的类被 RCT_EXPORT_MODULE 宏注册. 暴露给 JavaScript 的方法被 RCT_EXPORT_METHOD 宏为函数名加上了 <code>__rct_export__</code> 前缀, 通过 runtime 获取类的函数列表. 至此, 所有需要曝露给 JS 的 module , Method都已注册完成, 并以RCTModuleData格式存储在 RCTCxxBridge 中. Bridge 持有一个数组, 数组中保存了所有的模块的 RCTModuleData 对象. 只要给定 ModuleId 和 MethodId 就可以唯一确定要调用的方法.</p>\n<p>在 React Native 中, Objective-C 和 JavaScript 的交互都是通过传递 ModuleId、MethodId 和 Arguments 进行的.</p>\n<p>Objective-C 调用 JavaScript 代码时:</p>\n<ul>\n<li>在加载完JS代码后会调用 RCTBatchedBridge 的 <code>-enqueueApplicationScript:url:onComplete</code>方法.</li>\n<li>加载完成后会调用 RCTJSCExecutor 的 <code>-flushedQueue:</code>方法.</li>\n<li>最终主要是在 RCTJSCExecutor 的  <code>-_executeJSCall:arguments:unwrapResult:callback</code>方法, 这里这个函数名是我们要调用 JavaScript 的中转函数名, 它的作用其实是处理参数, 而非真正要调用的 JavaScript 函数. 这个中转函数接收到的参数包含了 ModuleId、MethodId 和 Arguments, 然后由中转函数查找自己的模块配置表, 找到真正要调用的 JavaScript 函数.</li>\n</ul>\n<p>实际使用的时候, 我们可以使用 RCTEventDispatcher 的 <code>-sendEvent:</code>方法直接向JS发送事件. 而不用通过模块配置表.</p>\n<p>JavaScript 调用 Objective-C 代码时: </p>\n<ul>\n<li>JS端调用某个OC模块暴露出来的方法. </li>\n<li>JavaScript 会解析出方法的 ModuleId, MethodId 和 Arguments 并放入到 MessageQueue 中, 等待 Objective-C 主动拿走, 或者超时后主动发送给 Objective-C.</li>\n<li>把JS的callback函数缓存在MessageQueue的一个成员变量里, 用CallbackID代表callback.</li>\n<li>Objective-C 负责处理调用的方法是 RCTBatchedBridge 的<code>-handleBuffer:</code> 在这里解析出ModuleId, MethodId, Params</li>\n<li>然后调用 RCTBatchedBridge 的 <code>- (id)callNativeModule:method:params:</code> 方法.</li>\n<li>RCTModuleMethod对JS传过来的每一个参数进行处理, CallbackID类型被转换为一个 block</li>\n<li>再实现 RCTModuleMethod 的 <code>[method invokeWithBridge:self module:moduleData.instance arguments:params]</code> 方法, OC模块方法调用完, 执行block回调至此方法调用结束.</li>\n<li>RCTModuleMethod 还有一个 <code>-processMethodSignature</code>方法, 它会根据 JavaScript 的 CallbackId 创建一个 Block, OC模块方法调用完, 执行上面参数转换的block回调.</li>\n<li>block里带着CallbackID 和block 传过来的参数去调 JS 里 MessageQueue 的方法 invokeCallbackAndReturnFlushedQueue. </li>\n<li>MessageQueue 通过 CallbackID 找到相应的JS callback方法. 调用callback方法, 并把OC带过来的参数一起传过去, 完成回调.</li>\n</ul>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://i.dotidea.cn/2016/05/react-native-communication-principle-for-ios/\" target=\"_blank\" rel=\"noopener\">React Native通信原理解析</a></p>\n<p>2.<a href=\"http://awhisper.github.io/2016/07/02/ReactNative%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/\" target=\"_blank\" rel=\"noopener\">ReactNative iOS源码解析</a></p>\n<p>3.<a href=\"https://zhang759740844.github.io/2017/01/17/RN%20Native%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">React-Native 初始化与通信原理源码分析</a></p>\n<p>4.<a href=\"https://www.jianshu.com/p/9e4f9f98f82d\" target=\"_blank\" rel=\"noopener\">React Native原理篇整理笔记</a></p>\n<p>5.<a href=\"https://blog.csdn.net/u011342466/article/details/57180192\" target=\"_blank\" rel=\"noopener\">React Native通讯机制—从源码分析</a></p>\n<p>6.<a href=\"https://www.jianshu.com/p/bd7dfd8c9917\" target=\"_blank\" rel=\"noopener\">React Native从源码一步一步解析它的实现原理</a></p>\n<p>7.<a href=\"http://fighting300.com/2017/03/02/reactnative-code/\" target=\"_blank\" rel=\"noopener\">React Native源码分析</a></p>\n<p>8.<a href=\"https://www.jianshu.com/p/0688b24950f4\" target=\"_blank\" rel=\"noopener\">React Native源码分析原理（二）(基于0.48版本)</a></p>\n<p>9.<a href=\"http://blog.cnbang.net/tech/2698/\" target=\"_blank\" rel=\"noopener\">React Native通信机制详解</a></p>\n<p>10.<a href=\"https://zhang759740844.github.io/2017/01/24/RN%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/\" target=\"_blank\" rel=\"noopener\">React-Native 如何创建原生 View 源码解析</a></p>\n<p>11.<a href=\"http://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/\" target=\"_blank\" rel=\"noopener\">ReactNative源码解析——通信机制详解</a></p>\n<p>12.<a href=\"https://bestswifter.com/react-native/#javascriptrctjscexecutor\" target=\"_blank\" rel=\"noopener\">React Native从入门到原理</a></p>\n<p>13.<a href=\"https://www.jianshu.com/p/bd7dfd8c9917\" target=\"_blank\" rel=\"noopener\">React Native源码中JavaScriptCore详解</a></p>\n","categories":["RN"],"tags":["RN"]},{"title":"iOS开发中的字符串匹配算法","url":"http://hchong.net/2018/04/12/iOS开发中的字符串匹配算法/","content":"<p>字符串匹配是计算机的基本任务之一, 例如有一个字符串”BBC ABCDAB ABCDABCDABDE”, 我想知道, 里面是否包含另一个字符串”ABCDABD”.</p>\n<h1 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h1>","categories":["算法"],"tags":["算法"]},{"title":"iOS开发总结系列-排序算法","url":"http://hchong.net/2018/04/09/iOS开发总结系列-排序算法/","content":"<p>这里主要是iOS开发中常见的排序算法. </p>\n<h1 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h1><p>原理: 从数列中挑出一个元素, 成为”基准”, 重新排序数列, 所有元素比基准值小的摆放在基准前面, 所有元素比基准值大的摆在基准的后面(相同的数可以放在任一边), 在这个分区退出之后, 该基准就处于数列的中间位置, 递归的把小于基准值元素的子数列和大于基准值元素的子数列排序.</p>\n<p>这种排序方法是基于二分的思想来实现的, 简单的说就是将一个大的问题通过不断的一分为二化简为较小的问题来解决. 通过二分化简了问题的规模来提高解决问题的效率. 因此我们将发现快速排序的平均时间复杂度是O(nlogn), 最差时间复杂度是O(n^2).</p>\n<ol>\n<li>定义两个哨兵i(数组的第一个位置), j(数组的最后一个位置), 一个基准数(数组的第一个元素). </li>\n<li>从j开始, 向i比较, 直到遇到一个数小于基准数. </li>\n<li>从i开始, 向j比较, 直到遇到一个数大于基准数.</li>\n<li>交换i, j两个位置的值.</li>\n<li>交换后, i, j继续按照之前的方式比较, 直到i与j相遇.</li>\n<li>我们交换基准数和哨兵位置上的数.</li>\n<li>接下来我们以这个哨兵位置为临界, 将原数组分为左右两部分, 再递归的调用上面的比对过程. </li>\n<li>此时原数组的左边部分的哨兵i实际就是原i, 哨兵j实际就是i-1.</li>\n<li>此时原数组的右边部分的哨兵i实际就是原i+1, 哨兵j实际就是原j.</li>\n</ol>\n<pre><code>- (void)quickSortArray:(NSMutableArray *)array formLeft:(NSInteger)left right:(NSInteger)right {\n    if (left &gt;= right) {\n        return;\n    }\n    NSInteger i = left;\n    NSInteger j = right;\n    //记录比较基准数\n    NSInteger key = [array[i] integerValue];\n\n    while (i &lt; j) {\n        //从右基准数开始向左递减, 直到一个数小于基准数(先从右边开始遍历是为了保持基准数不变)\n        while (i &lt; j &amp;&amp; [array[j] integerValue] &gt;= key) {\n            j--;\n        }\n        //从左基准位置开始向右递增, 直到遇到一个数大于基准数\n        while (i &lt; j &amp;&amp; [array[i] integerValue] &lt;= key) {\n            i++;\n        }\n        //交换两个数在数组中的位置\n        if (i &lt; j) {\n            array[i] = @([array[i] integerValue] + [array[j] integerValue]);\n            array[j] = @([array[i] integerValue] - [array[j] integerValue]);\n            array[i] = @([array[i] integerValue] - [array[j] integerValue]);\n        }\n    }\n\n    //此时, 两个基准数相等, 将基准数归位\n    array[left] = array[i];\n    array[i] = @(key);\n\n    //递归处理基准数左边\n    [self quickSortArray:array formLeft:left right:i - 1];\n    //递归处理基准数右边\n    [self quickSortArray:array formLeft:i + 1 right:right];\n}\n</code></pre><h1 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h1><p>归并排序是建立在归并操作上的一种有效的排序算法, 该算法是采用分治法(Divide and Conquer)的一个非常典型的应用. 他的时间复杂度是O(nlogn).</p>\n<p>它的原理是假设初始序列含有n个记录, 则可以看成是n个有序的子序列, 每个子序列的长度为1, 然后两两归并, 得到n/2个长度为2或者1的有序子序列; 再两两归并, 如此反复, 直到得到一个长度为n的有序序列为止, 这种排序方法称为归并排序.<br><img src=\"https://img-blog.csdn.net/20160908095240209\" alt=\"归并排序\"></p>\n<pre><code>- (void)mergeSortArray:(NSMutableArray *)array {\n  //创建一个副本数组\n  NSMutableArray * auxiliaryArray = [[NSMutableArray alloc]initWithCapacity:array.count];\n\n  //对数组进行第一次二分，初始范围为0到array.count-1\n  [self mergeSort:array auxiliary:auxiliaryArray low:0 high:array.count-1];\n}\n\n- (void)mergeSort:(NSMutableArray *)array auxiliary:(NSMutableArray *)auxiliaryArray low:(int)low high:(int)high {\n  //递归跳出判断\n  if (low&gt;=high) {\n    return;\n  }\n  //对分组进行二分\n  int middle = (high - low)/2 + low;\n\n  //对左侧的分组进行递归二分 low为第一个元素索引，middle为最后一个元素索引\n  [self mergeSort:array auxiliary:auxiliaryArray low:low high:middle];\n\n  //对右侧的分组进行递归二分 middle+1为第一个元素的索引，high为最后一个元素的索引\n  [self mergeSort:array auxiliary:auxiliaryArray low:middle + 1 high:high];\n\n  //对每个有序数组进行回归合并\n  [self merge:array auxiliary:auxiliaryArray low:low middel:middle high:high];\n}\n\n- (void)merge:(NSMutableArray *)array auxiliary:(NSMutableArray *)auxiliaryArray low:(int)low middel:(int)middle high:(int)high {\n  //将数组元素复制到副本\n  for (int i=low; i&lt;=high; i++) {\n    auxiliaryArray[i] = array[i];\n  }\n  //左侧数组标记\n  int leftIndex = low;\n  //右侧数组标记\n  int rightIndex = middle + 1;\n\n  //比较完成后比较小的元素要放的位置标记\n  int currentIndex = low;\n\n  while (leftIndex &lt;= middle &amp;&amp; rightIndex &lt;= high) {\n    //此处是使用NSNumber进行的比较，你也可以转成NSInteger再比较\n    if ([auxiliaryArray[leftIndex] compare:auxiliaryArray[rightIndex]]!=NSOrderedDescending) {\n        //左侧标记的元素小于等于右侧标记的元素\n        array[currentIndex] = auxiliaryArray[leftIndex];\n        currentIndex++;\n        leftIndex++;\n    }else{\n        //右侧标记的元素小于左侧标记的元素\n        array[currentIndex] = auxiliaryArray[rightIndex];\n        currentIndex++;\n        rightIndex++;\n    }\n  }\n  //如果完成后左侧数组有剩余\n  if (leftIndex &lt;= middle) {\n     for (int i = 0; i&lt;=middle - leftIndex; i++) {\n        array[currentIndex +i] = auxiliaryArray[leftIndex +i ];\n    }\n  }\n }\n</code></pre><hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/8fce5bfb0013\" target=\"_blank\" rel=\"noopener\">归并排序</a></p>\n","categories":["算法"],"tags":["算法"]},{"title":"iOS开发UI-事件传递&视图响应","url":"http://hchong.net/2018/04/08/iOS开发UI-事件传递-视图响应/","content":"<p>iOS开发中有大量的人机交互事件, 我们怎么来处理这些人机交互, 就需要代表用户操作事件的传递和视图的响应来完成整个传递链.<br>iOS中的事件分为3大类型: 触屏事件(手势), 传感器事件(摇一摇, 陀螺仪), 远程控制事件(耳机的线控, 外接手柄). 按照时间顺序, 事件的生命周期概括如下: </p>\n<ol>\n<li>事件的产生和传递</li>\n<li>找出最合适的View后事件的处理</li>\n</ol>\n<p>下面以触摸事件为例. 在iOS中不是任何对象都能处理事件, 只有继承了UIResponder的对象才能接受并处理事件, 我们称之为”响应者对象”. <code>UIApplication</code>, <code>UIViewController</code>, <code>UIView</code>都是继承自UIResponder的, 所以都能接收并处理事件.</p>\n<h1 id=\"1-事件的产生\"><a href=\"#1-事件的产生\" class=\"headerlink\" title=\"1 事件的产生\"></a>1 事件的产生</h1><p>发生触摸事件后, 系统会将该事件加入到一个由UIApplication管理的事件队列中. 因为队列的特点是FIFO, 先进先出, 先产生的事件先处理.</p>\n<p>UIApplication会从事件队列中取出最前面的事件, 并将事件分发下去以便处理, 通常先发送事件给应用程序的主窗口(Keywindow).</p>\n<p>主窗口(keywindow)会在视图层析结构找到一个最合适的视图来处理触摸事件, 找到合适的视图控件后就会调用视图控件的touches方法来做具体的事件处理.</p>\n<h1 id=\"2-事件的传递\"><a href=\"#2-事件的传递\" class=\"headerlink\" title=\"2 事件的传递\"></a>2 事件的传递</h1><p>触摸事件的传递是从父控件到子控件, 也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view. <em>如果父控件不能接受触摸事件, 那么子控件就不可能接收到触摸事件.</em></p>\n<ol>\n<li>主窗口接收到应用程序传递过来的事件后, 首先判断自己能否接手触摸事件. 如果能, 那么在判断触摸点在不在窗口自己身上.</li>\n<li>如果触摸点在自己身上, 那么窗口会倒序遍历子控件来寻找最合适的View(倒序先遍历最新添加的View, 效率更高).</li>\n<li>遍历到每一个子控件, 会重复上面的两个步骤. (传递事件给子控件, 判断子控件能否接受事件, 触摸点是否在子控件上)</li>\n<li>循环遍历子控件, 直到找到最合适的View. 如果没有符合条件的子控件, 那么就认为自己最合适处理.</li>\n</ol>\n<p>如果UIView的<code>userInteractionEnabled = NO</code>, 或者<code>hidden = YES</code>, 或者透明度&lt;0.01则不能接受触摸事件. 注意父控件的hidden属性和透明度alpha属性都会影响他的子控件.</p>\n<h2 id=\"2-1-寻找最合适View的底层实现\"><a href=\"#2-1-寻找最合适View的底层实现\" class=\"headerlink\" title=\"2.1 寻找最合适View的底层实现\"></a>2.1 寻找最合适View的底层实现</h2><p>寻找最合适的View用到了两个重要方法: <code>hitTest:withEvent:</code> 和 <code>pointInside:withEvent:</code>.</p>\n<h2 id=\"2-2-hitTest-withEvent\"><a href=\"#2-2-hitTest-withEvent\" class=\"headerlink\" title=\"2.2 hitTest:withEvent:\"></a>2.2 hitTest:withEvent:</h2><p>只要事件一传递给一个控件, 这个控件就会调用他自己的<code>hitTest:withEvent:</code>方法. 他的作用就是寻找并返回最合适的view(能够响应事件的那个最合适的view). <em>不管这个控件能不能处理事件, 也不管触摸点在不在这个控件上, 事件都会先传递给这个控件, 随后再调用 <code>hitTest:withEvent:</code>方法.</em></p>\n<pre><code>底层具体实现如下: \n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    // 1.判断当前控件能否接收事件\n    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;\n    // 2. 判断点在不在当前控件\n    if ([self pointInside:point withEvent:event] == NO) return nil;\n    // 3.从后往前遍历自己的子控件\n    NSInteger count = self.subviews.count;\n    for (NSInteger i = count - 1; i &gt;= 0; i--) {\n        UIView *childView = self.subviews[i];\n        // 把当前控件上的坐标系转换成子控件上的坐标系\n        CGPoint childP = [self convertPoint:point toView:childView];\n        UIView *fitView = [childView hitTest:childP withEvent:event];\n        if (fitView) { // 寻找到最合适的view\n            return fitView;\n        }\n    }\n    // 循环结束,表示没有比自己更合适的view\n    return self;\n}\n</code></pre><p>事件传递给窗口或者控件后, 就调用<code>hitTest:withEvent:</code>寻找最合适的View. 所以是先传递事件, 再根据事件在自己身上找到最合适的View. 不管子控件是不是最合适的View, 系统都会先把事件传递给子控件, 经过子控件的<code>hitTest:withEvent:</code>验证后才知道有没有最合适的View. 所以如果确定最终父控件是最合适的view, 那么该父控件的子控件的hitTest:withEvent:方法也是会被调用的.</p>\n<p>一般我们在父控件的hitTest:withEvent:中返回子控件作为最合适的view. 例如: 当遍历子控件时, 如果触摸点不在子控件A自己身上而是在子控件B身上, 还要要求返回子控件A作为最合适的view, 采用返回自己的方法可能会导致还没有来得及遍历A自己, 就有可能已经遍历了点真正所在的view, 也就是B. 这就导致了返回的不是自己而是触摸点真正所在的view, 所以还是建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view.</p>\n<h2 id=\"2-3-pointInside-withEvent\"><a href=\"#2-3-pointInside-withEvent\" class=\"headerlink\" title=\"2.3 pointInside:withEvent:\"></a>2.3 pointInside:withEvent:</h2><p>pointInside:withEvent:方法判断点在不在当前view上(方法调用者的坐标系上)如果返回YES, 代表点在方法调用者的坐标系上; 返回NO代表点不在方法调用者的坐标系上, 那么方法调用者也就不能处理事件.</p>\n<h1 id=\"3-事件传递的总结\"><a href=\"#3-事件传递的总结\" class=\"headerlink\" title=\"3 事件传递的总结\"></a>3 事件传递的总结</h1><p>由上面可知: 事件的传递顺序应该如下:<br>产生触摸事件 -&gt; <code>UIApplication</code>事件队列 -&gt; <code>[UIWindow hitTest:withEvent:]</code> -&gt; 返回更合适的view -&gt; 子控件<code>[hitTest:withEvent:]</code> -&gt; 返回最合适的view</p>\n<h1 id=\"4-事件的响应\"><a href=\"#4-事件的响应\" class=\"headerlink\" title=\"4. 事件的响应\"></a>4. 事件的响应</h1><p>上面介绍了事件的传递, 下面介绍下事件传递到最合适的处理view后, 如果响应.</p>\n<h2 id=\"4-1-响应者链条\"><a href=\"#4-1-响应者链条\" class=\"headerlink\" title=\"4.1 响应者链条\"></a>4.1 响应者链条</h2><ol>\n<li>用户点击屏幕后产生的一个触摸事件, 经过一系列的传递过程后, 会找到最合适的视图控件来处理这个事件. </li>\n<li>找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理<code>touchesBegan:withEvent:</code>, <code>touchesMoved:withEvent:</code>, <code>touchesEnded:withEvent:</code>, <code>touchesCancelled:withEvent:</code>  </li>\n<li>touch方法默认不处理事件, 只传递事件, 将事件(顺着响应者链条)交给上一个响应者进行处理. 如果找到合适的View之后就会调用该view的touches方法要进行响应处理具体的事件, 找不到就不会调用. </li>\n</ol>\n<h2 id=\"4-2-响应者链条\"><a href=\"#4-2-响应者链条\" class=\"headerlink\" title=\"4.2 响应者链条\"></a>4.2 响应者链条</h2><p>响应者链条其实就是很多响应者对象(继承自UIResponder的对象)一起组合起来的链条称之为响应者链条. 响应者链的事件传递过程如下:</p>\n<ol>\n<li>如果当前view是控制器的view, 那么控制器就是上一个响应者, 事件就传递给控制器; 如果当前view不是控制器的view, 那么父视图就是当前view的上一个响应者, 事件就传递给它的父视图.</li>\n<li>在视图层级结构的最顶级视图, 如果也不能处理接收到的事件或者消息, 则将其事件或消息传递给window对象进行处理.</li>\n<li>如果window对象也不处理, 则将其事件或消息传递给UIApplication对象.</li>\n<li>如果UIApplication也不能处理该事件或者消息则将其丢弃.</li>\n</ol>\n<p>注意: 在事件的响应中, 如果某个控件实现了touches的一系列方法. 则这个事件将由该控件来接受. 如果调用了[super touches…], 就会将事件顺着响应者链条往上传递, 传递给上一个响应者, 接着就会调用上一个响应者的touches…方法.</p>\n<h1 id=\"5-人机交互处理的完整流程\"><a href=\"#5-人机交互处理的完整流程\" class=\"headerlink\" title=\"5. 人机交互处理的完整流程\"></a>5. 人机交互处理的完整流程</h1><ol>\n<li>触摸屏产生触摸事件后, 触摸事件会被添加到由UIApplication管理的事件队列中去.</li>\n<li>UIApplication会从事件队列中取出最前面的事件, 把事件传递给应用程序的主窗口(keywindow).</li>\n<li>主窗口会在视图层级结构中找到一个最合适的View来处理触摸事件.</li>\n<li>最合适的View会调用自己的touches方法处理事件.</li>\n<li>把事件沿着响应者链条向上抛, 一直到找到能够处理的视图或者被UIApplication抛弃.</li>\n</ol>\n<p>事件的传递是从上到下(父控件到子控件), 事件的响应是从下到上(顺着响应者链条向上传递: 子控件到父控件).</p>\n<h1 id=\"6-常见用法\"><a href=\"#6-常见用法\" class=\"headerlink\" title=\"6. 常见用法\"></a>6. 常见用法</h1><p>下面是事件传递和视图响应中的一些常见用法</p>\n<h2 id=\"6-1-一个事件多个对象处理\"><a href=\"#6-1-一个事件多个对象处理\" class=\"headerlink\" title=\"6.1 一个事件多个对象处理\"></a>6.1 一个事件多个对象处理</h2><p>事件的响应是顺着响应者链条向上传递的, 即从子控件传递给父控件, touch方法默认不处理事件, 而是把事件顺着响应者链条传递给上一个响应者. 这样我们就可以依托这个原理, 让一个事件多个控件响应.</p>\n<pre><code>-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {\n  NSLog(@&quot;-- dosomething&quot;);\n  [super touchesBegan:touches withEvent:event];\n}\n</code></pre><h2 id=\"6-2-扩大view的点击区域\"><a href=\"#6-2-扩大view的点击区域\" class=\"headerlink\" title=\"6.2 扩大view的点击区域\"></a>6.2 扩大view的点击区域</h2><pre><code>底层具体实现如下: \n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;\n    CGRect touchRect = CGRectInset(self.bounds, -10, -10);\n    if (CGRectContainsPoint(touchRect, point)) {\n        NSInteger count = self.subviews.count;\n        for (NSInteger i = count - 1; i &gt;= 0; i--) {\n            UIView *childView = self.subviews[i];\n            CGPoint childP = [self convertPoint:point toView:childView];\n            UIView *fitView = [childView hitTest:childP withEvent:event];\n            if (fitView) {\n                return fitView;\n            }\n        }\n        return self;\n    }\n    return nil;\n}\n</code></pre><hr>\n<p>参考资料:<br>1.<a href=\"http://blog.flight.dev.qunar.com/2016/10/28/ios-event-mechanism-summary/\" target=\"_blank\" rel=\"noopener\">iOS事件传递及响应</a></p>\n<p>2.<a href=\"https://zhoon.github.io/ios/2015/04/12/ios-event.html\" target=\"_blank\" rel=\"noopener\">深入浅出iOS事件机制</a></p>\n<p>3.<a href=\"https://www.jianshu.com/p/2e074db792ba\" target=\"_blank\" rel=\"noopener\">史上最详细的iOS之事件的传递</a></p>\n","categories":["iOS开发-UI"],"tags":["基础知识"]},{"title":"iOS开发的崩溃日志分析与异常类型","url":"http://hchong.net/2018/04/05/iOS开发的崩溃日志分析与异常类型/","content":"<h1 id=\"崩溃分析\"><a href=\"#崩溃分析\" class=\"headerlink\" title=\"崩溃分析\"></a>崩溃分析</h1><h2 id=\"崩溃日志\"><a href=\"#崩溃日志\" class=\"headerlink\" title=\"崩溃日志\"></a>崩溃日志</h2><h3 id=\"如何得到crash-report\"><a href=\"#如何得到crash-report\" class=\"headerlink\" title=\"如何得到crash report\"></a>如何得到crash report</h3><ol>\n<li>当一个iOS应用程序崩溃时, 系统会创建一份crash日志保存在设备上. 这份crash日志记录着应用程序崩溃时的信息, 通常包含着每个执行线程的栈调用信息(低内存闪退日志例外). 如果设备就在身边, 可以连接设备, 打开Xcode - Window - Organizer, 在左侧面板中选择Device Logs(可以选择具体设备的Device Logs或者Library下所有设备的Device Logs), 然后根据时间排序查看设备上的crash日志. 这是开发, 测试阶段最经常采用的方式.</li>\n<li>如果应用程序已经提交到App Store发布, 用户已经安装使用了, 那么开发者可以通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志. 不过这并不是100%有效的, 因为这需要用户设备同意上传相关信息.</li>\n<li>线上app的崩溃日志会被app store收集并符号化分组. 类似的崩溃报告的集合被称为崩溃点, (如果用户选择了与苹果共享诊断数据, 这些崩溃日志才会被收集并被符号化). 打开Xcode - Window - Organizer, 在点击相应应用后, 会显示此应用的崩溃集合. 可以看到每一个集合中都会有很多个设备, 如果右键进去查看的话, 会看到很多文件. 右键显示包内容, 会看到最终的详细日志, 当选中了一个崩溃集合后, 如果选择在项目中打开, 会在项目代码中找到具体出问题的代码. 选中Open in Project的话, 会直接在工程中打开.</li>\n<li>如果用户反馈应用曾亏, 也可以通过让用户设备与iTunes同步, 设备与电脑上的iTunes Store同步后, 会将崩溃日志保存在电脑上(路径：Mac OS X:~/Library/Logs/CrashReporter/MobileDevice/)到上述位置把崩溃日志下载下来, 然后通过电子邮件发送给你.</li>\n<li>通过第三方工具来获取崩溃信息.</li>\n</ol>\n<h3 id=\"如何得到-dSYM\"><a href=\"#如何得到-dSYM\" class=\"headerlink\" title=\"如何得到.dSYM\"></a>如何得到.dSYM</h3><p>我们在Archive的时候会生成.xcarchive文件, 显示包内容就能够在里面找到.dSYM文件和.app文件. .dSYM文件位于 /Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives 目录下, 在目录中包含了一个16进制的保存函数地址映射信息的中转文件, 所有Debug文件的symbols都在这个文件中(包含文件名, 函数名, 行号等), 也称之为调试符号信息文件.</p>\n<p>当我们软件 release 模式打包或上线后, 不会像我们在 Xcode 中那样直观的看到用崩溃的错误, 这个时候我们就需要分析 crash report 文件了, iOS 设备中会有日志文件保存我们每个应用出错的函数内存地址, 通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件, 这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名. 大前提是我们需要有软件版本对应的 dSYM 文件, 这也是为什么我们很有必要保存每个发布版本的 Archives 文件了.</p>\n<p>每一个 xx.app 和 xx.app.dSYM 文件都有对应的 UUID, crash 文件也有自己的 UUID, 只要这三个文件的 UUID 一致, 我们就可以通过他们解析出正确的错误函数信息了.</p>\n<ol>\n<li>通过<code>dwarfdump --uuid xx.app/xx (xx代表你的项目名)</code>查看xx.app文件的UUID</li>\n<li>通过<code>dwarfdump --uuid xx.app.dSYM</code>查看xx.dSYM的UUID</li>\n<li>crash 文件内第一行 Incident Identifier 就是该 crash 文件的 UUID.</li>\n</ol>\n<h3 id=\"结合分析crash文件\"><a href=\"#结合分析crash文件\" class=\"headerlink\" title=\"结合分析crash文件\"></a>结合分析crash文件</h3><p>根据crash report, .dSYM分析崩溃函数.</p>\n<ol>\n<li>如果使用的是友盟的话, 友盟自带的有一个分析工具. 但是要注意, 使用的时候要确保你的.xcarchive在 ~/Library/Developer/Xcode/或该路径的子目录下. .xcarchive里的.dsYM文件和.app文件是有对应的UUID的. 然后你的crash report里也是有UUID, 只有当UUID相等时才能分析对. 如果是在别人电脑上archive, 那你需要把.dSYM文件copy过来.</li>\n<li>symbolicatecrash是xcode的一个符号化crash log的命令行工具. 使用方法也就是导出.crash文件（crash log）和找到.dsYM文件, 然后进行分析. <a href=\"http://www.cnblogs.com/ningxu-ios/p/4141783.html\" target=\"_blank\" rel=\"noopener\">查看这里</a></li>\n<li>如果你有多个“.ipa”文件, 多个”.dSYMB”文件, 你并不太确定到底“dSYM”文件对应哪个”.ipa”文件, 可以使用命令行工具atos. <a href=\"http://blog.sina.com.cn/s/blog_76a1980f0102wjcf.html\" target=\"_blank\" rel=\"noopener\">查看这里</a></li>\n</ol>\n<h3 id=\"崩溃日志分析\"><a href=\"#崩溃日志分析\" class=\"headerlink\" title=\"崩溃日志分析\"></a>崩溃日志分析</h3><p>Xcode-&gt;Window-&gt;Organizer-&gt;Crashes, <a href=\"http://www.cocoachina.com/industry/20130725/6677.html\" target=\"_blank\" rel=\"noopener\">这里</a>有关于崩溃日志的详细分析.</p>\n<p>盗图一张, 关于崩溃日志的详细信息<br><img src=\"http://devma.cn/images/2016/11/ios_crash_analysis_2.png\" alt=\"崩溃日志\"></p>\n<h2 id=\"野指针分析\"><a href=\"#野指针分析\" class=\"headerlink\" title=\"野指针分析\"></a>野指针分析</h2><p>因为野指针的原因发生崩溃是常常出现的事, 而且比较随机. 所以我们要提高野指针的崩溃率好来帮我们快速找到有问题的代码. 对象释放后只有出现被随机填入的数据是不可访问的时候才会必现Crash. </p>\n<p>这个地方我们可以做一下手脚, 把这一随机的过程变成不随机的过程. 对象释放后在内存上填上不可访问的数据, 其实这种技术其实一直都有, Edit Scheme -&gt; Diagnostics -&gt;Enable Malloc Scribble 选中就可以实现这个功能</p>\n<h2 id=\"僵尸模式分析\"><a href=\"#僵尸模式分析\" class=\"headerlink\" title=\"僵尸模式分析\"></a>僵尸模式分析</h2><p>启用了NSZombieEnabled, 它会用一个僵尸来替换默认的dealloc实现, 也就是在引用计数降到0时, 该僵尸实现会将该对象转换成僵尸对象. 僵尸对象的作用是在你向它发送消息时, 它会显示一段日志并自动跳入调试器. 当启用NSZombieEnabled时, 一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象. 僵尸对象会显示接受到得信息, 然后跳入调试器, 这样你就可以查看到底是哪里出了问题.<br>一般这时崩溃的原因就是因为调用了已经释放的内存空间，或者说重复释放了某个地址空间.</p>\n<ol>\n<li>打开NSZombieEnabled之后, 如果遇到对应的崩溃类型既调用了已经释放的内存空间, 或者说重复释放了某个地址空间, 那么就能在GDB中看到对应的输出信息.</li>\n<li>如果崩溃是发生在当前调用栈, 通过上面的做法, 系统就会把崩溃原因定位到具体代码中. 但是, 如果崩溃不在当前调用栈, 系统就仅仅只能把崩溃地址告诉我们, 而没办法定位到具体代码, 这样我们也没法去修改错误. 这时就可以修改scheme, 让xcode记录每个地址alloc的历史, 这样我们就可以用命令把这个地址还原出来. Edit Scheme -&gt; Environment Variables -&gt; 加入MallocStackLoggingNoCompact, 并且设置为YES.</li>\n</ol>\n<h2 id=\"Enable-Address-Sanitizer\"><a href=\"#Enable-Address-Sanitizer\" class=\"headerlink\" title=\"Enable Address Sanitizer\"></a>Enable Address Sanitizer</h2><p>Edit Scheme -&gt; Diagnostics -&gt;Enable Address Sanitizer选中就可以实现这个功能, 设置这个参数后, 我们可以看到一些更详细的错误信息提示, 设置还有内存使用情况的展示. </p>\n<p>这类工具的理论依据是: 访问内存时, 通过比较访问的内存和程序实际分配的内存, 验证内存访问的有效性, 从而在bug发生时就检测到它们, 而不会等到副作用产生时才有所察觉.</p>\n<h2 id=\"静态分析\"><a href=\"#静态分析\" class=\"headerlink\" title=\"静态分析\"></a>静态分析</h2><p>Static Analyzer是一个非常好的工具去发现编译器警告不会提示的问题和一些个人的内错泄露和死存储(不会用到的赋了值的变量)错误. 这个方法可能大大的提高内存使用和性能, 以及提升应用的整体稳定性和代码质量.</p>\n<p>打开方式: Xcode-&gt;Product-Analyze 然后我们就能看到如下蓝色箭头所示的一些有问题的代码.</p>\n<h2 id=\"unrecognized-selector-send-to-instancd-快速定位\"><a href=\"#unrecognized-selector-send-to-instancd-快速定位\" class=\"headerlink\" title=\"unrecognized selector send to instancd 快速定位\"></a>unrecognized selector send to instancd 快速定位</h2><ol>\n<li>在debug navigator的断点栏里添加Create Symbolic Breakpoint</li>\n<li>在Symbolic中填写如下方法签名： <code>-[NSObject(NSObject) doesNotRecognizeSelector:]</code></li>\n</ol>\n<h1 id=\"常见崩溃信息类型\"><a href=\"#常见崩溃信息类型\" class=\"headerlink\" title=\"常见崩溃信息类型\"></a>常见崩溃信息类型</h1><h2 id=\"Exception-Type异常类型\"><a href=\"#Exception-Type异常类型\" class=\"headerlink\" title=\"Exception Type异常类型\"></a>Exception Type异常类型</h2><h3 id=\"SIGABRT类型\"><a href=\"#SIGABRT类型\" class=\"headerlink\" title=\"SIGABRT类型\"></a>SIGABRT类型</h3><p>在iOS中就是未被捕获的Objective-C异常(NSException)导致程序向自身发送了SIGABRT信号而崩溃, 常见的如下:</p>\n<ul>\n<li>SIGSEGV: 段错误信息（SIGSEGV）是操作系统产生的一个更严重的问题。当硬件出现错误、访问不可读的内存地址或向受保护的内存地址写入数据时，就会发生这个错误。硬件错误这一情况并不常见。当要读取保存在RAM中的数据，而该位置的RAM硬件有问题时，你会收到SIGSEGV。SIGSEGV更多是出现在后两种情况。默认情况下，代码页不允许进行写操作，而数据而不允许进行执行操作。当应用中的某个指针指向代码页并试图修改指向位置的值时，你会收到SIGSEGV。当要读取一个指针的值，而它被初始化成指向无效内存地址的垃圾值时，你也会收到SIGSEGV SIGSEGV错误调试起来更困难，而导致SIGSEGV的最常见原因是不正确的类型转换。要避免过度使用指针或尝试手动修改指针来读取私有数据结构。如果你那样做了，而在修改指针时没有注意内存对齐和填充问题，就会收到SIGSEGV。</li>\n<li>SIGBUS: 总线错误信号（SIGBUG）代表无效内存访问，即访问的内存是一个无效的内存地址。也就是说，那个地址指向的位置根本不是物理内存地址（它可能是某个硬件芯片的地址）。SIGSEGV和SIGBUS都羽毛球EXC_BAD_ACCESS的子类型。</li>\n<li>SIGTRAP: SIGTRAP代表陷阱信号。它并不是一个真正的崩溃信号。它会在处理器执行trap指令发送。LLDB调试器通常会处理此信号，并在指定的断点处停止运行。如果你收到了原因不明的SIGTRAP，先清除上次的输出，然后重新进行构建通常能解决这个问题。</li>\n<li>EXC_ARITHETIC: 当要除零时，应用会收到EXC_ARITHMETIC信号。这个错误应该很容易解决.</li>\n<li>SIGILL: SIGILL代表signal illegal instruction(非法指令信号)。当在处理器上执行非法指令时，它就会发生。执行非法指令是指，将函数指针会给另外一个函数时，该函数指针由于某种原因是坏的，指向了一段已经释放的内存或是一个数据段。有时你收到的是EXC_BAD_INSTRUCTION而不是SIGILL，虽然它们是一回事，不过EXC_*等同于此信号不依赖体系结构。</li>\n<li>SIGABRT: SIGABRT代表SIGNAL ABORT（中止信号）。当操作系统发现不安全的情况时，它能够对这种情况进行更多的控制；必要的话，它能要求进程进行清理工作。在调试造成此信号的底层错误时，并没有什么妙招。Cocos2d或UIKit等框架通常会在特定的前提条件没有满足或一些糟糕的情况出现时调用C函数abort（由它来发送此信号）。当SIGABRT出现时，控制台通常会输出大量的信息，说明具体哪里出错了。由于它是可控制的崩溃，所以可以在LLDB控制台上键入bt命令打印出回溯信息</li>\n</ul>\n<p>更多的SIGABRT信号类型看<a href=\"http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h3 id=\"EXC-BAD-ACCESS\"><a href=\"#EXC-BAD-ACCESS\" class=\"headerlink\" title=\"EXC_BAD_ACCESS\"></a>EXC_BAD_ACCESS</h3><p>EXC_BAD_ACCESS是一个比较难处理的crash, 当一个app进入一种毁坏的状态, 通常是由于内存管理问题而引起的时, 就会出现出现这样的crash. 通常Signal信号错误都会提醒EXC_BAD_ACCESS, 我们可以通过僵尸模式来捕获这种异常.</p>\n<h3 id=\"看门狗超时\"><a href=\"#看门狗超时\" class=\"headerlink\" title=\"看门狗超时\"></a>看门狗超时</h3><p>这种崩溃通常比较容易分辨, 因为错误码是固定的0x8badf00d. 在iOS上, 它经常出现在执行一个同步网络调用而阻塞主线程的情况. 因此, 永远不要进行同步网络调用.</p>\n<h2 id=\"Exception-Codes异常编码\"><a href=\"#Exception-Codes异常编码\" class=\"headerlink\" title=\"Exception Codes异常编码\"></a>Exception Codes异常编码</h2><p>0x8badf00d: 读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的。 通常是应用花费太多时间而无法启动、终止或响应用系统事件。</p>\n<p>0xbad22222: 该编码表示 VoIP 应用因为过于频繁重启而被终止。</p>\n<p>0xdead10cc: 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。</p>\n<p>0xdeadfa11: 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面</p>\n<p>#常见的崩溃类型收集</p>\n<h2 id=\"新老操作系统兼容\"><a href=\"#新老操作系统兼容\" class=\"headerlink\" title=\"新老操作系统兼容\"></a>新老操作系统兼容</h2><p>在新 iOS 上正常的应用, 到了老版本 iOS 上秒退最常见原因是系统动态链接库或Framework无法找到. 这种情况通常是由于 App 引用了一个新版操作系统里的动态库(或者某动态库的新版本)或只有新 iOS 支持的 Framework, 而又没有对老系统进行测试, 于是当 App 运行在老系统上时便由于找不到而秒退.<br>还有就是有些方法是新版操作系统才支持的, 而又没有对该方法是否存在于老系统中做出判断.</p>\n<h2 id=\"本地存储的数据结构变化\"><a href=\"#本地存储的数据结构变化\" class=\"headerlink\" title=\"本地存储的数据结构变化\"></a>本地存储的数据结构变化</h2><p>程序在升级时, 修改了本地存储的数据结构, 但是对用户既存的旧数据没有做好升级, 结果导致初始化时因为无法正确读取用户数据而秒退.</p>\n<h2 id=\"访问的数据为空或者数据类型不对\"><a href=\"#访问的数据为空或者数据类型不对\" class=\"headerlink\" title=\"访问的数据为空或者数据类型不对\"></a>访问的数据为空或者数据类型不对</h2><p>这类情况是比较常见的, 后端传回了空数据, 客户端没有做对应的判断继续执行下去了, 这样就产生了crash. 或者自己本地的某个数据为空数据而去使用了. 还有就是访问的数据类型不是期望的数据类型而产生崩溃.</p>\n<h2 id=\"操作了不该操作的对象\"><a href=\"#操作了不该操作的对象\" class=\"headerlink\" title=\"操作了不该操作的对象\"></a>操作了不该操作的对象</h2><p>这里有可能是空指针或者野指针.<br>空指针是没有存储任何内存地址的指针, 一般指nil, 但是在iOS中向nil发消息是不会崩溃的.</p>\n<p>野指针是指指向一个已删除的对象(“垃圾”内存既不可用内存)或未申请访问受限内存区域的指针. 野指针是比较危险的, 因为野指针指向的对象已经被释放了, 不能用了, 你再给被释放的对象发送消息就是违法的, 所以会崩溃.</p>\n<h2 id=\"内存处理不当\"><a href=\"#内存处理不当\" class=\"headerlink\" title=\"内存处理不当\"></a>内存处理不当</h2><p>内存管理是软件开发中一个重要的课题, iOS自从引入ARC机制后, 对于内存的管理开发者好像轻松了很多, 但是还会发生一些内存泄露之类的问题. Facebook工程师们开源了一些自动化工具来解决监测内存泄露问题:FBRetainCycleDetector、FBAllocationTracker、FBMemoryProfiler.</p>\n<h2 id=\"主线程UI长时间卡死-被系统杀掉\"><a href=\"#主线程UI长时间卡死-被系统杀掉\" class=\"headerlink\" title=\"主线程UI长时间卡死, 被系统杀掉\"></a>主线程UI长时间卡死, 被系统杀掉</h2><p>主线程被卡住是非常常见的场景, 具体表现就是程序不响应任何的UI交互. 这时按下调试的暂停按钮, 查看堆栈, 就可以看到是到底是死锁, 死循环等, 导致UI线程被卡住.</p>\n<h2 id=\"多线程之间切换访问引起的crash\"><a href=\"#多线程之间切换访问引起的crash\" class=\"headerlink\" title=\"多线程之间切换访问引起的crash\"></a>多线程之间切换访问引起的crash</h2><p>多线程引起的崩溃大部分是因为使用数据库的时候多线程同时读写数据库而造成了crash. <a href=\"https://blog.csdn.net/lixing333/article/details/42149893\" target=\"_blank\" rel=\"noopener\">这里</a>关于多线程crash的调试.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/09b6084bcd01\" target=\"_blank\" rel=\"noopener\">iOS崩溃捕捉与分析</a></p>\n<p>2.<a href=\"http://www.cocoachina.com/ios/20171026/20921.html\" target=\"_blank\" rel=\"noopener\">全面的理解和分析iOS的崩溃日志</a></p>\n<p>3.<a href=\"https://www.jianshu.com/p/3261493e6d9e\" target=\"_blank\" rel=\"noopener\">浅谈iOS Crash</a></p>\n<p>4.<a href=\"https://blog.csdn.net/womendeaiwoming/article/details/44243571\" target=\"_blank\" rel=\"noopener\">iOS中的崩溃类型</a></p>\n<p>5.<a href=\"http://devma.cn/blog/2016/11/10/ios-beng-kui-crash-jie-xi/\" target=\"_blank\" rel=\"noopener\">iOS 崩溃Crash解析</a></p>\n<p>6.<a href=\"http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html\" target=\"_blank\" rel=\"noopener\">iOS异常捕获</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS中常见的内存泄漏","url":"http://hchong.net/2018/04/04/iOS中常见的内存泄漏/","content":"<p>内存泄漏是开发中常见的一种问题, 下面我们就开发中常见的容易出现内存泄漏的场景做一个总结和分析.</p>\n<h2 id=\"Block下的循环引用\"><a href=\"#Block下的循环引用\" class=\"headerlink\" title=\"Block下的循环引用\"></a>Block下的循环引用</h2><p>在ARC下基本上不用我们内存管理释放, block中导致的内存泄漏常常就是因为强引用互相之间持有而发生了循环引用无法释放. AFNetWorking上的经典代码, 防止循环引用.</p>\n<pre><code>//创建__weak弱引用，防止强引用互相持有\n__weak __typeof(self)weakSelf = self;\nAFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {\n    //创建局部__strong强引用，防止多线程情况下weakSelf被析构\n     __strong __typeof(weakSelf)strongSelf = weakSelf;\n    strongSelf.networkReachabilityStatus = status;\n    if (strongSelf.networkReachabilityStatusBlock) {\n         strongSelf.networkReachabilityStatusBlock(status);\n    }\n};\n</code></pre><p><strong>weak 本身是可以避免循环引用的问题的, 但是其会导致外部对象释放了之后, block 内部也访问不到这个对象的问题, 我们可以通过在 block 内部声明一个 </strong>strong 的变量来指向 weakObj, 使外部对象既能在 block 内部保持住, 又能避免循环引用的问题.</p>\n<h2 id=\"delegate循环引用问题\"><a href=\"#delegate循环引用问题\" class=\"headerlink\" title=\"delegate循环引用问题\"></a>delegate循环引用问题</h2><p>delegate循环引用问题比较基础, 只需注意将代理属性修饰为weak即可. 例如:<br>ViewController的self.view持有了UITableView. 所以UITableView的delegate和dataSource就不能持有ViewController. 所以要使用weak来修饰.</p>\n<h2 id=\"NSTimer的循环引用\"><a href=\"#NSTimer的循环引用\" class=\"headerlink\" title=\"NSTimer的循环引用\"></a>NSTimer的循环引用</h2><p>我们一般这么创建NSTimer</p>\n<pre><code>- (void)viewDidLoad {\n    NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(timerFire) userInfo:nil repeats:YES];//timer强引用self\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//RunLoop强引用timer\n    self.timer = timer;//self强引用timer\n}\n\n- (void)timerFire {\n    NSLog(@&quot;timer fire&quot;);\n}\n</code></pre><p>但是当我们把timer添加到RunLoop的时候, 会被RunLoop强引用, timer会对目标对象进行强引用. 这个时候已经出现了循环引用. 这时候我们就不能在 <code>-dealloc</code> 里加 <code>-invalidate</code> 的方法, 因为他们之间相互引用, 永远不会走<code>-dealloc</code>方法. 我们要做的就是打破这个循环.</p>\n<pre><code>__weak typeof(self) weakSelf = self;\nNSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:weakSelf selector:@selector(timerFire) userInfo:nil repeats:YES];\n</code></pre><h2 id=\"非OC对象内存处理\"><a href=\"#非OC对象内存处理\" class=\"headerlink\" title=\"非OC对象内存处理\"></a>非OC对象内存处理</h2><p>对于一些非OC对象, 我们在使用完毕后, 一定要记得手动释放内存, 例如下面常用的调节图片亮度的代码:</p>\n<pre><code>CIImage *beginImage = [[CIImage alloc]initWithImage:[UIImage imageNamed:@&quot;yourname.jpg&quot;]];\nCIFilter *filter = [CIFilter filterWithName:@&quot;CIColorControls&quot;];\n[filter setValue:beginImage forKey:kCIInputImageKey];\n[filter setValue:[NSNumber numberWithFloat:.5] forKey:@&quot;inputBrightness&quot;];//亮度-1~1\nCIImage *outputImage = [filter outputImage];\n//GPU优化\nEAGLContext * eaglContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\neaglContext.multiThreaded = YES;\nCIContext *context = [CIContext contextWithEAGLContext:eaglContext];\n[EAGLContext setCurrentContext:eaglContext];\n\nCGImageRef ref = [context createCGImage:outputImage fromRect:outputImage.extent];\nUIImage *endImg = [UIImage imageWithCGImage:ref];\n_imageView.image = endImg;\nCGImageRelease(ref);//非OC对象需要手动内存释放\n</code></pre><p>其他的对于CoreFoundation框架下的某些对象或变量需要手动释放, C语言代码中的malloc等需要对应free等都需要注意.</p>\n<h2 id=\"地图类处理\"><a href=\"#地图类处理\" class=\"headerlink\" title=\"地图类处理\"></a>地图类处理</h2><p>若项目中使用地图相关类, 一定要检测内存情况, 因为地图是比较耗费App内存的, 因此在根据文档实现某地图相关功能的同时, 我们需要注意内存的正确释放, 大体需要注意的有需在使用完毕时将地图, 代理等滞空为nil, 注意地图中标注(大头针)的复用, 并且在使用完毕时清空标注数组等.</p>\n<h2 id=\"大次数循环内存暴涨问题\"><a href=\"#大次数循环内存暴涨问题\" class=\"headerlink\" title=\"大次数循环内存暴涨问题\"></a>大次数循环内存暴涨问题</h2><p>循环内产生大量的临时对象, 直至循环结束才释放, 可能导致内存泄漏, 解决方法为在循环中创建自己的autoReleasePool, 及时释放占用内存大的临时变量, 减少内存占用峰值.</p>\n<pre><code>for (int i = 0; i &lt; 100000; i++) {\n   @autoreleasepool {\n       NSString *string = @&quot;Abc&quot;;\n       string = [string lowercaseString];\n       string = [string stringByAppendingString:@&quot;xyz&quot;];\n       NSLog(@&quot;%@&quot;, string);\n   }\n}\n</code></pre><hr>\n<p>参考资料:<br>1.<a href=\"https://www.cnblogs.com/mddblog/p/6517377.html\" target=\"_blank\" rel=\"noopener\">NSTimer定时器</a></p>\n<p>2.<a href=\"http://www.cocoachina.com/ios/20150710/12444.html\" target=\"_blank\" rel=\"noopener\">iOS中的NSTimer</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-性能优化","url":"http://hchong.net/2018/04/04/iOS开发总结系列-性能优化/","content":"<p>这里主要记录一下APP开发中, 经常遇到的一些性能问题, 以及优化的建议.</p>\n<h1 id=\"卡顿优化\"><a href=\"#卡顿优化\" class=\"headerlink\" title=\"卡顿优化\"></a>卡顿优化</h1><p>通常来说, 计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的. CPU 计算好显示内容提交到 GPU, GPU 渲染完成后将渲染结果放入帧缓冲区, 随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据, 经过可能的数模转换传递给显示器显示.</p>\n<h2 id=\"CPU主要责任\"><a href=\"#CPU主要责任\" class=\"headerlink\" title=\"CPU主要责任\"></a>CPU主要责任</h2><ul>\n<li>对象创建: 对象的创建会分配内存, 调整属性, 甚至还有读取文件等操作, 比较消耗 CPU 资源. 尽量用轻量的对象代替重量的对象, 可以对性能有所优化, 例如不需要触摸事件时我们可以使用CALayer代替UIView. 尽量推迟对象创建的时间, 并把对象的创建分散到多个任务中去, 如果对象可以复用, 并且复用的代价比释放, 创建新对象要小, 那么这类对象应当尽量放到一个缓存池里复用.</li>\n<li>对象调整: UIView 的关于显示相关的属性(比如 frame/bounds/transform)等实际上都是 CALayer 属性映射来的, 所以对 UIView 的这些属性进行调整时, 消耗的资源要远大于一般的属性. 对此你在应用中, 应该尽量减少不必要的属性修改. 当视图层次调整时, UIView、CALayer 之间会出现很多方法调用与通知, 所以在优化性能时, 应该尽量避免调整视图层次、添加和移除视图.</li>\n<li>对象销毁: 对象的销毁虽然消耗资源不多, 但累积起来也是不容忽视. 如果对象可以放到后台线程去释放, 那就挪到后台线程去. 把对象捕获到 block 中, 然后扔到后台队列去随便发送个消息以避免编译器警告, 就可以让对象在后台线程销毁了.</li>\n<li>布局计算: 不论通过何种技术对视图进行布局, 其最终都会落到对 UIView.frame/bounds/center 等属性的调整上. 上面也说过, 对这些属性的调整非常消耗资源, 所以尽量提前计算好布局, 在需要时一次性调整好对应属性, 而不要多次、频繁的计算和调整这些属性.</li>\n<li>AutoLayout: 苹果本身提倡Autolayout, 但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题. 随着视图数量的增长, Autolayout 带来的 CPU 消耗会呈指数级上升.</li>\n<li>文本计算: 如果一个界面中包含大量文本(比如微博微信朋友圈等), 文本的宽高计算会占用很大一部分资源, 并且不可避免.<br>  可以参考下 UILabel 内部的实现方式: 用 <code>-[NSAttributedString boundingRectWithSize:options:context:]</code> 来计算文本宽高, 用 <code>-[NSAttributedString drawWithRect:options:context:]</code> 来绘制文本. 尽管这两个方法性能不错, 但仍旧需要放到后台线程进行以避免阻塞主线程.<br>  如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象, 然后自己计算了, 并且 CoreText 对象还能保留以供稍后绘制使用.</li>\n<li>文本渲染: 屏幕上能看到的所有文本内容控件, 包括 UIWebView, 在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的. 当显示大量文本时, CPU 的压力会非常大. 我们可以自定义文本控件, 用 TextKit 或最底层的 CoreText 对文本异步绘制.<br>  CoreText 对象创建好后, 能直接获取文本的宽高等信息, 避免了多次计算(调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍);CoreText 对象占用内存较少, 可以缓存下来以备稍后多次渲染.</li>\n<li>图片的解码: 当你用 UIImage 或 CGImageSource 的那几个方法创建图片时, 图片数据并不会立刻解码. 图片设置到 UIImageView 或者 CALayer.contents 中去, 并且 CALayer 被提交到 GPU 前, CGImage 中的数据才会得到解码. 这一步是发生在主线程的, 并且不可避免. 如果想要绕开这个机制, 常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中, 然后从 Bitmap 直接创建图片.</li>\n<li>图像的绘制: 图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中, 然后从画布创建图片并显示这样一个过程. 这个最常见的地方就是 <code>[UIView drawRect:]</code> 里面. 由于 CoreGraphic 方法通常都是线程安全的, 所以图像的绘制可以很容易的放到后台线程进行.</li>\n</ul>\n<h2 id=\"GPU主要责任\"><a href=\"#GPU主要责任\" class=\"headerlink\" title=\"GPU主要责任:\"></a>GPU主要责任:</h2><p>相对于 CPU 来说, GPU 能干的事情比较单一: 接收提交的纹理(Texture)和顶点描述(三角形), 应用变换(transform), 混合并渲染, 然后输出到屏幕上. 通常你所能看到的内容, 主要也就是纹理(图片)和形状(三角模拟的矢量图形)两类.</p>\n<ul>\n<li>纹理的渲染: 所有的 Bitmap, 包括图片、文本、栅格化的内容, 最终都要由内存提交到显存, 绑定为 GPU Texture. 当在较短时间显示大量图片时(比如 TableView 存在非常多的图片并且快速滑动时), CPU 占用率很低, GPU 占用非常高, 界面仍然会掉帧. 所以应该尽量减少在短时间内大量图片的显示, 尽可能将多张图片合成为一张进行显示.<br>  当图片过大, 超过 GPU 的最大纹理尺寸时, 图片需要先由 CPU 进行预处理, 这对 CPU 和 GPU 都会带来额外的资源消耗. 所以纹理尺寸都不应超过上限.</li>\n<li>视图的混合: 当多个视图（或者说 CALayer）重叠在一起显示时, GPU 会首先把他们混合到一起. 如果视图结构过于复杂, 混合的过程也会消耗很多 GPU 资源. 为了减轻这种情况的 GPU 消耗, 应用应当尽量减少视图数量和层次, 并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成. 当然, 这也可以用上面的方法, 把多个视图预先渲染为一张图片来显示.</li>\n<li>图形的生成: CALayer 的 border、圆角、阴影、遮罩(mask), CASharpLayer 的矢量图形显示, 通常会触发离屏渲染. 快速滑动时, 可以观察到 GPU 资源已经占满, 而 CPU 资源消耗很少. 我们可以尝试开启 CALayer.shouldRasterize 属性, 但这会把原本离屏渲染的操作转嫁到 CPU 上去. 对于只需要圆角的某些场合, 也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果. 最彻底的解决办法, 就是把需要显示的图形在后台线程绘制为图片, 避免使用圆角、阴影、遮罩等属性.</li>\n</ul>\n<p>所以, 我们常见的性能优化技巧有以下几种: 预排版, 预渲染, 异步绘制, 全局并发控制, 异步加载图片.</p>\n<h1 id=\"编译优化\"><a href=\"#编译优化\" class=\"headerlink\" title=\"编译优化\"></a>编译优化</h1><h2 id=\"增加XCode执行的线程数\"><a href=\"#增加XCode执行的线程数\" class=\"headerlink\" title=\"增加XCode执行的线程数\"></a>增加XCode执行的线程数</h2><p>XCode默认使用与CPU核数相同的线程来进行编译, 但由于编译过程中的IO操作往往比CPU运算要多, 因此适当的提升线程数可以在一定程度上加快编译速度. 在终端输入<code>defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</code>开启多线程, 更改线程数设置<code>defaults write com.apple.Xcode PBXNumberOfParallelBuildSubtasks 5</code>.</p>\n<h2 id=\"将Debug-Information-Format改为DWARF\"><a href=\"#将Debug-Information-Format改为DWARF\" class=\"headerlink\" title=\"将Debug Information Format改为DWARF\"></a>将Debug Information Format改为DWARF</h2><p>将Target-&gt;Build Settings中, 找到Debug Information Format这一项, 将Debug时的DWARF with dSYM file改为DWARF.</p>\n<p>这一项设置的是是否将调试信息加入到可执行文件中, 改为DWARF后, 如果程序崩溃, 将无法输出崩溃位置对应的函数堆栈, 但由于Debug模式下可以在XCode中查看调试信息, 所以改为DWARF影响并不大. 这一项更改完之后, 可以大幅提升编译速度.<br>将Debug Information Format改为DWARF之后, 会导致在Debug窗口无法查看相关类类型的成员变量的值. 当需要查看这些值时, 可以将Debug Information Format改回DWARF with dSYM file, clean(必须)之后重新编译.</p>\n<h2 id=\"将Build-Active-Architecture-Only改为Yes\"><a href=\"#将Build-Active-Architecture-Only改为Yes\" class=\"headerlink\" title=\"将Build Active Architecture Only改为Yes\"></a>将Build Active Architecture Only改为Yes</h2><p>将Target-&gt;Build Settings中, 找到Build Active Architecture Only这一项, 将Debug时的 NO 改为 YES.</p>\n<p>需要注意的是, 此选项在Release模式下必须为NO, 否则发布的ipa在部分设备上将不能运行. 这一项更改完之后, 可以显著提高编译速度.</p>\n<h2 id=\"设计编译优化等级\"><a href=\"#设计编译优化等级\" class=\"headerlink\" title=\"设计编译优化等级\"></a>设计编译优化等级</h2><p>不要再项目中或者静态库中使用-O4, 因为这会让Clang链接Link Time Optimizations (LTO)使得编译更慢, 通常使用-O3. 在设置编译优化之后, XCode断点和调试信息会不正常, 所以一般静态库或者其他Target这样设置.</p>\n<h2 id=\"将常用的代码及文件打包成静态库\"><a href=\"#将常用的代码及文件打包成静态库\" class=\"headerlink\" title=\"将常用的代码及文件打包成静态库\"></a>将常用的代码及文件打包成静态库</h2><p>我们用Cocoapods来管理第三方包, 我们可以将第三方包打包成静态库, 也可以提升编译速度. 也可以将第三方包打包成二进制文件, 但是这样不方便调试.</p>\n<h2 id=\"添加预编译文件\"><a href=\"#添加预编译文件\" class=\"headerlink\" title=\"添加预编译文件\"></a>添加预编译文件</h2><p>使用.pch文件, 把常用的头文件放到预编译文件里面.</p>\n<h1 id=\"启动优化\"><a href=\"#启动优化\" class=\"headerlink\" title=\"启动优化\"></a>启动优化</h1><p>App总启动时间 = t1(main()之前的加载时间) + t2(main()之后的加载时间).<br>t1 = 系统dylib(动态链接库)和自身App可执行文件的加载;<br>t2 = main方法执行之后到AppDelegate类中的<code>- (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法执行结束前这段时间, 主要是构建第一个界面, 并完成渲染展示.</p>\n<h2 id=\"main-调用之前的加载过程\"><a href=\"#main-调用之前的加载过程\" class=\"headerlink\" title=\"main()调用之前的加载过程\"></a>main()调用之前的加载过程</h2><ol>\n<li>系统首先加载可执行文件. 自身App的所有.o文件的集合.</li>\n<li>加载动态链接库dyld, dyld是一个专门用来加载动态链接库的库.</li>\n<li>dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库. 动态链接库包括: iOS 中用到的所有系统 framework, 加载OC runtime方法的libobjc, 系统级别的libSystem, 例如libdispatch(GCD)和libsystem_blocks (Block).</li>\n</ol>\n<p>所以对于main()调用之前的耗时我们可以优化的点如下:</p>\n<ol>\n<li>减少不必要的framework, 因为动态链接比较耗时.</li>\n<li>check framework应当设为optional和required, 如果该framework在当前App支持的所有iOS系统版本都存在, 那么就设为required, 否则就设为optional, 因为optional会有些额外的检查.</li>\n<li>合并或者删减一些OC类, 关于清理项目中没用到的类.</li>\n<li>删减一些无用的静态变量.</li>\n<li>删减没有被调用到或者已经废弃的方法.</li>\n<li>将不必须在+load方法中做的事情延迟到+initialize中.</li>\n<li>尽量不要用C++虚函数(创建虚函数表有开销), C++静态对象.</li>\n</ol>\n<h2 id=\"main-调用之后的加载过程\"><a href=\"#main-调用之后的加载过程\" class=\"headerlink\" title=\"main()调用之后的加载过程\"></a>main()调用之后的加载过程</h2><p>在main()被调用之后, App的主要工作就是初始化必要的服务, 显示首页内容. 所以主要耗时操作在执行main()函数的耗时, 执行applicationWillFinishLaunching的耗时, rootViewController及其childViewController的加载、view及其subviews的加载.</p>\n<h1 id=\"瘦身优化\"><a href=\"#瘦身优化\" class=\"headerlink\" title=\"瘦身优化\"></a>瘦身优化</h1><h2 id=\"资源瘦身\"><a href=\"#资源瘦身\" class=\"headerlink\" title=\"资源瘦身\"></a>资源瘦身</h2><p>资源瘦身主要是去掉无用资源和压缩资源, 资源包括图片, 音视频文件, 配置文件以及多语言wording. 资源压缩主要对png进行无损压缩.</p>\n<h2 id=\"编译选项优化\"><a href=\"#编译选项优化\" class=\"headerlink\" title=\"编译选项优化\"></a>编译选项优化</h2><ul>\n<li>Optimization Level 使用Fastest, Smalllest. 该选项对安装包大小影响几无，但可以提高app的性能</li>\n<li>Strip Linked Product 设置为YES, 需要注意的是Strip Linked Product也受到Deployment Postprocessing设置选项的影响. 在Build Settings中, 我们可以看到， Strip Linked Product是在Deployment这栏中的, 而Deployment Postprocessing相当于是Deployment的总开关. 记得把Deployment Postprocessing也设置为YES.</li>\n<li>Symbols Hidden by Default设置为YES</li>\n<li>Make Strings Read-Only 设置为YES</li>\n</ul>\n<h2 id=\"二进制安装包\"><a href=\"#二进制安装包\" class=\"headerlink\" title=\"二进制安装包\"></a>二进制安装包</h2><p>二进制包是由各种代码文件, 静态库 动态库 经过编译后生成的可执行文件.</p>\n<ul>\n<li>XCode开启编译选项Write Link Map File XCode -&gt; target -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为yes, 并指定好linkMap的存储位置.</li>\n<li>编译后到编译目录里找到该txt文件, 文件名和路径就是上述的Path to Link Map File.<br>~/Library/Developer/Xcode/DerivedData/XXX-eumsvrzbvgfofvbfsoqokmjprvuh/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/. 这个LinkMap里展示了整个可执行文件的全貌, 列出了编译后的每一个.o目标文件的信息(包括静态链接库.a里的), 以及每一个目标文件的代码段, 数据段存储详情.</li>\n<li>到<a href=\"https://github.com/huanxsd/LinkMap\" target=\"_blank\" rel=\"noopener\">https://github.com/huanxsd/LinkMap</a>下载这个mac工程, 然后运行, 对文件进行分析.</li>\n<li>通过对上面的文件进行分析, 就知道每个类在最终的可执行文件中占据的大小. 然后有针对性的进行优化就可以了.</li>\n</ul>\n<h2 id=\"删除一些无用文件\"><a href=\"#删除一些无用文件\" class=\"headerlink\" title=\"删除一些无用文件\"></a>删除一些无用文件</h2><p>查找无用selector, 无用OC类, 扫描重复代码.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">iOS 保持界面流畅的技巧</a></p>\n<p>2.<a href=\"https://techblog.toutiao.com/2017/01/17/iosspeed/#more\" target=\"_blank\" rel=\"noopener\">今日头条iOS客户端启动速度优化</a></p>\n<p>3.<a href=\"https://github.com/skyming/iOS-Performance-Optimization\" target=\"_blank\" rel=\"noopener\">iOS-Performance-Optimization</a></p>\n<p>4.<a href=\"https://juejin.im/entry/5d61559e5188253cf525cc2c\" target=\"_blank\" rel=\"noopener\">Archive、ipa 和 App 包瘦身</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-生命周期","url":"http://hchong.net/2018/03/30/iOS开发总结系列-生命周期/","content":"<p>这里主要总结一下iOS开发中一些声明周期相关的知识</p>\n<h1 id=\"1-UIView的生命周期\"><a href=\"#1-UIView的生命周期\" class=\"headerlink\" title=\"1 UIView的生命周期\"></a>1 UIView的生命周期</h1><p>当创建View的时: </p>\n<ol>\n<li><code>initWithFrame:</code>, initWithFrame进行初始化时, 当rect的值不为CGRectZero时会触发layoutSubviews. init初始化不会触发layoutSubviews.</li>\n<li><code>willMoveToSuperview:</code></li>\n<li><code>didMoveToSuperview</code></li>\n<li><code>willMoveToWindow:</code></li>\n<li><code>didMoveToWindow</code></li>\n<li><code>layoutSubviews</code>, 在子视图布局变动时会多次调用.</li>\n</ol>\n<p>当View销毁时:</p>\n<ol>\n<li><code>willMoveToWindow:</code></li>\n<li><code>didMoveToWindow</code></li>\n<li><code>willMoveToSuperview:</code></li>\n<li><code></code>didMoveToSuperview`</li>\n<li><code>removeFromSuperview</code></li>\n<li><code>dealloc</code></li>\n</ol>\n<p>如果View中有子View的话, 创建时除了上面的顺序之外, 还会调用:</p>\n<ol>\n<li><code>layoutSubviews</code>, 这是因为子视图的布局变动, 所以会触发.</li>\n<li><code>didAddSubview:</code></li>\n<li><code>drawRect:</code>.</li>\n</ol>\n<p>移除时, 除了上面的顺序之外, 还会调用:</p>\n<ol>\n<li><code>willRemoveSubview:</code>, 是在dealloc后面执行的. 如果有多个子视图, willRemoveSubview会循环执行, 直到移除所有子视图.</li>\n</ol>\n<h1 id=\"2-UIViewController声明周期\"><a href=\"#2-UIViewController声明周期\" class=\"headerlink\" title=\"2 UIViewController声明周期\"></a>2 UIViewController声明周期</h1><ol>\n<li><code>initWithCoder: 或 initWithNibName:bundle:</code>, 首先从归档文件中加载UIViewController对象. 非StoryBoard创建调用<code>initWithNibName:bundle:</code>, 如果使用StoryBoard进行视图管理, 从nib中加载对象实例时, 程序不会直接初始化一个UIViewController, StoryBoard会自动初始化或在segue被触发时自动初始化<code>initWithCoder:</code>.</li>\n<li><code>awakeFromNib</code>, 从xib或者storyboard加载完毕就会调用.</li>\n<li><code>loadView</code>, 每次访问UIViewController的view(比如controller.view, self.view)而且view为nil, loadView方法就会被调用. loadView方法是用来负责创建UIViewController的view. 如果在初始化UIViewController指定了xib文件名, 就会根据传入的xib文件名加载对应的xib文件, 如果没有明显地传xib文件名, 就会加载跟UIViewController同名的xib文件. 如果没有找到相关联的xib文件, 就会创建一个空白的UIView, 然后赋值给UIViewController的view属性. 苹果设计这个方法就是给我们自定义UIViewController的view用的, 我们直接在该方法中指定UIViewController的View.</li>\n<li><code>viewDidLoad</code>, 无论你是通过xib文件还是重写loadView方法创建UIViewController的view, 在view创建完毕后, 最终都会调用viewDidLoad方法. 在这里视图层次已经加载到内存中. 通常, 我们对于各种初始化数据的载入, 初始设定, 修改约束, 移除视图等很多操作都可以这个方法中实现.</li>\n<li><code>viewWillAppear:</code>, 系统在载入所有的数据后, 将会在屏幕上显示视图, 这时会先调用这个方法, 通常我们会在这个方法对即将显示的视图做进一步的设置.</li>\n<li><code>viewWillLayoutSubviews</code>, view 即将布局其Subviews. 比如view的bounds改变了(例如:状态栏从不显示到显示,视图方向变化), 要调整Subviews的位置, 在调整之前要做的工作可以放在该方法中实现.</li>\n<li><code>viewDidLayoutSubviews</code>, view已经布局其Subviews, 这里可以放置调整完成之后需要做的工作.</li>\n<li><code>viewDidAppear:</code>, 在view被添加到视图层级中以及多视图上下级视图切换时调用这个方法, 可以对正在显示的视图做进一步的设置.</li>\n<li><code>viewWillDisappear:</code>, 当前视图在即将被移除, 或被覆盖时, 会调用该方法. 此时还没有调用removeFromSuperview.</li>\n<li><code>viewDidDisappear:</code>, view已经消失或被覆盖,视图已经被从屏幕上移除, 用户看不到这个视图了, 此时已经调用removeFromSuperView.</li>\n<li><code>viewWillUnload</code>, 如果当前有能被释放的view，系统会调用viewWillUnload方法来释放view</li>\n<li><code>dealloc</code>, UIViewController被销毁时调用, 此次需要对你在init和viewDidLoad中创建的对象进行释放.</li>\n<li><code>didReceiveMemoryWarning</code>, 内存不够时, 系统会自动调用这个方法. 默认实现是如果当前UIViewController的view不在应用程序的视图层次结构(View Hierarchy)中, 即view的superview为nil的时候, 就会将view释放, 并且调用viewDidUnload方法.</li>\n<li><code>viewDidUnload</code>, 收到内存警告时, 如果当前UIViewController的View的superView为nil时, 就会将View释放, 并且调用viewDidUnload. 从 iOS 6 开始, viewDidUnload 方法被废弃掉了</li>\n</ol>\n<h2 id=\"2-1-push-pop\"><a href=\"#2-1-push-pop\" class=\"headerlink\" title=\"2.1 push pop\"></a>2.1 push pop</h2><p>假设现在有一个 AViewController(简称 Avc) 和 BViewController (简称 Bvc)，通过 navigationController 的 push 实现 Avc 到 Bvc 的跳转，下面是各个方法的执行执行顺序：</p>\n<ol>\n<li>A loadView</li>\n<li>A viewDidLoad</li>\n<li>A viewWillAppear</li>\n<li>A viewWillLayoutSubviews</li>\n<li>A viewDidLayoutSubviews</li>\n<li>A viewDidAppear</li>\n<li>B loadView(开始跳转)</li>\n<li>B viewDidLoad</li>\n<li>A viewWillDisappear</li>\n<li>B viewWillAppear</li>\n<li>B viewWillLayoutSubviews</li>\n<li>B viewDidLayoutSubviews</li>\n<li>A viewDidDisappear</li>\n<li>B viewDidAppear</li>\n</ol>\n<p>如果再从 Bvc pop到 Avc，会产生下面的执行顺序：</p>\n<ol>\n<li>B viewWillDisappear  </li>\n<li>A viewWillAppear  </li>\n<li>B viewDidDisappear  </li>\n<li>A viewDidAppear</li>\n</ol>\n<h2 id=\"2-2-present-dismiss\"><a href=\"#2-2-present-dismiss\" class=\"headerlink\" title=\"2.2 present dismiss\"></a>2.2 present dismiss</h2><p>假设现在有一个 AViewController(简称 Avc) 和 BViewController (简称 Bvc)，通过 present 实现 Avc 到 Bvc 的跳转，下面是各个方法的执行执行顺序：</p>\n<ol>\n<li>A loadView</li>\n<li>A viewDidLoad</li>\n<li>A viewWillAppear</li>\n<li>A viewWillLayoutSubviews</li>\n<li>A viewDidLayoutSubviews</li>\n<li>A viewDidAppear</li>\n<li>B loadView(开始跳转)</li>\n<li>B viewDidLoad</li>\n<li>A viewWillDisappear</li>\n<li>B viewWillAppear</li>\n<li>B viewWillLayoutSubviews</li>\n<li>B viewDidLayoutSubviews</li>\n<li>B viewDidAppear</li>\n<li>A viewDidDisappear </li>\n</ol>\n<p>如果再从 Bvc dismiss Avc，会产生下面的执行顺序：</p>\n<ol>\n<li>B viewWillDisappear</li>\n<li>A viewWillAppear</li>\n<li>A viewDidAppear</li>\n<li>B viewDidDisappear</li>\n</ol>\n<p>总结:<br>加载的顺序是一样的, push和present的不同点:</p>\n<ul>\n<li>push时总是A先消失, B后出现. pop时总是B先消失, A再出现.</li>\n<li>present时总是B先出现, A再消失. dismiss时总是A先出现, B再消失.</li>\n</ul>\n<h1 id=\"3-AppDelegate生命周期\"><a href=\"#3-AppDelegate生命周期\" class=\"headerlink\" title=\"3 AppDelegate生命周期\"></a>3 AppDelegate生命周期</h1><ol>\n<li>进入main函数, 设置AppDelegate称为函数的代理.</li>\n<li>程序加载完成, -[AppDelegate application:didFinishLaunchingWithOptions:].</li>\n<li>创建window窗口</li>\n<li><code>applicationWillResignActive:</code>, 将进入后台. 当应用程序从活动状态(active)变到非活动状态(inactive)时被触发调用, 这可能发生在一些临时中断下(例如: 来电话, 来短信)又或者程序退出时, 他会先过渡到后台. 然后使用这方法去暂停正在进行的任务, 禁用计时器, 节流OpenGL ES 帧率. 在游戏中应该在这个方法里面暂停游戏.</li>\n<li><code>applicationDidEnterBackground:</code>, 已经进入后台. 使用这种方法来释放共享资源, 保存用户数据, 无效计时器, 存储足够多的应用程序状态信息来恢复您的应用程序的当前状态, 以防它终止丢失数据. 如果你的程序支持后台运行, 那么当用户退出时不会调用.</li>\n<li><code>applicationWillEnterForeground</code>, 将进入前台. 先从后台切换到非活动状态, 然后进入活动状态.</li>\n<li><code>applicationDidBecomeActive</code>, 已经进入前台. 重启所有的任务, 不管是从非活动状态还是刚启动程序, 还是后台状态.</li>\n<li><code>applicationWillTerminate</code>, 程序即将退出. 当应用将要终止时, 调用这个方法, 在这里我们可以做一些数据的保存.</li>\n</ol>\n<h1 id=\"4-APP启动生命周期\"><a href=\"#4-APP启动生命周期\" class=\"headerlink\" title=\"4 APP启动生命周期\"></a>4 APP启动生命周期</h1><ol>\n<li>系统先读取APP的可执行文件(Mach-O)文件, 从里面获取dyld的路径, 然后加载dyld, dyld去初始化运行环境. </li>\n<li>开启缓存策略, 加载程序相关依赖库(其中也包含我们的可执行文件)到内存中, 调用每个依赖库的初始化方法, 动态链接依赖库. 在这一步Runtime会被初始化.</li>\n<li>当所有依赖库的初始化后, 轮到最后一位(程序可执行文件)进行初始化, 在这时runtime会对项目中所有类进行类结构初始化, 然后调用所有的load方法.</li>\n<li>最后dyld返回main函数地址, main函数被调用, 我们就进入了程序的入口.</li>\n</ol>\n<p>Mach-O文件格式是 OS X 与 iOS 系统上的可执行文件格式, 像我们编译过程产生的.O文件, 以及程序的可执行文件, 动态库等都是Mach-O文件. 有如下几个部分组成:</p>\n<ul>\n<li>Header: 保存了一些基本信息, 包括了该文件运行的平台, 文件类型, LoadCommands的个数等等.</li>\n<li>LoadCommands: 可以理解为加载命令, 在加载Mach-O文件时会使用这里的数据来确定内存的分布以及相关的加载命令. 比如我们的main函数的加载地址, 程序所需的dyld的文件路径, 以及相关依赖库的文件路径.</li>\n<li>Data: 这里包含了具体的代码, 数据等等.</li>\n</ul>\n<p>dyld: (the dynamic link editor)动态链接器, 系统 kernel 做好启动程序的初始准备后，交给 dyld 负责.<br>ImageLoader: ImageLoader 作用是将这些文件加载进内存, 且每一个文件对应一个ImageLoader实例来负责加载. 在程序运行时它先将动态链接的 image(二进制文件) 递归加载,<br>再从可执行文件 image 递归加载所有符号.</p>\n<p>dyld 担当了 runtime 和 ImageLoader 中间的协调者, 当新 image 加载进来后交由 runtime 去解析这个二进制文件的符号表和代码.<br>整个调用栈顺序是这样的:</p>\n<ol>\n<li>dyld 开始将程序二进制文件初始化.</li>\n<li>交由 ImageLoader 读取 image, 其中包含了我们的类, 方法等各种符号.</li>\n<li>由于 runtime 向 dyld 绑定了回调, 当 image 加载到内存后, dyld 会通知 runtime 进行处理.</li>\n<li>runtime 接手后调用 map_images 做解析和处理. 接下来 load_images 中调用 call_load_methods 方法, 遍历所有加载进来的 Class, 按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法.</li>\n<li>至此, 可执行文件中和动态库所有的符号 (Class, Protocol, Selector, IMP, …) 都已经按格式成功加载到内存中, 被 runtime 所管理, 再这之后, runtime 的那些方法（动态添加 Class, swizzle 等等才能生效.</li>\n</ol>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-语言设计","url":"http://hchong.net/2018/03/27/iOS开发总结系列-语言设计/","content":"<p>这里主要是一些语言设计方面的常见问题.</p>\n<h2 id=\"NSString如何计算字符的个数\"><a href=\"#NSString如何计算字符的个数\" class=\"headerlink\" title=\"NSString如何计算字符的个数\"></a>NSString如何计算字符的个数</h2><p>首先我们要知道字符串末尾会自动加上一个<code>\\0</code>, 因此我们可以设计这么一个函数: </p>\n<pre><code>int string_length(char *s) {\n    int c = 0;\n    while (*s[c] != `\\0`){\n        c++:\n    }\n    return c;\n}\n</code></pre><p>通过指针偏移量来获取每个元素, 同<code>\\0</code>比较, 相等时的指针偏移量就是字符串元素的个数.</p>\n<h2 id=\"NSUserDefaults性能优化\"><a href=\"#NSUserDefaults性能优化\" class=\"headerlink\" title=\"NSUserDefaults性能优化\"></a>NSUserDefaults性能优化</h2><p>当使用NSUserDefaults写入文件后, 值会被存放到Library/Preferences/com.xxx.AppName.plist文件里(com.xxx.AppName是应用的标识符). 这个文件是个plist文件, 因此, 它可以存放plist可以存放的数据类型: NSData, NSString, NSNumber, NSDate, NSArray, 或者NSDictionary.<br>它是针对每个应用适用的, 只作用于自身应用内. sandbox的安全机制保证, 它不能修改其他应用的值, 也不会被其他应用修改.</p>\n<p>NSUserDefaults是个单例, 而且它访问的文件也只有一个, NSUserDefaults帮我们做了一层优化. NSUserDefaults是带缓存的, NSUserDefaults会把访问到的key缓存到内存里, 下次再访问时, 如果内存中命中就直接访问, 如果未命中再从文件中载入. 应用会时不时调用[defaults synchronize]方法来保证内存与文件中的数据的一致性, 有时在写入一个值后也最好调用下这个方法来保证数据真正写入文件.</p>\n<p>我们不能在一个地方大规模写入NSUserDefaults, 性能会有很大影响. 用plist文件读入内存在访问的瓶颈主要在读入的过程中, 如果文件很大会比较耗时, 但是一旦载好, 在内存中读取就很快; 但是, 对内存值的写入则会造成内存与文件数据不一致, 这时为了保证数据一致性就要写入文件, 写入后又要读入内存, 这就导致延迟.</p>\n<p>NSUserDefaults对象发valueForKey:消息, 返回的数据永远是不可变类型的.</p>\n<h2 id=\"数据库为什么要创建索引\"><a href=\"#数据库为什么要创建索引\" class=\"headerlink\" title=\"数据库为什么要创建索引\"></a>数据库为什么要创建索引</h2><p>创建索引的优点:</p>\n<ol>\n<li>通过创建唯一性索引, 可以保证数据库表中每一行数据的唯一性</li>\n<li>可以加快数据的检索速度</li>\n<li>可以加速表与表之间的链接</li>\n<li>可以显著减少查询中分组和排序的时间</li>\n<li>使用索引在查询过程中使用优化隐藏器, 提高系统性能</li>\n</ol>\n<p>创建索引的缺点:</p>\n<ol>\n<li>创建索引和维护索引要耗费时间, 这种时间随着数据量增加而增加</li>\n<li>创建索引需要占用物理空间</li>\n<li>对表的数据增删改查时, 索引也要动态的维护</li>\n</ol>\n<p>因此我们经常在主键列, 常用在连接的列, 经常根据范围搜索的列, 经常排序的列, 经常使用在WHERE子句中的列上面创建索引.<br>而那些在查询中很少用的列, 数据值很少的列, text, image和bit数据类型的列(因为要么数据量大要么取值少), 修改性能远远大于检索性能时不应该创建索引.</p>\n<h2 id=\"Full-Text-Search为什么快\"><a href=\"#Full-Text-Search为什么快\" class=\"headerlink\" title=\"Full Text Search为什么快\"></a>Full Text Search为什么快</h2><p>它的工作原理是计算机索引程序通过扫描文章中的每一个词, 对每一个词建立一个索引, 指明该词在文章中出现的次数和位置, 当用户查询时, 检索程序就根据事先建立的索引进行查找, 并将查找的结果反馈给用户的检索方式.</p>\n<p>分为按字检索和按词检索: 按字检索是指对于文章中的每一个字都建立索引, 检索时将词分解为字的组合. 按词检索是指对文章中的词, 即语义单位建立索引, 检索时按词检索.</p>\n<h2 id=\"imageNamed-与imageWithContentsOfFile-对比\"><a href=\"#imageNamed-与imageWithContentsOfFile-对比\" class=\"headerlink\" title=\"imageNamed:与imageWithContentsOfFile:对比\"></a>imageNamed:与imageWithContentsOfFile:对比</h2><p>使用imageNamed这个方法生成的UIImage对象, 会在应用的main bundle中寻找图片, 如果找到则Cache到系统缓存中, 作为内存的cache, 而程序员是无法操作cache的, 只能由系统自动处理, 如果我们需要重复加载一张图片, 那这无疑是一种很好的方式, 因为系统能很快的从内存的cache找到这张图片. 但是试想, 如果加载很多很大的图片的时候, 内存消耗过大的时候, 就会会强制释放内存, 即会遇到内存警告(memory warnings). 由于在iOS系统中释放图片的内存比较麻烦, 所以冲易产生内存泄露.<br>经常使用在图片资源反复使用到, 而且占用内存少的场景下.</p>\n<p>相比上面的imageNamed这个方法要写的代码多了几行, 使用imageWithContentsOfFile的方式加载的图片, 图片会被系统以数据的方式进行加载. 返回的对象不会保存在缓存中, 一旦对象销毁就会释放内存, 所以一般不会因为加载图片的方法遇到内存问题.<br>经常使用在图片资源较大, 加载到内存后, 比较耗费内存资源, 图片一般只使用一次的场景下.</p>\n<h2 id=\"Image的加载以及内存计算\"><a href=\"#Image的加载以及内存计算\" class=\"headerlink\" title=\"Image的加载以及内存计算\"></a>Image的加载以及内存计算</h2><p>iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤: </p>\n<ol>\n<li>从磁盘拷贝数据到内核缓冲区.</li>\n<li>从内核缓冲区复制数据到用户空间.</li>\n<li>生成UIImageView, 把图像数据赋值给UIImageView.</li>\n<li>如果图像数据为未解码的PNG/JPG, 解码为位图数据.</li>\n<li>CATransaction捕获到UIImageView layer树的变化.</li>\n<li>主线程Runloop提交CATransaction, 开始进行图像渲染.<ul>\n<li>分配内存缓冲区用于管理文件 IO 和解压缩操作</li>\n<li>将文件数据从磁盘读到内存中</li>\n<li>将压缩的图片数据解码成未压缩的位图形式, 这是一个非常耗时的 CPU 操作.</li>\n<li>如果数据没有字节对齐, Core Animation会再拷贝一份数据, 进行字节对齐.</li>\n<li>GPU处理位图数据, 进行渲染.</li>\n</ul>\n</li>\n</ol>\n<p>位图就是一个像素数组, 数组中的每个像素就代表着图片中的一个点. 我们在应用中经常用到的 JPEG 和 PNG 图片就是位图.</p>\n<p>不管是 JPEG 还是 PNG 图片, 都是一种压缩的位图图形格式. 只不过 PNG 图片是无损压缩, 并且支持 alpha 通道, 而 JPEG 图片则是有损压缩. 因此, 在将磁盘中的图片渲染到屏幕之前, 必须先要得到图片的原始像素数据, 才能执行后续的绘制操作, 这就是为什么需要对图片解压缩的原因.</p>\n<p>解压缩后的图片大小 = 图片的像素宽 <em> 图片的像素高 </em> 每个像素所占的字节数. 因为位图不用解压缩, 所以位图的内存大小就是图片的实际大小. 非位图的图片要解压缩, 所以非位图的图片在内存中的大小就是上面的公式.</p>\n<p>强制解压缩的原理就是对图片进行重新绘制, 得到一张新的解压缩后的位图. 其中, 用到的最核心的函数是 <code>CGBitmapContextCreate:</code>.</p>\n<h2 id=\"isEqual与hash\"><a href=\"#isEqual与hash\" class=\"headerlink\" title=\"==, isEqual与hash\"></a>==, isEqual与hash</h2><ul>\n<li>对于基本类型, ==运算符比较的是值; 对于对象类型, ==运算符比较的是对象的地址(即是否为同一对象)</li>\n<li>常见类型的isEqual方法还有NSString isEqualToString / NSDate isEqualToDate / NSArray isEqualToArray / NSDictionary isEqualToDictionary / NSSet isEqualToSet. isEqual比较对象值是否相等, 如果是自定义对象, 那么对象所有的属性也要像等.</li>\n<li><p>hash 值决定了该对象在 hash 表中存储的位置. hash值是对象判等的必要非充分条件, 集成成员的hash值和目标hash值相等, 并且进行对象判等为true, 则hash返回true.</p>\n<ul>\n<li>作为判等的结果 hash方法只在对象被添加至NSSet和设置为NSDictionary的key时会调用. </li>\n<li>基于hash值索引的Hash Table查找某个成员的过程就是: 通过hash值直接找到查找目标的位置, 如果目标位置上有多个相同hash值得成员, 此时再按照数组方式进行查找.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"NSDictionary-内部结构、实现原理\"><a href=\"#NSDictionary-内部结构、实现原理\" class=\"headerlink\" title=\"NSDictionary 内部结构、实现原理\"></a>NSDictionary 内部结构、实现原理</h2><p>NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的, hash函数设计的好坏影响着数据的查找访问效率.</p>\n<p>Objective-C 中的字典 NSDictionary 底层其实是一个哈希表, 实际上绝大多数语言中字典都通过哈希表实现. 哈希表的本质是一个数组, 数组中每一个元素称为一个箱子(bin), 箱子中存放的是键值对.</p>\n<ol>\n<li>根据 key 计算出它的哈希值 h.</li>\n<li>假设箱子的个数为 n, 那么这个键值对应该放在第 (h % n) 个箱子中.</li>\n<li>如果该箱子中已经有了键值对, 那么就会有冲突, 如何解决冲突:<ul>\n<li>开放寻址法. </li>\n<li>链地址法. 每个箱子其实是一个链表, 属于同一个箱子的所有键值对都会排列在链表中</li>\n<li>再哈希法. 当发生冲突时, 使用第二个, 第三个, 哈希函数计算地址, 直到无冲突. 缺点: 计算时间增加. 比如对字符串首字母进行哈希, 如果产生冲突可以按照字符串字母第二位进行哈希, 再冲突, 第三位, 直到不冲突为止.</li>\n<li>建立一个公共溢出区. 假设哈希函数的值域为[0,m-1], 则设向量HashTable[0..m-1]为基本表, 另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录.</li>\n</ul>\n</li>\n</ol>\n<p>负载因子(load factor), 它用来衡量哈希表的 空/满 程度, 一定程度上也可以体现查询的效率, 计算公式为: <code>负载因子 = 总键值对数 / 箱子个数</code>. 负载因子越大, 意味着哈希表越满, 越容易导致冲突, 性能也就越低. 因此, 一般来说, 当负载因子大于某个常数(可能是 1, 或者 0.75 等)时, 哈希表将自动扩容.<br>哈希表在自动扩容时, 一般会创建两倍于原来个数的箱子, 因此即使 key 的哈希值不变, 对箱子个数取余的结果也会发生改变, 因此所有键值对的存放位置都有可能发生改变, 这个过程也称为重哈希(rehash).</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"获取设备唯一标识符","url":"http://hchong.net/2018/03/27/获取设备唯一标识符/","content":"<p>获取设备的唯一标识符具体可以分为如下几种：UDID MAC IDFA IDFV UUID. 下面分别来介绍下.</p>\n<h2 id=\"UDID-Unique-Device-Identifier-Description\"><a href=\"#UDID-Unique-Device-Identifier-Description\" class=\"headerlink\" title=\"UDID (Unique Device Identifier Description)\"></a>UDID (Unique Device Identifier Description)</h2><p>UDID 是由子母和数字组成的40个字符串的序号, 用来区别每一个唯一的iOS设备, 这些编码看起来是随机的, 但实际上是跟硬件设备特点相关联的. 我们平时用开发者账号在设备上安装测试应用时, 往开发者账号上添加的就是设备的UDID.</p>\n<pre><code>NSString *UDID = [[UIDevice currentDevice] uniqueIdentifier];\n</code></pre><p>由于UDID是跟设备唯一对应的, 许多开发者试图通过UDID获取到用户的真实姓名, 密码, 地址等隐私数据. 为了避免引起麻烦, 苹果在iOS 5.0 的时候废除了UDID的代码获取权限, 现在应用试图获取UDID已被禁止且不允许上架.</p>\n<h2 id=\"MAC-Medium-Media-Access-Control\"><a href=\"#MAC-Medium-Media-Access-Control\" class=\"headerlink\" title=\"MAC (Medium/Media Access Control)\"></a>MAC (Medium/Media Access Control)</h2><p>这个就是常说的网卡地址, 一部iPhone上可能有多个MAC地址, 包括WIFI的, SIM的等. 具有全球唯一性, 这样就可以非常好的标识设备唯一性.</p>\n<pre><code>- (NSString *) getMacAddress {  \n        int mib[6];  \n        size_t len;  \n        charchar *buf;  \n        unsigned charchar *ptr;  \n        struct if_msghdr *ifm;  \n        struct sockaddr_dl *sdl;  \n\n        mib[0] = CTL_NET;  \n        mib[1] = AF_ROUTE;  \n        mib[2] = 0;  \n        mib[3] = AF_LINK;  \n        mib[4] = NET_RT_IFLIST;  \n\n        if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) {  \n            printf(&quot;Error: if_nametoindex error/n&quot;);  \n            return NULL;  \n        }  \n\n        if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) {  \n            printf(&quot;Error: sysctl, take 1/n&quot;);  \n            return NULL;  \n        }  \n\n        if ((buf = malloc(len)) == NULL) {  \n            printf(&quot;Could not allocate memory. error!/n&quot;);  \n            return NULL;  \n        }  \n\n        if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) {  \n            printf(&quot;Error: sysctl, take 2&quot;);  \n            return NULL;  \n        }  \n\n        ifm = (struct if_msghdr *)buf;  \n        sdl = (struct sockaddr_dl *)(ifm + 1);  \n        ptr = (unsigned charchar *)LLADDR(sdl);  \n        NSString *outstring = [NSString stringWithFormat:@&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];  \n        free(buf);  \n\n        return [outstring uppercaseString]; \n    }\n</code></pre><p>但MAC地址跟UDID一样, 存在隐私问题, 所以在 iOS 7.0 之后, Mac地址再次遭到苹果的无情封杀. 如果使用之前的方法请求Mac地址都会返回一个固定值 02:00:00:00:00:00, 这一条路再次被堵死.</p>\n<h2 id=\"IDFA-Identifier-For-Identifier\"><a href=\"#IDFA-Identifier-For-Identifier\" class=\"headerlink\" title=\"IDFA (Identifier For Identifier)\"></a>IDFA (Identifier For Identifier)</h2><p>这是 iOS 6.0中提供的一个新方法, 在同一个设备上的所有App都会取到相同的值, 是苹果专门给各广告提供商用来追踪用户而设的. </p>\n<pre><code>#import &lt;AdSupport/AdSupport.h&gt;\n\nNSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];\n</code></pre><p>IDFA并不是唯一不变的, 如果用户完全重置系统(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私), 这个广告标示符会重新生成. 另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符), 那么广告标示符也会重新生成. 在iOS 10.0以后如果用户打开限制广告跟踪(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 限制广告跟踪), 则获取到的IDFA为一个固定值00000000-0000-0000-0000-000000000000. 因此, 通过IDFA也无法唯一标识一个设备.<br>如果使用IDFA, 在上传Appstore时必须在iTunes Connect中的上传页面进行相应的设置.</p>\n<h2 id=\"IDFV（Identifier-For-Vendor）\"><a href=\"#IDFV（Identifier-For-Vendor）\" class=\"headerlink\" title=\"IDFV（Identifier For Vendor）\"></a>IDFV（Identifier For Vendor）</h2><p>IDFV是给Vendor标识用户用的, 每个设备在所属同一个Vendor的应用里, 都有相同的值. 其中的Vendor是指应用提供商, 准确的说, 是通过BundleID的反转的前两部分进行匹配, 如果相同就是同一个Vendor, 例如对于com.abc.app1, com.abc.app2 这两个BundleID来说, 就属于同一个Vendor, 共享同一个IDFV的值. 当然, 对于同一个设备不同Vendor的话, 获取到的值是不同的. 和IDFA不同的是, IDFV的值是一定能取到的. 它是iOS 6中新增的.</p>\n<pre><code>NSString *strIDFV = [[[UIDevice currentDevice] identifierForVendor] UUIDString];\n</code></pre><p>但是使用IDFV也会存在一些问题, 如果用户将属于此Vendor的所有App卸载, 则IDFV的值会被重置, 即再重装此Vendor的App, IDFV的值也会和之前的不同.</p>\n<h2 id=\"UUID-Universally-Unique-Identifier\"><a href=\"#UUID-Universally-Unique-Identifier\" class=\"headerlink\" title=\"UUID (Universally Unique Identifier)\"></a>UUID (Universally Unique Identifier)</h2><p>UUID是Universally Unique Identifier的缩写, 中文意思是通用唯一识别码. 它是苹果提供的一个获取大随机数的方法, 据说UUID随机数算法得到的数重复概率为170亿分之一. 这样, 每个人都可以建立不与其它人冲突的 UUID.</p>\n<h3 id=\"CFUUID\"><a href=\"#CFUUID\" class=\"headerlink\" title=\"CFUUID\"></a>CFUUID</h3><p>从iOS 2.0开始, CFUUID就已经出现了. 它是CoreFoundation包的一部分, 因此API属于C语言风格.</p>\n<pre><code>CFUUIDRef cfuuid = CFUUIDCreate(kCFAllocatorDefault);\nNSString *cfuuidString = (NSString*)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, cfuuid));\n</code></pre><h3 id=\"NSUUID\"><a href=\"#NSUUID\" class=\"headerlink\" title=\"NSUUID\"></a>NSUUID</h3><p>NSUUID在iOS 6.0中才出现, 这跟CFUUID几乎完全一样, 只不过它是Objective-C接口. 通过下面的代码可以获得一个UUID字符串:</p>\n<pre><code>NSString *uuid = [[NSUUID UUID] UUIDString];\n</code></pre><h2 id=\"比较完善的做法\"><a href=\"#比较完善的做法\" class=\"headerlink\" title=\"比较完善的做法\"></a>比较完善的做法</h2><pre><code>//获取UQID\n+ (NSString *)getUQID {\n    //从本地沙盒取\n    NSString *uqid = [[NSUserDefaults standardUserDefaults] objectForKey:UQID_KEY];\n\n    if (!uqid) {\n        //从keychain取\n        uqid = (NSString *)[YDKeyChain readObjectForKey:UQID_KEY];\n\n        if (uqid) {\n            [[NSUserDefaults standardUserDefaults] setObject:uqid forKey:UQID_KEY];\n            [[NSUserDefaults standardUserDefaults] synchronize];\n\n        } else {\n            //从pasteboard取\n            UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n            id data = [pasteboard dataForPasteboardType:UQID_KEY];\n            if (data) {\n                uqid = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n            }\n\n            if (uqid) {\n                [[NSUserDefaults standardUserDefaults] setObject:uqid forKey:UQID_KEY];\n                [[NSUserDefaults standardUserDefaults] synchronize];\n                [YDKeyChain saveObject:uqid forKey:UQID_KEY];\n\n            } else {\n\n                //获取idfa\n                uqid = [self getIDFA];\n\n                //idfa获取失败的情况，获取idfv\n                if (!uqid || [uqid isEqualToString:@&quot;00000000-0000-0000-0000-000000000000&quot;]) {\n                    uqid = [self getIDFV];\n\n                    //idfv获取失败的情况，获取uuid\n                    if (!uqid) {\n                        uqid = [self getUUID];\n                    }\n                }\n\n                [[NSUserDefaults standardUserDefaults] setObject:uqid forKey:UQID_KEY];\n                [[NSUserDefaults standardUserDefaults] synchronize];\n\n                [YDKeyChain saveObject:uqid forKey:UQID_KEY];\n\n                UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n                NSData *data = [uqid dataUsingEncoding:NSUTF8StringEncoding];\n                [pasteboard setData:data forPasteboardType:UQID_KEY];\n\n            }\n        }\n    }\n    return uqid;\n</code></pre>","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-网络编程","url":"http://hchong.net/2018/03/26/iOS开发总结系列-网络编程/","content":"<p>这里主要是一些计算机的基础知识部分, 在平常业务中不怎么用, 但是对深入了解计算机原理有很大帮助.</p>\n<h2 id=\"HTTP请求中的GET和POST\"><a href=\"#HTTP请求中的GET和POST\" class=\"headerlink\" title=\"HTTP请求中的GET和POST\"></a>HTTP请求中的GET和POST</h2><p>GET和POST是网络请求到的两种基本方式.<br>GET把参数包含在URL中, POST通过request body传递参数.<br>GET在浏览器回退时是无害, 而POST会再次提交请求.<br>GET产生的URL地址可以保存为书签, 而POST不可以.<br>GET请求会被浏览器主动cache, 而POST不会, 除非手动设置.<br>GET请求只能进行url编码, 而POST支持多种编码方式.<br>GET请求参数会被完整保留在浏览器历史记录里, 而POST中的参数不会被保留.<br>GET请求在URL中传送的参数是有长度限制的, 而POST没有.<br>对参数的数据类型, GET只接受ASCII字符, 而POST没有限制.<br>GET比POST更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息.<br>GET参数通过URL传递, POST放在Request body中.<br>GET和POST都是HTTP协议中的两种发送请求的方法.HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议.HTTP的底层是TCP/IP, 所以GET和POST的底层也是TCP/IP. 也就是说, GET/POST都是TCP链接. GET和POST能做的事情是一样一样的. 你要给GET加上request body, 给POST带上url参数, 技术上是完全行的通的</p>\n<h2 id=\"TCP与UDP\"><a href=\"#TCP与UDP\" class=\"headerlink\" title=\"TCP与UDP\"></a>TCP与UDP</h2><p>TCP面向连接（如打电话要先拨号建立连接); UDP是无连接的, 即发送数据之前不需要建立连接.<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道.<br>TCP协议会向对方发一个带有ACK标志的空数据包（KeepAlive探针）, 对方在收到ACK包以后，如果连接一切正常，应该回复一个ACK；如果连接出现错误了，则应当回复一个RST；如果对方没有回复，服务器每隔intvl的时间再发ACK，如果连续probes个包都被无视了，说明连接被断开了; UDP协议的客户端需要定时向服务器发送心跳包，告诉服务器自己在线. </p>\n<p>TCP: 面向连接, 传输可靠(保证数据正确性, 保证数据顺序), 用于传输大量数据(流模式), 速度慢, 建立连接需要开销较多(时间, 系统资源).<br>UDP: 面向非连接, 传输不可靠, 用于传输少量数据(数据包模式), 速度快.</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>第一次握手: 建立连接, 客户端发送连接请求报文段, 将SYN位置为1, Sequence Number置为x; 然后, 客户端进入SYN_SEND状态, 等待服务器确认.<br>第二次握手: 服务器收到SYN报文段, 服务器收到客户端的SYN报文段, 需要对这个报文段确认, 设置Acknowledgment Number为x+1(Sequence Number+1); 同时, 自己还要发送SYN请求信息, 将SYN位置为1, Sequence Number为y; 服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中, 一并发送给客户端, 此时服务器进入SYN_RECV状态.<br>第三次握手: 客户端收到服务器的SYN+ACK报文段, 然后将Acknowledgment Number设置为y+1, 向服务器发送ACK报文段, 这个报文段发送完毕以后, 客户端和服务器端都进入ESTABLISHED状态, 完成TCP三次握手. 完成了三次握手, 客户端和服务器端就可以开始传送数据.</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>第一次挥手: 主机1(可以使客户端, 也可以是服务端), 设置设置Sequence Number和Acknowledgment Number, 向主机2发送一个FIN报文段; 此时，主机1进入FIN_WAIT_1状态; 这表示主机1没有数据要发送给主机2了.<br>第二次挥手: 主机2收到了主机1发送的FIN报文段, 向主机1回一个ACK报文段, Acknowledgment Number为Sequence Number加1; 主机1进入FIN_WAIT_2状态; 主机2告诉主机1, 我”同意”你的关闭请求.<br>第三次挥手: 主机2向主机1发送FIN报文段, 请求关闭连接, 同时主机2进入LAST_ACK状态.<br>第四次挥手: 主机1收到主机2发送的FIN报文段, 向主机2发送ACK报文段, 然后主机1进入TIME_WAIT状态; 主机2收到主机1的ACK报文段以后, 就关闭连接; 此时, 主机1向等待2MSL后依然没有收到回复, 则证明主机2已经正常关闭, 那么主机1也就此关闭.</p>\n<h2 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h2><p>HTTPS的主要思想是在不安全的网络上创建一安全信道, 并可在使用适当的加密包和服务器证书可被验证且可被信任时, 对窃听和中间人攻击提供合理的防护. HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构.<br>HTTPS中的S指的就是TLS(SSL), 相当于是HTTP over SSL. 使用SSL/TLS协议进行加解密, 下面我们来详细说一下是如何加密的. HTTP默认端口是80, HTTPS默认端口是443.</p>\n<ol>\n<li>客户端给出协议号和一个随机数A, 以及客户端支持的加密算法.</li>\n<li>服务端确认双方使用的加密算法, 并给出数字证书(包含了网站的地址, 加密用的公钥, 以及证书的颁发机构, 过期时间等), 以及一个服务器生成的随机数B.</li>\n<li>客户端解析证书, 传送加密信息: 确认数字证书有效, 然后生成一个新的随机数C, 并且使用数字证书中的公钥, 加密这个随机数, 发送给服务端.</li>\n<li>服务端解密信息: 服务端使用自己的私钥进行解密, 获取客户端发来的随机数, 使用该随机序列号, 对该消息进行加密, 验证的到的校验值是否与客户端发来的一致.</li>\n<li>客户端和服务端使用约定的加密方法, 使用前面的三个随机数, 生成对话密钥, 用对话密钥来加密接下来的整个过程.</li>\n</ol>\n<h2 id=\"数字签名和数字证书\"><a href=\"#数字签名和数字证书\" class=\"headerlink\" title=\"数字签名和数字证书\"></a>数字签名和数字证书</h2><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"noopener\">这里</a>讲的特别详细, 我做一个总结和整理.</p>\n<ol>\n<li>服务端有两把钥匙, 一个公钥一个私钥. </li>\n<li>服务端把公钥发送到客户端.</li>\n<li>客户端向服务端传输信息可以使用公钥来加密, 以达到保密的效果. 服务端收到信息后, 用私钥解密. 只要服务端的私钥不泄密, 意味着这封信就是安全的.</li>\n<li>服务端向客户端发送信息, 对信息Hash化, 生成信息的摘要, 然后再使用私钥对这个摘要进行加密, 加密的结果就是<em>数字签名</em>. 服务端将这个签名附在信息中, 一起下发给客户端.</li>\n<li>客户端收到信息后, 将数字签名用公钥解密, 得到信息的摘要, 这就可以证明这些信息是由服务端下发的.</li>\n<li>客户端再对信息本身Hash化, 将得到的结果与上一步骤中的摘要对比, 如果两者一致, 就说明信息没有被篡改过.</li>\n<li>那么如果有一个第三方, 拦截了客户端与原服务端的传递, 用自己的公钥换走了原服务端的公钥, 那么此时客户端使用的就是第三方的公钥和数字签名, 原服务端给客户端发消息, 就是第三方的假消息, 而不是原服务端的消息.</li>\n<li>这时候我们无法保证公钥属于原服务端还是第三方, 那么我们就要去找证书中心(CA), 为公钥做认证. 证书中心用自己的私钥, 对原服务端的一些相关信息一起加密, 生成<em>数字证书</em>.</li>\n<li>原服务端拿到数字证书后, 再给客户端下发信息, 就可以把数字证书附在信息中.</li>\n<li>客户端收到信息后, 用CA的公钥解开数字证书, 就可以拿到服务端真正的公钥了, 然后就知道数字签名是不是真服务端签的.</li>\n</ol>\n<p>举例: 客户端向服务端发出加密请求, 服务端用自己的私钥加密后, 连同数字证书一起发送给客户端. 客户端(浏览器)中内置有证书管理器, 有”受信任的根证书颁发机构”列表. 客户端会根据这张表查看解开数字证书的公钥是否在列表内. 如果数字证书记载的网址与浏览的不一致, 就说明这张证书被冒用, 浏览器会发出警告. 如果这张数字证书不是由受信任的机构颁发的, 浏览器会发出另一种警告(12306)就是第二种警告. 如果数字证书是可靠的, 客户端就可以使用证书中的服务器公钥, 对信息进行加密, 然后与服务器交换加密信息.</p>\n<h2 id=\"HTTP如何做缓存\"><a href=\"#HTTP如何做缓存\" class=\"headerlink\" title=\"HTTP如何做缓存\"></a>HTTP如何做缓存</h2><p>http1.0 时代给客户端设定缓存方式可通过两个字段: Pragma和Expires来规范.<br>当该字段值为no-cache的时候(事实上现在RFC中也仅标明该可选值), 会知会客户端不要对该资源读缓存, 即每次都得向服务器发一次请求才行. 有了Pragma来禁用缓存, 自然也需要有个东西来启用缓存和定义缓存时间, 对http1.0而言, Expires就是做这件事的首部字段. Expires的值对应一个GMT(格林尼治时间), 比如Mon, 22 Jul 2002 11:12:01 GMT来告诉浏览器资源缓存过期时间, 如果还没过该时间点则不发请求.</p>\n<p>HTTP1.1后, 新增了 Cache-Control 来定义缓存过期时间. 注意: 若报文中同时出现了 Expires 和 Cache-Control, 则以 Cache-Control 为准. 也就是说优先级从高到低分别是 Pragma -&gt; Cache-Control -&gt; Expires.</p>\n<p>作为request的header时, cache-directive 的可选值有:<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FkctxGN8VXdie7M8Fbx6U5Bpfi4c\" alt=\"作为request的header\"><br>作为response的header时, cache-directive 的可选值有:<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FixnilG9OWm4w4qUNZGKSkYXZ4gu\" alt=\"作为response的header\"><br>Cache-Control 允许自由组合可选值.</p>\n<p>另外还有两个字段Last-Modified和ETag.<br>服务器将资源传递给客户端时, 会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端. 格式为: <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code>. 客户端会为资源标记上该信息, 下次再次请求时, 会把该信息附带在请求报文中一并带给服务器去做检查, 若传递的时间值与服务器上该资源最终修改时间是一致的, 则说明该资源没有被修改过, 直接返回304状态码, 内容为空, 这样就节省了传输数据量. 如果两个时间不一致, 则服务器会发回该资源并返回200状态码, 和第一次请求时类似. 这样保证不向客户端重复发出资源, 也保证当服务器有变化时, 客户端能够得到最新的资源. 一个304响应比一个静态资源通常小得多, 这样就节省了网络带宽.</p>\n<p>为了解决上述Last-Modified可能存在的不准确的问题, Http1.1还推出了 ETag 实体首部字段. 服务器会通过某种算法, 给资源计算得出一个唯一标志符(比如md5标志), 在把资源响应给客户端的时候, 会在实体首部加上”ETag: 唯一标识符”一起返回给客户端.</p>\n<p>更多内容可以看<a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"HTTP长连接-vs-TCP连接-vs-websocket\"><a href=\"#HTTP长连接-vs-TCP连接-vs-websocket\" class=\"headerlink\" title=\"HTTP长连接 vs TCP连接 vs websocket\"></a>HTTP长连接 vs TCP连接 vs websocket</h2><h3 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h3><p>长连接: 在HTTP 1.1, 客户端发出请求, 服务端接收请求, 双方建立连接, 在服务端没有返回之前保持连接, 当客户端再发送请求时, 它会使用同一个连接. 这一直继续到客户端或服务器端认为会话已经结束, 其中一方中断连接.</p>\n<p>优势: 减少了连接请求, 降低TCP阻塞, 减少了延迟, 实时性较好.<br>劣势: 可能会影响性能, 因为它在文件被请求之后还保持了不必要的连接很长时间.</p>\n<p>HTTP是无状态, 的也就是说, 浏览器和服务器每进行一次HTTP操作, 就建立一次连接, 但任务结束就中断连接(短连接). 当需要建立 HTTP 长连接时, HTTP 请求头将包含如下内容: <code>Connection: Keep-Alive</code>. 如果服务端同意建立长连接, HTTP 响应头也将包含如下内容: <code>Connection: Keep-Alive</code>. 当需要关闭连接时, HTTP 头中会包含如下内容: <code>Connection: Close</code>.</p>\n<h3 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h3><p>TCP 连接两端好比两个人, 这两个人之间保持通信往来(建立 TCP 连接). 如果他俩经常通信(经常发送 TCP 数据), 那这个 TCP 连接自然是建立着的. 但如果两人只是偶尔通信, 那么, 其中一个人(或两人同时)想知道对方是否还在, 就会定期发送一份邮件(Keep Alive 探测包), 这个邮件没有实质内容, 只是问对方是否还在, 如果对方收到, 就会回复说还在(对这个探测包的 ACK 回应).<br>TCP Keep Alive 用于探测对端是否存在, 而 HTTP Keep Alive 用于协商以复用 TCP 连接. 即便一个 TCP 连接未启用 Keep Alive 功能, 也不妨碍 HTTP 层面开启长连接.</p>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><p>很多网站为了实现推送技术, 所用的技术都是轮询. 轮询是在特定的的时间间隔(如每1秒), 由浏览器对服务器发出HTTP请求, 然后由服务器返回最新的数据给客户端的浏览器. 这种传统的模式带来很明显的缺点, 即浏览器需要不断的向服务器发出请求, 然而HTTP请求可能包含较长的头部, 其中真正有效的数据可能只是很小的一部分, 显然这样会浪费很多的带宽等资源. 因此HTML5定义了WebSocket协议, 能更好的节省服务器资源和带宽, 并且能够更实时地进行通讯.</p>\n<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单, 允许服务端主动向客户端推送数据. 在 WebSocket API 中, 客户端发送一次http websocket请求, 服务器响应请求, 浏览器和服务器只需要完成一次握手, 建立持久连接，并进行双向数据传输，后面不进行HTTP连接，而是使用TCP连接.</p>\n<p>websocket有以下优点: </p>\n<ol>\n<li>较少的控制开销. 在连接创建后, 服务器和客户端之间交换数据时, 用于协议控制的数据包头部相对较小, 相对于HTTP请求每次都要携带完整的头部, 此项开销显著减少了.</li>\n<li>更强的实时性. 协议是全双工的, 服务端可以随时下发信息到客户端, HTTP请求需要等待客户端发起请求服务端才能响应.</li>\n<li>保持连接状态. Websocket需要先创建连接, 这就使得其成为一种有状态的协议, 之后通信时可以省略部分状态信息. 而HTTP请求可能需要在每个请求都携带状态信息(如身份认证等).</li>\n<li>更好的二进制支持. Websocket定义了二进制帧, 相对HTTP, 可以更轻松地处理二进制内容.</li>\n<li>Websocket定义了扩展, 用户可以扩展协议, 实现部分自定义的子协议. 如部分浏览器支持压缩等.</li>\n<li>更好的压缩效果. 相对于HTTP压缩, Websocket在适当的扩展支持下, 可以沿用之前内容的上下文, 在传递类似的数据时, 可以显著地提高压缩率.</li>\n</ol>\n<h2 id=\"HTTP2-0针对同一个域名的多个请求-会建立多少个tcp连接\"><a href=\"#HTTP2-0针对同一个域名的多个请求-会建立多少个tcp连接\" class=\"headerlink\" title=\"HTTP2.0针对同一个域名的多个请求, 会建立多少个tcp连接\"></a>HTTP2.0针对同一个域名的多个请求, 会建立多少个tcp连接</h2><p>这里主要是HTTP2.0的多路复用机制.</p>\n<p>在同一个域名下, 开启一个TCP的connection, 每个请求以stream的方式发送, 每个steam有一个唯一标识. connection一旦建立, 后续的请求都可以复用这个connection并且可以同时发送, server端可以根据stream的唯一标识来相应对应的请求.<br>直到客户端不需要与服务器进行进一步的通信(例如主动用户离开这个页面), 或者服务器主动关闭connection, 这个connection就断开.</p>\n<p>stream的基本组成单位是frame(二进制帧), 每种frame又分为很多种类型例如HEADERS Frame(头部帧), DATA Frame(内容帧)等等. 请求头HEADERS Frame组成了resquest, 返回头HEADERS Frame和DATA Frame组成了response, request和response组成了一个stream.</p>\n<h2 id=\"TCP的拥塞控制机制\"><a href=\"#TCP的拥塞控制机制\" class=\"headerlink\" title=\"TCP的拥塞控制机制\"></a>TCP的拥塞控制机制</h2><p>拥塞控制是TCP协议的意向重要功能, TCP的拥塞机制是从端到端的角度, 推测网络是否发生拥堵, 如果拥堵则降低数据发送效率, 以缓解网络拥塞. 拥塞机制控制算法包括了慢启动, 拥塞避免, 快速重传, 快速恢复四部分.<br>TCP的拥塞控制采用的是窗口机制, TCP的发送端维持一个称为拥塞窗口cwnd的变量, 单位为字节, 用于表示在未收到接收端确认的情况下, 可以连续发送的数据字节数. 他会动态变化, 与网络拥塞情况成反比.</p>\n<ul>\n<li>慢启动指的是, 在TCP的开始传输阶段, 因为不知道网络负荷情况, 因此采用试探的方法, 逐渐增大拥塞窗口.</li>\n<li>拥塞避免指的是, 为了防止拥塞窗口增长过快而引起网络拥塞, TCP还需要设置一个慢启动阈值ssthresh, 当拥塞窗口的值增加到阈值时, 就减缓拥塞窗口的增长速度. 当网络拥塞时, 我们重新执行慢启动算法. </li>\n<li>快速重传指的是, 接收端每收到一个失序的数据报文段后就立即发出重复确认, 以便更早地通知发送端有丢包的情况发生. 举例: 接收端收到了1, 2两个报文, 接下来应该收到3. 但是, 直接收到了4, 这时就会向发送端发送2号数据报文段的确认, 这个称为重复确认. 继续往下走接收到了5, 6报文, 接收端仍然要向发送端发出2号数据报文段的重复确认. 这时发送端会收到多个2号数据报文段的重复确认, 则认为3号数据报文段发生了丢包, 需要立即向接收端重传3号数据报文段, 而不需要等待重传计时器到期再重传. 快速重传算法中规定如果收到某数据报文段的三个重复确认, 则立即重传下一个数据报文段.</li>\n<li>快速重连指的是, 当发送端连续收到三个重复确认时, 就将慢启动阈值ssthresh减半, 以预防网络拥塞的发生, 并且将拥塞窗口cwnd的值置为减半后的ssthresh, 然后开始执行拥塞避免算法, 使得cwnd缓慢地加性增大.</li>\n</ul>\n<h2 id=\"HTTP-post的body体使用form-urlencoded和multipart-form-data的区别\"><a href=\"#HTTP-post的body体使用form-urlencoded和multipart-form-data的区别\" class=\"headerlink\" title=\"HTTP post的body体使用form-urlencoded和multipart/form-data的区别\"></a>HTTP post的body体使用form-urlencoded和multipart/form-data的区别</h2><ul>\n<li>form-urlencoded是默认的mime内容编码类型, 是通用的, 但是它在传输比较大的二进制或者文本数据时效率极低.</li>\n<li>multipart/form-data是当上传文件或者二进制数据和非ASCII数据使用.</li>\n</ul>\n<h2 id=\"网络基本模型\"><a href=\"#网络基本模型\" class=\"headerlink\" title=\"网络基本模型\"></a>网络基本模型</h2><p>OSI 模型(Open System Interconnection model)是一个由国际标准化组织􏰁提出的概念模型,试图􏰁供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架. 它将计算机网络体系结构划分为七层, 每层都可以􏰁供抽象良好的接口. 了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议. OSI 模型从最底层到最高层依次是下面七层结构. 在TCP/IP的四层模型中应用层, 表示层, 会话层统称为应用层. 数据链路层和物理层统称为网络接口层. 见下图:<br><img src=\"https://upload-images.jianshu.io/upload_images/2667071-60c63f19bb202a10.jpg?imageMogr2/auto-orient/\" alt=\"网络基本模型\"></p>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><p>物理层主要是利用传输介质为数据链路层提供物理连接, 实现比特流的透明传输. 规定了激活, 维持, 关闭通信端点之间的机械特性, 电气特性, 功能特性以及过程特性. 为上层协议提供了一个传输数据的物理媒体. 在这一层协议数据单元为比特(bit). 物理层的互联设备包括: 集线器, 中继器等.</p>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h3><p>控制网络层与物理层之间的通信, 主要作用是在不可靠的物理介质上提供可靠的传输. 数据链路层的作用主要包括: 物理地址殉职, 数据的成帧, 流量控制, 数据的检错, 重发等. 在这一层协议数据单元为帧(frame). 数据链路层的互联设备包括: 网桥, 交换机等.</p>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><p>网络层的主要作用是将网络地址翻译成对应的物理地址, 并决定如何将数据从发送方路由到接收方, 建立的是主机到主机的通信. 该层的作用包括: 对子网见的数据包进行路由选择, 实现拥塞控制, 网际互联等功能. 在这一层协议数据单元为数据包(packet). 网络层的互联设备包括: 路由器等.</p>\n<p>网络层主要解决的问题有: 根据MAC地址寻址. 规定不同的信息交换方式. 根据路由算法将数据分组, 并且将信息星最合适的路径由发送端传送到接收端. 控制从源节点到目的节点间的流量.</p>\n<p>网络层的作用是引进一套新的地址, 使得我们能够区分不同的计算机是否属于同一个子网络. 这套地址就叫做”网络地址”, 简称”网址”. 规定网络地址的协议, 叫做IP协议, 他所定义的地址就被称为IP地址. </p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><p>传输层是最重要的一部分, 建立端口到端口的通信. 每个数据包都发到主机的特定端口, 所以不同的程序就能取到自己所需要的数据. </p>\n<p>传输层的主要功能是负责将上层数据分段并提供端到端的, 可靠活着不可靠的传输. 此外, 传输层还要处理端到端的差错控制和流量控制等问题. 在传输层协议数据单元为数据段(segment). 传输层协议的代表包括: TCP, UDP, SPX等.</p>\n<h3 id=\"会话层\"><a href=\"#会话层\" class=\"headerlink\" title=\"会话层\"></a>会话层</h3><p>会话层主要是管理主机之间的会话进程, 负责建立, 管理, 终止进程之间的会话. 主要功能是建立通信链接, 保持会话过程通信链接的畅通, 利用在数据中插入校验点来同步两个时间点之间的对话. 决定通信是否被中断以及通信中断是决定从何处重新发送.</p>\n<h3 id=\"表示层\"><a href=\"#表示层\" class=\"headerlink\" title=\"表示层\"></a>表示层</h3><p>表示层是应用程序和网络之间的翻译官, 负责对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解. 表示层的数据转换包括数据的解密和加密, 压缩格式转换等.</p>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><p>应用层负责为操作系统或网络应用程序提供访问网络服务的接口, 规定应用程序的数据格式. 应用层提供的服务包括文件传输, 文件管理, 以及电子邮件的信息处理. 在应用层的互联设备主要包括: 网关(Gateway)等.</p>\n<p>常见的应用层协议有: 文本传输协议(FTP), 端口号是21. 超文本传输协议(HTTP), 端口是80. 简单网络管理协议(SNMP). 域名服务协议(DNS). 网络文件系统(NFS). 远程终端协议(Telent).</p>\n<h2 id=\"完整的网络请求过程解析\"><a href=\"#完整的网络请求过程解析\" class=\"headerlink\" title=\"完整的网络请求过程解析\"></a>完整的网络请求过程解析</h2><p><a href=\"http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html\" target=\"_blank\" rel=\"noopener\">这里</a>讲的挺详细, 大概做下总结.</p>\n<p>首先电脑要上网我们必须需要四个参数, 分别是: </p>\n<ul>\n<li>本机的IP地址(动态的或者静态的)</li>\n<li>子网掩码</li>\n<li>网关的IP地址</li>\n<li>DNS的IP地址</li>\n</ul>\n<p>我们在浏览器里面输入了一个网址<a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a>, 这意味着浏览器要向Google发送一个网页请求的数据包. </p>\n<ol>\n<li>我们知道了网址但是不知道IP地址, 那么我们就需要DNS协议帮助我们将网址转换为IP地址. 于是我们想DNS服务器(DNS的IP地址, 端口是53)发送一个DNS数据包, DNS服务器告诉我们Google的IP地址, 于是我们知道了Google的IP地址.</li>\n<li>接下来, 我们要判断Google的IP地址是不是和本机的IP地址在同一个子网络里面, 这里我们要用到子网掩码. 我们通过子网掩码分别对本机IP地址和Google的IP地址做&amp;运算, 如果结果不同就表示不在同一个自网络. 很显然我们和Google的IP地址不在同一个自网络. 因此, 我们要向Google发送数据包, 必须通过网关转发. 也就是说, 接收方的MAC地址将是网关的MAC地址.</li>\n<li>浏览网页用的是HTTP协议, HTTP协议包含一些请求方式, HOST, User-Agent, Accept-Encoding, Accept-Language, Accept-Charset, Cookie等信息.</li>\n<li>TCP数据包需要设置端口, Google默认是80端口, 本机随机生成一个端口号. 然后把HTTP的数据包嵌入到TCP的数据包中.</li>\n<li>TCP数据包再嵌入IP数据包, IP数据包需要设置双方的IP地址, 这个我们在前面已经解析出来了.</li>\n<li>最后, IP数据包嵌入以太网数据包. 以太网数据包需要设置双方的MAC地址, 发送方为本机的网卡MAC地址, 接收方为网关的MAC地址(通过ARP协议得到).</li>\n<li>以太网数据包的数据部分, 最大长度为1500字节. 因此IP数据包必须分割成若干个包. 每个包都有自己的IP标头(20字节).</li>\n<li>经过多个网关的转发, Google的服务器(解析出来的IP地址), 收到了这若干个以太网数据包. 根据IP标头的序号, Google将四个包拼起来, 取出完整的TCP数据包, 然后读出里面的”HTTP请求”, 接着做出”HTTP响应”, 再用TCP协议发回来. 本机收到HTTP响应以后, 就可以将网页显示出来, 完成一次网络通信.</li>\n</ol>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-多线程","url":"http://hchong.net/2018/03/24/iOS开发总结系列-多线程/","content":"<p>这一篇主要总结开发中的多线程问题, 之前已经写过一篇多线程总结, 可以看<a href=\"http://hchong.net/2017/11/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/\">这里</a>.</p>\n<h2 id=\"GCD里面有哪几种Queue\"><a href=\"#GCD里面有哪几种Queue\" class=\"headerlink\" title=\"GCD里面有哪几种Queue\"></a>GCD里面有哪几种Queue</h2><ol>\n<li>主队列 dispatch_main_queue(); 串行, 主要用来更新UI </li>\n<li>全局队列 dispatch_global_queue(); 并行, 四个优先级：background, low, default, high </li>\n<li>自定义队列 dispatch_queue_t queue; 可以自定义是并行DISPATCH_QUEUE_CONCURRENT 或者 串行DISPATCH_QUEUE_SERIAL.</li>\n</ol>\n<h2 id=\"若干个url异步加载多张图片，然后在都下载完成后合成一张整图\"><a href=\"#若干个url异步加载多张图片，然后在都下载完成后合成一张整图\" class=\"headerlink\" title=\"若干个url异步加载多张图片，然后在都下载完成后合成一张整图\"></a>若干个url异步加载多张图片，然后在都下载完成后合成一张整图</h2><p>使用dispatch_group, 有两种使用方式</p>\n<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\ndispatch_group_async(group, queue, ^{ /*加载图片1 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片2 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片3 */ }); \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        // 合并图片\n});\n</code></pre><pre><code>- (void)groupTest2 {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_group_t group = dispatch_group_create();\n\n    dispatch_group_enter(group);\n    dispatch_async(queue, ^{\n        sleep(2); //这里线程睡眠1秒钟，模拟异步请求\n        NSLog(@&quot;%@ one finish&quot;, [NSThread currentThread]);\n        dispatch_group_leave(group);\n    });\n\n    dispatch_group_enter(group);\n    dispatch_async(queue, ^{\n        sleep(2); //这里线程睡眠1秒钟，模拟异步请求\n        NSLog(@&quot;%@ two finish&quot;, [NSThread currentThread]);\n        dispatch_group_leave(group);\n    });\n\n    dispatch_group_notify(group, queue, ^{\n        NSLog(@&quot;group finished&quot;);\n    });\n}\n</code></pre><h2 id=\"dispatch-barrier-async的作用\"><a href=\"#dispatch-barrier-async的作用\" class=\"headerlink\" title=\"dispatch_barrier_async的作用\"></a>dispatch_barrier_async的作用</h2><p>在并行队列中, 为了保持某些任务的顺序, 需要等待一些任务完成后才能继续进行, 使用 barrier 来等待之前任务完成, 避免数据竞争等问题. 假设一个并行队列中添加了五个异步任务, 虽然遵循FIFO的原则, 这五个任务的执行必定是无序的. 当我们在第三个任务之后加入dispatch_barrier_async任务, 那么这五个任务就被分割成两部分, 前三次无序执行, 然后执行dispatch_barrier_async任务, 然后再无序执行后两次任务. 注意此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行.</p>\n<pre><code>- (void)barrierTest {\n\n    //此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行\n    dispatch_queue_t queue = dispatch_queue_create(&quot;barrierTest&quot;, DISPATCH_QUEUE_CONCURRENT);\n\n    dispatch_async(queue, ^{\n        NSLog(@&quot;1&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;2&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;3&quot;);\n    });\n    dispatch_barrier_async(queue, ^{\n        sleep(3);\n        NSLog(@&quot;插入执行&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;4&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;5&quot;);\n    });\n}\n</code></pre><h2 id=\"为什么要废弃dispatch-get-current-queue\"><a href=\"#为什么要废弃dispatch-get-current-queue\" class=\"headerlink\" title=\"为什么要废弃dispatch_get_current_queue\"></a>为什么要废弃dispatch_get_current_queue</h2><p>dispatch_get_current_queue可能造成死锁, 详细的原因看<a href=\"为什么dispatch_get_current_queue被废弃\">这里</a></p>\n<h2 id=\"如何取消一个正在运行的线程\"><a href=\"#如何取消一个正在运行的线程\" class=\"headerlink\" title=\"如何取消一个正在运行的线程\"></a>如何取消一个正在运行的线程</h2><h3 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h3><ol>\n<li><p>使用dispatch_block_cancel(iOS8之后)来取消, 但是必须使用 dispatch_block_create 创建 dispatch_block_t.</p>\n<pre><code> - (void)gcdBlockCancel{\n     dispatch_queue_t queue = dispatch_queue_create(&quot;com.gcdtest.www&quot;, DISPATCH_QUEUE_CONCURRENT);\n\n     dispatch_block_t block1 = dispatch_block_create(0, ^{\n         sleep(5);\n         NSLog(@&quot;block1 %@&quot;,[NSThread currentThread]);\n     });\n\n     dispatch_block_t block2 = dispatch_block_create(0, ^{\n         NSLog(@&quot;block2 %@&quot;,[NSThread currentThread]);\n     });\n\n     dispatch_block_t block3 = dispatch_block_create(0, ^{\n         NSLog(@&quot;block3 %@&quot;,[NSThread currentThread]);\n     });\n\n     dispatch_async(queue, block1);\n     dispatch_async(queue, block2);\n     dispatch_block_cancel(block3);\n }\n</code></pre><p> 注意: dispatch_block_cancel只能取消尚未执行的任务, 对正在执行的任务不起作用.</p>\n</li>\n<li>模仿NSOperation, 定义外部变量, 标记block是否需要取消</li>\n</ol>\n<pre><code>@property (nonatomic, assign) BOOL isCancel;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.view.backgroundColor = [UIColor whiteColor];\n    [self gcdCancel];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        self.isCancel = YES;\n    });\n}\n\n- (void)gcdCancel {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_async(queue, ^{\n        for (int i = 0; i &lt; 10000; i++) {\n            NSLog(@&quot;%d&quot;, i);\n            if (self.isCancel) {\n                return;\n            }\n        }\n    });\n}\n</code></pre><p>不等循环结束, self.isCancel已经被标记为YES, 线程就已经return, 结束.</p>\n<h3 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h3><p>NSOperation提供了cancel方法, 但是这也只是把状态标记为cancel, 已经执行的任务是还在继续跑的, 所以我们要要在Operation的声明周期函数中, 频繁的检查 .cancelled 状态, 只要 .cancelled == true我们就把operation的 finished 状态, 设置为true, 并且结束没有完成的任务.</p>\n<p>我们要在<code>- start</code>, <code>- main</code>等任何声明周期函数中检查, 也可以通过KVO观察cancel的变化来做相应的操作. </p>\n<blockquote>\n<p>In life cycle of operation, you should frequently check .cancelled whenever .cancelled == true, you should stop operation and set .finished == true<br>In macOS 10.6 and later, if you call the cancel method on an operation that is in an operation queue and has unfinished dependent operations, those dependent operations are subsequently ignored. Because the operation is already cancelled, this behavior allows the queue to call the operation’s start method to remove the operation from the queue without calling its main method. If you call the cancel method on an operation that is not in a queue, the operation is immediately marked as being cancelled. In each case, marking the operation as ready or finished results in the generation of the appropriate KVO notifications.</p>\n</blockquote>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中, 因争夺资源而造成的一种互相等待的现象, 若无外力作用, 它们都将无法推进下去.</p>\n<p>死锁产生的主要原因:</p>\n<ul>\n<li>系统资源不足</li>\n<li>进程运行推进的顺序不合适</li>\n<li>资源分配不当</li>\n</ul>\n<p>产生死锁的四个必要条件:</p>\n<ul>\n<li>互斥条件: 一个资源每次只能被一个进程使用. 这个无法预防, 恰恰是设备的固有属性, 我们还应该保护.</li>\n<li>占有且等待: 一个进程因请求资源而阻塞时, 对已获得的资源保持不放. 这个我们可以通过要求进程一次性的请求所有需要的资源, 并且阻塞这个进程直到所有请求都同时满足来预防. </li>\n<li>不可强行占有: 进程已获得的资源, 在未使用完成之前, 不能强行剥夺. 如果占有某些资源的一个进程进行进一步资源请求时被拒绝, 则该进程必须释放它最初占有的资源, 或者抢占另外一条进程并要求释放资源这两种方式来预防.</li>\n<li>循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系. 我们可以通过定义资源类型的线性顺序来预防.</li>\n</ul>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发中的锁","url":"http://hchong.net/2018/03/21/iOS开发中的锁/","content":"<p>锁是比较常用的同步工具, 用于保证一段代码段在同一个时间只能允许被有限个线程访问, 下面我们来介绍下iOS开发中常见的锁.</p>\n<h2 id=\"NSLock\"><a href=\"#NSLock\" class=\"headerlink\" title=\"NSLock\"></a>NSLock</h2><blockquote>\n<p>The NSLock class uses POSIX threads to implement its locking behavior. When sending an unlock message to an NSLock object, you must be sure that message is sent from the same thread that sent the initial lock message. Unlocking a lock from a different thread can result in undefined behavior.</p>\n</blockquote>\n<p>NSLock是一个对象锁, 遵循 NSLocking 协议, 加锁和解锁务必在同一线程中完成. 常用方法有以下几个: <code>-lock</code> 方法是加锁, <code>-unlock</code> 是解锁, <code>-tryLock</code> 是尝试加锁, 如果失败的话返回 NO, <code>-lockBeforeDate:</code> 是在指定Date之前尝试加锁, 如果在指定时间之前都不能加锁, 则返回NO. </p>\n<pre><code>//主线程中\nNSLock *lock = [[NSLock alloc] init];\n\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   NSLog(@&quot;进入线程1&quot;);\n   [lock lock];\n   NSLog(@&quot;线程1&quot;);\n   sleep(5);\n   [lock unlock];\n   NSLog(@&quot;线程1解锁成功&quot;);\n});\n\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   NSLog(@&quot;进入线程2&quot;);\n   sleep(1);\n   [lock lock];\n   NSLog(@&quot;线程2&quot;);\n   [lock unlock];\n});\n</code></pre><p>执行结果是: </p>\n<pre><code>2018-03-25 14:20:16.642007+0800 HCLock[9802:336637] 进入线程1\n2018-03-25 14:20:16.642007+0800 HCLock[9802:336636] 进入线程2\n2018-03-25 14:20:16.642181+0800 HCLock[9802:336637] 线程1\n2018-03-25 14:20:21.647601+0800 HCLock[9802:336637] 线程1解锁成功\n2018-03-25 14:20:21.647624+0800 HCLock[9802:336636] 线程2\n</code></pre><p>这里说一下lock的具体过程: 首先两个异步线程, 分别进入两个线程. 当线程1 lock 时, 这时会阻塞线程. 因为线程2中也有lock, 这时会空转(可以理解为跑一个while循环), 不断去申请加锁(在空转1s后, 线程会进入waiting状态, 此时线程就不占用CPU资源了), 等锁可用的时候, 这个线程会立即被唤醒. </p>\n<p>这里值得注意的是tryLock是不会阻塞线程的. lockBeforeDate: 方法会在所指定 Date 之前尝试加锁, 会阻塞线程, 如果在指定时间之前都不能加锁, 则返回 NO, 指定时间之前能加锁, 则返回 YES.</p>\n<p>NSLock实际是在内部封装了pthread_mutex, 属性为 PTHREAD_MUTEX_ERRORCHECK, 它会损失一定性能换来错误提示.</p>\n<h2 id=\"NSConditionLock\"><a href=\"#NSConditionLock\" class=\"headerlink\" title=\"NSConditionLock\"></a>NSConditionLock</h2><p>NSConditionLock是一个条件锁, 和 NSLock 类似, 都遵循 NSLocking 协议, 方法都类似, 只是多了一个 condition 属性, 以及每个操作都多了一个关于 condition 属性的方法, 例如 tryLock, tryLockWhenCondition:, NSConditionLock 可以称为条件锁, 只有 condition 参数与初始化时候的 condition 相等, lock 才能正确进行加锁操作. 而 unlockWithCondition: 并不是当 Condition 符合条件时才解锁, 而是解锁之后, 修改 Condition 的值. </p>\n<pre><code>@interface NSConditionLock : NSObject &lt;NSLocking&gt; {\n@private\n    void *_priv;\n}\n\n- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;\n\n@property (readonly) NSInteger condition;\n- (void)lockWhenCondition:(NSInteger)condition;\n- (BOOL)tryLock;\n- (BOOL)tryLockWhenCondition:(NSInteger)condition;\n- (void)unlockWithCondition:(NSInteger)condition;\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);\n\n@end\n</code></pre><p>关于上面几个方法有几点要说明: </p>\n<ul>\n<li>初始化时候的 condition 参数为 0.</li>\n<li>lockWhenCondition加锁失败会阻塞线程, tryLockWhenCondition则不会.</li>\n<li>NSConditionLock 可以通过Condition来实现任务之间的依赖</li>\n</ul>\n<p>具体使用的案例可以看<a href=\"https://www.jianshu.com/p/ddbe44064ca4\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"NSRecursiveLock\"><a href=\"#NSRecursiveLock\" class=\"headerlink\" title=\"NSRecursiveLock\"></a>NSRecursiveLock</h2><p>NSRecursiveLock是一个递归锁, 他和 NSLock 的区别在于, NSRecursiveLock 可以在一个线程中重复加锁(单线程内任务是按顺序执行的, 不会出现资源竞争问题), NSRecursiveLock 会记录上锁和解锁的次数, 当二者平衡的时候, 才会释放锁, 其它线程才可以上锁成功.</p>\n<pre><code>@interface NSRecursiveLock : NSObject &lt;NSLocking&gt; {\n@private\n    void *_priv;\n}\n\n- (BOOL)tryLock;\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);\n\n@end\n</code></pre><p>递归锁也是通过 pthread_mutex_lock 函数来实现, 在函数内部会判断锁的类型, 如果显示是递归锁, 就允许递归调用, 仅仅将一个计数器加一. 锁的释放过程也是同理.</p>\n<h2 id=\"NSCondition\"><a href=\"#NSCondition\" class=\"headerlink\" title=\"NSCondition\"></a>NSCondition</h2><p>NSCondition是一个条件锁, 是封装了一个互斥锁和条件变量, 锁上之后其它线程也能上锁, 而之后可以根据条件决定是否继续运行线程, 即线程是否要进入 waiting 状态. NSCondition 并不会像上文的那些锁一样, 先轮询, 而是直接进入 waiting 状态, 当其它线程中的该锁执行 signal 或者 broadcast 方法时, 线程被唤醒, 继续运行之后的方法.</p>\n<pre><code>@interface NSCondition : NSObject &lt;NSLocking&gt; {\n@private\n    void *_priv;\n}\n\n- (void)wait;//让当前线程处于等待状态\n- (BOOL)waitUntilDate:(NSDate *)limit;\n- (void)signal;\n- (void)broadcast;//CPU发信号告诉线程不用在等待, 可以继续执行\n\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);\n\n@end\n</code></pre><p>一般用于多线程同时访问, 修改同一个数据源, 保证在同一时间内数据源只被访问, 修改一次, 其他线程的命令需要在lock 外等待, 只到unlock, 才可访问.</p>\n<p>NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的. 条件变量有点像信号量, 提供了线程阻塞与信号机制, 因此可以用来阻塞某个线程, 并等待某个数据就绪, 随后唤醒线程.</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h2><p>这其实是一个 OC 层面的锁, 是一个互斥锁. 主要是通过牺牲性能换来语法上的简洁与可读. @synchronized 后面需要紧跟一个 OC 对象, 它实际上是把这个对象当做锁来使用. 这是通过一个哈希表来实现的, OC 在底层使用了一个互斥锁的数组(可以理解为锁池), 通过对对象去哈希值来得到对应的互斥锁.</p>\n<pre><code>//主线程中\nNSObject *obj = [[NSObject alloc] init];\n//线程1\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   @synchronized(obj){\n       NSLog(@&quot;线程1&quot;);\n       sleep(10);\n   }\n});\n//线程2\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);\n   NSLog(@&quot;进入线程2&quot;);\n   @synchronized(obj){\n       NSLog(@&quot;线程2&quot;);\n   }\n});\n</code></pre><p>执行结果如下:</p>\n<pre><code>2018-03-25 15:41:26.477502+0800 HCLock[10997:451231] 线程1\n2018-03-25 15:41:27.477745+0800 HCLock[10997:451230] 进入线程2\n2018-03-25 15:41:36.478718+0800 HCLock[10997:451230] 线程2\n</code></pre><p>@synchronized指令使用的obj为该锁的唯一标识, 只有当标识相同时, 才为满足互斥. @synchronized也是会轮询, 需要加锁的对象是否可以使用.<br>@synchronized块会隐式的添加一个异常处理例程来保护代码, 该处理例程会在异常抛出的时候自动的释放互斥锁.<br>@sychronized(object){} 内部 object 被释放或被设为 nil 没有问题, 但如果 object 一开始就是 nil, 则失去了锁的功能. 不过虽然 nil 不行, 但 @synchronized([NSNull null]) 是完全可以的.<br>调用 @sychronized 的每个对象, Objective-C runtime 都会为其分配一个递归锁并存储在哈希表中. </p>\n<h2 id=\"dispatch-semaphore\"><a href=\"#dispatch-semaphore\" class=\"headerlink\" title=\"dispatch_semaphore\"></a>dispatch_semaphore</h2><p>dispatch_semaphore 是 GCD 用来同步的一种方式, 与他相关的只有三个函数, 一个是创建信号量, 一个是等待信号, 一个是发送信号.</p>\n<pre><code>dispatch_semaphore_create(long value);\n\ndispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);\n\ndispatch_semaphore_signal(dispatch_semaphore_t dsema);\n</code></pre><p>dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式，但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）。而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t 类型的信号量。</p>\n<p>dispatch_semaphore_create(1) 方法可以创建一个 dispatch_semaphore_t 类型的信号量，设定信号量的初始值为 1。注意，这里的传入的参数必须大于或等于 0，否则 dispatch_semaphore_create 会返回 NULL。</p>\n<p>dispatch_semaphore_wait(signal, overTime); 方法会判断 signal 的信号值是否大于 0。大于 0 不会阻塞线程，消耗掉一个信号，执行后续任务。如果信号值为 0，该线程会和 NSCondition 一样直接进入 waiting 状态，等待其他线程发送信号唤醒线程去执行后续任务，或者当 overTime  时限到了，也会执行后续任务。</p>\n<p>dispatch_semaphore_signal(signal); 发送信号，如果没有等待的线程接受信号，则使 signal 信号值加一（做到对信号的保存）。</p>\n<p>从上面的实例代码可以看到，一个 dispatch_semaphore_wait(signal, overTime); 方法会去对应一个 dispatch_semaphore_signal(signal); 看起来像 NSLock 的 lock 和 unlock，其实可以这样理解，区别只在于有信号量这个参数，lock unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatch_semaphore 的信号量初始值为 x ，则可以有 x 个线程同时访问被保护的临界区.</p>\n<h2 id=\"OSSpinLock\"><a href=\"#OSSpinLock\" class=\"headerlink\" title=\"OSSpinLock\"></a>OSSpinLock</h2><pre><code>#import &lt;libkern/OSAtomic.h&gt;\n\n__block OSSpinLock theLock = OS_SPINLOCK_INIT;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   OSSpinLockLock(&amp;theLock);\n   NSLog(@&quot;线程1&quot;);\n   sleep(10);\n   OSSpinLockUnlock(&amp;theLock);\n   NSLog(@&quot;线程1解锁成功&quot;);\n});\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   sleep(1);\n   OSSpinLockLock(&amp;theLock);\n   NSLog(@&quot;线程2&quot;);\n   OSSpinLockUnlock(&amp;theLock);\n});\n</code></pre><p>OSSpinLock 是一种自旋锁, 只有加锁, 解锁, 尝试加锁三个方法. 和 NSLock 不同的是 NSLock 请求加锁失败的话, 会先轮询, 但一秒过后便会使线程进入 waiting 状态, 等待唤醒. 而 OSSpinLock 会一直轮询, 等待时会消耗大量 CPU 资源, 不适用于较长时间的任务.</p>\n<p>如果一个低优先级的线程获得锁并访问共享资源, 这时一个高优先级的线程也尝试获得这个锁, 它会处于 spin lock 的忙等状态从而占用大量 CPU. 此时低优先级线程无法与高优先级线程争夺 CPU 时间, 从而导致任务迟迟完不成、无法释放 lock. 因为上面的特性, 导致这个锁已经被废弃, </p>\n<p>具体看<a href=\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"pthread-mutex\"><a href=\"#pthread-mutex\" class=\"headerlink\" title=\"pthread_mutex\"></a>pthread_mutex</h2><p>pthread_mutex 表示互斥锁. 互斥锁的实现原理与信号量非常相似, 不是使用忙等, 而是阻塞线程并睡眠, 需要进行上下文切换. 常见的API有:</p>\n<pre><code>pthread_mutexattr_t attr;  \npthread_mutexattr_init(&amp;attr);  \npthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性\n\npthread_mutex_t mutex;  \npthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁\n\npthread_mutex_lock(&amp;mutex); // 申请锁\npthread_mutex_unlock(&amp;mutex); // 释放锁\n</code></pre><p>一般情况下, 一个线程只能申请一次锁, 也只能在获得锁的情况下才能释放锁, 多次申请锁或释放未获得的锁都会导致崩溃. 假设在已经获得锁的情况下再次申请锁, 线程会因为等待锁的释放而进入睡眠状态, 因此就不可能再释放锁, 从而导致死锁.</p>\n<pre><code>- (void)example5 {\n    pthread_mutex_init(&amp;theLock, NULL);//初始化一个锁&amp;theLock\n\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&amp;attr);\n    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);\n    pthread_mutex_init(&amp;theLock, &amp;attr);\n    pthread_mutexattr_destroy(&amp;attr);\n\n    pthread_t thread;\n    pthread_create(&amp;thread, NULL, threadMethord, 5);\n}\n\nvoid *threadMethord(int value) {\n    pthread_mutex_lock(&amp;theLock);\n\n    if (value &gt; 0) {\n        printf(&quot;Value:%i\\n&quot;, value);\n        sleep(1);\n        threadMethord(value - 1);\n    }\n    pthread_mutex_unlock(&amp;theLock);\n    return 0;\n}\n</code></pre><p><code>int pthread_mutex_init(pthread_mutex_t * __restrict, const pthread_mutexattr_t * __restrict);</code>表示初始化一个锁, pthread_mutexattr_t表示互斥锁的类型, 传NULL表示默认类型, 一共有四种类型.</p>\n<pre><code>PTHREAD_MUTEX_NORMAL 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。\n\nPTHREAD_MUTEX_ERRORCHECK 检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。\n\nPTHREAD_MUTEX_RECURSIVE 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。\n\nPTHREAD_MUTEX_DEFAULT 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列。\n</code></pre><h2 id=\"互斥锁与信号量的区别\"><a href=\"#互斥锁与信号量的区别\" class=\"headerlink\" title=\"互斥锁与信号量的区别\"></a>互斥锁与信号量的区别</h2><p>信号量用在多线程多任务同步的, 一个线程完成了某一个动作就通过信号量告诉别的线程, 别的线程再进行某些动作. 信号量的作用域是进程间或线程间.<br>而互斥锁是用在多线程多任务互斥的, 一个线程占用了某一个资源, 那么别的线程就无法访问, 直到这个线程unlock, 其他的线程才开始可以利用这个资源. 比如对全局变量的访问, 有时要加锁, 操作完了再解锁. 有的时候锁和信号量会同时使用. 互斥锁的作用域是线程间.<br>信号量不一定是锁定某一个资源, 而是流程上的概念, 比如: 有A, B两个线程, B线程要等A线程完成某一任务以后再进行自己下面的步骤, 这个任务并不一定是锁定某一资源, 还可以是进行一些计算或者数据处理之类. 而线程互斥量则是”锁住某一资源”的概念, 在锁定期间内, 其他线程无法对被保护的数据进 行操作. 在有些情况下两者可以互换.<br>具体看<a href=\"https://blog.csdn.net/jenny8080/article/details/52094140\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://mrpeak.cn/blog/synchronized/\" target=\"_blank\" rel=\"noopener\">正确使用多线程同步锁@synchronized()</a></p>\n<p>2.<a href=\"https://www.jianshu.com/p/1e59f0970bf5\" target=\"_blank\" rel=\"noopener\">iOS 中几种常用的锁总结</a></p>\n<p>3.<a href=\"https://blog.csdn.net/jenny8080/article/details/52094140\" target=\"_blank\" rel=\"noopener\">线程同步(互斥锁与信号量的作用与区别)</a></p>\n<p>4.<a href=\"http://www.cocoachina.com/ios/20171218/21570.html\" target=\"_blank\" rel=\"noopener\">iOS的线程安全与锁</a></p>\n<p>5.<a href=\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/\" target=\"_blank\" rel=\"noopener\">不再安全的 OSSpinLock</a></p>\n<p>6.<a href=\"http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/\" target=\"_blank\" rel=\"noopener\">关于 @synchronized，这儿比你想知道的还要多</a></p>\n<p>7.<a href=\"https://www.jianshu.com/p/ddbe44064ca4\" target=\"_blank\" rel=\"noopener\">iOS 常见知识点（三）：Lock</a></p>\n<p>8.<a href=\"https://bestswifter.com/ios-lock/\" target=\"_blank\" rel=\"noopener\">深入理解 iOS 开发中的锁</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Autoreleasepool原理分析","url":"http://hchong.net/2018/03/12/Autoreleasepool原理分析/","content":"<p>Autoreleasepool是用来管理内存的好工具, 官方推荐了几个我们要使用的地方:</p>\n<ul>\n<li>If you are writing a program that is not based on a UI framework, such as a command-line tool.</li>\n<li>If you write a loop that creates many temporary objects. You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</li>\n<li>If you spawn a secondary thread. You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. </li>\n</ul>\n<p>下面我们来分析下他其中的实现. 本文是对大神博客的理解和拾遗. </p>\n<h2 id=\"AutoreleasePoolPage\"><a href=\"#AutoreleasePoolPage\" class=\"headerlink\" title=\"AutoreleasePoolPage\"></a>AutoreleasePoolPage</h2><p>ARC下我们使用<code>@autoreleasepool{}</code>来使用一个AutoreleasePool, 随后编译器将其改写成下面的样子: </p>\n<pre><code>void *context = objc_autoreleasePoolPush();\n// {}中的代码\nobjc_autoreleasePoolPop(context);\n</code></pre><p>而这两个函数都是对AutoreleasePoolPage的简单封装, 所以核心在AutoreleasePoolPage. AutoreleasePoolPage是一个C++类. </p>\n<pre><code>magic_t const magic;\nid *next;\npthread_t const thread;\nAutoreleasePoolPage * const parent;\nAutoreleasePoolPage *child;\nuint32_t const depth;\nuint32_t hiwat;\n</code></pre><p>他并没有单独的节后是由若干个AutoreleasePoolPage以双向链表的形式组合而成. AutoreleasePool是按线程一一对应的. AutoreleasePoolPage每个对象会开辟4096字节内存(也就是虚拟内存一页的大小), 除了上面的实例变量所占空间, 剩下的空间全部用来储存autorelease对象的地址. <code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置. 一个AutoreleasePoolPage的空间被占满时, 会新建一个AutoreleasePoolPage对象, 连接链表, 后来的autorelease对象在新的page加入.</p>\n<p>下面是AutoreleasePoolPage中存储数据的示例,<br><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg\" alt=\"AutoreleasePoolPage存储示例\"><br>如果这一页满了的话(next指针马上指向栈顶), 这是就要建立下一页page对象, 与这一页链表链接完成后, 新page的next指针被初始化在栈底, 然后继续向栈中添加对象.<br>所以, 向一个对象发送- autorelease消息, 就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置.</p>\n<h2 id=\"释放时刻\"><a href=\"#释放时刻\" class=\"headerlink\" title=\"释放时刻\"></a>释放时刻</h2><p>AutoreleasePool 是在两次 RunLoop 之间释放, 系统会把需要 release 的对象集中释放掉.</p>\n<p>每次调用<code>objc_autoreleasePoolPush</code>时, runtime就向AutoreleasePoolPage中add一个哨兵对象, 值为nil. objc_autoreleasePoolPush的返回值正是这个哨兵对象的地址, 被objc_autoreleasePoolPop(哨兵对象)作为入参.</p>\n<p>根据传入的哨兵对象地址找到哨兵对象所处的page, 在当前page中, 将晚于哨兵对象插入的所有autorelease对象都发送一次release, 从最新加入的对象一直向前清理, 可以向前跨越若干个page, 直到哨兵所在的page. 然后将next指针指向正确的位置.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">黑幕背后的Autorelease</a></p>\n<p>2.<a href=\"https://draveness.me/autoreleasepool\" target=\"_blank\" rel=\"noopener\">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></p>\n<p>3.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-RunLoop","url":"http://hchong.net/2018/03/11/iOS开发总结系列-RunLoop/","content":"<p>这篇主要是RunLoop相关的知识, 具体关于RunLoop可以看<a href=\"http://hchong.net/2017/12/11/RunLoop%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">RunLoop用法与分析</a></p>\n<h2 id=\"RunLoop和线程是什么关系\"><a href=\"#RunLoop和线程是什么关系\" class=\"headerlink\" title=\"RunLoop和线程是什么关系\"></a>RunLoop和线程是什么关系</h2><p>普通线程执行的任务是一条直线, 任务执行完就释放掉. RunLoop可以理解为特殊的线程, 这个现成不断的循环. 每个线程, 包括程序的主线程（main thread）都有与之相应的run loop对象.</p>\n<p>他们之间的关系(CFDictionarySetValue(loopsDic, thread, loop);), 线程和 RunLoop 之间是一一对应的, 他们之间的关系保存在一个全局的字典中(key 是 pthread_t, value 是 CFRunLoopRef), 线程刚创建时是没有RunLoop的, 如果不主动获取就一直不会有, RunLoop的创建是发生在第一次获取时, RunLoop的销毁发生自线程结束时. 只能在一个线程的内部获取其RunLoop.</p>\n<h2 id=\"runloop的mode作用是什么\"><a href=\"#runloop的mode作用是什么\" class=\"headerlink\" title=\"runloop的mode作用是什么\"></a>runloop的mode作用是什么</h2><p>主要是用来指定事件在运行循环中的优先级, 系统默认注册了5个Mode: </p>\n<ul>\n<li>NSDefaultRunLoopMode:(kCFRunLoopDefaultMode, 公开) App的默认Mode, 通常主线程是在这个Mode下运行, App 平时就是处在这个状态.</li>\n<li>UITrackingRunLoopMode: 界面跟踪 Mode, 用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响.</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode, 启动完成后就不再使用.</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode, 通常用不到.</li>\n<li>NSRunLoopCommonModes:(kCFRunLoopCommonModes, 公开) 这是一个占位用的Mode, 不是一种真正的Mode</li>\n</ul>\n<p>一个runloop可以包含多个model, 每个model都是独立的, 而且runloop只能选择一个model运行, 也就是currentModel. 如果需要切换 Mode, 只能退出 Loop, 再重新指定一个 Mode 进入. 这样做主要是为了分隔开不同组的 Source/Timer/Observer, 让其互不影响. </p>\n<p>这里有个概念叫 “CommonModes”: 一个 Mode 可以将自己标记为”Common”属性(通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中). 每当 RunLoop 的内容发生变化时, RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common”标记的所有Mode里.</p>\n<h2 id=\"以-scheduledTimerWithTimeInterval的方式触发的timer-在滑动页面上的列表时-timer会暂定回调，为什么？如何解决\"><a href=\"#以-scheduledTimerWithTimeInterval的方式触发的timer-在滑动页面上的列表时-timer会暂定回调，为什么？如何解决\" class=\"headerlink\" title=\"以+ scheduledTimerWithTimeInterval的方式触发的timer, 在滑动页面上的列表时, timer会暂定回调，为什么？如何解决\"></a>以+ scheduledTimerWithTimeInterval的方式触发的timer, 在滑动页面上的列表时, timer会暂定回调，为什么？如何解决</h2><p>RunLoop只能运行在一种mode下, 如果要换mode, 当前的loop也需要停下重启成新的. 利用这个机制, ScrollView滚动过程中NSDefaultRunLoopMode(kCFRunLoopDefaultMode)的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动: 只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动. 如果我们把一个NSTimer对象以NSDefaultRunLoopMode(kCFRunLoopDefaultMode)添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换, 而导致NSTimer将不再被调度.<br>正常情况下, 我们可能这样使用NSTimer:</p>\n<pre><code>    [NSTimer scheduledTimerWithTimeInterval:1.0\n                                     target:self\n                                   selector:@selector(timerTick)\n                                   userInfo:nil\n                                    repeats:YES];\n</code></pre><p>这个问题有两个解决方案:</p>\n<ol>\n<li><p>我们使用创建一个NSTimer对象, 我们把它添加到当前的RunLoop中去, 指定他的Mode为NSRunLoopCommonModes, 或者分别加入到NSDefaultRunLoopMode和UITrackingRunLoopMode中.</p>\n<pre><code> NSTimer *timer = [NSTimer timerWithTimeInterval:1.0\n      target:self\n      selector:@selector(timerTick:)\n      userInfo:nil\n      repeats:YES];\n //分别加入两种Mode中\n [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n [[NSRunLoop mainRunLoop] addTimer:timer forMode: UITrackingRunLoopMode];\n //加入CommonMode中\n [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n</code></pre></li>\n<li><p>使用GCD定时器</p>\n<pre><code> @property (nonatomic, strong) dispatch_source_t timer;\n\n // 获得队列\n dispatch_queue_t queue = dispatch_get_main_queue();\n // 创建一个定时器(dispatch_source_t本质还是个OC对象)\n self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n // 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）\n // GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）\n // 比当前时间晚1秒开始执行\n dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));\n //每隔一秒执行一次\n uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);\n dispatch_source_set_timer(self.timer, start, interval, 0);\n // 设置回调\n dispatch_source_set_event_handler(self.timer, ^{\n     NSLog(@&quot;------------%@&quot;, [NSThread currentThread]);\n });\n // 启动定时器\n dispatch_resume(self.timer);\n</code></pre><h2 id=\"猜想runloop内部是如何实现的\"><a href=\"#猜想runloop内部是如何实现的\" class=\"headerlink\" title=\"猜想runloop内部是如何实现的\"></a>猜想runloop内部是如何实现的</h2><p><img src=\"https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png\" alt=\"RunLoop内部逻辑\"></p>\n</li>\n<li><p>通知观察者, RunLoop已经启动.</p>\n</li>\n<li>通知观察者, 将要处理定时器.</li>\n<li>通知观察者, 将要处理Source0(即将启动的非基于端口的源).</li>\n<li>启动任何准备好的Source0(非基于端口的源).</li>\n<li>如果有任何Source1(基于端口的源)准备好并且处于等待状态, 立即启动, 并进入步骤9.</li>\n<li>通知所有观察者, 线程即将进入休眠.</li>\n<li>线程处于休眠状态, 直到遇到下列事件中的任意一个:<ul>\n<li>某一事件到达Source0(非基于端口的源)</li>\n<li>NSTimer定时器启动</li>\n<li>RunLoop设置的时间已经超时</li>\n<li>RunLoop被外部手动显示唤醒.</li>\n</ul>\n</li>\n<li>通知观察者, 线程刚被唤醒</li>\n<li>处理唤醒时收到的事件:<ul>\n<li>如果是定时器启动, 处理定时器并重启RunLoop, 进入步骤2</li>\n<li>如果是输入源启动, 传递相应的消息</li>\n<li>如果是RunLoop被显式唤醒(Source1), 重启RunLoop, 进入步骤2</li>\n</ul>\n</li>\n<li>通知观察者RunLoop即将结束.<br>详细内容参考<a href=\"http://hchong.net/2017/12/11/RunLoop%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">RunLoop用法与分析</a>.<h2 id=\"autoreleasepool如何实现-一个autoreleasepool对象何时释放\"><a href=\"#autoreleasepool如何实现-一个autoreleasepool对象何时释放\" class=\"headerlink\" title=\"autoreleasepool如何实现, 一个autoreleasepool对象何时释放\"></a>autoreleasepool如何实现, 一个autoreleasepool对象何时释放</h2>可以看<a href=\"https://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">这里</a>, <a href=\"https://draveness.me/autoreleasepool\" target=\"_blank\" rel=\"noopener\">这里</a>, <a href=\"http://hchong.net/2018/03/23/Autoreleasepool%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/\">这里</a></li>\n</ol>\n<p>autoreleasepool实际上被两个函数<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>包括, 这两个函数的实质又是AutoreleasePoolPage.<br>AutoreleasePoolPage是一个双向链表, 存储了对象的内存地址. AutoreleasePoolPage里面有个next指针, 当向一个对象发送- autorelease消息, 就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置.<br>每次调用<code>objc_autoreleasePoolPush()</code>, runtime就向链表中插入一个哨兵对象(nil), <code>objc_autoreleasePoolPush()</code>的返回值正是这个哨兵对象的地址. <code>objc_autoreleasePoolPop()</code>的入参也是这个哨兵对象的地址, 根据传入的哨兵对象地址找到哨兵对象所处的page, 在当前page中(从最新加入的对象一直向前清理, 可以向前跨越若干个page, 直到哨兵所在的page), 将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息, 并向回移动next指针到正确位置.</p>\n<p>在没有手加Autorelease Pool的情况下, Autorelease对象是在当前的runloop迭代结束时释放的, 而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop.</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-Runtime","url":"http://hchong.net/2018/03/07/iOS开发总结系列-Runtime/","content":"<p>这篇主要是RunTime相关的知识, 具体关于RunTime可以看<a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">RunTime用法与分析</a></p>\n<h2 id=\"什么时候会报unrecognized-selector的异常\"><a href=\"#什么时候会报unrecognized-selector的异常\" class=\"headerlink\" title=\"什么时候会报unrecognized selector的异常\"></a>什么时候会报unrecognized selector的异常</h2><p>涉及到消息的转发阶段知识<a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">Runtime用法与分析</a></p>\n<p>当调用该对象上某个方法, 而该对象上没有实现这个方法的时候, 可以通过“消息转发”进行解决. objc在向一个对象发送消息时, runtime库会根据对象的isa指针找到该对象实际所属的类, 然后在该类中的方法列表以及其父类方法列表中寻找方法运行, 如果在最顶层的父类中依然找不到相应的方法时, 程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX. 但是在这之前, objc的运行时会给出三次拯救程序崩溃的机会.</p>\n<ol>\n<li>Method resolution阶段. objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>, 让你有机会提供一个函数实现. 如果你添加了函数, 那运行时系统就会重新启动一次消息发送的过程, 否则, 运行时就会移到下一步, 消息转发(Message Forwarding).</li>\n<li>Fast forwarding阶段. 如果目标对象实现了<code>-forwardingTargetForSelector:</code>方法, Runtime这时就会调用这个方法, 给你把这个消息转发给其他对象的机会. 只要这个方法返回的不是nil和self, 整个消息发送过程会被重启, 当然发送的对象会变成你返回的那个对象. 否则就会继续Normal fowarging. 这里叫做Fast只是为了区别下一步的转发机制, 因为这一步不会创建任何新的对象, 但下一步会转发会创建一个NSInvocation对象, 所以相对更快一点.</li>\n<li>Normal forwarding阶段. 这一步是Runtime最后给你的挽救机会. 首先会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型. 如果<code>-methodSignatureForSelector:</code>返回nil, Runtime就会发出<code>-doesNotRecognizeSelector:</code>消息, 程序这时候就挂掉了. 如果返回了一个函数签名, Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象. </li>\n</ol>\n<h2 id=\"一个objc对象如何进行内存布局\"><a href=\"#一个objc对象如何进行内存布局\" class=\"headerlink\" title=\"一个objc对象如何进行内存布局\"></a>一个objc对象如何进行内存布局</h2><p>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.<br>每一个对象内部都有一个isa指针, 指向他的类对象, 类对象中存放着本对象的对象方法列表, 成员列表的变量, 属性列表.<br>类的内部也有一个isa指针, 指向原类, 原类内部存放得失类方法列表, 内部也有一个superclass指针, 指向他的父类对象.</p>\n<h2 id=\"objc-msgForward函数是做什么的-直接调用它将会发生什么\"><a href=\"#objc-msgForward函数是做什么的-直接调用它将会发生什么\" class=\"headerlink\" title=\"_objc_msgForward函数是做什么的, 直接调用它将会发生什么\"></a>_objc_msgForward函数是做什么的, 直接调用它将会发生什么</h2><p>_objc_msgForward是 IMP 类型, 用于消息转发: 当向一个对象发送一条消息, 但它并没有实现的时候, _objc_msgForward会尝试做消息转发.</p>\n<p>首先我们从消息的查找看起:</p>\n<pre><code>id objc_msgSend(id self, SEL op, ...) {\n    if (!self) return nil;\n    IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);\n    imp(self, op, ...); //调用这个函数，伪代码...\n}\n\n//查找IMP\nIMP class_getMethodImplementation(Class cls, SEL sel) {\n    if (!cls || !sel) return nil;\n    IMP imp = lookUpImpOrNil(cls, sel);\n    if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发\n    return imp;\n}\n\nIMP lookUpImpOrNil(Class cls, SEL sel) {\n    if (!cls-&gt;initialize()) {\n        _class_initialize(cls);\n    }\n\n    Class curClass = cls;\n    IMP imp = nil;\n    do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询\n        if (!curClass) break;\n        if (!curClass-&gt;cache) fill_cache(cls, curClass);\n        imp = cache_getImp(curClass, sel);\n        if (imp) break;\n    } while (curClass = curClass-&gt;superclass);\n\n    return imp;\n}\n</code></pre><p>我们可以看出, _objc_msgForward 是一个函数指针(和 IMP 的类型一样), 是用于消息转发的: 当向一个对象发送一条消息, 但没有实现的时候, _objc_msgForward会尝试做消息转发.</p>\n<p>我们向一个对象发送一条错误的消息, 然后在程序中加入断点或者暂停程序运行, 并在 gdb 中输入下面的命令: <code>call (void)instrumentObjcMessageSends(YES)</code>. 之后, 运行时发送的所有消息都会打印到/tmp/msgSend-xxxx文件里了. 终端中输入命令<code>open /private/tmp</code>前往文件夹, 找到最新生成的, 双击打开.</p>\n<p>在里面我们可以看到整个程序运行时调用的方法, 排除NSObject做的事, 剩下的就是<code>_objc_msgForward</code>消息转发做的事(实际也是消息转发的整个完整流程, <a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">Runtime用法与分析</a>). </p>\n<ol>\n<li>调用resolveInstanceMethod:方法 (或 resolveClassMethod:). 允许用户在此时为该 Class 动态添加实现. 如果有实现了, 则调用并返回YES, 那么重新开始objc_msgSend流程. 这一次对象会响应这个选择器, 一般是因为它已经调用过class_addMethod. 如果仍没实现, 继续下面的动作.</li>\n<li>调用forwardingTargetForSelector:方法, 尝试找到一个能响应该消息的对象. 如果获取到, 则直接把消息转发给它, 返回非 nil 对象. 否则返回 nil, 继续下面的动作. 注意, 这里不要返回 self, 否则会形成死循环.</li>\n<li>调用methodSignatureForSelector:方法, 尝试获得一个方法签名. 如果获取不到, 则直接调用doesNotRecognizeSelector抛出异常. 如果能获取, 则返回非nil: 创建一个 NSlnvocation 并传给forwardInvocation:.</li>\n<li>调用forwardInvocation:方法, 将第3步获取到的方法签名包装成 Invocation 传入, 如何处理就在这里面了, 并返回非nil.</li>\n<li>调用doesNotRecognizeSelector:, 默认的实现是抛出异常. 如果第3步没能获得一个方法签名, 执行该步骤.</li>\n</ol>\n<p>上面前4个方法均是模板方法, 开发者可以override, 由 runtime 来调用. 最常见的实现消息转发: 就是重写方法3和4, 忽略掉一个消息或者代理给其他对象.</p>\n<p>一旦调用_objc_msgForward, 将跳过查找 IMP 的过程, 直接触发”消息转发”. 具体可以看上面消息查找的具体过程. 可能会导致抛出unrecoginised selector的异常而导致程序crash. </p>\n<h2 id=\"能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h2><p>不能向编译后的类中增加实例变量, 因为已经注册在runtime中, 类结构体中的objc_ivar_list(实例变量链表)和instance_size(实例变量的内存大小)已经确定, 同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用, 所以不能向存在的类中添加实例变量.</p>\n<p>可以向运行时创建的类中添加实例变量, 直接调用class_addIvar函数, 但是得在调用 objc_allocateClassPair 之后, objc_registerClassPair 之前, 原因同上.</p>\n<h2 id=\"load-vs-initialize\"><a href=\"#load-vs-initialize\" class=\"headerlink\" title=\"+load vs +initialize\"></a>+load vs +initialize</h2><p>+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的, 实现这个方法可以让我们在类加载的时候执行一些类相关的行为. 子类的 +load 方法会在它的所有父类的 +load 方法之后执行, 而分类的 +load 方法会在它的主类的 +load 方法之后执行. 但是不同的类之间的 +load 方法的调用顺序是不确定的.<br>对 +load 方法进行调用使用的是<code>(*load_method)(cls, SEL_load)</code>，而不是使用发送消息 objc_msgSend 的方式. 这样的调用方式就使得 +load 方法拥有了一个非常有趣的特性, 那就是子类、父类和分类中的 +load 方法的实现是被区别对待的. 也就是说如果子类没有实现 +load 方法, 那么当它被加载时 runtime 是不会去调用父类的 +load 方法的. 同理, 当一个类和它的分类都实现了 +load 方法时, 两个方法都会被调用.</p>\n<p>+initialize 方法是在类或它的子类收到第一条消息之前被调用的, 这里所指的消息包括实例方法和类方法的调用. 也就是说 +initialize 方法是以懒加载的方式被调用的, 如果程序一直没有给某个类或它的子类发送消息, 那么这个类的 +initialize 方法是永远不会被调用的. 这么做节省了系统资源, 避免浪费.<br>runtime 使用了发送消息 objc_msgSend 的方式对 +initialize 方法进行调用. 也就是说 +initialize 方法的调用与普通方法的调用是一样的, 走的都是发送消息的流程. 如果子类没有实现 +initialize 方法, 那么继承自父类的实现会被调用; 如果一个类的分类实现了 +initialize 方法, 那么就会对这个类中的实现造成覆盖.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>+load</th>\n<th>+initialize</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本质</td>\n<td>(*load_method)(cls, SEL_load)</td>\n<td>(*load_method)(cls, SEL_load)</td>\n</tr>\n<tr>\n<td>调用时机</td>\n<td>被添加到runtime时</td>\n<td>直到给他的某个分类或它的子类发送消息</td>\n</tr>\n<tr>\n<td>调用顺序</td>\n<td>父类-&gt;子类-&gt;分类</td>\n<td>父类-&gt;子类</td>\n</tr>\n<tr>\n<td>调用次数</td>\n<td>1次</td>\n<td>多次</td>\n</tr>\n<tr>\n<td>是否需要显式调用父类实现</td>\n<td>不会</td>\n<td>不会</td>\n</tr>\n<tr>\n<td>是否沿用父类方法</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>分类中的实现</td>\n<td>类和分类都执行</td>\n<td>分类会覆盖类中的方法, 只执行分类的实现</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Method-swizzling\"><a href=\"#Method-swizzling\" class=\"headerlink\" title=\"Method swizzling\"></a>Method swizzling</h2><p>该特性的实质是, 为类添加一个新的方法, 然后将目标方法和新的方法的IMP进行互换, 结果就是修改selector和IMP的对应关系.</p>\n<p>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP.<br>我们可以利用 class_replaceMethod 来修改类.<br>我们可以利用 method_setImplementation 来直接设置某个方法的IMP.<br>…<br>归根到底都是更换selector的IMP(函数指针, 指向方法的实现).</p>\n<h2 id=\"如何使用runtime-hook类方法和实例方法\"><a href=\"#如何使用runtime-hook类方法和实例方法\" class=\"headerlink\" title=\"如何使用runtime hook类方法和实例方法\"></a>如何使用runtime hook类方法和实例方法</h2><p>使用Method Swizzling 方法. swizzling大多时候是在category中的+load方法中使用, 也可以创建hook的管理类, 放在里面使用.</p>\n<p>使用<code>class_getInstanceMethod</code>来获取实例方法, 使用<code>class_getClassMethod</code>来获取类方法. </p>\n<ul>\n<li>我们可以利用 <code>class_addMethod</code>来检测方法是否存在.</li>\n<li>我们可以利用 <code>method_exchangeImplementations</code> 来交换2个方法中的IMP.</li>\n<li>我们可以利用 <code>class_replaceMethod</code> 来修改类.</li>\n<li>我们可以利用 <code>method_setImplementation</code> 来直接设置某个方法的IMP.</li>\n</ul>\n<p>下面是AFN中的写法:</p>\n<pre><code>static inline void af_swizzleSelector(Class class, SEL originalSelector, SEL swizzledSelector) {\n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    if (class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) {\n        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));\n    } else {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n</code></pre><h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>在iOS中代理的本质就是代理对象内存的传递和操作, 我们在委托方设置代理属性后, 实际上只是用一个id类型的指针将代理对象进行了一个弱引用. 委托方让代理方执行协议, 实际上是在委托方中向这个id类型的指针指向的对象(代理方对象)发送消息.</p>\n<p>委托方的代理属性本质上就是代理对象自身, 设置委托代理就是代理属性指针指向代理对象, 相当于代理对象只是在委托方中调用自己的方法. 如果方法没有实现就会报错(代理方没有实现委托方中协议中的方法).</p>\n<p>协议只是一种语法, 是声明委托方中的代理属性可以调用协议中声明的方法. 如果代理方遵守协议那么协议中方法的实现就会加入到代理方类的objc_protocol_list中去. 委托方的self.delegate实际指向代理方的地址, 消息转发到代理方那里, 调用代理方objc_protocol_list中的实现.</p>\n<h2 id=\"为什么category不能添加属性可以添加方法\"><a href=\"#为什么category不能添加属性可以添加方法\" class=\"headerlink\" title=\"为什么category不能添加属性可以添加方法\"></a>为什么category不能添加属性可以添加方法</h2><p>因为category在runtime中是用一个结构体表示的, 结构体在C中是初始化完成后是不能改变的, 但是方法是一个链表, 他是可以往里面添加新的方法的.</p>\n<pre><code>struct _category_t {\n    const char *name;\n    struct _class_t *cls;\n    const struct _method_list_t *instance_methoods;\n    const struct _method_list_t *class_methods;\n    const struct _protocol_list_t *protocols;\n    const struct _prop_list_t *properties;\n}\n</code></pre><p>这里面虽然可以添加property, 但是这些property并不会自动生成Ivar, 也就是不会有 @synthesize 的作用. dyld加载的期间, 这些categories会被加载并patch到相应的类中, 这个过程是动态的, Ivar不能动态添加, 因为表示ObjC类的结构体运行时并不能改变. </p>\n","categories":["基础知识"],"tags":["基础知识","Runtime"]},{"title":"iOS开发总结系列-属性关键字","url":"http://hchong.net/2018/03/01/iOS开发总结系列-属性关键字/","content":"<p>常见的问题, 在这里做一个汇总. 只讲结论, 内部细节, 慢慢填坑.</p>\n<h2 id=\"什么情况使用-weak-关键字，相比-assign-有什么不同\"><a href=\"#什么情况使用-weak-关键字，相比-assign-有什么不同\" class=\"headerlink\" title=\"什么情况使用 weak 关键字，相比 assign 有什么不同\"></a>什么情况使用 weak 关键字，相比 assign 有什么不同</h2><p>weak常用在有可能出现循环引用的地方, 他表示一种非拥有关系, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 与assign类似, 但是不同的是当属性所指的对象被释放时, 属性值会被置为nil, 而assign只执行基础类型的简单赋值操作. </p>\n<p>weak必须用于OC对象类型, assign可以用于基础类型.</p>\n<h2 id=\"怎么用-copy-关键字\"><a href=\"#怎么用-copy-关键字\" class=\"headerlink\" title=\"怎么用 copy 关键字\"></a>怎么用 copy 关键字</h2><ol>\n<li>NSString, NSArray, NSDictionary 等等经常使用copy关键字, 是因为他们有对应的可变类型: NSMutableString, NSMutableArray, NSMutableDictionary. </li>\n<li>若想令自己所写的对象具有拷贝功能要实现NSCopying. 如果自定义的对象分为可变版本与不可变版本, 那么就要同时实现 NSCopying 与 NSMutableCopying 协议.</li>\n<li>block 也经常使用 copy 关键字. </li>\n</ol>\n<p>对可变对象进行copy, 返回的会是一个不可变对象, 并不是一般意义上的copy行为, 因为copy后的对象类型不同了.<br>对可变对象进行mutableCopy, 返回的是另一个可变对象, 这种才是copy行为, 两个对象内容一样, 类型一样, 地址不同.<br>对不可变对象进行copy, 系统不会再创建对象, 而是直接返回源对象地址.<br>对不可变对象进行mutableCopy则返回一个可变对象, 同样不是一般意义上的copy.</p>\n<p>block使用关键字copy是MRC时代的产物, 因为Block有三种类型, _NSConcreteStackBlock, _NSConcreteGlobalBlock, _NSConcreteMallocBlock. 由于_NSConcreteStackBlock存储在栈上面, 一旦返回之后所属的变量域一旦结束, 就被系统销毁了, 所以他是不安全的, 我们通过copy属性可以把它存储在堆上面, 生命周期我们就可以控制了. 在 MRC 中, 方法内部的 block 是在栈区的, 使用 copy 可以把它放到堆区. 在 ARC 中写不写都行: 对于 block 使用 copy 还是 strong 效果是一样的. 可以参考<a href=\"http://hchong.net/2017/07/04/Block%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/\">这里</a>.</p>\n<h2 id=\"对象的copy与mutableCopy\"><a href=\"#对象的copy与mutableCopy\" class=\"headerlink\" title=\"对象的copy与mutableCopy\"></a>对象的copy与mutableCopy</h2><p>在集合类对象中, 对不可变对象进行 copy, 是指针复制(浅copy), mutableCopy 是内容复制(深copy); 对可变对象进行 copy 和 mutableCopy 都是内容复制(深copy). 但是集合对象的内容复制仅限于对象本身, 对象元素仍然是指针复制. </p>\n<p>可以参考<a href=\"http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/\">这里</a>.</p>\n<h2 id=\"runtime-如何实现-weak-属性\"><a href=\"#runtime-如何实现-weak-属性\" class=\"headerlink\" title=\"runtime 如何实现 weak 属性\"></a>runtime 如何实现 weak 属性</h2><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship). 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 此特质同 assign 类似, 然而在属性所指的对象遭到摧毁时, 属性值也会清空(nil out).</p>\n<p>Runtime维护了一个weak表, 用于存储指向某个对象的所有weak指针. weak表其实是一个hash表, Key是所指对象的地址, Value是weak指针的地址(这个地址的值是所指对象的地址)数组. 当此对象的引用计数为0的时候会 dealloc, 假如 weak 指向的对象内存地址是a, 那么就会以a为键, 在这个 weak 表中搜索, 找到所有以a为键的 weak 对象, 从而设置为 nil. </p>\n<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil, ARC 会自动帮我们处理.</p>\n<p>详细的可以看<a href=\"http://www.cocoachina.com/ios/20170328/18962.html\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"property中有哪些属性关键字？-property-后面可以有哪些修饰符？\"><a href=\"#property中有哪些属性关键字？-property-后面可以有哪些修饰符？\" class=\"headerlink\" title=\"@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？\"></a>@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h2><ol>\n<li>原子性: nonatomic, atomic(默认值).</li>\n<li>读/写权限: readwrite(默认值), readonly.</li>\n<li>内存管理: assign, strong, weak, unsafe_unretained, copy.</li>\n<li>方法名: getter, setter.</li>\n<li>其他: nonnull, null_resettable, nullable.</li>\n</ol>\n<p>基本数据类型默认关键字: atomic, assign, readwrite. 对象类型默认关键字: atomic, strong, readwrite.</p>\n<p>atomic 会加一个@synchronized()锁, 并且引用计数会 +1, 来向调用者保证这个对象会一直存在, 但是这个锁并不能保证线程安全. </p>\n<h2 id=\"protocol-和-category-中如何使用-property\"><a href=\"#protocol-和-category-中如何使用-property\" class=\"headerlink\" title=\"@protocol 和 category 中如何使用 @property\"></a>@protocol 和 category 中如何使用 @property</h2><p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明, 我们使用属性的目的, 是希望遵守我协议的对象能实现该属性.</p>\n<p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明, 如果我们真的需要给 category 增加属性的实现, 需要借助于运行时的两个函数<code>objc_setAssociatedObject</code>和<br><code>objc_getAssociatedObject</code>.</p>\n<h2 id=\"property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h2><p>@property的本质是 ivar(实例变量) + getter + setter.</p>\n<pre><code>typedef struct objc_property *objc_property_t;\n\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n\ntypedef struct {\n    const char *name;           /**&lt; The name of the attribute */\n    const char *value;          /**&lt; The value of the attribute (usually empty) */\n} objc_property_attribute_t;\n</code></pre><p>attributes的具体内容包含: 类型, 原子性, 内存语义和对应的实例变量.</p>\n<p>我们每次在增加一个属性, 系统都会在 ivar_list 中添加一个成员变量的描述, 在 method_list 中增加 setter 与 getter 方法的描述, 在属性列表中增加一个属性的描述, 然后计算该属性在对象中的偏移量, 然后给出 setter 与 getter 方法对应的实现, 在 setter 方法中从偏移量的位置开始赋值, 在 getter 方法中从偏移量开始取值, 为了能够读取正确字节数, 系统对象偏移量的指针类型进行了类型强转.</p>\n<p>详见<a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">Runtime用法与分析</a></p>\n<h2 id=\"synthesize和-dynamic分别有什么作用\"><a href=\"#synthesize和-dynamic分别有什么作用\" class=\"headerlink\" title=\"@synthesize和@dynamic分别有什么作用\"></a>@synthesize和@dynamic分别有什么作用</h2><p>@property有两个关键词, @synthesize(默认值)和@dynamic. </p>\n<p>@synthesize表示系统会默认添加一个@syntheszie var = _var的实例变量, 并且自动生成setter和getter方法. @synthesize 合成实例变量有以下几点规则:</p>\n<ol>\n<li>如果指定了成员变量的名称, 会生成一个指定的名称的成员变量.</li>\n<li>如果这个成员已经存在就不再生成了.</li>\n<li>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量.</li>\n</ol>\n<p>@synthesize的使用场景: </p>\n<ol>\n<li>同时重写了setter和getter时</li>\n<li>重写了只读属性的getter时</li>\n<li>在使用了@dynamic时</li>\n<li>在@Protocol和category中定义属性时</li>\n<li>重载父类的属性时, 来手动合成Ivar(实例变量/成员变量).</li>\n</ol>\n<p>@dynamic表示我们不需要系统自动生成, 由用户自己实现, 如果没有手动生成的话, 在使用过程中是会奔溃的.</p>\n<h2 id=\"block-vs-weak\"><a href=\"#block-vs-weak\" class=\"headerlink\" title=\"block vs weak\"></a><strong>block vs </strong>weak</h2><p><strong>weak主要是用来避免循环引用的. </strong>weak修饰的变量, 在block内部被捕获后, 和外部的实际不是用一个变量. 他是对外部<strong>weak修饰的对象进行了一个弱引用. 当我们在block外部把</strong>weak修饰的变量释放后, block内部夜读不到这个变量. 如果外部被__weak修饰的变量被置为nil, 那么内部的对象实际上也是nil, 就会被释放掉. </p>\n<p><strong>block实际上是提升了变量的作用域, 我们在block内外, 用</strong>block修饰的变量实际上不是同一个, 在block内部使用相当于被强引用了一份. <strong>block 本身无法避免循环引用的问题, 但是我们可以通过在 block 内部手动把 blockObj 赋值为 nil 的方式来避免循环引用的问题.<br>这里需要注意, 我们只能在堆上面block对象使用</strong>block修饰的对象, ARC下一旦block赋值就会触发copy, block就会被复制到堆上因此可以直接使用, 但是MRC下我们则需要手动调用copy, 否则会编译报错.<br>MRC下<strong>block修饰的变量在block中使用是不會retain的, ARC下是会retain的. 可以使用</strong>weak(ARC下使用, 但只支持iOS5以后)或是__unsafe_unretained来代替.</p>\n<h2 id=\"nonatomic和atomic的线程安全\"><a href=\"#nonatomic和atomic的线程安全\" class=\"headerlink\" title=\"nonatomic和atomic的线程安全\"></a>nonatomic和atomic的线程安全</h2><p>atomic: 原子操作, 系统会为setter方法加锁(@synchronized), 需要消耗大量系统资源来为属性加锁. atomic所说的线程安全只是保证了getter和setter存取方法的线程安全, 并不能保证整个对象是线程安全的.<br>例如当线程A进行写操作, 这时其他线程的读或者写操作会因为该操作而等待. 当A线程的写操作结束后, B线程进行写操作, 然后当A线程需要读操作时, 却获得了在B线程中的值, 这就破坏了线程安全, 如果有线程C在A线程读操作前release了该属性, 那么还会导致程序崩溃. 所以仅仅使用atomic并不会使得线程安全, 我们还要为线程添加lock来确保线程的安全.</p>\n<p>nonatomic: 不会为setter方法加锁, 线程不安全, 适合内存较小的移动设备.</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"KVO用法与自定义实现","url":"http://hchong.net/2018/01/24/KVO详解/","content":"<h1 id=\"KVO用法与自定义实现\"><a href=\"#KVO用法与自定义实现\" class=\"headerlink\" title=\"KVO用法与自定义实现\"></a>KVO用法与自定义实现</h1><h2 id=\"KVO用法\"><a href=\"#KVO用法\" class=\"headerlink\" title=\"KVO用法\"></a>KVO用法</h2><p>KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知. KVO的用法在这里不做叙述, 十分简单. 首先注册, 添加一个观察者:</p>\n<pre><code>- (void)addObserver:(NSObject *)observer\n         forKeyPath:(NSString *)keyPath\n            options:(NSKeyValueObservingOptions)options\n            context:(void *)context\n</code></pre><blockquote>\n<ul>\n<li>observer: 观察者，负责处理监听事件的对象, 注册 KVO 通知的对象。观察者必须实现 key-value observing 方法 observeValueForKeyPath:ofObject:change:context:</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>keyPath: 要监听的属性, 观察者的属性的 keypath，相对于接受者，值不能是 nil。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>options: 观察的选项(观察新、旧值，也可以都观察), NSKeyValueObservingOptions 的组合，它指定了观察通知中包含了什么，可以查看 “NSKeyValueObservingOptions”。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>context: 上下文，用于传递数据，可以利用上下文区分不同的监听, 在 observeValueForKeyPath:ofObject:change:context: 传给 observer 参数的随机数据</li>\n</ul>\n</blockquote>\n<p>当 keyPath 的值改变的时候这个方法会被调用:</p>\n<pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context\n</code></pre><blockquote>\n<ul>\n<li>keyPath 监听的属性名</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>object  属性所属的对象</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>change  属性的修改情况（属性原来的值<code>oldValue</code>、属性最新的值<code>newValue</code>）</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>context 传递的上下文数据，与监听的时候传递的一致，可以利用上下文区分不同的监听</li>\n</ul>\n</blockquote>\n<p>当一个观察者完成了监听一个对象的改变, 经常在 <code>-observeValueForKeyPath:ofObject:change:context:</code>，或者 <code>-dealloc</code> 中调用注销监听的方法:</p>\n<pre><code>- (void)removeObserver:(NSObject *)anObserver\n            forKeyPath:(NSString *)keyPath\n\n</code></pre><hr>\n<p>这里有几个特殊的方法需要着重说明一下, </p>\n<pre><code>- (void)willChangeValueForKey:(NSString *)key;\n- (void)didChangeValueForKey:(NSString *)key;\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;\n</code></pre><p><code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>默认是在setter方法中实现的, 用KVO做键值观察后, 系统会在运行时重写属性的set方法, 并且在赋值前后分别调用.</p>\n<p><code>automaticallyNotifiesObserversForKey:</code>控制是否自动发送通知, 如果返回NO, KVO无法自动运作, 需手动触发.</p>\n<h2 id=\"KVO的原理\"><a href=\"#KVO的原理\" class=\"headerlink\" title=\"KVO的原理\"></a>KVO的原理</h2><p>KVO 的实现也依赖于 Objective-C 强大的 Runtime. Apple 的文档有简单提到过 KVO 的实现: </p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>\n</blockquote>\n<blockquote>\n<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>\n</blockquote>\n<blockquote>\n<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>\n</blockquote>\n<blockquote>\n<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>\n</blockquote>\n<p>概述下KVO的实现就是: </p>\n<p>KVO 是通过 isa-swizzling 实现的. 当你观察一个对象时, 会动态创建一个新的类. 这个类继承自该对象的原本的类, 如果用户注册了对某此目标对象的某一个属性的观察，那么此派生类会重写被观察属性的 setter 方法，并在其中添加进行通知的代码. 自然, 重写的 setter 方法会负责在调用原 setter 方法之前和之后, 通知所有观察对象值的更改. 最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类, 对象就神奇的变成了新创建的子类的实例. 这个中间类, 继承自原本的那个类. 不仅如此, Apple 还重写了 -class 方法, 企图欺骗我们这个类没有变, 就是原本那个类.</p>\n<h2 id=\"如何实现带block回调的KVO\"><a href=\"#如何实现带block回调的KVO\" class=\"headerlink\" title=\"如何实现带block回调的KVO\"></a>如何实现带block回调的KVO</h2><p> 根据Apple的官方文档, 我们不难发现自定义KVO需要的几个步骤:</p>\n<ol>\n<li><p>创建注册子类, 重写子类的class方法</p>\n<pre><code>//1.创建注册子类\n//1.1获取被监听对象的类名称\nClass class = object_getClass(self);\nNSString *className = NSStringFromClass(class);\n//1.2检查被检测对象的class的前缀是否被替换过(通过检查前缀来判断), 如果被替换过就说明正在被观测\nif (![className hasPrefix:kHCKVOClassPrefix]) {\n    class = [self makeKvoClassWithOriginalClassName:className];\n    //为观测的对象设置一个指定的类\n    object_setClass(self, class);\n}\n</code></pre></li>\n<li><p>为新的子类添加set方法</p>\n<pre><code> //2.为新的子类添加set方法\n//2.1得到Setter方法\nSEL setterSelector = NSSelectorFromString(setterForGetter(key));\n//2.2得到指定类的实例方法\nMethod setterMethod = class_getInstanceMethod([self class], setterSelector);\nif (!setterMethod) {\n    @throw @&quot;没有对应的Setter方法&quot;;\n    return;\n}\n//2.3为新类添加set方法\nif (![self hasSelector:setterSelector]) {\n    const char *types = method_getTypeEncoding(setterMethod);\n    class_addMethod(class, setterSelector, (IMP)kvo_setter, types);\n}\n</code></pre></li>\n<li><p>改变isa指针, 指向新的子类</p>\n<pre><code>//3改变isa指针，指向子类\nobject_setClass(self, class);\n</code></pre></li>\n<li><p>保存set, get方法, 保存block</p>\n<pre><code>//保存set、get方法名\n    objc_setAssociatedObject(self, kHCKVO_getter_key, key, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    objc_setAssociatedObject(self, kHCKVO_setter_key, setterForGetter(key), OBJC_ASSOCIATION_COPY_NONATOMIC);\n    //保存block\n    objc_setAssociatedObject(self, kHCKVO_block_key, block, OBJC_ASSOCIATION_COPY_NONATOMIC);\n</code></pre></li>\n</ol>\n<p>这里面主要的难点在重写属性的set方法, 代码如下:</p>\n<pre><code>//新类的set方法\nstatic void kvo_setter(id self, SEL _cmd, id newValue) {\n    //包括调用父类的set方法，获取旧值、新值，获取observer并通知observer\n    NSString *setterName = NSStringFromSelector(_cmd);\n    NSString *getterName = getterForSetter(setterName);\n\n    if (!getterName) {\n        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have getter %@&quot;, self, setterName];\n        @throw [NSException exceptionWithName:NSInvalidArgumentException\n                                       reason:reason\n                                     userInfo:nil];\n        return;\n    }\n\n    /*\n     //使用objc_msgSendSuper向父类发消息, 调用父类set方法\n    id oldValue = [self valueForKey:getterName];\n\n    //superclass\n    struct objc_super superclazz = {\n        .receiver = self,\n        .super_class = class_getSuperclass(object_getClass(self))\n    };\n    // cast our pointer so the compiler won&#39;t complain\n    void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper;\n    // call super&#39;s setter, which is original class&#39;s setter method\n    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);\n     */\n\n\n    //保存子类类型\n    Class class = [self class];\n    //isa指向原类\n    object_setClass(self, class_getSuperclass(class));\n    //调用原类get方法，获取oldValue\n    id oldValue = objc_msgSend(self, NSSelectorFromString(getterName));\n    //调用原类set方法\n    objc_msgSend(self, _cmd, newValue);\n    //isa改回子类类型\n    object_setClass(self, class);\n\n\n    //取出block\n    HCObservingBlock block = objc_getAssociatedObject(self, kHCKVO_block_key);\n    block(self, getterName, oldValue, newValue);\n}\n</code></pre><p>其中, 关于调用父类的set方法有两种方式. 一种是直接向新类的superClass发送消息, 另外一种是先改变isa指向superclass, 调用完set方法后重新再改变isa指向新类.</p>\n<h2 id=\"如何实现系统自带的KVO\"><a href=\"#如何实现系统自带的KVO\" class=\"headerlink\" title=\"如何实现系统自带的KVO\"></a>如何实现系统自带的KVO</h2><p>系统自带KVO的实现方法和自定义带block回调的KVO的实现方法一样, 不同的是我们在重写新类的set方法中不是调用父类的set方法, 而是调用父类的<code>observeValueForKeyPath: ofObject: change: context:</code>方法.</p>\n<hr>\n<p>完整代码查看<a href=\"https://github.com/HChong3210/HCKVO\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://nshipster.cn/key-value-observing/\" target=\"_blank\" rel=\"noopener\">Key-Value Observing</a></p>\n<p>2.<a href=\"https://draveness.me/kvocontroller\" target=\"_blank\" rel=\"noopener\">如何优雅地使用 KVO</a></p>\n<p>3.<a href=\"https://github.com/facebook/KVOController\" target=\"_blank\" rel=\"noopener\">KVOController</a></p>\n<p>4.<a href=\"http://tech.glowing.com/cn/implement-kvo/\" target=\"_blank\" rel=\"noopener\">如何自己动手实现 KVO</a></p>\n","categories":["基础知识"],"tags":["基础知识","Runtime"]},{"title":"脚本批量下载网易云音乐歌曲","url":"http://hchong.net/2017/12/20/脚本批量下载网易云音乐歌曲/","content":"<h1 id=\"脚本批量下载网易云音乐歌曲\"><a href=\"#脚本批量下载网易云音乐歌曲\" class=\"headerlink\" title=\"脚本批量下载网易云音乐歌曲\"></a>脚本批量下载网易云音乐歌曲</h1><p>闲来无事用Python撸了一个可以批量下载网易云音乐的脚本, 大致实现方式如下:</p>\n<ol>\n<li>获取到要下载的歌曲的ID</li>\n<li>通过<code>http://music.163.com/song/media/outer/url?id=%s.mp3</code>链接来获取下载的真实链接</li>\n<li>伪造浏览器访问, 循环遍历下载至本地.</li>\n</ol>\n<p>当然在这里面也是有很多坑的, 如何获取歌曲ID, 因为我只想获取<em>我喜欢的歌</em>列表, 通过Charles抓包, 或者在浏览器里面<code>alt + command + J</code>打开开发者模式在Network中获取列表的JSON结果, 再通过正则来获取到有用的信息. 这个脚本需要改进的一点就是, 不能自己调用最喜欢的歌曲的API来自动获取JSON结果, 需要我们先复制进去.</p>\n<p>需要注意的是, 这样下载的歌曲不是最高音质的, 如果想要获取高音质的下载链接还有三种方式:</p>\n<ul>\n<li>播放音乐时通过Charles抓包来获取真实下载地址</li>\n<li>通过查看本地的Log日志, 来获取播放音乐的真实地址</li>\n<li>在缓存目录中查找已经听过的歌.</li>\n</ul>\n<p>上面这三种方式均可以获取真实有效地址, 但是不能批量获取, 并且名字都是一长串经过加密的字符串. </p>\n<hr>\n<p><a href=\"https://github.com/HChong3210/163musicDownload\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"http://blog.csdn.net/Ciiiiiing/article/details/62434438\" target=\"_blank\" rel=\"noopener\">网易云音乐API分析</a></p>\n<p>2.<a href=\"http://blog.csdn.net/jiisd/article/details/52207199\" target=\"_blank\" rel=\"noopener\"> 在 Mac 端获取【网易云音乐】付费音乐的播放地址</a></p>\n<p>3.<a href=\"http://www.889.name/gcw/rj/rj823.html\" target=\"_blank\" rel=\"noopener\">网易云音乐mp3外链、真实地址下载方法</a></p>\n<p>4.<a href=\"https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%8e%b7%e5%8f%96%e7%b2%be%e5%93%81%e6%ad%8c%e5%8d%95\" target=\"_blank\" rel=\"noopener\">网易云音乐 API</a></p>\n","categories":["Python"],"tags":["Python","脚本"]},{"title":"链式编程实践","url":"http://hchong.net/2017/12/17/链式编程实践/","content":"<p>链式编程是将多个操作, 通过<code>.</code>的形式连接在一起, 形成一句话, 以增强代码的阅读性. 链式编程的核心在于, 方法的返回值必须是<code>返回值是self, 参数为需要操作的值的block</code>. 下面我们来看一下Masonry中链式编程的应用.</p>\n<h2 id=\"Masonry中的应用\"><a href=\"#Masonry中的应用\" class=\"headerlink\" title=\"Masonry中的应用\"></a>Masonry中的应用</h2><p>Masonry的使用大致如下</p>\n<pre><code class=\"oc\">UIView *demo = [[UIView alloc] init];\n[self.view addSubview:demo];\n[demo mas_updateConstraints:^(MASConstraintMaker *make) {\n   make.left.equalTo(self.mas_left).offset(16);\n   make.centerY.equalTo(self.mas_centerY).offset(0);\n   make.width.height.equalTo(@(200));\n}];\n</code></pre>\n<p>这里只简单分析一下他链式编程的实现. 我们先看下<code>mas_makeConstraints</code>方法.</p>\n<pre><code class=\"oc\">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {\n    self.translatesAutoresizingMaskIntoConstraints = NO;\n    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];\n    block(constraintMaker);\n    return [constraintMaker install];\n}\n</code></pre>\n<p>这里一共有三步:</p>\n<ol>\n<li>创建一个<code>MASConstraintMaker</code>对象<code>constraintMaker</code>.</li>\n<li>调用<code>block(constraintMaker)</code>, 这样在外面我们调用<code>mas_makeConstraints</code>方法里面的<code>make</code>实际就是这里的<code>constraintMaker</code>. 相当于我们在外面调用地方写的控件的约束全部都保存到<code>constraintMaker</code>对象里面了.</li>\n<li>调用<code>[constraintMaker install]</code>方法, 先遍历卸载之前的约束, 再安装新的约束, 最后返回包含所有约束的数组.</li>\n</ol>\n<p>下面我们再看一下添加约束的步骤, 以<code>make.width.height.equalTo(@(200))</code>为例.</p>\n<pre><code class=\"oc\">@implementation MASConstraint\n- (MASConstraint *)width {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeWidth];\n}\n\n- (MASConstraint *)height {\n    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeHeight];\n}\n\n- (MASConstraint * (^)(id))equalTo {\n    return ^id(id attribute) {\n        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);\n    };\n}\n\n- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {\n    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];\n}\n\n@end\n</code></pre>\n<p>我们可以发现, <code>width</code>和<code>height</code>方法的返回值都是<code>MASConstraint</code>对象, 方法内部封装了 一些内部实现, 这样就可以无限的<code>.</code>下去.<br><code>equalTo</code>这样的方法需要通过<code>()</code>的方式传参进去, 并且还行要能一直<code>.</code>下去. 通过<code>()</code>的方式传参只有通过block, 想持续<code>.</code>必须返回<code>MASConstraint</code>对象, 所以<code>equalTo</code>的返回值是一个block<code>MASConstraint * (^)(id)</code>(返回值是self, 并且还有参数).</p>\n<p>总结一下核心就是:</p>\n<ul>\n<li>把要做的事封装到block, 给外界提供一个返回这个block的方法.</li>\n<li>方法返回值必须是block, block的返回值是方法调用者(一般就是self), block的参数是传入的需要操作的内容.</li>\n</ul>\n<h2 id=\"链式编程的Demo\"><a href=\"#链式编程的Demo\" class=\"headerlink\" title=\"链式编程的Demo\"></a>链式编程的Demo</h2><p>我们以完成一个计算器的Demo为例. 我们新建一个<code>Caculator</code>类来做计算, 实现<code>add</code>方法如下:</p>\n<pre><code class=\"oc\">@interface Caculator : NSObject\n\n@property (nonatomic, assign) NSInteger result;//结果\n\n//返回值是block(Caculator *(^)(NSInteger number)), 该block的返回值是Caculator*, 参数为NSInteger类型\n- (Caculator *(^)(NSInteger number))add;\n@end\n\n\n@implementation Caculator\n\n- (Caculator *(^)(NSInteger number))add {\n    return ^Caculator *(NSInteger number) {\n        self.result += number;\n        return self;\n    };\n}\n@end\n</code></pre>\n<p>要实现类似Masonry的调用方式, 就要再封装一层:</p>\n<pre><code class=\"oc\">@interface NSObject (Calculator)\n\n+ (NSInteger)makeCaculators:(void(^)(Caculator *make))block;\n@end\n\n\n@implementation NSObject (Calculator)\n\n+ (NSInteger)makeCaculators:(void(^)(Caculator *make))block {\n    Caculator *mgr = [[Caculator alloc] init];\n    block(mgr);\n    return mgr.result;\n}\n@end\n</code></pre>\n<p>在计算时调用这个方法，创建计算制造者，然后调用传入的block, 并且返回结果.</p>\n<pre><code>NSInteger result = [NSObject makeCaculators:^(Caculator *make) {\n    make.add(4).multiply(5).minus(4).divide(8).add(13);\n}];\n</code></pre><hr>\n<p>完整Demo地址在<a href=\"https://github.com/HChong3210/MethodChaining\" target=\"_blank\" rel=\"noopener\">这里</a>. <a href=\"https://www.jianshu.com/p/f53a3182f659\" target=\"_blank\" rel=\"noopener\">这篇</a>循序渐进, 写的也不错.</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Vue实践指南","url":"http://hchong.net/2017/12/11/Vue实践指南/","content":"","categories":[],"tags":[]},{"title":"Swift实践指南","url":"http://hchong.net/2017/12/11/Swift实践指南/","content":"","categories":[],"tags":[]},{"title":"HTTP请求中的GET与POST","url":"http://hchong.net/2017/12/11/HTTP请求中的GET与POST/","content":"<h1 id=\"HTTP请求中的GET与POST\"><a href=\"#HTTP请求中的GET与POST\" class=\"headerlink\" title=\"HTTP请求中的GET与POST\"></a>HTTP请求中的GET与POST</h1><p>GET和POST是网络请求到的两种基本方式, GET把参数包含在URL中, POST通过request body传递参数. </p>\n<p>GET在浏览器回退时是无害, 而POST会再次提交请求.<br>GET产生的URL地址可以保存为书签, 而POST不可以.<br>GET请求会被浏览器主动cache, 而POST不会, 除非手动设置.<br>GET请求只能进行url编码, 而POST支持多种编码方式.<br>GET请求参数会被完整保留在浏览器历史记录里, 而POST中的参数不会被保留.<br>GET请求在URL中传送的参数是有长度限制的, 而POST没有.<br>对参数的数据类型, GET只接受ASCII字符, 而POST没有限制.<br>GET比POST更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息.<br>GET参数通过URL传递, POST放在Request body中.</p>\n<p>GET和POST都是HTTP协议中的两种发送请求的方法.HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议.</p>\n<p>HTTP的底层是TCP/IP, 所以GET和POST的底层也是TCP/IP. 也就是说, GET/POST都是TCP链接. GET和POST能做的事情是一样一样的. 你要给GET加上request body, 给POST带上url参数, 技术上是完全行的通的.</p>\n<p>GET产生一个TCP数据包. POST产生两个TCP数据包.对于GET方式的请求, 浏览器会把http header和data一并发送出去, 服务器响应200(返回数据). 而对于POST, 浏览器先发送header, 服务器响应100 continue, 浏览器再发送data, 服务器响应200 ok(返回数据).</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"RunLoop用法与分析","url":"http://hchong.net/2017/12/11/RunLoop用法与分析/","content":"<p>RunLoop是iOS开发中一个常用的概念, 用来保证线程能够随时处理事件, 但是并不退出. 代码逻辑通常是这样的: </p>\n<pre><code>function loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n</code></pre><p>在iOS开发中RunLoop的主要作用是:</p>\n<ol>\n<li>保持程序的持续运行(如: 程序一启动就会开启一个主线程(线程中的 runloop 是自动创建并运行), runloop 保证主线程不会被销毁, 也就保证了程序的持续运行). </li>\n<li>处理App中的各种事件(如: touches 触摸事件, NSTimer 定时器事件, Selector事件(选择器 performSelector)).</li>\n<li>节省CPU资源, 提高程序性能(有事情就做事情, 没事情就休息(其资源释放)). </li>\n<li>负责渲染屏幕上的所有UI.</li>\n</ol>\n<p><a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>讲的实在太详细了, 这里只是做一个总结和拾遗. 官方文档可以看<a href=\"https://developer.apple.com/documentation/corefoundation/cfrunloop?language=objc\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"RunLoop的概念\"><a href=\"#RunLoop的概念\" class=\"headerlink\" title=\"RunLoop的概念\"></a>RunLoop的概念</h2><p>RunLoop实际上是一个对象, 这个对象管理了其需要处理的时间和消息, 并提供了一个入口函数来执行上面的逻辑, 线程执行了这个函数后, 就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中, 直到这个循环结束(比如传入 quit 的消息), 函数返回.</p>\n<p>iOS提供了两个这样的对象: NSRunLoop 和 CFRunLoopRef. CFRunLoopRef 是在 CoreFoundation 框架内的, 它提供了纯 C 函数的 API, 所有这些 API 都是线程安全的.<br>NSRunLoop 是基于 CFRunLoopRef 的封装, 提供了面向对象的 API, 但是这些 API 不是线程安全的.</p>\n<h2 id=\"RunLoop与线程的关系\"><a href=\"#RunLoop与线程的关系\" class=\"headerlink\" title=\"RunLoop与线程的关系\"></a>RunLoop与线程的关系</h2><p>CFRunLoop 是基于 pthread 来管理的. 苹果不允许直接创建 RunLoop, 它只提供了两个自动获取的函数: CFRunLoopGetMain() 和 CFRunLoopGetCurrent(). </p>\n<p>线程与RunLoop之间是一一对应的关系, 他们之间的关系(<code>CFDictionarySetValue(loopsDic, thread, loop);</code>)保存在一个全局的字典中(key 是 pthread_t, value 是 CFRunLoopRef), 线程刚创建时是没有RunLoop的, 如果不主动获取就一直不会有, RunLoop的创建是发生在第一次获取时, RunLoop的销毁发生自线程结束时. 只能在一个线程的内部获取其RunLoop. </p>\n<h2 id=\"RunLoop对外的接口\"><a href=\"#RunLoop对外的接口\" class=\"headerlink\" title=\"RunLoop对外的接口\"></a>RunLoop对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中 CFRunLoopModeRef 类并没有对外暴露, 只是通过 CFRunLoopRef 的接口进行了封装, 他们之间的关系如图所示.<br><img src=\"https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png\" alt=\"RunLoop类之间的关系\"></p>\n<p>Source/Timer/Observer 被统称为 mode item, 一个 item 可以被同时加入多个 mode. 但一个 item 被重复加入同一个 mode 时是不会有效果的. 如果一个 mode 中一个 item 都没有, 则 RunLoop 会直接退出, 不进入循环. </p>\n<h3 id=\"CFRunLoopSourceRef\"><a href=\"#CFRunLoopSourceRef\" class=\"headerlink\" title=\"CFRunLoopSourceRef\"></a>CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef是事件源(输入源), 例如外部的触摸, 点击事件和系统内部进程间的通信等. 按照官方文档Source主要分为: </p>\n<ul>\n<li>Input Sources: Input Sources以异步的方式将事件传递给线程, 通过分为两种:<ul>\n<li>Port-based input sources: Cocoa和Core Foundation提供了内置的支持, 可以使用端口相关的对象和函数创建基于端口的输入源. 我们不必直接创建输入源, 只需创建一个端口对象, 并使用NSPort的方法将该端口添加到运行循环中. 它是来监视应用程序的Mach端口, 消息由内核发出.</li>\n<li>Custom Input Sources: 我们使用CFRunLoopSourceRef来创建自定义输入源, 监视事件的自定义源, 消息由其他线程手动发出.</li>\n</ul>\n</li>\n<li>Cocoa Perform Selector Sources: 与基于端口的源不同, 我们可以在任何线程上perform a selector, 并且执行选择器源在执行选择器之后从运行循环中移除自己.</li>\n<li>Timer Sources: 在将来的预定时间内, 计时器源会同步地将事件发送到线程.<br>更多详细信息可以看<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1\" target=\"_blank\" rel=\"noopener\">Threading Programming Guide</a>.</li>\n</ul>\n<p>按照函数调用栈, Source主要分为两类:</p>\n<ul>\n<li>Source0: 非基于Port的. 只包含了一个回调(函数指针), 它并不能主动触发事件. 使用时, 需要先调用 CFRunLoopSourceSignal(source), 将这个 Source 标记为待处理, 然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop, 让其处理这个事件. </li>\n<li>Source1: 基于Port的, 通过内核和其他线程通信, 接收, 分发系统事件. 这种 Source 能主动唤醒 RunLoop 的线程. 创建常驻线程就是在线程中添加一个NSport来实现的.<h3 id=\"CFRunLoopObserverRef\"><a href=\"#CFRunLoopObserverRef\" class=\"headerlink\" title=\"CFRunLoopObserverRef\"></a>CFRunLoopObserverRef</h3>每个 Observer 都包含了一个回调(函数指针)当 RunLoop 的状态发生变化时, 观察者就能通过回调接受到这个变化. 可以观测的时间点有以下几个: </li>\n</ul>\n<pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop     （1）\n    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer   （2）\n    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source  （4）\n    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠      （32）\n    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒     (64)\n    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop      (128)\n    kCFRunLoopAllActivities = 0x0FFFFFFU, // 包含上面所有状态\n\n};\n</code></pre><h3 id=\"CFRunLoopTimerRef\"><a href=\"#CFRunLoopTimerRef\" class=\"headerlink\" title=\"CFRunLoopTimerRef\"></a>CFRunLoopTimerRef</h3><p>是基于时间的触发器, 它和 NSTimer 是toll-free bridged 的, 可以混用, 我们基本上可以认为他就是NSTimer,  其包含一个时间长度和一个回调(函数指针), 当其加入到 RunLoop 时, RunLoop会注册对应的时间点, 当时间点到时, RunLoop会被唤醒以执行那个回调.<br>它受RunLoop的Mode影响, GCD的定时器不受RunLoop的Mode影响.<br>注意, 这里这个NSTimer实际是有误差的</p>\n<h3 id=\"CFRunLoopModeRef\"><a href=\"#CFRunLoopModeRef\" class=\"headerlink\" title=\"CFRunLoopModeRef\"></a>CFRunLoopModeRef</h3><p>一个runloop可以包含多个model, 每个model都是独立的, 而且runloop只能选择一个model运行, 也就是currentModel. 如果需要切换 Mode, 只能退出 Loop, 再重新指定一个 Mode 进入. 这样做主要是为了分隔开不同组的 Source/Timer/Observer, 让其互不影响.</p>\n<p>系统默认注册了5个Mode:<br>NSDefaultRunLoopMode: App的默认Mode, 通常主线程是在这个Mode下运行, App 平时就是处在这个状态.<br>UITrackingRunLoopMode: 界面跟踪 Mode, 用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响.<br>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode, 启动完成后就不再使用.<br>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode, 通常用不到.<br>NSRunLoopCommonModes: 这是一个占位用的Mode, 不是一种真正的Mode.</p>\n<p>这里有个概念叫 “CommonModes”: 一个 Mode 可以将自己标记为”Common”属性(通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中). 每当 RunLoop 的内容发生变化时, RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common”标记的所有Mode里.<br>应用场景举例: 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作. 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到commonMode 中。那么所有被标记为commonMode的mode（defaultMode和TrackingMode）都会执行该timer。这样你在滑动界面的时候也能够调用timer，下面会有实例讲解</p>\n<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>\n<pre><code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);\nCFRunLoopRunInMode(CFStringRef modeName, ...);\n</code></pre><p>Mode暴露的管理Mode item的接口有下面几个: </p>\n<pre><code>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\nCFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\n</code></pre><p>你只能通过 mode name 来操作内部的 mode, 当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时, RunLoop会自动帮你创建对应的 CFRunLoopModeRef. 对于一个 RunLoop 来说, 其内部的 mode 只能增加不能删除.</p>\n<h2 id=\"RunLoop的内部逻辑\"><a href=\"#RunLoop的内部逻辑\" class=\"headerlink\" title=\"RunLoop的内部逻辑\"></a>RunLoop的内部逻辑</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/277755-1184c261c96d3116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"官方的RunLoop逻辑\"></p>\n<p>盗图一张, 大神总结的.<br><img src=\"https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png\" alt=\"RunLoop内部逻辑\"><br>运行RunLoop具体的流程如下: </p>\n<ol>\n<li>通知观察者, RunLoop已经启动.</li>\n<li>通知观察者, 将要处理定时器.</li>\n<li>通知观察者, 将要处理Source0(即将启动的非基于端口的源).</li>\n<li>启动任何准备好的Source0(非基于端口的源).</li>\n<li>如果有任何Source1(基于端口的源)准备好并且处于等待状态, 立即启动, 并进入步骤9.</li>\n<li>通知所有观察者, 线程即将进入休眠.</li>\n<li>线程处于休眠状态, 直到遇到下列事件中的任意一个:<ul>\n<li>某一事件到达Source0(非基于端口的源)</li>\n<li>NSTimer定时器启动</li>\n<li>RunLoop设置的时间已经超时</li>\n<li>RunLoop被外部手动显示唤醒.</li>\n</ul>\n</li>\n<li>通知观察者, 线程刚被唤醒</li>\n<li>处理唤醒时收到的事件<ul>\n<li>如果是定时器启动, 处理定时器并重启RunLoop, 进入步骤2</li>\n<li>如果是输入源启动, 传递相应的消息</li>\n<li>如果是RunLoop被显式唤醒(Source1), 重启RunLoop, 进入步骤2</li>\n</ul>\n</li>\n<li>通知观察者RunLoop即将结束.</li>\n</ol>\n<p>实际上 RunLoop 内部是一个 do-while 循环函数. 当你调用 CFRunLoopRun() 时, 线程就会一直停留在这个循环里; 直到超时或被手动停止, 该函数才会返回. </p>\n<h2 id=\"系统中RunLoop的常见实现\"><a href=\"#系统中RunLoop的常见实现\" class=\"headerlink\" title=\"系统中RunLoop的常见实现\"></a>系统中RunLoop的常见实现</h2><p>下面列举几个Apple中常见的RunLoop的使用场景.</p>\n<h3 id=\"AutoreleasePool\"><a href=\"#AutoreleasePool\" class=\"headerlink\" title=\"AutoreleasePool\"></a>AutoreleasePool</h3><p>APP启动后, 系统在主线程RunLoop中注册了两个Observer, 其回调都是 _wrapRunLoopWithAutoreleasePoolHandler().</p>\n<p>第一个Observer监视的事件是kCFRunLoopEntry(进入RunLoop), 会调用_objc_autoreleasePoolPush() 创建自动释放池, 其 order 是-2147483647, 优先级最高, 保证创建释放池发生在其他所有回调之前.<br>第二个Observer监视的事件是kCFRunLoopBeforeWaiting(RunLoop休眠)和kCFRunLoopExit(RunLoop退出). 会在休眠是调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池; 会在退出时调用 _objc_autoreleasePoolPop() 来释放自动释放池. 这个 Observer 的 order 是 2147483647, 优先级最低, 保证其释放池子发生在其他所有回调之后.</p>\n<p>在主线程执行的代码, 通常是写在诸如事件回调, Timer回调内的. 这些回调会被 RunLoop 创建好的 AutoreleasePool 包围, 所以不会出现内存泄漏, 开发者也不必显示创建 Pool 了.</p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port) 用来接收系统事件, 其回调函数为 __IOHIDEventSystemClientQueueCallback(). </p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后,  IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收. SpringBoard 只接收按键(锁屏/静音等), 触摸, 加速, 接近传感器等几种 Event, 随后用 mach port 转发给需要的App进程. 随后苹果注册的那个 Source1 就会触发回调, 并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发.<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发, 其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等. 通常事件比如 UIButton 点击, touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的.</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当_UIApplicationHandleEventQueue() 识别了一个手势时, 其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断. 随后系统将对应的 UIGestureRecognizer 标记为待处理.<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件, 这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver(), 其内部会获取所有刚被标记为待处理的 GestureRecognizer, 并执行GestureRecognizer的回调.<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时, 这个回调都会进行相应处理.</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI, 比如改变了 Frame, 更新了 UIView/CALayer 的层次时, 或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后, 这个 UIView/CALayer 就被标记为待处理, 并被提交到一个全局的容器去.<br>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件, 回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv(). 这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整, 并更新 UI 界面.</p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef, 他们之间是 toll-free bridged 的. 一个 NSTimer 注册到 RunLoop 后, RunLoop 会为其重复的时间点注册好事件. 例如 10:00, 10:10, 10:20 这几个时间点. RunLoop为了节省资源, 并不会在非常准确的时间点回调这个Timer. Timer 有个属性叫做 Tolerance (宽容度), 标示了当时间点到后, 容许有多少最大误差.<br>如果某个时间点被错过了, 例如执行了一个很长的任务, 则那个时间点的回调也会跳过去, 不会延后执行.</p>\n<h3 id=\"performSelecter方法\"><a href=\"#performSelecter方法\" class=\"headerlink\" title=\"performSelecter方法\"></a>performSelecter方法</h3><p>调用 NSObject 的 performSelecter:afterDelay: 后, 实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中. 所以如果当前线程没有 RunLoop, 则这个方法会失效.<br>当调用 performSelector:onThread: 时, 实际上其会创建一个 Timer 加到对应的线程去, 同样的, 如果对应线程没有 RunLoop 该方法也会失效.</p>\n<h2 id=\"开发中RunLoop的常见使用\"><a href=\"#开发中RunLoop的常见使用\" class=\"headerlink\" title=\"开发中RunLoop的常见使用\"></a>开发中RunLoop的常见使用</h2><h3 id=\"滚动scrollView导致定时器失效\"><a href=\"#滚动scrollView导致定时器失效\" class=\"headerlink\" title=\"滚动scrollView导致定时器失效\"></a>滚动scrollView导致定时器失效</h3><p>如果在界面上有一个UIscrollview控件(tableview, collectionview等), 如果此时还有一个定时器在执行一个事件, 你会发现当你滚动scrollview的时候, 定时器会失效. </p>\n<p>原因是当滚动UIscrollview的时候, runloop会进入UITrackingRunLoopMode 模式, 而定时器运行在defaultMode下面, 系统一次只能处理一种模式的runloop, 所以导致defaultMode下的定时器失效. 解决方案有两种:</p>\n<ol>\n<li><p>把定时器的runloop的model改为NSRunLoopCommonModes 模式, 这个模式是一种占位mode, 并不是真正可以运行的mode, 它是用来标记一个mode的. 默认情况下default和tracking这两种mode 都会被标记上NSRunLoopCommonModes 标签 改变定时器的mode为commonmodel, 可以让定时器运行在defaultMode和trackingModel两种模式下, 不会出现滚动scrollview导致定时器失效的故障. </p>\n<pre><code> [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n</code></pre></li>\n<li><p>使用GCD创建定时器</p>\n<pre><code> // 获得队列\n dispatch_queue_t queue = dispatch_get_main_queue();\n\n // 创建一个定时器(dispatch_source_t本质还是个OC对象)\n self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\n // 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）\n // GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）\n // 比当前时间晚1秒开始执行\n dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));\n\n //每隔一秒执行一次\n uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);\n dispatch_source_set_timer(self.timer, start, interval, 0);\n\n // 设置回调\n dispatch_source_set_event_handler(self.timer, ^{\n     NSLog(@&quot;------------%@&quot;, [NSThread currentThread]);\n\n });\n\n // 启动定时器\n dispatch_resume(self.timer);\n</code></pre><h3 id=\"图片下载\"><a href=\"#图片下载\" class=\"headerlink\" title=\"图片下载\"></a>图片下载</h3><p>由于图片渲染到屏幕需要消耗较多资源, 为了提高用户体验, 当用户滚动UIscrollview的时候, 只在后台下载图片, 但是不显示图片, 当用户停下来的时候才显示图片. 核心代码如下:</p>\n</li>\n</ol>\n<pre><code>[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];\n</code></pre><p>这是因为限定了方法setImage只能在NSDefaultRunLoopMode 模式下使用. 而滚动UIscrollview的时候, 程序运行在tracking模式下面, 所以方法setImage不会执行. </p>\n<h3 id=\"常驻线程\"><a href=\"#常驻线程\" class=\"headerlink\" title=\"常驻线程\"></a>常驻线程</h3><p>需要创建一个在后台一直存在的程序, 来做一些需要频繁处理的任务. 比如检测网络状态等. 默认情况一个线程创建出来, 运行完要做的事情, 线程就会消亡. 而程序启动的时候, 就创建的主线程已经加入到runloop, 所以主线程不会消亡. AFN里面就有一条通过添加NSPort来实现常驻的线程, 常见的有两种方式: </p>\n<ol>\n<li><p>添加NSPort</p>\n<pre><code> - (void)viewDidLoad {\n     [super viewDidLoad];\n\n     self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n     [self.thread start];\n }\n\n - (void)run {\n     NSLog(@&quot;----------run----%@&quot;, [NSThread currentThread]);\n     @autoreleasepool{\n     /*如果不加这句，会发现runloop创建出来就挂了，因为runloop如果没有CFRunLoopSourceRef事件源输入或者定时器，就会立马消亡。\n       下面的方法给runloop添加一个NSport，就是添加一个事件源，也可以添加一个定时器，或者observer，让runloop不会挂掉*/\n     [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n\n     // 方法1 ,2，3实现的效果相同，让runloop无限期运行下去\n     [[NSRunLoop currentRunLoop] run];\n    }\n\n     // 方法2\n     [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n\n     // 方法3\n     [[NSRunLoop currentRunLoop] runUntilDate:[NSDate distantFuture]];\n\n     NSLog(@&quot;---------&quot;);\n }\n\n - (void)test {\n     NSLog(@&quot;----------test----%@&quot;, [NSThread currentThread]);\n }\n\n - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\n     [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];\n }\n</code></pre></li>\n<li><p>添加NSTimer</p>\n<pre><code> - (void)viewDidLoad {\n     [super viewDidLoad];\n\n     self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n     [self.thread start];\n }\n - (void)run {\n     [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES];\n\n     [[NSRunLoop currentRunLoop] run];\n }\n</code></pre><p>如果没有实现添加NSPort或者NSTimer, 会发现执行完run方法, 线程就会消亡, 后续再执行touchbegan方法无效. 我们必须保证线程不消亡, 才可以在后台接受时间处理.</p>\n</li>\n</ol>\n<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source, 所以在 <code>[runLoop run]</code> 之前先创建了一个新的 NSMachPort 添加进去了. 通常情况下, 调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内; 但此处添加 port 只是为了让 RunLoop 不至于退出, 并没有用于实际的发送消息. </p>\n<p>可以发现执行完了run方法, 这个时候再点击屏幕, 可以不断执行test方法, 因为线程self.thread一直常驻后台, 等待事件加入其中, 然后执行.</p>\n<h3 id=\"在所有UI相应操作之前处理任务\"><a href=\"#在所有UI相应操作之前处理任务\" class=\"headerlink\" title=\"在所有UI相应操作之前处理任务\"></a>在所有UI相应操作之前处理任务</h3><p>主要思路就是我们可以新建一个Observer, 来观察RUnLoop的状态, 因为我们的UI操作都会导致RunLoop状态的变动, 通过日志我们可以发现, 在执行按钮事件之前, 先执行Observer里面的方法, 这样就可以拦截事件, 让我们的代码在UI事件之前执行.</p>\n<pre><code>- (IBAction)btnClick:(id)sender {\n    NSLog(@&quot;btnClick----------&quot;);\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self observer];\n}\n\n- (void)observer {\n    // 创建observer，参数kCFRunLoopAllActivities表示监听所有状态\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n        NSLog(@&quot;----监听到RunLoop状态发生改变---%zd&quot;, activity);\n    });\n\n    // 添加观察者：监听RunLoop的状态\n    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);\n\n    // 释放Observer\n    CFRelease(observer);\n}\n</code></pre><pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL &lt;&lt; 0),   //1\n    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    //2\n    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   //4\n    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   //32\n    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    //64\n    kCFRunLoopExit = (1UL &lt;&lt; 7),    //128\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n</code></pre><h3 id=\"其他用法\"><a href=\"#其他用法\" class=\"headerlink\" title=\"其他用法\"></a>其他用法</h3><p>例如我们实现Cell高度的缓存计算, 我们可以在RunLoop空闲时来计算, 所以我们可以创建一个Observer, 来监听RunLoop的kCFRunLoopBeforeWaiting状态(这一次 RunLoop 迭代处理完成了所有事件, 马上要休眠时), 在其中来计算高度并且缓存, </p>\n<pre><code>CFRunLoopRef runLoop = CFRunLoopGetCurrent();\nCFStringRef runLoopMode = kCFRunLoopDefaultMode;\nCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler\n(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) {\n    // TODO here\n});\nCFRunLoopAddObserver(runLoop, observer, runLoopMode);\n在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer\n</code></pre><hr>\n<p>参考资料: </p>\n<p>1.<a href=\"http://www.bijishequ.com/detail/355655?p=70-67\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a></p>\n<p>2.<a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a>, 这个是经典之作</p>\n<p>3.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1\" target=\"_blank\" rel=\"noopener\">Threading Programming Guide</a>, 官方</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Runtime用法与分析","url":"http://hchong.net/2017/12/11/Runtime用法与分析/","content":"<p>Objective-C 是C的语言的超集, C是一门静态语言而Objective-C却是一门动态语言, 这个动态特性就是由基于<a href=\"https://zh.wikipedia.org/wiki/Smalltalk\" target=\"_blank\" rel=\"noopener\">Smalltalk</a>消息传递特性的<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1\" target=\"_blank\" rel=\"noopener\">Runtime</a>来提供的. 那么什么是Runtime, 官方的说法是这样的:</p>\n<blockquote>\n<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.<br>大致翻译一下就是: Objective-C尽可能的提供更多策略把原本需要在编译和链接时做的事尽一切可能放到了运行时来动态的处理. 那也就意味着我们不仅需要一套编译系统, 还需要一套运行时系统来执行编译后的代码. 对于Objective-C来说, Runtime就是这样的一套运行时操作系统; Runtime为Objective-C的的动态特性提供了底层的技术支持.</p>\n</blockquote>\n<p>Runtime其实有两个版本: Modern和Legacy. 我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统, 只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中. 而 maxOS 较老的32位程序仍采用 Objective-C 1 中的早期(Legacy)版本的 Runtime 系统. 这两个版本最大的区别在于当你更改一个类的实例变量的布局时, 在早期版本中你需要重新编译它的子类, 而现行版就不需要.</p>\n<h2 id=\"Runtime简介\"><a href=\"#Runtime简介\" class=\"headerlink\" title=\"Runtime简介\"></a>Runtime简介</h2><p>Objective-C在三种层面上与Runtime系统进行交互: </p>\n<ol>\n<li>通过 Objective-C 源代码<br> Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码, 在运行时确定对应的数据结构和调用具体哪个方法.</li>\n<li>通过 Foundation 框架的 NSObject 类定义的方法<br> NSObject类是遵守NSObject协议的, 在这个协议里面有很多方法是和Runtime相关, 或者直接从Runtime中获取信息的, 具体的可以看这里<a href=\"https://developer.apple.com/documentation/objectivec/1418956-nsobject?language=objc\" target=\"_blank\" rel=\"noopener\">NSObject Protocol Reference</a>.</li>\n<li>通过对 Runtime 库函数的直接调用<br> 在这里需要注意一下, 系统本身是默认关闭了Runtime的代码提示的, 我们需要在BuildSettings -&gt; Enable Strict Checking objc_msgSend Calls -&gt;设置为NO<br> Objective-C 的 Runtime 为我们提供了很多运行时状态下跟类与对象相关的函数, 具体的可以看<a href=\"https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime Reference</a>.</li>\n</ol>\n<h2 id=\"Runtime-基础数据结构\"><a href=\"#Runtime-基础数据结构\" class=\"headerlink\" title=\"Runtime 基础数据结构\"></a>Runtime 基础数据结构</h2><p>这里我们需要先关注了解几个概念: Object(对象), Class(类), Meta Class(原类), id. 通过objc_class的定义我们大致可以看出他们之间的关系:</p>\n<pre><code>typedef struct objc_class *Class;  \ntypedef struct objc_object *id;\n\n@interface Object { \n    Class isa; \n}\n\n@interface NSObject &lt;NSObject&gt; {\n    Class isa  OBJC_ISA_AVAILABILITY;\n}\n\nstruct objc_object {  \nprivate:  \n    isa_t isa;\n}\n\nstruct objc_class : objc_object {  \n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n}\n\nunion isa_t  \n{\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n    Class cls;\n    uintptr_t bits;\n}\n\n</code></pre><p>用文字总结一下就是: </p>\n<ol>\n<li><p>id 在 Objective-C 中可以代指任意的对象类型, 他是一个指向 objc_object 结构体的指针(这个struct的定义本身就带了一个 <em>, 所以我们在使用其他NSObject类型的实例时需要在前面加上 </em>, 而使用 id 时却不用). </p>\n<pre><code> /// A pointer to an instance of a class.\n typedef struct objc_object *id;\n</code></pre></li>\n<li><p>那么什么是 objc_object 呢? Objective-C中的Object(objc_object)在最后会被转换成C的结构体, 而在这个struct中有一个 <a href=\"#isa_t\">isa_t</a> 类型的结构体isa, 通过查看 isa_t 我们发现它里面有一个指向它的类别 Class(定义了对象所属的类). <em>注意: isa 指针不总是指向实例对象所属的类, 不能依靠它来确定类型, 而是应该用 class 方法来确定实例对象的类.</em> </p>\n<pre><code> struct objc_object {  \n private:  \n     isa_t isa;\n public:\n     // initIsa() should be used to init the isa of new objects only.\n     // If this object already has an isa, use changeIsa() for correctness.\n     // initInstanceIsa(): objects with no custom RR/AWZ\n     void initIsa(Class cls /*indexed=false*/);\n     void initInstanceIsa(Class cls, bool hasCxxDtor);\n private:  \n     void initIsa(Class newCls, bool indexed, bool hasCxxDtor);\n }\n</code></pre></li>\n<li><p>那么什么是 Class 呢? Class 其实是一个指向 objc_class 结构体的指针. </p>\n<pre><code> /// An opaque type that represents an Objective-C class.\n typedef struct objc_class *Class;\n</code></pre></li>\n<li><p>那么什么是objc_class呢? 我们可以看到 objc_class 继承自 objc_object, 由此可以看出<em>Objective-C 中类也是一个对象</em>. 我们调用类方法的时候, 类对象的isa里面是什么呢? 这样就引出了原类的概念. </p>\n<pre><code> struct objc_class : objc_object {  \n     // Class ISA;\n     Class superclass;\n     cache_t cache;             // formerly cache pointer and vtable\n     class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n }\n</code></pre></li>\n</ol>\n<p><em>总结: Class在设计中本身也是一个对象. 而这个Class对象的对应的类, 我们叫它 Meta Class, 它用来表述类对象本身所具备的元数据, 类方法就定义于此处, 因为这些方法可以理解成类对象的实例方法. 每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类. 即Class结构体中的 isa 指向的就是它的 Meta Class. 我们可以把Meta Class理解为一个Class对象的Class. 当我们给一个NSObject对象发送消息时(实例方法), 这条消息会在对象所属的类的方法列表里查找. 当我们发送一个消息给一个类时(类方法), 这条消息会在类的Meta Class的方法列表里查找.</em> </p>\n<p>下面这个图很好地说明了Object, Class, Meta Class之间的关系.<br><img src=\"http://7ni3rk.com1.z0.glb.clouddn.com/Runtime/class-diagram.jpg\" alt=\"Object, Class, Meta Class之间的关系\"><br>概括一下, 上图主要说了以下几点: </p>\n<ol>\n<li>每个实例(Object)的isa指针都指向该实例所属的类. </li>\n<li>每个类(Class)的isa指针都指向为一个该类所属的Meta Class(原类).</li>\n<li>每个Meta Class(原类)的isa指针都指向Root Class(Meta)(根原类), 大部分情况是都是NSObject.</li>\n<li>Root class(meta)的superclass指向Root class(Class), 也就是NSObject, 形成一个回路.</li>\n<li>Root class(Class)其实就是NSObject, NSObject是没有超类的, 所以Root class(Class)的superclass指向nil.</li>\n</ol>\n<p>下面是针对上面出现的一些结构体和对象的详细解析.</p>\n<h3 id=\"isa-t\"><a href=\"#isa-t\" class=\"headerlink\" title=\"isa_t\"></a><span id=\"isa_t\">isa_t</span></h3><p>objc_object 结构体包含一个 isa 指针, 类型为 isa_t 联合体. 因为 isa_t 使用 union 实现, 所以可能表示多种形态, 既可以当成是指针, 也可以存储标志位. 有关 isa_t 联合体的更多内容可以查看 <a href=\"http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/#isa-%E6%8C%87%E9%92%88%EF%BC%88NONPOINTER-ISA%EF%BC%89\" target=\"_blank\" rel=\"noopener\">Objective-C 引用计数原理</a>.</p>\n<pre><code>union isa_t  \n{\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n    Class cls;\n    uintptr_t bits;\n}\n</code></pre><h3 id=\"cache-t\"><a href=\"#cache-t\" class=\"headerlink\" title=\"cache_t\"></a>cache_t</h3><p>cache_t 出现在 objc_class 中, cache_t 中存储了一个 bucket_t 的结构体 _buckets ，和两个unsigned int 的变量 _mask 和 _occupied. _mask 分配用来缓存bucket的总数, _occupied 表明目前实际占用的缓存bucket的个数. bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP. IMP是一个函数指针, 指向了一个方法的具体实现. bucket_t *_buckets其实就是一个散列表, 用来存储Method的链表. </p>\n<p>Cache 的作用主要是为了优化方法调用的性能. 当对象receiver调用方法message时, 首先根据对象receiver 的 isa 指针查找到它对应的类, 然后在类的 methodLists 中搜索方法, 如果没有找到, 就使用 super_class 指针到父类中的 methodLists 查找, 一旦找到就调用方法. 如果没有找到, 有可能消息转发, 也可能忽略它. 但这样查找方式效率太低, 所以使用Cache来缓存经常调用的方法, 当调用方法时, 优先在Cache查找, 如果没有找到, 再到methodLists查找.</p>\n<pre><code>//cache_t结构\nstruct cache_t {  \n   struct bucket_t *_buckets;\n   mask_t _mask;\n   mask_t _occupied;\n}\n\ntypedef unsigned int uint32_t;  \ntypedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits\n\ntypedef unsigned long  uintptr_t;  \ntypedef uintptr_t cache_key_t;\n\nstruct bucket_t {  \nprivate:  \n   cache_key_t _key;\n   IMP _imp;\npublic:\n    inline cache_key_t key() const { return _key; }\n    inline IMP imp() const { return (IMP)_imp; }\n    inline void setKey(cache_key_t newKey) { _key = newKey; }\n    inline void setImp(IMP newImp) { _imp = newImp; }\n\n    void set(cache_key_t newKey, IMP newImp);\n}\n</code></pre><h3 id=\"class-data-bits-t\"><a href=\"#class-data-bits-t\" class=\"headerlink\" title=\"class_data_bits_t\"></a><span id=\"class_data_bits_t\">class_data_bits_t</span></h3><pre><code>//class_data_bits_t结构\nstruct class_data_bits_t {\n   // Values are the FAST_ flags above.\n   uintptr_t bits;\n}\n\nstruct class_rw_t {  \n   uint32_t flags;\n   uint32_t version;\n\n   const class_ro_t *ro;\n\n   method_array_t methods;\n   property_array_t properties;\n   protocol_array_t protocols;\n\n   Class firstSubclass;\n   Class nextSiblingClass;\n\n   char *demangledName;\n}\n\nstruct class_ro_t {  \n   uint32_t flags;\n   uint32_t instanceStart;\n   uint32_t instanceSize;\n#ifdef __LP64__\n   uint32_t reserved;\n#endif\n\n   const uint8_t * ivarLayout;\n\n   const char * name;\n   method_list_t * baseMethodList;\n   protocol_list_t * baseProtocols;\n   const ivar_list_t * ivars;\n\n   const uint8_t * weakIvarLayout;\n   property_list_t *baseProperties;\n\n   method_list_t *baseMethods() const {\n       return baseMethodList;\n   }\n};\n</code></pre><p><img src=\"https://ob6mci30g.qnssl.com/Blog/ArticleImage/23_15.png\" alt=\"class_data_bits_t\"></p>\n<p>上面这张图很好地说明了 class_data_bits_t 的作用. 详见<a href=\"https://github.com/Draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-objc-%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"noopener\">深入解析 ObjC 中方法的结构</a>. 大致说明一下就是, Objc的类的属性, 方法, 以及遵循的协议在obj 2.0的版本之后都放在 class_rw_t 中. class_ro_t 是一个指向常量的指针, 存储来编译器决定了的属性、方法和遵守协议. 在运行时发消息时, 会从 class_data_bits_t 调用 data 方法, 将结果从 class_rw_t 强制转换为 class_ro_t 指针. 最后调用 methodizeClass 方法, 把类里面的属性, 协议, 方法都加载进来.</p>\n<h2 id=\"方法与消息\"><a href=\"#方法与消息\" class=\"headerlink\" title=\"方法与消息\"></a>方法与消息</h2><h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p>SEL 又叫做方法选择器, 是表示一个方法的 selector 的指针, 定义如下: </p>\n<pre><code>typedef struct objc_selector *SEL;\n</code></pre><p>Objective-C在编译时, 会依据每一个方法的名字, 参数序列, 生成一个唯一的整型标识(Int类型的地址), 这个标识就是SEL. 不同类的不同方法, 只要方法名相同, 哪怕参数类型不同, 这两个方法的SEL就是一样的. 同一个类中就不能存在两个方法, 方法名一致, 参数不一致, 这样是会编译错误的. 但是不同的类就可以, 因为不同的类的实例对象执行方法时, 是从各自类的方法列表中根据selector去寻找自己对应的IMP. </p>\n<p>工程中所有的SEL组合成一个set集合, 因此SEL是唯一的. set中的元素都是唯一的, 所以SEL也是唯一的, 所以我们找一个selector, 通过他对应的SEL是最快的方法. SEL实际就是根据方法名Hash过的一个字符串(这也解释了上面相同方法名编译为什么报错的原因), 字符串的比较只需比较地址就可以了, 速度十分快. 本质上, SEL只是一个指向方法的指针(准确的说, 只是一个根据方法名hash化了的KEY值, 能唯一代表一个方法), 它的存在只是为了加快方法的查询速度.</p>\n<p>我们可以在运行时添加和获取selector, 也可以通过下面几种方式来获取SEL:</p>\n<pre><code>1. sel_registerName函数\n2. Objective-C编译器提供的@selector()\n3. NSSelectorFromString()方法\n</code></pre><h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><p>IMP实际上是一个函数指针, 指向方法实现的地址. 定义如下:</p>\n<pre><code>id (*IMP)(id, SEL,...)\n</code></pre><p>该函数的第一个参数是self的指针, 如果是实例方法, 则是类实例的内存地址; 如果是类方法, 则是指向元类的指针. 第二个参数是方法选择器, 后面是方法的参数列表. </p>\n<p>每个方法对应唯一的SEL, 我们通过SEL就是为了查找方法的最终实现IMP, 而IMP这个函数指针指向了最终的这个方法的实现, 取得IMP后, 我们就获得了执行这个方法代码的入口点. 通过取得IMP, 我们可以跳过Runtime的消息传递机制, 直接执行IMP指向的函数实现, 这样省去了Runtime消息传递过程中所做的一系列查找操作, 会比直接向对象发送消息高效一些.</p>\n<p>通过一组id和SEL参数就能确定唯一的方法实现地址, 而一个确定的方法也只有唯一的一组id和SEL参数.</p>\n<h3 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h3><p>Method用于表示类定义中的方法, 定义如下:</p>\n<pre><code>struct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n\n    struct SortBySELAddress :\n        public std::binary_function&lt;const method_t&amp;,\n                                    const method_t&amp;, bool&gt;\n    {\n        bool operator() (const method_t&amp; lhs,\n                         const method_t&amp; rhs)\n        { return lhs.name &lt; rhs.name; }\n    };\n};\n</code></pre><p>我们可以看到, 该结构体包含有 name(方法名, 本质是IMP), types(方法类型, 本质是个char指针, 存储方法的参数类型和返回值), imp(方法指向, 本质是个IMP, 也可以说是函数指针). 该结构体实际上相当于在 SEL 和 IMP 之间做了一个映射, 让我们可以通过 SEL 快速的找到 IMP.</p>\n<h2 id=\"成员变量与属性\"><a href=\"#成员变量与属性\" class=\"headerlink\" title=\"成员变量与属性\"></a>成员变量与属性</h2><h3 id=\"Ivar\"><a href=\"#Ivar\" class=\"headerlink\" title=\"Ivar\"></a>Ivar</h3><p>Ivar用来表示实例变量, 其实际是一个指向 objc_ivar 结构体的指针, 定义如下:</p>\n<pre><code>typedef struct objc_ivar *Ivar;\n\nstruct ivar_t {\n    int32_t *offset;//表示基地址偏移字节\n    const char *name;\n    const char *type;\n    // alignment is sometimes -1; use alignment() instead\n    uint32_t alignment_raw;\n    uint32_t size;\n\n    uint32_t alignment() const {\n        if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT;\n        return 1 &lt;&lt; alignment_raw;\n    }\n};\n</code></pre><p>关于Ivar我们需要知道以下几点: </p>\n<ol>\n<li>我们对 ivar 的访问就可以通过 对象地址 ＋ Ivar偏移字节的方法来访问, 但是如果增加了父类的Ivar, 那怎么办, Objective-C使用Non Fragile Ivars机制, Runtime会进行检测来调整类中新增的ivar的偏移量, 这样我们就可以通过 对象地址 + 基类大小 + ivar偏移字节的方法来计算出ivar相应的地址, 并访问到相应的ivar, 而不用重新编译子类.</li>\n<li>我们无法通过-&gt;函数来修改私有属性, 但是我们可以通过对象地址 + Ivar偏移量来访问地址, 获取到指针后直接修改.</li>\n<li>属性实际就是Ivar加上系统自动为我们生成的get和set方法.</li>\n</ol>\n<h3 id=\"objc-property-t\"><a href=\"#objc-property-t\" class=\"headerlink\" title=\"objc_property_t\"></a>objc_property_t</h3><p>@property 标记了类中的属性, 他是一个指向 objc_property 结构体的指针:</p>\n<pre><code>typedef struct property_t *objc_property_t;\n</code></pre><p>需要注意的是, 与 class_copyIvarList 函数不同, 使用 class_copyPropertyList 函数只能获取类的属性, 而不包含成员变量, 但此时获取的属性名是不带下划线的.</p>\n<p>更多姿势可以看<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h3 id=\"protocol-t\"><a href=\"#protocol-t\" class=\"headerlink\" title=\"protocol_t\"></a>protocol_t</h3><p>这个没啥好讲的, 直接看定义:</p>\n<pre><code>struct protocol_t : objc_object {\n    const char *mangledName;\n    struct protocol_list_t *protocols;\n    method_list_t *instanceMethods;\n    method_list_t *classMethods;\n    method_list_t *optionalInstanceMethods;\n    method_list_t *optionalClassMethods;\n    property_list_t *instanceProperties;\n    uint32_t size;   // sizeof(protocol_t)\n    uint32_t flags;\n    // Fields below this point are not always present on disk.\n    const char **_extendedMethodTypes;\n    const char *_demangledName;\n    property_list_t *_classProperties;\n    ... 省略一些封装的便捷 get 方法\n}\n</code></pre><h2 id=\"Category\"><a href=\"#Category\" class=\"headerlink\" title=\"Category\"></a>Category</h2><p>美团的<a href=\"https://tech.meituan.com/DiveIntoCategory.html\" target=\"_blank\" rel=\"noopener\">这篇</a>讲的具详细, 这里我们就大概说一下.<br>Category(分类), 他为现有的类提供了扩展, 它是 category_t 结构体的指针.</p>\n<pre><code>typedef struct category_t *Category;\n\ntypedef struct category_t {\n    const char *name;//类的名字\n    classref_t cls;//类\n    struct method_list_t *instanceMethods;//category中所有给类添加的实例方法的列表\n    struct method_list_t *classMethods;//给所有类添加类方法的列表\n    struct protocol_list_t *protocols;//所有协议的列表\n    struct property_list_t *instanceProperties;//category中添加的所有属性的列表\n} category_t;\n</code></pre><p><em>从category的定义也可以看出我们可以添加实例方法, 类方法, 甚至可以实现协议, 添加属性, 但是无法添加实例变量</em>.</p>\n<p>在APP的启动过程中, 会在 <code>_read_images</code> 函数间接调用到 attachCategories 函数, 完成向类中添加 Category 的工作. 向 class_rw_t(上面<a href=\"#class_data_bits_t\">class_data_bits_t</a>中有介绍) 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针. 把category的实例方法, 协议以及属性添加到类上, 把category的类方法和协议添加到类的metaclass上.</p>\n<p>我们需要注意的是: </p>\n<ol>\n<li>category不会覆盖原类中的方法, 而是两个都存在, 但是category的在前面, 按照方法列表来找, 找到category的之后, 就不再往下找了, 造成被覆盖的假象. </li>\n<li>附加category的类的工作会先于+load方法的执行. </li>\n<li>+load的执行顺序是先类, 后category, 而category的+load执行顺序是根据编译顺序(Compile Sources中的顺序)决定的.</li>\n</ol>\n<h2 id=\"消息查找与转发\"><a href=\"#消息查找与转发\" class=\"headerlink\" title=\"消息查找与转发\"></a>消息查找与转发</h2><p>Objective-C中任何方法的调用, 编译器都会将[receiver message]转化为一个消息函数的调用, 即objc_msgSend, 消息直到运行时才绑定到方法的实现上. objc_msgSend 的定义如下:</p>\n<pre><code>objc_msgSend(receiver, selector, arg1, arg2, ...)\n\n</code></pre><p>在<a href=\"http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html\" target=\"_blank\" rel=\"noopener\">Obj-C Optimization: The faster objc_msgSend</a>中有一段 objc_msgSend 方法实现思路的代码:</p>\n<pre><code>id  c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...)  \n{\n   struct objc_class    *cls;\n   struct objc_cache    *cache;\n   unsigned int         hash;\n   struct objc_method   *method;   \n   unsigned int         index;\n\n   if( self)\n   {\n      cls   = self-&gt;isa;\n      cache = cls-&gt;cache;\n      hash  = cache-&gt;mask;\n      index = (unsigned int) _cmd &amp; hash;\n\n      do\n      {\n         method = cache-&gt;buckets[ index];\n         if( ! method)\n            goto recache;\n         index = (index + 1) &amp; cache-&gt;mask;\n      }\n      while( method-&gt;method_name != _cmd);\n      return( (*method-&gt;method_imp)( (id) self, _cmd));\n   }\n   return( (id) self);\n\nrecache:  \n   /* ... */\n   return( 0);\n}\n\n</code></pre><p>查了一堆资料, 总结一下消息的查找和转发的过程:</p>\n<h3 id=\"消息的查找和动态解析\"><a href=\"#消息的查找和动态解析\" class=\"headerlink\" title=\"消息的查找和动态解析\"></a>消息的查找和动态解析</h3><ol>\n<li>判断 selector 是不是需要被忽略的垃圾回收用到的方法, 是的话就忽略, 不是的话继续下一步操作.</li>\n<li>判断target是不是nil, 如果这里有相应的nil的处理函数, 就跳转到相应的函数中. 如果没有处理nil的函数, 就自动清理现场并返回. 这一点就是为何在OC中给nil发送消息不会崩溃的原因.</li>\n<li>查找当前类的缓存, 如果命中缓存获取到了IMP就将IMP返回, 如果没有继续下一步操作.</li>\n<li>在当前类的方法列表中查找(根据 selector 查找到 Method 后, 获取 Method 中的 IMP), 对已经排序的列表使用二分法查找, 未排序的列表则是线性遍历. 如果找到把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作.</li>\n<li>在继承层级中递归向父类(一直到 NSObject 为止)中查找, 情况跟上一步类似, 也是先查找缓存, 缓存没中就查找方法列表, 查到后就终止递归查询, 把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作.</li>\n<li><p>在消息查找阶段, 如果没找到IMP(也就是接收到未知的消息), 会进入动态方法解析阶段, 首先会调用所属类的<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)方法. 前提是我们必须自己实现该方法, 并且添加到类里面.</p>\n<pre><code> void functionForMethod1(id self, SEL _cmd) {\n    NSLog(@&quot;%@, %p&quot;, self, _cmd);\n }\n\n + (BOOL)resolveInstanceMethod:(SEL)sel {\n     NSString *selectorString = NSStringFromSelector(sel);\n     if ([selectorString isEqualToString:@&quot;method1&quot;]) {\n         class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);\n     }\n     return [super resolveInstanceMethod:sel];\n }\n</code></pre></li>\n<li>此时如果既没有没查找到 IMP, 动态方法解析也不奏效, 那么就进入了下一个阶段-消息转发阶段.</li>\n</ol>\n<h3 id=\"消息的转发\"><a href=\"#消息的转发\" class=\"headerlink\" title=\"消息的转发\"></a><span id=\"消息的转发\">消息的转发</span></h3><p>上面主要是消息的查找阶段主要完成的是通过select()快速查找IMP的过程, 接下来才是消息的转发阶段, 到了转发阶段, 会调用到了转发阶段, 会调用<code>id _objc_msgForward(id self, SEL _cmd,...)</code>方法. 在执行<code>_objc_msgForward</code>之后会调用 <code>__objc_forward_handler</code>函数. 它的实现大致如下: </p>\n<pre><code>// Default forward handler halts the process.\n__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)  \n{\n    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;\n                &quot;(no message forward handler is installed)&quot;, \n                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, \n                object_getClassName(self), sel_getName(sel), self);\n}\n\n</code></pre><p>当我们给一个对象发送一个没有实现的方法的时候, 如果其父类也没有这个方法, 则会崩溃, 报错信息类似于这样: unrecognized selector sent to instance, 然后接着会跳出一些堆栈信息. 这些信息就是从这里而来. </p>\n<ol>\n<li><p>如果上面的查找和解析都失败的话, 消息就会无法处理, 这是Runtime会调用以下方法:</p>\n<pre><code> - (id)forwardingTargetForSelector:(SEL)aSelector\n</code></pre><p> 我们可以通过重写- (id)forwardingTargetForSelector:(SEL)aSelector方法来把消息的接受者换成一个可以处理该消息的实例对象或者类对象. 示例如下:</p>\n<pre><code> - (id)forwardingTargetForSelector:(SEL)aSelector\n {\n     if(aSelector == @selector(Method:)){\n         return otherObject;\n     }\n     return [super forwardingTargetForSelector:aSelector];\n }\n\n + (id)forwardingTargetForSelector:(SEL)aSelector {\n     if(aSelector == @selector(xxx)) {\n         return NSClassFromString(@&quot;Class name&quot;);\n     }\n     return [super forwardingTargetForSelector:aSelector];\n }\n</code></pre><p> 如果一个对象实现了这个方法, 并返回一个非nil的结果, 则这个对象会作为消息的新接收者, 且消息会被分发到这个对象. 当然这个对象不能是self自身, 否则就是出现无限循环. 如果我们没有指定相应的对象来处理aSelector, 则应该调用父类的实现来返回结果. 这一步合适于我们只想将消息转发到另一个能处理该消息的对象上, 但这一步无法对消息进行处理, 如操作消息的参数和返回值.</p>\n</li>\n<li><p>如果在上一步还不能处理未知消息, 则唯一能做的就是启用完整的消息转发机制了. 运行时系统会给消息接收者最后一次机会将消息转发给其它对象. 我们首先要通过, 指定方法签名, 若返回nil, 则表示不处理. </p>\n<pre><code> - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;]){\n      return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];\n   }  \n return [super methodSignatureForSelector: aSelector];\n }\n</code></pre><p> 若返回方法签名, 则会进入下一步调用.</p>\n<pre><code> - (void)forwardInvovation:(NSInvocation)anInvocation {\n     if ([someOtherObject respondsToSelector:\n             [anInvocation selector]]) {\n         [anInvocation invokeWithTarget:someOtherObject];\n     } else {\n         [super forwardInvocation:anInvocation];\n     }\n }\n</code></pre><p> 该方法对象会创建一个表示消息的NSInvocation对象, 把与尚未处理的消息有关的全部细节都封装在anInvocation中, 包括selector, 目标(target)和参数. 我们可以在forwardInvocation方法中选择将消息转发给其它对象. 我们可以通过anInvocation对象做很多处理, 比如修改实现方法, 修改响应对象等.</p>\n<p> 这个方法的主要作用是定位可以响应封装在anInvocation中的消息的对象(这个对象不需要能处理所有未知消息). 使用anInvocation作为参数, 将消息发送到选中的对象. anInvocation将会保留调用结果, 运行时系统会提取这一结果并将其发送到消息的原始发送者. 在这个方法中我们也可以实现一些更复杂的功能, 我们可以对消息的内容进行修改, 比如追回一个参数等, 然后再去触发消息. 另外, 若发现某个消息不应由本类处理, 则应调用父类的同名方法, 以便继承体系中的每个类都有机会处理此调用请求.</p>\n</li>\n<li><p>上面两个补救措施做完后, 若发现某调用不应由本类处理, 则会调用超类的同名方法. 如此, 继承体系中的每个类都有机会处理该方法调用的请求, 一直到NSObject根类. 如果到NSObject也不能处理该条消息, 那么就是再无挽救措施了, 只能抛出”doesNotRecognizeSelector”异常.</p>\n</li>\n</ol>\n<h2 id=\"Runtime经典问题分析\"><a href=\"#Runtime经典问题分析\" class=\"headerlink\" title=\"Runtime经典问题分析\"></a>Runtime经典问题分析</h2><p>这里有几个网络上常见的Runtime经典问题, 下面我会逐个分析.</p>\n<h3 id=\"self-class-与-super-class\"><a href=\"#self-class-与-super-class\" class=\"headerlink\" title=\"[self class]与[super class]\"></a>[self class]与[super class]</h3><pre><code> @implementation Son : Father\n- (id)init {\n    self = [super init];\n    if (self)\n    {\n        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));\n        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));\n    }\nreturn self;\n}\n@end\n</code></pre><p>如题, 先说结果: </p>\n<pre><code>2018-03-15 20:02:57.031501+0800 HCRuntime[8115:645357] Son\n2018-03-15 20:02:57.034428+0800 HCRuntime[8115:645357] Son\n</code></pre><p>首先我们有几个概念要理解: </p>\n<pre><code>//[self class]实际是调用objc_msgSend方法\nid objc_msgSend(id self, SEL op, ...)\n//[super class]实际是调用objc_msgSendSuper方法\nid objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n\nstruct objc_super {\n   __unsafe_unretained id receiver;//类似于objc_msgSend中的self\n   __unsafe_unretained Class super_class;//记录当前类的父类是什么\n};\n\n- (Class)class {\n    return object_getClass(self);\n}\n</code></pre><p>self 和 super 的唯一区别是, 当使用 self 调用方法时, 会从当前类的方法列表中开始找, 如果没有, 就从父类中再找; 而当使用 super 时, 则从父类的方法列表中开始找, 然后调用父类的这个方法. self 是类的隐藏参数, 指向当前调用方法的这个类的实例. 而 super 是一个 Magic Keyword, 它本质是一个编译器标示符, 和 self 是指向的同一个消息接受者.</p>\n<p>结合本题, 当调用<code>[self class]</code>时, 先调用的是 <code>objc_msgSend</code> 函数, 第一个参数是<code>Son</code>这个类的实例, 然后去示例的ISA(Son类)中找 <code>- (Class)class</code> 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 而 <code>- (Class)class</code> 的实现就是返回self的类别, 故上述输出结果为 Son.<br>当调用<code>[super class]</code>时, 先调用的是<code>class_getSuperclass</code>函数, 该函数第一个参数是结构体 <code>objc_super</code>(第一个参数是self, 第二个参数是当前实例变量的super_class, 就是Father类). 然后直接从实例变量所在类的父类(Father)去找<code>- (Class)class</code> 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用, 此时已经和<code>[self class]</code>调用相同了, 故上述输出结果仍然返回 Son.</p>\n<h3 id=\"isKindOfClass与isMemberOfClass\"><a href=\"#isKindOfClass与isMemberOfClass\" class=\"headerlink\" title=\"isKindOfClass与isMemberOfClass\"></a>isKindOfClass与isMemberOfClass</h3><pre><code>@interface Student : NSObject\n@end\n@implementation Student\n@end\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\n        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];\n        BOOL res3 = [(id)[Student class] isKindOfClass:[Student class]];\n        BOOL res4 = [(id)[Student class] isMemberOfClass:[Student class]];\n        NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4);\n    }\n    return 0;\n}\n</code></pre><p>如题, 先说结果: </p>\n<pre><code>2018-03-15 21:33:16.047955+0800 HCRuntime[8721:695376] 1 0 0 0\n</code></pre><p>再来进行分析, 这里主要的知识点是类, 原类, 实例变量之间的关系, 以及三个函数的内部实现: </p>\n<pre><code>+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n\nClass object_getClass(id obj) {\n    if (obj) return obj-&gt;getIsa();\n    else return Nil;\n}\n\n- (BOOL)isKindOf:(Class)cls {\n    Class cls;\n    for (cls = isa; cls; cls = cls-&gt;superclass) \n        if (cls == (Class)aClass)\n            return YES;\n    return NO;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n- (BOOL)isMemberOf:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return object_getClass((id)self) == cls;\n}\n</code></pre><p>接下来我们挨个分析: </p>\n<ol>\n<li><code>[(id)[NSObject class] isKindOfClass:[NSObject class]]</code>; <code>[NSObject class]</code>返回NSObject(Class), 所以走类方法. cls是NSObject(Class). 第一次比较, tcls是object_getClass((id)self)也就是NSObject(Class)的ISA也就是NSObject(Class)的Meta Class, 两者不相等, 第二次比较, cls是NSObject(Class), tcls是NSObject(Class)的Meta Class的superclass, 也就是NSObject(Class), 两者相等, 循环结束, 返回YES.</li>\n<li><code>[(id)[NSObject class] isMemberOfClass:[NSObject class]]</code>; 因为<code>[NSObject class]</code>返回NSObject(Class), 所以走类方法. 只比较一次, cls是NSObject(Class), object_getClass((id)self)也就是NSObject(Class)的ISA也就是NSObject(Class)的Meta Class, 两者不相等, 返回NO;</li>\n<li><p><code>[(id)[Student class] isKindOfClass:[Student class]]</code>; 类似于第一题, <code>[Student class]</code>返回Student(Class), 所以走类方法. cls是Student(Class). 第一次比较, tcls是Student(Class)的ISA, 也就是Student(Class)的Meta Class, 不相等. 第二次比较, tcls是Student(Class)的Meta Class的superclass, 也就是NSObject的Meta Class, 不相等. 第三次比较, tcls是NSObject的Meta Class的superclass也就是NSObject(Class), 不相等. 第四次比较. tcls是NSObject(Class)的superclass, 是nil, 不相等. 至此不满足循环条件, 退出循环, 返回NO;</p>\n<p> 这里需要注意的是如果是<code>[(id)[[[Student alloc] init] class] isKindOfClass:[Student class]]</code>的话, <code>[Student alloc] init]</code>返回一个实例变量, 所以走实例方法. cls是Student(Class). 第一次比较, tcls是Student(Object)的ISA, 也就是Student(Class), 相等, 循环结束, 返回YES;</p>\n</li>\n<li><code>[(id)[Student class] isMemberOfClass:[Student class]]</code>; 类似于第二题, <code>[Student class]</code>返回Student(Class), 所以走类方法, 只比较一次. cls是Student(Class), <code>object_getClass((id)self)</code>是Student(Class)的ISA, 也就是Student(Class)的Meta Class, 两者不相等, 返回NO;</li>\n</ol>\n<h3 id=\"Class与内存地址\"><a href=\"#Class与内存地址\" class=\"headerlink\" title=\"Class与内存地址\"></a>Class与内存地址</h3><pre><code>@interface Student : NSObject\n@property (nonatomic, copy) NSString *name;\n- (void)speak;\n@end\n@implementation Student\n- (void)speak {                            \n   NSLog(@&quot;my name&#39;s %@&quot;, self.name);\n}\n@end\n@implementation ViewController\n\n- (void)viewDidLoad {  \n  [super viewDidLoad];\n  id cls = [Student class];\n  void *obj = &amp;cls;\n  [(__bridge id)obj speak];\n}\n@end\n</code></pre><p>如题, 先说结果: 程序可以正常运行, 结果如下:  </p>\n<pre><code>2018-03-15 22:45:52.486617+0800 HCRuntime[9838:786076] my name&#39;s &lt;ViewController: 0x7fc349d0a670&gt;\n</code></pre><p>接下来我们分析一下都发生了什么. 首先, obj被转换成了一个指向<code>[Student class]</code>的指针, 然后使用<code>(__bridge id)</code>转换成了 objc_object 类型, 这时候实际上已经是一个Student类型的实例对象了, 所以可以正常调用speak方法. 那么调用speak方法会输出什么呢? 我们接下来分析.</p>\n<p>首先我们要知道, Objective-C中的对象是一个指向ClassObject地址的变量, 即 id obj = &amp;ClassObject, 而对象的实例变量 void *ivar = &amp;obj + offset(N). 在C中局部变量是存储到内存的栈区, 程序运行时栈的地址从高到低. C语言到头来讲是一个顺序运行的语言, 随着程序运行, 栈中的地址越来越低. 我们来看下程序运行到执行到speak方法时, 栈中都放了哪些变量. </p>\n<p>首先, 执行会有两个隐藏参数传进来 self() 和 _cmd这两个参数依次被压入栈中. 然后调用<code>[super viewDidload]</code>方法, 这个方法实际是调用的<code>OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...)</code>, <code>objc_msgSendSuper2</code>方法入参是一个<code>objc_super *super</code>, <code>objc_super</code>的结构如下.</p>\n<pre><code>struct objc_super {  \n    /// Specifies an instance of a class.\n    __unsafe_unretained id receiver;\n\n    /// Specifies the particular superclass of the instance to message. \n#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__\n    /* For compatibility with old objc-runtime.h header */\n    __unsafe_unretained Class class;\n#else\n    __unsafe_unretained Class super_class;\n#endif\n    /* super_class is the first class to search */\n};\n#endif\n</code></pre><p>在调用<code>[super viewDidload]</code>方法时, 又产生了几个局部变量, <code>super_class</code>(等同于self.class)和<code>receiver</code>(等同于self), 依次被压入栈. 调用完<code>[super viewDidload]</code>方法后, 又产生了一个局部变量obj, 被压入栈.</p>\n<p>这时候栈中一共有五个变量, 地址从高到低分别是: 第一个是self和第二个是隐藏参数_cmd, 第三个是self.class和第四个self是<code>[super viewDidLoad]</code>方法执行时候的参数, 第五个是obj. 当我们调用self.name的时候, 本质上就是self指针在内存向高位地址偏移一个指针. 如果我们打印对象地址就可以看出, obj就是cls的地址, obj就是Student(Object), 所以self.name也就是obj的地址向上偏移一个指针, 指向了第四个参数self, 也就是viewController的地址.</p>\n<h3 id=\"Category-1\"><a href=\"#Category-1\" class=\"headerlink\" title=\"Category\"></a>Category</h3><pre><code>下面的代码会？Compile Error / Runtime Crash / NSLog…?\n\n @interface NSObject (Student)\n + (void)foo;\n - (void)foo;\n @end\n\n @implementation NSObject (Student)\n - (void)foo {\n    NSLog(@&quot;IMP: -[NSObject(Student) foo]&quot;);\n }\n\n@end\n\n#import &quot;NSObject+Student.h&quot;\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        [NSObject foo];\n        [[NSObject new] foo];\n\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n</code></pre><p>如题, 先说结果, 程序可以正常运行, 结果如下: </p>\n<pre><code>2018-03-17 22:47:42.695913+0800 HCRuntime[7043:463076] IMP: -[NSObject(Student) foo]\n2018-03-17 22:47:42.700542+0800 HCRuntime[7043:463076] IMP: -[NSObject(Student) foo]\n</code></pre><p>category中新增的方法, 如果是实例方法, 协议以及属性是直接添加到当前类上面, 如果是类方法和协议则会添加到当前类的原类上面去. </p>\n<p>所以调用<code>[NSObject foo]</code>时, 由于是类方法, 根据objc_msgSend的相关知识, 会先在NSObject(Class)的isa中也就是NSObject的meta-class中, 去查找foo方法的IMP, 没找到, 然后去NSObject的meta-class的superclass(NSObject)中找, 找到了, 执行foo方法. 调用<code>[[NSObject new] foo]</code>时, 会先在NSObject(Object)的isa中, 也就是NSObject(Class)中找, 找到了, 直接执行, 输出结果.</p>\n<h2 id=\"Runtime的常见用法\"><a href=\"#Runtime的常见用法\" class=\"headerlink\" title=\"Runtime的常见用法\"></a>Runtime的常见用法</h2><p>讲了那么多, 下面看下Runtime在实际应用中主要有用法. </p>\n<h3 id=\"实现多继承Multiple-Inheritance\"><a href=\"#实现多继承Multiple-Inheritance\" class=\"headerlink\" title=\"实现多继承Multiple Inheritance\"></a>实现多继承Multiple Inheritance</h3><p>转发和继承相似, 可以用于为Objc编程添加一些多继承的效果, 但是本身是不支持多继承的, 但是我们可以通过消息转发机制来实现多继承的功能. </p>\n<p>消息转发提供了许多类似于多继承的特性, 但是他们之间有一个很大的不同. 多继承合并了不同的行为特征在一个单独的对象中, 会得到一个重量级多层面的对象. 而消息转发则是将各个功能分散到不同的对象中, 得到的一些轻量级的对象, 这些对象通过消息转发联合起来.</p>\n<p>我们要重写消息转发函数, 并在其中, 把我们想要转发的类做一个判断, 类似与下面代码:</p>\n<pre><code>//我们在A类中重写他的消息转发方法, 把他转发给B类的对象\n- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector {\n    NSMethodSignature* signature = [super methodSignatureForSelector:selector];\n    if (!signature) {\n        signature = [objectB methodSignatureForSelector:selector];\n    }\n    return signature;\n}\n</code></pre><p>这样, 虽然我们可以正常运行这个方法, 但是如果我们调用<code>respondsToSelector:</code>, <code>isKindOfClass:</code>和 <code>instancesRespondToSelector:</code>方法, 还有如果我们使用了协议, 那么<code>conformsToProtocol:</code>和上面三个方法都是要被重写的, 因为这类方法只会考虑继承体系, 不会考虑转发链. </p>\n<h3 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h3><p>Method Swizzling本质上就是对IMP和SEL进行交换, 当Method Swilzzling代码执行完毕之后互换才起作用, Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式. 我们替换ViewController的<code>viewWillAppear:</code>方法为例, 使用方式如下: </p>\n<pre><code>@implementation ViewController (MethodSwizzling)\n\n+ (void)load {\n    static dispatch_once_t once;\n    dispatch_once(&amp;once, ^{\n        Class class = [self class];\n        //这里需要注意, 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身.\n        // Class class = object_getClass((id)self);\n        SEL originalSelector = @selector(viewWillAppear:);\n        SEL swizzledSelector = @selector(xxx_viewWillAppear:);\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n        //我们先把要替换的类添加到category中\n        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));\n        if (didAddMethod) {\n            //class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现\n            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));\n        } else {\n            //交换IMP, IMP是函数指针, 直接指向方法的内存地址\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)xxx_viewWillAppear:(BOOL)animated {\n    [self xxx_viewWillAppear:animated];\n    NSLog(@&quot;%@ viewWillAppear&quot;, self);\n}\n@end\n</code></pre><p>这里有几点是要注意的: </p>\n<ol>\n<li>Objective-C在运行时会自动调用类的两个方法<code>+load</code>和<code>+initialize</code>. <code>+load</code>会在类初始加载时调用, <code>+initialize</code>方法是以懒加载的方式被调用的, 只有当你给某个类或它的子类发送消息, 那么这个类的<code>+initialize</code>方法才会被调用. 所以Swizzling要写在<code>+load</code>方法中, 因为写在<code>+initialize</code>方法中, 是有可能永远都不被执行. </li>\n<li>Swizzling应该只被执行一次, 如果Swizzling的方法被多次执行, 那么就有可能造成Swizzling失效, 所以我们要用dispatch_once来保证只被执行一次. </li>\n<li>Swizzling在<code>+load</code>中执行时, 不要调用<code>[super load]</code>. 如果是多继承, 并且对同一个方法都进行了Swizzling, 那么调用[super load]以后, 父类的Swizzling就失效了.</li>\n<li>在swizzling的过程中, 方法中的<code>[self xxx_viewWillAppear:animated]</code>已经被重新指定到UIViewController类的<code>-viewWillAppear:</code>中. 这时不会产生无限循环. 如果我们调用的是<code>[self viewWillAppear:animated]</code>, 因为<code>viewWillAppear:</code>被重定向到<code>xxx_viewWillAppear:</code>, 就会产生无限循环.</li>\n<li>如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. <code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 Class, 但前者为元类, 后者为其本身.</li>\n<li>我们也可以使用这个来做一些异常保护, 例如数组的越界问题, 我们可以Swizzling数组的<code>objectAtIndex:</code>方法, 在新方法中做一些异常处理, 来抛出一些异常信息, 方便我们定位问题.<h3 id=\"Isa-Swizzling\"><a href=\"#Isa-Swizzling\" class=\"headerlink\" title=\"Isa Swizzling\"></a>Isa Swizzling</h3>在Objective-C中, 所有的类自身也是一个对象, 这个对象的Class里面也有一个isa指针, 它指向metaClass(元类). 而消息的转发objc_msgSend也是从他的isa开始查找方法列表, 所以如果我们替换了isa, 实际也相当于替换了类. </li>\n</ol>\n<p>可以参考<a href=\"http://hchong.net/2018/01/24/KVO%E8%AF%A6%E8%A7%A3/\">KVO的实现</a>. KVO在调用addObserver方法之后, 苹果的做法是在执行完 <code>addObserver: forKeyPath: options: context:</code> 方法之后, 把isa指向到另外一个类去. </p>\n<h3 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h3><p>面向切面编程, 常用的第三方库有一个<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a>. 他的实现逻辑我们可以看<a href>这篇文章</a>. 下面我们来分析一下我们如何为自己实现一个AOP.</p>\n<p>AOP的多数操作就是在forwardInvocation(<a href=\"#消息的转发\">消息转发的第二阶段</a>)中完成的. 一般会分为2个阶段, 一个是Intercepter注册阶段, 一个是Intercepter执行阶段.</p>\n<p>首先会把类里面的某个要切片的方法的IMP加入到Aspect中, 类方法里面如果有forwardingTargetForSelector:的IMP, 也要加入到Aspect中. 然后对类的切片方法和forwardingTargetForSelector:的IMP进行替换, 两者的IMP相应的替换为objc_msgForward()方法和hook过的forwardingTargetForSelector:. 这样主要的Intercepter注册就完成了. </p>\n<p>当执行func()方法的时候, 会去查找它的IMP, 现在它的IMP已经被我们替换为了objc_msgForward()方法, 于是开始查找备援转发对象. 查找备援接受者调用forwardingTargetForSelector:这个方法, 由于这里是被我们hook过的, 所以IMP指向的是hook过的forwardingTargetForSelector:方法. 这里我们会返回Aspect的target, 即选取Aspect作为备援接受者. 有了备援接受者之后, 就会重新objc_msgSend. 从消息发送阶段重头开始. objc_msgSend找不到指定的IMP, 再进行_class_resolveMethod, 这里也没有找到, forwardingTargetForSelector:这里也不做处理, 接着就会methodSignatureForSelector. 在methodSignatureForSelector方法中创建一个NSInvocation对象, 传递给最终的forwardInvocation方法. </p>\n<p>Aspect里面的forwardInvocation方法会干所有切面的事情. 这里转发逻辑就完全由我们自定义了. Intercepter注册的时候我们也加入了原来方法中的method()和forwardingTargetForSelector:方法的IMP, 这里我们可以在forwardInvocation方法中去执行这些IMP. 在执行这些IMP的前后都可以任意的插入任何IMP以达到切面的目的.</p>\n<h3 id=\"动态的增加方法\"><a href=\"#动态的增加方法\" class=\"headerlink\" title=\"动态的增加方法\"></a>动态的增加方法</h3><p>在消息发送阶段, 如果在父类中也没有找到相应的IMP, 就会执行resolveInstanceMethod方法. 在这个方法里面, 我们可以动态的给类对象或者实例对象动态的增加方法. </p>\n<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)sel {\n\n    NSString *selectorString = NSStringFromSelector(sel);\n    if ([selectorString isEqualToString:@&quot;method1&quot;]) {\n        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);\n    }\n\n    return [super resolveInstanceMethod:sel];\n}\n</code></pre><p>关于方法操作的函数还有以下这些: </p>\n<pre><code>// 调用指定方法的实现\nid method_invoke ( id receiver, Method m, ... );  \n// 调用返回一个数据结构的方法的实现\nvoid method_invoke_stret ( id receiver, Method m, ... );  \n// 获取方法名\nSEL method_getName ( Method m );  \n// 返回方法的实现\nIMP method_getImplementation ( Method m );  \n// 获取描述方法参数和返回值类型的字符串\nconst char * method_getTypeEncoding ( Method m );  \n// 获取方法的返回值类型的字符串\nchar * method_copyReturnType ( Method m );  \n// 获取方法的指定位置参数的类型字符串\nchar * method_copyArgumentType ( Method m, unsigned int index );  \n// 通过引用返回方法的返回值类型字符串\nvoid method_getReturnType ( Method m, char *dst, size_t dst_len );  \n// 返回方法的参数的个数\nunsigned int method_getNumberOfArguments ( Method m );  \n// 通过引用返回方法指定位置参数的类型字符串\nvoid method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );  \n// 返回指定方法的方法描述结构体\nstruct objc_method_description * method_getDescription ( Method m );  \n// 设置方法的实现\nIMP method_setImplementation ( Method m, IMP imp );  \n// 交换两个方法的实现\nvoid method_exchangeImplementations ( Method m1, Method m2 );\n</code></pre><h3 id=\"动态关联对象\"><a href=\"#动态关联对象\" class=\"headerlink\" title=\"动态关联对象\"></a>动态关联对象</h3><p>实现原理<a href=\"http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/\" target=\"_blank\" rel=\"noopener\">看这里</a>, <a href=\"https://draveness.me/ao\" target=\"_blank\" rel=\"noopener\">看这里</a>. 这个也很常用, 主要涉及到三个函数: </p>\n<pre><code>OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)  \n    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n\nOBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)  \n    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n\nOBJC_EXPORT void objc_removeAssociatedObjects(id object)  \n    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n</code></pre><p>上面需要传入的几个参数的含义:</p>\n<ol>\n<li><p>id object 设置关联对象的实例对象</p>\n</li>\n<li><p>const void *key 区分不同的关联对象的 key。这里会有3种写法。</p>\n<pre><code> //使用 &amp;AssociatedObjectKey 作为key值\n static char AssociatedObjectKey = &quot;AssociatedKey&quot;;\n\n //使用AssociatedKey 作为key值\n static const void *AssociatedKey = &quot;AssociatedKey&quot;;\n\n //使用@selector    \n @selector(associatedKey)\n</code></pre></li>\n<li>id value 关联的对象</li>\n<li><p>objc_AssociationPolicy policy 关联对象的存储策略, 它是一个枚举, 与property的attribute 相对应</p>\n<pre><code> typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n     //弱引用关联对象\n     OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */\n     //强引用关联对象且为非原子操作\n     OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. \n                                             *   The association is not made atomically. */\n     //复制关联对象, 切位非原子操作\n     OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. \n                                             *   The association is not made atomically. */\n     //强引用关联对象, 且为原子操作\n     OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.\n                                             *   The association is made atomically. */\n     //复制关联对象, 且为原子操作\n     OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.\n                                             *   The association is made atomically. */\n };\n</code></pre></li>\n</ol>\n<p>例如我们给NSobjet的category增加一个name属性</p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n\n@interface NSObject (Student)\n- (NSString *)name;\n\n- (void)setName:(NSString *)name;\n@end\n\n#import &quot;NSObject+Student.h&quot;\n#import &lt;objc/runtime.h&gt;\n\n@implementation NSObject (Student)\n\n- (NSString *)name {\n    return objc_getAssociatedObject(self, _cmd);\n}\n\n- (void)setName:(NSString *)name {\n    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n@end\n</code></pre><h3 id=\"NSCoding的自动归档和自动解档\"><a href=\"#NSCoding的自动归档和自动解档\" class=\"headerlink\" title=\"NSCoding的自动归档和自动解档\"></a>NSCoding的自动归档和自动解档</h3><p>这个太常用了, 主要思路是获取成员变量列表, 利用KVC读取和赋值来完成<code>encodeWithCoder</code>和<code>initWithCoder</code>.</p>\n<pre><code>#import &quot;Student.h&quot;\n#import &lt;objc/runtime.h&gt;\n#import &lt;objc/message.h&gt;\n\n@implementation Student\n\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    unsigned int outCount = 0;\n    Ivar *vars = class_copyIvarList([self class], &amp;outCount);\n    for (int i = 0; i &lt; outCount; i ++) {\n        Ivar var = vars[i];\n        const char *name = ivar_getName(var);\n        NSString *key = [NSString stringWithUTF8String:name];\n\n        id value = [self valueForKey:key];\n        [aCoder encodeObject:value forKey:key];\n    }\n}\n\n- (nullable __kindof)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        unsigned int outCount = 0;\n        Ivar *vars = class_copyIvarList([self class], &amp;outCount);\n        for (int i = 0; i &lt; outCount; i ++) {\n            Ivar var = vars[i];\n            const char *name = ivar_getName(var);\n            NSString *key = [NSString stringWithUTF8String:name];\n            id value = [aDecoder decodeObjectForKey:key];\n            [self setValue:value forKey:key];\n        }\n    }\n    return self;\n}\n@end\n</code></pre><h3 id=\"字典和模型互相转换\"><a href=\"#字典和模型互相转换\" class=\"headerlink\" title=\"字典和模型互相转换\"></a>字典和模型互相转换</h3><ol>\n<li><p>字典转模型</p>\n<ol>\n<li>调用 class_getProperty 方法获取当前 Model 的所有属性.</li>\n<li>调用 property_copyAttributeList 获取属性列表.</li>\n<li>根据属性名称生成 setter 方法.</li>\n<li><p>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC)<br>示例代码如下: </p>\n<pre><code>+(id)objectWithKeyValues:(NSDictionary *)aDictionary{\n id objc = [[self alloc] init];\n for (NSString *key in aDictionary.allKeys) {\n     id value = aDictionary[key];\n\n     /*判断当前属性是不是Model*/\n     objc_property_t property = class_getProperty(self, key.UTF8String);\n     unsigned int outCount = 0;\n     objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);\n     objc_property_attribute_t attribute = attributeList[0];\n     NSString *typeString = [NSString stringWithUTF8String:attribute.value];\n\n     //防止model嵌套, 比如说Student里面还有一层Student, 那么这里就需要再次转换一次, 当然这里有几层就需要转换几次.\n     if ([typeString isEqualToString:@&quot;@\\&quot;Student\\&quot;&quot;]) {\n         value = [self objectWithKeyValues:value];\n     }\n\n     //生成setter方法，并用objc_msgSend调用\n     NSString *methodName = [NSString stringWithFormat:@&quot;set%@%@:&quot;,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];\n     SEL setter = sel_registerName(methodName.UTF8String);\n     if ([objc respondsToSelector:setter]) {\n         ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);\n     }\n     free(attributeList);\n }\n return objc;\n}\n</code></pre><p>几个出名的开源库JSONModel, MJExtension等都是通过这种方式实现的. 利用runtime的class_copyIvarList获取属性数组, 遍历模型对象的所有成员属性, 根据属性名找到字典中key值进行赋值, 当然这种方法只能解决NSString, NSNumber等. 如果含有NSArray或NSDictionary, 还要进行第二步转换, 如果是字典数组, 需要遍历数组中的字典, 利用objectWithDict方法将字典转化为模型, 在将模型放到数组中, 最后把这个模型数组赋值给之前的字典数组.</p>\n</li>\n</ol>\n</li>\n<li><p>模型转字典</p>\n<ol>\n<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性. </li>\n<li>调用 property_getName 获取属性名称.</li>\n<li>根据属性名称生成 getter 方法.</li>\n<li><p>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.<br>示例代码如下: </p>\n<pre><code>//模型转字典\n-(NSDictionary *)keyValuesWithObject{\n unsigned int outCount = 0;\n objc_property_t *propertyList = class_copyPropertyList([self class], &amp;outCount);\n NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n for (int i = 0; i &lt; outCount; i ++) {\n     objc_property_t property = propertyList[i];\n\n     //生成getter方法，并用objc_msgSend调用\n     const char *propertyName = property_getName(property);\n     SEL getter = sel_registerName(propertyName);\n     if ([self respondsToSelector:getter]) {\n         id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);\n\n         /*判断当前属性是不是Model*/\n         if ([value isKindOfClass:[self class]] &amp;&amp; value) {\n             value = [value keyValuesWithObject];\n         }\n\n         if (value) {\n             NSString *key = [NSString stringWithUTF8String:propertyName];\n             [dict setObject:value forKey:key];\n         }\n     }\n\n }\n free(propertyList);\n return dict;\n}\n</code></pre></li>\n</ol>\n</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://halfrost.com/objc_runtime_isa_class/\" target=\"_blank\" rel=\"noopener\">神经病院 Objective-C Runtime 入院系列</a></p>\n<p>2.<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime</a></p>\n<p>3.<a href=\"http://southpeak.github.io/2014/10/25/objective-c-runtime-1/\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime 运行时系列</a></p>\n<p>4.<a href=\"https://halfrost.com/ios_aspect/\" target=\"_blank\" rel=\"noopener\">iOS 如何实现 Aspect Oriented Programming</a></p>\n<p>5.<a href=\"http://tech.glowing.com/cn/method-swizzling-aop/\" target=\"_blank\" rel=\"noopener\">Method Swizzling 和 AOP 实践</a></p>\n<p>6.<a href=\"http://www.cocoachina.com/ios/20141224/10740.html\" target=\"_blank\" rel=\"noopener\">刨根问底Objective－C Runtime</a></p>\n<p>7.<a href=\"https://tech.meituan.com/DiveIntoCategory.html\" target=\"_blank\" rel=\"noopener\">深入理解Objective-C：Category</a></p>\n<p>8.<a href=\"http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/\" target=\"_blank\" rel=\"noopener\">Objective-C 消息发送与转发机制原理</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"RN实践指南","url":"http://hchong.net/2017/12/01/RN实践指南/","content":"<h1 id=\"RN实践指南\"><a href=\"#RN实践指南\" class=\"headerlink\" title=\"RN实践指南\"></a>RN实践指南</h1><p>RN区别于传统项目三板斧(HTML, CSS, JS)我们可以在JS文件中写HTML的语法和CSS的布局, 这种语法称为JSX, 属于JS的语法拓展. RN使用的是虚拟DOM(存在于内存中的DOM), 他与DOM是一一对应的关系. 当界面发生变化时, 得益于DOM Diff算法, 我们就知道了虚拟DOM的变化, 从而高效的改动DOM, 避免了重新绘制DOM.</p>\n<p>RN的本质就是JS与OC通过JavaScript Core的相互调用, 源码分析参考<a href=\"http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">这里</a>, JS与OC的通信机制参考<a href=\"http://blog.cnbang.net/tech/2698/\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>RN的生命周期, 大致可以用下面这张图来概括:</p>\n<p><img src=\"http://7rf9ir.com1.z0.glb.clouddn.com/3-3-component-lifecycle.jpg\" alt=\"RN声明周期\"></p>\n<p>如图所示, RN的生命周期大致分为三个阶段:</p>\n<ul>\n<li><p>第一阶段: 是组件第一次绘制阶段, 如图中的上面虚线框内, 在这里完成了组件的加载和初始化;</p>\n<ul>\n<li><p><code>getDefaultProps</code>该函数用于初始化一些默认属性, 全局仅调用一次, 通常会将固定的内容放在这个函数中进行初始化和赋值. <em>注意</em>这是ES5的写法, 在ES6中我们使用static成员来实现. 更多ES5与ES6使用对照参考<a href=\"http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</li>\n<li><p><code>getInitialState</code>该函数用于对组件一些状态进行初始化, 可以将控制控件状态的一些变量放在这里初始化. 通过get取值, set写值. <em>注意</em>这是ES5的写法, 在ES6中我们常使用下面这种写法:</p>\n<pre><code>```\nconstructor(props){\n    super(props);\n    this.state = {\n        key: value,\n    };\n}\n```\n</code></pre></li>\n<li><p><code>componentWillMount</code>, 该方法表示组件将要加载到虚拟DOM中, 在render()方法之前执行, 整个生命周期只执行一次.</p>\n</li>\n<li><p><code>componentDidMount</code>, 该方法在组件第一次绘制之后调用, 通知组件已经加载完成, 这个函数整个生命周期只被调用一次, 这个函数被调用的时候就说虚拟DOM已经构建完成, 可以在这个函数中获取其中的元素和子组件. 这个函数之后, 就进入了稳定状态, 只有等到其他事件触发才会再次调用其他的函数.</p>\n</li>\n</ul>\n</li>\n<li><p>第二阶段: 是组件在运行和交互阶段, 如图中左下角虚线框, 这个阶段组件可以处理用户交互, 或者接收事件更新界面;</p>\n<ul>\n<li><p><code>componentWillReceiveProps</code>, 在组件接收到其父组件传递的props的时候执行, 参数为父组件传递的props. 在组件的整个生命周期可以多次执行, 通常在此方法接收新的props值, 重新设置state. </p>\n<pre><code>  componentWillReceiveProps(nextProps) {\n       this.setState({\n         //key : value\n       });\n  }\n</code></pre></li>\n<li><p><code>shouldComponentUpdate</code>, 当组件接收到新的props或者state改变时, 都会调用该方法, 该函数的返回值直接决定是否要更新组件. 该方法包含两个参数, 分别是props和state. 该方法在组件的整个生命周期可以多次执行. 如果该方法返回false, 则componentWillUpdate(nextProps, nextState)及其之后执行的方法都不会执行, 组件则不会进行重新渲染.</p>\n<pre><code>  shouldComponentUpdate(nextProps, nextState) {\n    return true;\n  }\n</code></pre></li>\n<li><p><code>componentWillUpdate</code>, 如果组件状态或者属性改变, 并且<code>shouldComponentUpdate</code>的返回值为true, 就会更新组件, 在组件更新之前会先调用该方法, 该方法在整个声明周期中可以被多次执行. 在该方法中可以做一些更新界面之前要做的事情. <em>注意</em>, 在这个函数中不能使用set来修改state的值. 该函数调用之后, 就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中. 紧接着这个函数, 就会调用 <code>render()</code> 来更新界面.</p>\n<pre><code>  componentWillUpdate(nextProps, nextState) {\n\n  }\n</code></pre></li>\n<li><p><code>render</code>, 方法用于渲染组件, 在初始化阶段和运行期阶段都会执行.</p>\n<pre><code>  render() {\n    return(\n      &lt;View/&gt;\n    );\n  }\n</code></pre></li>\n<li><p><code>componentDidUpdate</code>, 该方法在<code>render()</code>之后立刻调用, 包含两个参数, 分别是props和state. 该方法在组件的整个生命周期可以多次执行. 因为到这里已经完成了属性和状态的更新, 此时, 函数的参数就变成prevProps和prevState.</p>\n<pre><code>  componentDidUpdate(prevProps, prevState)(  \n\n  )\n</code></pre></li>\n</ul>\n</li>\n<li><p>第三阶段: 是组件卸载消亡的阶段, 如图中右下角的虚线框中, 这里做一些组件的清理工作;</p>\n<ul>\n<li><code>componentWillUnmount</code>, 当组件将要从界面上移除的时候, 就会调用该方法.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>RN布局采用的是前端的flex布局, 关于这种布局方式, 网上的教程一大堆, 强烈推荐阮阮一峰<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>.</p>\n<h2 id=\"组件间通信\"><a href=\"#组件间通信\" class=\"headerlink\" title=\"组件间通信\"></a>组件间通信</h2><p>RN的组件间通信主要分为父子组件和跨级组件间通信.</p>\n<ul>\n<li>父子组件通信, 父组件设置属性参数, 子组件通过props取得参数.</li>\n<li><p>子父组件通信, 也通过props.</p>\n<pre><code>  //子组件\n  class Son extends Component {\n      constructor(props) {\n          super(props);\n      }\n      componentDidMount() {\n          //子组件给父组件的方法传参\n          this.props.onChange(&#39;newVal&#39;);\n      }\n      render() {\n          return (\n              &lt;View /&gt;\n          );\n      }\n  }\n\n  //父组件\n  class Father extends Component {\n      constructor(props) {\n          super(props);\n          this.state = {\n              key: &#39;defVal&#39;\n          };\n      }\n\n      //父组件接受子组件的参数，并改变 state\n      handleChange(val) {\n          this.setState({\n              key: val \n          });\n      }\n\n      render() {\n          return (\n              &lt;Son onChange={this.clickItem}/&gt;\n          );\n      }\n\n      clickItem = (item) =&gt; {\n          this.handleChange(item);\n      }\n  }\n</code></pre></li>\n<li><p>跨级组件间通信<br>  如果是兄弟组件可以先把值向上传递到父组件, 在向下传递到子组件. 如果是嵌套多层的传值可以使用context对象. 参考<a href=\"https://www.jianshu.com/p/fb915d9c99c4\" target=\"_blank\" rel=\"noopener\">React 中组件间通信的几种方式</a>.</p>\n</li>\n<li><p>观察者模式通信, 使用eventProxy对象. 该对象共有四个函数, 使用方法很简单.</p>\n<ul>\n<li>on, one: on 与 one 函数用于订阅者监听相应的事件, 并将事件响应时的函数作为参数, on 与 one 的唯一区别就是, 使用 one 进行订阅的函数, 只会触发一次, 而使用 on 进行订阅的函数, 每次事件发生相应时都会被触发.</li>\n<li>trigger: trigger 用于发布者发布事件, 将除第一参数(事件名)的其他参数, 作为新的参数, 触发使用 one 与 on 进行订阅的函数.</li>\n<li>off: 用于解除所有订阅了某个事件的所有函数.</li>\n</ul>\n</li>\n<li><p>使用Refs, Refs的关键在于保存组件的实例, 实例代码如下(子组件向父组件传递).</p>\n<pre><code>  //子组件\n  class Son extends Component {\n      constructor(props) {\n          super(props);\n      }\n\n      //开放的实例方法\n      doIt() {\n          //...做点什么\n      }\n\n      render() {\n          return (\n              &lt;View /&gt;\n          );\n      }\n  }\n\n  //父组件\n  class Father extends Component {\n      constructor(props) {\n          super(props);\n      }\n\n      render() {\n          //this.yyy 保存组件的实例\n          return (\n              &lt;Son ref={(xxx) =&gt; {this.yyy = xxx;}} /&gt;\n          );\n      }\n\n      componentDidMount() {\n          //调用组件的实例方法\n          this.myCpt.doIt();\n      }\n  }\n</code></pre></li>\n<li><p>使用global<br>  global 类似浏览器里的 window 对象, 它是全局的, 一处定义, 所有组件都可以访问, 一般用于存储一些全局的配置参数或方法. 使用场景: 全局参数不想通过 props 层层组件传递, 有些组件对此参数并不关心, 只有嵌套的某个组件使用.</p>\n<pre><code>  global.isOnline = true;\n</code></pre></li>\n</ul>\n<h2 id=\"MobX与RN的结合使用\"><a href=\"#MobX与RN的结合使用\" class=\"headerlink\" title=\"MobX与RN的结合使用\"></a>MobX与RN的结合使用</h2><p>强烈推荐使用<a href=\"https://mobx.js.org/index.html\" target=\"_blank\" rel=\"noopener\">MobX</a>以数据驱动视图, 通过数据绑定, 我们只需修改数据本身, 便可自动更新视图. <a href=\"http://cn.mobx.js.org/\" target=\"_blank\" rel=\"noopener\">中文文档</a></p>\n<h2 id=\"MobX与RN的结合使用范式\"><a href=\"#MobX与RN的结合使用范式\" class=\"headerlink\" title=\"MobX与RN的结合使用范式\"></a>MobX与RN的结合使用范式</h2><p>我们尽量推荐一个模块由若干pages, 若干models和stores组成. 他们分别对应到iOS开发中的VC, M和VM三层. 如果使用store, 那么建议不要再使用state来控制UI状态, 建议都放进store里面.</p>\n<ul>\n<li>pages内就是一些组件, 业务逻辑</li>\n<li>store内可以定义一些跟数据相关的action, 对接口获取回来的数据做一层映射, 利用Mobx来实现数据变化自动分发渲染, 统一规划数据层.</li>\n<li>model类似于OC的瘦model, 也可以在里面做数据映射和数据校验</li>\n</ul>\n<h2 id=\"MobX使用注意\"><a href=\"#MobX使用注意\" class=\"headerlink\" title=\"MobX使用注意\"></a>MobX使用注意</h2><p>关于MobX的使用还要注意下面这些: </p>\n<blockquote>\n<p>MobX 会对在追踪函数执行过程中读取现存的可观察属性做出反应。<br>“读取” 是对象属性的间接引用，可以用<code>.</code>(例如 user.name) 或者 <code>[]</code>(例如 user[‘name’]) 的形式完成。<br>“追踪函数” 是 computed 表达式、observer 组件的 render() 方法和 when、reaction 和 autorun 的第一个入参函数。<br>“过程(during)” 意味着只追踪那些在函数执行时被读取的 observable 。这些值是否由追踪函数直接或间接使用并不重要。<br>MobX 追踪属性访问, 而不是值. 也可以理解为c/c++当中的指针的概念. 例如一个数组新增一个元素, 是不会触发MobX.</p>\n</blockquote>\n<h2 id=\"MobX与其他状态管理框架的对比\"><a href=\"#MobX与其他状态管理框架的对比\" class=\"headerlink\" title=\"MobX与其他状态管理框架的对比\"></a>MobX与其他状态管理框架的对比</h2><p>MobX与Redux, Flux总是要放在一起对比的, 他们的对比<a href=\"http://zhenhua-lee.github.io/react/state-manage.html\" target=\"_blank\" rel=\"noopener\">看这里</a>. </p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/2a1571d23cf1\" target=\"_blank\" rel=\"noopener\">React Native组件的生命周期</a></p>\n<p>2.<a href=\"https://www.race604.com/react-native-component-lifecycle/\" target=\"_blank\" rel=\"noopener\">React Native 中组件的生命周期</a></p>\n<p>3.<a href=\"http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">React/React Native的ES5 ES6对照表</a></p>\n<p>4.<a href=\"http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">ReactNative iOS源码解析</a></p>\n<p>5.<a href=\"https://bestswifter.com/react-native/\" target=\"_blank\" rel=\"noopener\">React Native 从入门到原理</a></p>\n<p>6.<a href=\"http://blog.cnbang.net/tech/2698/\" target=\"_blank\" rel=\"noopener\">React Native通信机制详解</a></p>\n<p>7.<a href=\"https://reactnative.cn/docs/0.39/communication-ios.html\" target=\"_blank\" rel=\"noopener\">在原生和React Native间通信</a></p>\n","categories":["基础知识","RN"],"tags":["基础知识","RN"]},{"title":"iOS多线程","url":"http://hchong.net/2017/11/21/iOS多线程/","content":"<p>首先我们来搞清楚几个概念和他们之间的联系和区别: </p>\n<h2 id=\"多线程开发常用概念\"><a href=\"#多线程开发常用概念\" class=\"headerlink\" title=\"多线程开发常用概念\"></a>多线程开发常用概念</h2><ol>\n<li><p>进程和线程<br> 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.<br> 线程是进程的一个实体, 是CPU调度和分派(资源分配)的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数器, 一组寄存器和栈), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br> 一个线程可以创建和撤销另一个线程; 同一个进程中的多个线程之间可以并发执行.<br> 进程和线程的主要差别在于它们是不同的操作系统资源管理方式. 进程有独立的地址空间, 一个进程崩溃后, 在保护模式下不会对其它进程产生影响. 而线程只是一个进程中的不同执行路径. 线程有自己的堆栈和局部变量, 但线程之间没有单独的地址空间, 一个线程死掉就等于整个进程死掉, 所以多进程的程序要比多线程的程序健壮, 但在进程切换时, 耗费资源较大, 效率要差一些. 但对于一些要求同时进行并且又要共享某些变量的并发操作, 只能用线程, 不能用进程. </p>\n<ul>\n<li>简而言之, 一个程序至少有一个进程, 一个进程至少有一个线程.</li>\n<li>线程的划分尺度小于进程, 使得多线程程序的并发性高. </li>\n<li>另外, 进程在执行过程中拥有独立的内存单元, 而多个线程共享内存, 从而极大地提高了程序的运行效率. </li>\n<li>线程在执行过程中与进程还是有区别的. 每个独立的线程有一个程序运行的入口, 顺序执行序列和程序的出口. 但是线程不能够独立执行, 必须依存在应用程序中, 由应用程序提供多个线程执行控制. </li>\n<li><p>从逻辑角度来看, 多线程的意义在于一个应用程序中, 有多个执行部分可以同时执行. 但操作系统并没有将多个线程看做多个独立的应用, 来实现进程的调度和管理以及资源分配. 这就是进程和线程的重要区别.</p>\n<p>打个比方, 多进程就好比同时执行多个程序. 比如同时运行QQ, 音乐播放器, 以及浏览器. 多线程就是同一时刻执行多个线程, 用浏览器一边下载, 一边听歌, 一边看视频, 一边看网页. 浏览器这个进程下有多个线程, 这些线程共享系统分配给浏览器这个进程的资源, 所以各个线程之间可很方便的通信, 一个线程死了, 不会影响其他线程的运行. 如果浏览器这个进程死了, 那么他下面的所有线程就都用不了了. 我们可以通过浏览器打开QQ这里就是进程间通信, 由于不同的进程系统资源不同, 所以进程间的通信不是很容易实现. 并且切换进程会有性能问题.</p>\n</li>\n</ul>\n</li>\n<li><p>并发和并行<br> 并发指能够让多个任务在逻辑上交织执行的程序设计, 但并发事件之间不一定要同一时刻发生. 并行指的是程序运行时的状态是物理上同时执行, 是指同时发生的两个并发事件, 具有并发的含义, 而并发则不一定并行.<br> 并发是一种现象, 面对这一现象, 我们首先创建多个线程. 真正加快程序运行速度的, 是并行技术. 也就是让多个CPU同时工作. 而多线程, 是为了让多个CPU同时工作成为可能. 并发设计让并发执行成为可能, 而并行是并发执行的一种模式.<br> 并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头. 一个人同时吃三个馒头但是同一时间只能啃一个馒头, 三个人同时吃三个馒头, 三个馒头同一时间都会被啃.<br> 下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况. 假设每个核心有两个线程, 那么每个CPU中两个线程会交替并发, 两个CPU之间的操作会并行运算. 就CPU1而言虽然实现了并发但是同一时间只有一个任务在进行, CPU只是快速的在任务之间切换, CPU1和CPU2整体来看是并行元算, 同一时间是有多个任务在进行. 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题, 其本身运行效率并没有提高. 多CPU的并行运算才真正解决了运行效率问题, 这也正是并发和并行的区别. </p>\n<p>  <img src=\"http://img.souche.com/f2e/5d7717afde012bbfc557f26bc5eaffea.png\" alt=\"并发和并行\"></p>\n<p> 注意: 并行和串行是相对应的. 串行在物理层面上同一时刻只会有一个任务在进行.</p>\n</li>\n<li><p>同步和异步<br> 同步在发出一个同步调用时, 在没有得到结果之前, 该调用就不返回. 多个任务情况下, 一个任务A执行结束, 才可以执行另一个任务B. 只存在一个线程. 异步在发出一个异步调用后, 调用者不会立刻得到结果, 该调用就返回了. 多个任务情况下, 一个任务A正在执行, 同时可以执行另一个任务B. 任务B不用等待任务A结束才执行. 存在多条线程. </p>\n</li>\n</ol>\n<h2 id=\"多线程实现方案\"><a href=\"#多线程实现方案\" class=\"headerlink\" title=\"多线程实现方案\"></a>多线程实现方案</h2><p>在iOS开发中常见的多线程方案一共有4套, 分别是<code>Pthreads</code>, <code>NSThread</code>, <code>GCD</code>, <code>NSOperation &amp; NSOperationQueue</code>. 前两种不怎么常用, 这里就简单的介绍一下, 着重介绍后两种. </p>\n<h3 id=\"Pthresds\"><a href=\"#Pthresds\" class=\"headerlink\" title=\"Pthresds\"></a>Pthresds</h3><p>POSIX线程(POSIX threads), 简称Pthreads, 是线程的POSIX标准. 该标准定义了创建和操纵线程的一整套API, 在类Unix操作系统(Unix、Linux、Mac OSX等)中, 都使用Pthreads作为操作系统的线程. 那也就意味着可以跨平台使用, 但是使用起来特别酸爽. 🙂</p>\n<pre><code>#import &lt;pthread.h&gt;\n\n- (void)pthreadsDoTask {\n    /*\n     pthread_t：线程指针\n     pthread_attr_t：线程属性\n     pthread_mutex_t：互斥对象\n     pthread_mutexattr_t：互斥属性对象\n     pthread_cond_t：条件变量\n     pthread_condattr_t：条件属性对象\n     pthread_key_t：线程数据键\n     pthread_rwlock_t：读写锁\n     //\n     pthread_create()：创建一个线程\n     pthread_exit()：终止当前线程\n     pthread_cancel()：中断另外一个线程的运行\n     pthread_join()：阻塞当前的线程, 直到另外一个线程运行结束\n     pthread_attr_init()：初始化线程的属性\n     pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）\n     pthread_attr_getdetachstate()：获取脱离状态的属性\n     pthread_attr_destroy()：删除线程的属性\n     pthread_kill()：向线程发送一个信号\n     pthread_equal(): 对两个线程的线程标识号进行比较\n     pthread_detach(): 分离线程\n     pthread_self(): 查询线程自身线程标识号\n     //\n     *创建线程\n     int pthread_create(pthread_t _Nullable * _Nonnull __restrict, //指向新建线程标识符的指针\n     const pthread_attr_t * _Nullable __restrict,  //设置线程属性. 默认值NULL. \n     void * _Nullable (* _Nonnull)(void * _Nullable),  //该线程运行函数的地址\n     void * _Nullable __restrict);  //运行函数所需的参数\n     *返回值：\n     *若线程创建成功, 则返回0\n     *若线程创建失败, 则返回出错编号\n     */\n\n    //\n    pthread_t thread = NULL;\n    NSString *params = @&quot;Hello World&quot;;\n    int result = pthread_create(&amp;thread, NULL, threadTask, (__bridge void *)(params));\n    result == 0 ? NSLog(@&quot;creat thread success&quot;) : NSLog(@&quot;creat thread failure&quot;);\n    //设置子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源\n    pthread_detach(thread);\n}\n\nvoid *threadTask(void *params) {\n    NSLog(@&quot;%@ - %@&quot;, [NSThread currentThread], (__bridge NSString *)(params));\n    return NULL;\n}\n\n</code></pre><p>看下这些API设计可以说是相当不友好, 并且需要手动管理线程的各个状态的转换和生命周期的管理.</p>\n<h3 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h3><p><code>NSThread</code>的API设计大致如下: </p>\n<pre><code>@interface NSThread : NSObject\n//当前线程\n@property (class, readonly, strong) NSThread *currentThread;\n//使用类方法创建线程执行任务\n+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;\n//判断当前是否为多线程\n+ (BOOL)isMultiThreaded;\n//指定线程的线程参数, 例如设置当前线程的断言处理器. \n@property (readonly, retain) NSMutableDictionary *threadDictionary;\n//当前线程暂停到某个时间\n+ (void)sleepUntilDate:(NSDate *)date;\n//当前线程暂停一段时间\n+ (void)sleepForTimeInterval:(NSTimeInterval)ti;\n//退出当前线程\n+ (void)exit;\n//当前线程优先级\n+ (double)threadPriority;\n//设置当前线程优先级\n+ (BOOL)setThreadPriority:(double)p;\n//指定线程对象优先级 0.0～1.0, 默认值为0.5\n@property double threadPriority NS_AVAILABLE(10_6, 4_0);\n//服务质量\n@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);\n//线程名称\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);\n//栈区大小\n@property NSUInteger stackSize NS_AVAILABLE(10_5, 2_0);\n//是否为主线程\n@property (class, readonly) BOOL isMainThread NS_AVAILABLE(10_5, 2_0);\n//获取主线程\n@property (class, readonly, strong) NSThread *mainThread NS_AVAILABLE(10_5, 2_0);\n//初始化\n- (instancetype)init NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;\n//实例方法初始化, 需要再调用start方法\n- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);\n- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n//线程状态, 正在执行\n@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);\n//线程状态, 正在完成\n@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);\n//线程状态, 已经取消\n@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);\n//取消, 仅仅改变线程状态, 并不能像exist一样真正的终止线程\n- (void)cancel NS_AVAILABLE(10_5, 2_0);\n//开始\n- (void)start NS_AVAILABLE(10_5, 2_0);\n//线程需要执行的代码, 一般写子类的时候会用到\n- (void)main NS_AVAILABLE(10_5, 2_0);\n@end\n</code></pre><p>还有一个NSObject的分类</p>\n<pre><code>@interface NSObject (NSThreadPerformAdditions)\n//隐式的创建并启动线程, 并在指定的线程（主线程或子线程）上执行方法. \n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;\n- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);\n- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);\n- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);\n@end\n</code></pre><p>常见的用法有以下几种: </p>\n<pre><code>- (void) startThread {\n\n    //创建并且手动启动\n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n    [thread start];\n\n    //类方法创建并且自动启动\n    [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];\n\n    //通过NSObject的方法自动启动\n    [self performSelectorInBackground:@selector(run) withObject:nil];\n}    \n\n- (void)run {\n    NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n}\n</code></pre><h3 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h3><p>Grand Central Dispatch, 它是苹果为多核的并行运算提出的解决方案, 会自动合理地利用更多的CPU内核(比如双核、四核), 最重要的是它会自动管理线程的生命周期(创建线程、调度任务、销毁线程), 完全不需要我们管理, 我们只需要告诉干什么就行. 同时它使用的也是C语言, 不过由于使用了Block(Swift里叫做闭包), 使得使用起来更加方便, 而且灵活.</p>\n<p>了解GCD我们需要先了解两个概念, <strong><code>队列</code></strong>和<strong><code>任务</code></strong>.</p>\n<ol>\n<li><p>任务<br>要执行的操作或方法函数. 在GCD中指的就是block块, 在NSThread中指的是<code>performSelector:</code>中的方法. 加入任务时有两种形式: <code>同步任务(dispatch_sync)</code>和<code>异步任务(dispatch_async)</code>.</p>\n<ul>\n<li>同步任务: 不会开启新的线程, 会阻塞当前线程. 完成需要做的任务后才会返回, 进行下一任务. 创建方式为:<pre><code>   //把右边的参数(任务)提交给左边的参数(队列)进行执行\n   dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n</code></pre></li>\n<li><p>异步任务: 不会等待任务完成才返回, 会立即返回. 异步是多线程的代名词, 因为必定会开启新的线程, 线程的申请是由异步负责, 起到开分支的作用. 创建方式为:</p>\n<pre><code>   //把右边的参数(任务)提交给左边的参数(队列)进行执行\n   dispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n</code></pre></li>\n</ul>\n</li>\n<li><p>队列<br>存放任务的集合, 我们要做的就是将任务添加到队列然后执行, GCD会自动将队列中的任务按先进先出的方式取出. 队列主要有的有<code>串行队列(Serial Dispatch Queue)</code>, <code>并行队列(Concurrent Dispatch Queue)</code>, <code>全局队列(Global Queue)</code>和<code>主队列(Main Queue)</code>.</p>\n<ul>\n<li><p>串行队列: 任务依次执行, 同一时间队列中只有一个任务在执行, 每个任务只有在前一个任务执行完成后才能开始执行. 你不知道在一个Block(任务)执行结束到下一个Block(任务)开始执行之间的这段时间时间是多长, 这部分是由GCD控制. 创建方式为:</p>\n<pre><code>  //创建一个名为queue的串行队列\n  //第一个参数为队列名称\n  //第二个参数为队列类型, DISPATCH_QUEUE_SERIAL和NULL表示串行队列\n  dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.SerialQueue&quot;, DISPATCH_QUEUE_SERIAL);\n</code></pre></li>\n<li><p>并行队列: 任务并发执行, 唯一能保证的是, 这些任务会按照被添加的顺序开始执行. 但是任务可以以任何顺序完成, 你不知道在执行下一个任务是从什么时候开始, 或者说任意时刻有多个Block(任务)运行, 这个完全是取决于GCD. GCD默认已经提供了全局的并发队列, 供整个应用使用, 一般不需要手动创建创建方式为:</p>\n<pre><code>  //创建一个名为queue的并行队列\n  //第一个参数为队列名称\n  //第二个参数为队列类型, DISPATCH_QUEUE_CONCURRENT表示并行队列\n  dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.ConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);\n</code></pre></li>\n<li><p>全局队列: <strong>隶属于并行队列</strong>, 不要与 barrier 栅栏方法搭配使用, barrier 只有与自定义的并行队列一起使用, 才能让 barrier 达到我们所期望的栅栏功能. 与串行队列或者global队列 一起使用, barrier的表现会和dispatch_sync方法一样. 创建方式为:</p>\n<pre><code>  //获取系统全局队列, 并赋值给队列queue\n  //第一个参数表示优先级, 这里是新老优先级的对照Map\n  *  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED//高\n  *  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT//默认\n  *  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY//低\n  *  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND//后台\n\n  //第二个参数是预留参数, 传0就好\n  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n</code></pre></li>\n<li><p>主队列: <strong>隶属于串行队列</strong>, 不能与sync同步方法搭配使用, 会造成死循环. 主队列是GCD自带的一种特殊的串行队列, 放在主队列中的任务, 都会放到主线程中执行. 创建方式为:</p>\n<pre><code>  //获取系统主队列, 并赋值给队列queue\n    dispatch_queue_t queue = dispatch_get_main_queue();\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<p>不管是串行队列(SerialQueue)还是并行队列(ConcurrencyQueue), 都是FIFO队列. 也就意味着, 任务一定是一个一个地, 按照先进先出的顺序来执行.</p>\n<h3 id=\"NSOperation-amp-NSOperationQueue\"><a href=\"#NSOperation-amp-NSOperationQueue\" class=\"headerlink\" title=\"NSOperation &amp; NSOperationQueue\"></a>NSOperation &amp; NSOperationQueue</h3><p><code>NSOperation</code> 是苹果公司对<code>GCD</code>的封装, 完全面向对象, 所以使用起来更好理解. 大家可以看到 <code>NSOperation</code>和<code>NSOperationQueue</code>分别对应<code>GCD</code>的<strong>任务</strong>和<strong>队列</strong>. 所以他的操作步骤和<code>GCD</code>类似: 首先将要执行的任务封装到一个<code>NSOperation</code>对象中. 然后将此任务添加到一个<code>NSOperationQueue</code>对象中, 然后系统就会自动在执行任务.</p>\n<h4 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h4><p>NSOperation主要有一下这些属性和方法</p>\n<pre><code>@interface NSOperation : NSObject {\n@private\n id _private;\n int32_t _private1;\n#if __LP64__\n int32_t _private1b;\n#endif\n}\n\n- (void)start;//启动任务 默认在当前线程执行\n- (void)main;//自定义NSOperation，写一个子类，重写这个方法，在这个方法里面添加需要执行的操作。\n\n@property (readonly, getter=isCancelled) BOOL cancelled;//是否已经取消，只读\n- (void)cancel;//取消任务\n\n@property (readonly, getter=isExecuting) BOOL executing;//正在执行，只读\n@property (readonly, getter=isFinished) BOOL finished;//执行结束，只读\n@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &#39;asynchronous&#39; below\n@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);//是否并发，只读\n@property (readonly, getter=isReady) BOOL ready;//准备执行\n\n- (void)addDependency:(NSOperation *)op;//添加依赖\n- (void)removeDependency:(NSOperation *)op;//移除依赖\n\n@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;//所有依赖关系，只读\n\ntypedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n NSOperationQueuePriorityVeryLow = -8L,\n NSOperationQueuePriorityLow = -4L,\n NSOperationQueuePriorityNormal = 0,\n NSOperationQueuePriorityHigh = 4,\n NSOperationQueuePriorityVeryHigh = 8\n};//系统提供的优先级关系枚举\n\n@property NSOperationQueuePriority queuePriority;//执行优先级\n\n@property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);//任务执行完成之后的回调\n\n- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);//阻塞当前线程，等到某个operation执行完毕。\n\n@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);//已废弃，用qualityOfService替代。\n\n@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);//服务质量，一个高质量的服务就意味着更多的资源得以提供来更快的完成操作。\n\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);//任务名称\n\n@end\n</code></pre><p>由于<code>NSOperation</code>是一个抽象基类, 不能直接使用, 在这里我么你一般使用<code>NSOperation</code>的两个子类<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>, 或者<code>NSOperation的自定义子类</code>:</p>\n<ul>\n<li><p><code>NSInvocationOperation</code>基于应用的一个target对象和selector来创建operation object. 如果你已经有现有的方法来执行需要的任务, 就可以使用这个类. 使用方式大致如下: </p>\n<pre><code>  - (void)NSInvocationOperationRun {\n    NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];\n    [invocationOper start];\n  }\n  - (void)invocationOperSel {\n    NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);\n  }\n</code></pre><p>  从打印结果可以看出, 该实现方式是同步顺序执行.</p>\n</li>\n<li><p><code>NSBlockOperation</code>用来并发地执行一个或多个block对象. operation object使用<strong>组</strong>的语义来执行多个block对象，所有相关的 block 都执行完成之后, operation object才算完成. 使用方法如下:</p>\n<pre><code>  //系统提供的API\n  @interface NSBlockOperation : NSOperation {\n  @private\n  id _private2;\n  void *_reserved2;\n  }\n\n  + (instancetype)blockOperationWithBlock:(void (^)(void))block;//在当前线程执行\n\n  - (void)addExecutionBlock:(void (^)(void))block;//新开线程执行\n  @property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;\n\n  @end\n</code></pre><p> 使用<code>NSBlockOperation</code>类方法创建任务, 从打印结果可以看出来该任务是在主线程执行的</p>\n<pre><code>  - (void)NSBlockOperationRun {\n  NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n     NSLog(@&quot;NSBlockOperationRun_%@_%@&quot;, [NSOperationQueue currentQueue], [NSThread currentThread]);\n  }];\n  [blockOper start];\n  }\n</code></pre><p> 使用<code>NBlockOperation</code>的实例方法创建任务, 从打印结果可以看出来, 第一个任务是在主线程执行, 其他任务均是新开的线程, 所有的任务是以异步并发的形式执行. </p>\n<pre><code>  - (void)NSBlockOperationRun {\n  NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n      NSLog(@&quot;NSBlockOperationRun_1_%@&quot;, [NSThread currentThread]);\n  }];\n  [blockOper addExecutionBlock:^{\n      NSLog(@&quot;NSBlockOperationRun_2_%@&quot;, [NSThread currentThread]);\n  }];\n  [blockOper addExecutionBlock:^{\n      NSLog(@&quot;NSBlockOperationRun_3_%@&quot;, [NSThread currentThread]);\n  }];\n  [blockOper addExecutionBlock:^{\n      NSLog(@&quot;NSBlockOperationRun_4_%@&quot;, [NSThread currentThread]);\n  }];\n  [blockOper start];\n  }\n</code></pre></li>\n<li><p>NSOperation的自定义子类. 在子类中重写父类的<code>-(void)main</code>函数, 在里面实现主要逻辑. <code>NSBlockOperation</code>, <code>NSBlockOperationRun</code>或者<code>NSOperation的自定义子类</code>创建的operation object都可以使用<code>NSOperation</code>的所有属性, 意味着他们具有以下主要特性: </p>\n<ul>\n<li>多个任务之间可以使用有依赖关系</li>\n<li>可以获得Operation object任务执行完成之后的回调</li>\n<li>支持应用使用 KVO 通知来监控 operation 的执行状态</li>\n<li>可以通过operation优先级, 从而影响相对的执行顺序</li>\n<li>可以终止正在执行的任务</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"NSOperationQueue\"><a href=\"#NSOperationQueue\" class=\"headerlink\" title=\"NSOperationQueue\"></a>NSOperationQueue</h4><p><code>NSOperationQueue</code>类似于GCD中的队列, 只需要吧任务加入到<code>NSOperationQueue</code>中, 就会自动运行, 由系统通过最大并发数来控制是并行还是串行, 官方提供的API如下:</p>\n<pre><code>static const NSInteger NSOperationQueueDefaultMaxConcurrentOperationCount = -1;\n\nNS_CLASS_AVAILABLE(10_5, 2_0)\n@interface NSOperationQueue : NSObject {\n@private\n   id _private;\n   void *_reserved;\n}\n\n- (void)addOperation:(NSOperation *)op;//向队列中添加任务\n- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一组任务\n\n- (void)addOperationWithBlock:(void (^)(void))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一个block形式的任务\n\n@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;//队列中所有任务的数组\n@property (readonly) NSUInteger operationCount API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//队列中所有任务数\n\n@property NSInteger maxConcurrentOperationCount;//最大并发数\n\n@property (getter=isSuspended) BOOL suspended;//暂停\n\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//名称\n\n@property NSQualityOfService qualityOfService API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));//服务质量, 系统会为权重高的服务分配更多的资源\n\n@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));\n\n- (void)cancelAllOperations;//取消队列中所有的任务\n\n- (void)waitUntilAllOperationsAreFinished;//阻塞当前线程, 等到队列中的全部任务全部执行完毕\n\n@property (class, readonly, strong, nullable) NSOperationQueue *currentQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取当前队列\n@property (class, readonly, strong) NSOperationQueue *mainQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取主队列\n\n@end\n</code></pre><p>使用方式如下:</p>\n<pre><code>//以三种方式为队列添加了三个任务, \n- (void)NSOperationQueueRun {\n   NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n   NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];\n   [queue addOperation:invocationOper];\n   NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n       NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]);\n   }];\n   [queue addOperation:blockOper];\n   [queue addOperationWithBlock:^{\n       NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]);\n   }];\n}\n\n- (void)invocationOperSel {\n   NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);\n}\n</code></pre><p>一般情况下, <code>NSOperationQueue</code>会按照任务添加的顺序来执行任务, 但是我们可以通过使用优先级和依赖关系来改变执行顺序. 并发数大于任务数, 没有设置依赖关系, 并且在同一队列.</p>\n<h2 id=\"常见的使用方式\"><a href=\"#常见的使用方式\" class=\"headerlink\" title=\"常见的使用方式\"></a>常见的使用方式</h2><h3 id=\"GCD向并行队列中添加异步任务\"><a href=\"#GCD向并行队列中添加异步任务\" class=\"headerlink\" title=\"GCD向并行队列中添加异步任务\"></a>GCD向并行队列中添加异步任务</h3><p>该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加异步任务. 任务会遵守FIFO原则来执行, 但是每个任务何时执行完我们却并不知道. 但是系统会新开线程来执行异步任务, 三个异步任务会分别在三个线程中执行, 各个任务的执行顺序无法确定.</p>\n<pre><code>- (void)test1 {\n    //获取系统提供的全局队列\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n        sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD向串行队列中添加异步任务\"><a href=\"#GCD向串行队列中添加异步任务\" class=\"headerlink\" title=\"GCD向串行队列中添加异步任务\"></a>GCD向串行队列中添加异步任务</h3><p>该过程一共分为两步, 第一步创建串行队列, 第二步向并行队列中添加异步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 但是由于我们是在串行队列中添加的任务, 不会新开线程, 所有的异步任务会按照顺序前一个执行完毕再执行后一个.</p>\n<pre><code> - (void)test2 {\n    //创建串行队列, 第一个参数为串行队列的名称, 第二个参数为队列的属性, NULL或者DISPATCH_QUEUE_SERIAL表示是串行队列\n    dispatch_queue_t queue = dispatch_queue_create(&quot;test2&quot;, NULL);\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n        sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD向并行队列添加同步任务\"><a href=\"#GCD向并行队列添加同步任务\" class=\"headerlink\" title=\"GCD向并行队列添加同步任务\"></a>GCD向并行队列添加同步任务</h3><p>该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加同步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 虽然是并行队列, 单由于添加的是同步任务, 不会新开线程, 全都在当前线程中执行, 所以三个任务会顺序执行, 并行队列失去了并行的能力. </p>\n<pre><code>//并行队列中添加同步任务\n- (void)test3 {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n    //向队列中添加异步任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n        sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD-向串行队列添加异步任务\"><a href=\"#GCD-向串行队列添加异步任务\" class=\"headerlink\" title=\"GCD 向串行队列添加异步任务\"></a>GCD 向串行队列添加异步任务</h3><p>该过程一共分为两步, 第一步创建自定义串行队列, 第二步向并行队列中添加异步任务. 虽然异步任务会新开线程, 但是由于是在串行队列中执行, 所以不新开线程, 所有任务前一个执行完毕再执行下一个.</p>\n<pre><code>- (void)test4 {\n    dispatch_queue_t queue = dispatch_queue_create(&quot;test4&quot;, NULL);\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n       NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n       sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n       NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n       NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h3><p>分组模式 <code>dispatch_group_notify</code>. 可以异步执行多个耗时操作. 等耗时操作都执行完毕之后会回到主线程执行操作, 主要用于监听任务是否完成. 主要有两种用法: </p>\n<p>第一种用法是通过<code>dispatch_group_async</code>, 首先创建一个全局并行队列和一个group队列组, 再次创建异步group任务加入到前面创建的group队列中去. 当所有异步任务完成后, 会通过<code>dispatch_group_notify</code>回到主线程.</p>\n<pre><code>- (void)groupTest1 {\n    //获取全局队列\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    //创建一个队列组\n    dispatch_group_t group = dispatch_group_create();\n\n    dispatch_group_async(group, queue, ^{\n        NSLog(@&quot;--- 1 开始--- %@&quot;, [NSThread currentThread]);\n        //延时5秒 模仿堵塞子线程\n        [NSThread sleepForTimeInterval:5];\n        NSLog(@&quot;--- 1 --- 完成 %@&quot;, [NSThread currentThread]);\n    });\n\n    dispatch_group_async(group, queue, ^{\n        NSLog(@&quot;--- 2 开始--- %@&quot;, [NSThread currentThread]);\n        //延时5秒 模仿堵塞子线程\n        [NSThread sleepForTimeInterval:5];\n        NSLog(@&quot;--- 2 --- 完成 %@&quot;, [NSThread currentThread]);\n    });\n\n    //在这个队列组里面，会等group中的全部代码执行完毕再去执行其它的操作\n    dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        // 等前面的异步操作都执行完毕后，回到主线程...\n        NSLog(@&quot;全部完成&quot;);\n    });\n}\n</code></pre><p>第二种用法是通过信号量<code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code>. 创建一个并行线程和多个异步任务, 将异步任务添加到并行线程中区. 通过<code>dispatch_group_enter</code>来告知<code>group</code>一个异步任务开始,  未执行完毕任务数加1. 在异步线程任务执行完毕时, 通过<code>dispatch_group_leave</code>告知group, 一个任务结束, 未执行完毕任务数减1. 当未执行完毕任务数为0的时候, 这时group才认为组内任务都执行完毕了(这个和GCD的信号量的机制有些相似), 这时候才会回调<code>dispatch_group_notify</code>中的block. 此处需要注意, <code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的数量一定要一致. </p>\n<pre><code>- (void)groupTest2 {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_group_t group = dispatch_group_create();\n\n    dispatch_group_enter(group);\n    dispatch_async(queue, ^{\n        sleep(2); //这里线程睡眠1秒钟，模拟异步请求\n        NSLog(@&quot;%@ one finish&quot;, [NSThread currentThread]);\n        dispatch_group_leave(group);\n    });\n\n    dispatch_group_enter(group);\n    dispatch_async(queue, ^{\n        sleep(2); //这里线程睡眠1秒钟，模拟异步请求\n        NSLog(@&quot;%@ two finish&quot;, [NSThread currentThread]);\n        dispatch_group_leave(group);\n    });\n\n    dispatch_group_notify(group, queue, ^{\n        NSLog(@&quot;group finished&quot;);\n    });\n}\n</code></pre><h3 id=\"GCD延时操作-dispatch-after\"><a href=\"#GCD延时操作-dispatch-after\" class=\"headerlink\" title=\"GCD延时操作(dispatch_after)\"></a>GCD延时操作(dispatch_after)</h3><p>使用很简单, 两个核心的对象<code>dispatch_time_t</code>和<code>dispatch_after</code>. 大家都经常使用, 不用多说. 下面的代码和在3妙手用<code>dispatch_async</code>函数追加block到主线程的操作是相同的</p>\n<pre><code>- (void)afterTest {\n    double delayInSeconds = 2.0;\n    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));\n    //第一个参数代表时间, 第二各参数代表要在哪个线程执行接下来的任务, 第三个参数就是任务block\n    dispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n        NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD单例-dispatch-once\"><a href=\"#GCD单例-dispatch-once\" class=\"headerlink\" title=\"GCD单例(dispatch_once)\"></a>GCD单例(dispatch_once)</h3><p>这个更是不用多说, 直接贴上代码.</p>\n<pre><code>@interface Tool : NSObject\n+ (instancetype)sharedTool;\n@end\n\n@implementation Tool\nstatic id _instance;\n+ (instancetype)sharedTool {\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        _instance = [[Tool alloc] init];\n    });\n    return _instance;\n}\n@end\n</code></pre><h3 id=\"GCD-线程间的通讯\"><a href=\"#GCD-线程间的通讯\" class=\"headerlink\" title=\"GCD 线程间的通讯\"></a>GCD 线程间的通讯</h3><p>常用的方式就是在后台线程中执行长时间任务, 处理结束时, 主线程使用该处理结果. 代码如下: </p>\n<pre><code>- (void)threadTest {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_async(queue, ^{\n        //在这里执行耗时的操作\n        dispatch_async(dispatch_get_main_queue(), ^{\n            //在主线程使用上面操作的结果\n        });\n    });\n}\n</code></pre><h3 id=\"GCD重复执行同一个任务-dispatch-apply\"><a href=\"#GCD重复执行同一个任务-dispatch-apply\" class=\"headerlink\" title=\"GCD重复执行同一个任务(dispatch_apply)\"></a>GCD重复执行同一个任务(dispatch_apply)</h3><p><code>disaptch_apply</code>函数是<code>dispatch_sync</code>函数和<code>Dispatch Group</code>的关联API, 该函数按照指定的次数将指定的Block追加到指定的Dispatch Queue中, 并等待处理执行结束. </p>\n<pre><code>- (void)applyTest {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_apply(10, queue, ^(size_t index) {\n        //并行处理10次任务\n        NSLog(@&quot;%zu&quot;, index);\n    });\n}\n</code></pre><p>但是由于<code>dispatch_apply</code>函数与<code>dispatch_sync</code>函数相同, 会等待任务执行结束, 所以我们强烈推荐在<code>dispatch_async</code>函数中异步执行. </p>\n<pre><code>- (void)applyTest {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n    //在全局并行队列中异步执行\n    dispatch_async(queue, ^{\n        //等待函数中操作全部执行完毕\n        dispatch_apply(10, queue, ^(size_t index) {\n            //并行处理10次任务\n            sleep(2);\n            NSLog(@&quot;%zu&quot;, index);\n        });\n\n        //dispatch_apply中的处理全部结束, 在主线程异步执行\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSLog(@&quot;Done&quot;);\n        });\n    });\n}\n</code></pre><h3 id=\"GCD设置优先级-dispatch-set-target-queue\"><a href=\"#GCD设置优先级-dispatch-set-target-queue\" class=\"headerlink\" title=\"GCD设置优先级(dispatch_set_target_queue)\"></a>GCD设置优先级(dispatch_set_target_queue)</h3><p>将queue的优先级通过<code>dispatch_set_target_queue</code>变更的和queue1的优先级一致, 代码如下. </p>\n<pre><code>- (void)targetQueeuTest {\n    dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, NULL);\n    dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    //把第一个参数的执行优先级设置的和第二个参数的优先级一致.\n    dispatch_set_target_queue(queue, queue1);\n}\n</code></pre><h3 id=\"GCD栅栏-dispatch-barrier-async\"><a href=\"#GCD栅栏-dispatch-barrier-async\" class=\"headerlink\" title=\"GCD栅栏(dispatch_barrier_async)\"></a>GCD栅栏(dispatch_barrier_async)</h3><p>以下面的代码为例, 假设一个并行队列中添加了五个异步任务, 虽然遵循FIFO的原则, 这五个任务的执行必定是无序的. 当我们在第三个任务之后加入<code>dispatch_barrier_async</code>任务, 那么这五个任务就被分割成两部分, 前三次无序执行, 然后执行<code>dispatch_barrier_async</code>任务, 然后再无序执行后两次任务. 注意<strong>此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行</strong></p>\n<pre><code>- (void)barrierTest {\n\n    //此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行\n    dispatch_queue_t queue = dispatch_queue_create(&quot;barrierTest&quot;, DISPATCH_QUEUE_CONCURRENT);\n\n    dispatch_async(queue, ^{\n        NSLog(@&quot;1&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;2&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;3&quot;);\n    });\n    dispatch_barrier_async(queue, ^{\n        sleep(3);\n        NSLog(@&quot;插入执行&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;4&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;5&quot;);\n    });\n}\n</code></pre><h3 id=\"GCD信号量-dispatch-semaphore-t\"><a href=\"#GCD信号量-dispatch-semaphore-t\" class=\"headerlink\" title=\"GCD信号量(dispatch_semaphore_t)\"></a>GCD信号量(dispatch_semaphore_t)</h3><p>我们以这个使用场景为例, 来说明一下, 不考虑顺序 将所有的数据添加到空数组中去, 我们可能会这么实现:</p>\n<pre><code>- (void)dispatchSemaphoreDemo {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    NSMutableArray *array = [NSMutableArray array];\n    for (int i = 0; i &lt; 100000; i++) {\n        dispatch_async(queue, ^{\n            NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n            [array addObject:@(i)];\n        });\n    }\n}\n</code></pre><p>因为是并行队列, 异步任务, 所以会开大量的线程, 并且这些线程会保存在内存中,相当耗费资源, 最终运行的结果就是崩溃. 那么我们就需要通过信号量来控制任务的执行. <code>dispatch_semaphore_t</code>类似于单个队列的最大并发数控制机制, 提高并行效率的同时, 也可以防止太多线程的开辟对系统造成太大的负担. 改造后应该是这样的: </p>\n<pre><code>- (void)dispatchSemaphoreDemo {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    NSMutableArray *array = [NSMutableArray array];\n\n    //设置信号量初始值, 当信号量为0时, 所有任务等待, 信号量越大, 允许可并行执行的任务数量越多. 并发的线程由系统调配, 不一定一直是同样的两条, 但是最多只能同时存在两条.\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);\n    for (int i = 0; i &lt; 100; i++) {\n\n        //当信号量大于等于设定的初始值时就继续执行, 否则一直等待\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        dispatch_async(queue, ^{\n            //执行到这里就代表信号量大于等于设定的初始值, 所以在这里信号量要减1\n            NSLog(@&quot;%d+++++%@&quot;, i, [NSThread currentThread]);\n            [array addObject:@(i)];\n            //到这里的时候, 因为异步任务已经将要结束, 要将信号量加1. 如果前面有等待的线程, 最先等待的线程先执行\n            dispatch_semaphore_signal(semaphore);\n        });\n    }\n}\n</code></pre><h3 id=\"GCD定时器\"><a href=\"#GCD定时器\" class=\"headerlink\" title=\"GCD定时器\"></a>GCD定时器</h3><p>GCD实现定时器主要用到<code>dispatch_source_t</code>函数, 该函数实际有多种Type, <code>DISPATCH_SOURCE_TYPE_TIMER</code>是定时器相关的任务, 还有其他类型的处理事件类型. </p>\n<pre><code>- (void)timerDemo {\n    NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n    //指定DISPATCH_SOURCE_TYPE_TIMER类型, 作成Dispatch Source\n\n    //在定时器经过指定时间, 把任务追加到main queue\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n\n    //定时器的相关设置, 将定时器设置为5s后, 不指定为重复, 允许延迟1s\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 1ull * NSEC_PER_SEC);\n\n    //指定定时器指定时间内执行的处理\n    dispatch_source_set_event_handler(timer, ^{\n        NSLog(@&quot;wake up&quot;);\n        dispatch_source_cancel(timer);\n    });\n\n    //取消定时器时的处理\n    dispatch_source_set_cancel_handler(timer, ^{\n        NSLog(@&quot;canceled&quot;);\n    });\n\n    //定时器启动\n    dispatch_resume(timer);\n}\n</code></pre><h3 id=\"NSOperation的优先级\"><a href=\"#NSOperation的优先级\" class=\"headerlink\" title=\"NSOperation的优先级\"></a>NSOperation的优先级</h3><p>NSOperationQueue中NSOperation对象的执行方式是按照FIFO的原则顺序执行, 但是如果我们设置了任务的优先级, 那么系统就会给优先级高的优先分配资源. </p>\n<p>优先级一共有这几种, 从高到低依次排列. </p>\n<pre><code>typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n    NSOperationQueuePriorityVeryLow = -8L,\n    NSOperationQueuePriorityLow = -4L,\n    NSOperationQueuePriorityNormal = 0,\n    NSOperationQueuePriorityHigh = 4,\n    NSOperationQueuePriorityVeryHigh = 8\n};\n</code></pre><p>示例代码如下, 三个任务被添加到队列中去, 这三个任务分别在三个线程, 互不干扰, 类似于GCD的异步并行模式, 如果我们设置<code>invocationOper.queuePriority = NSOperationQueuePriorityVeryLow</code>理论上, <code>invocationOper</code>任务会在最后执行, 但是我们发现并没有, 那是因为我们没有设置最大并发数的原因, 我猜测系统可能是做了某些限制, 虽然是新开了线程, 但是由于最大并发数小于等于1实际还是按照FIFO顺序执行, <strong>所以注意一定要设置最大并发数</strong>.</p>\n<pre><code>//把注释打开就可以看到想要的效果\n- (void)NSOperationQueueRun {\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    //queue.maxConcurrentOperationCount = 3;\n    NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];\n    //invocationOper.queuePriority = NSOperationQueuePriorityVeryLow;\n    [queue addOperation:invocationOper];\n    NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]);\n    }];\n    [queue addOperation:blockOper];\n    [queue addOperationWithBlock:^{\n        NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]);\n    }];\n}\n\n- (void)invocationOperSel {\n    NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);\n}\n</code></pre><h3 id=\"NSOperation的依赖关系\"><a href=\"#NSOperation的依赖关系\" class=\"headerlink\" title=\"NSOperation的依赖关系\"></a>NSOperation的依赖关系</h3><p>首先我们创建一个队列, 分别创建要执行的任务, <strong>在把要执行的任务添加到队列中去之前, 通过<code>addDependency</code>来建立任务间的依赖关系</strong>. 如果我们没有设置依赖的话, 如果设置的并发数大于1,  那么<code>blockOper_1</code>和<code></code>blockOper_2<code>的执行顺序是随机的. 可是当我们执行</code>[blockOper_1 addDependency:blockOper_2]<code>时, 就给两个任务添加了依赖关系,</code>blockOper_1<code>永远只会在</code>blockOper_2<code>后执行. 即使我们给</code>blockOper_1<code>设置了最高的优先级, 因为**依赖的优先级要高于</code>queuePriority`**. </p>\n<pre><code>- (void)NSOperationQueueRun2 {\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n//    queue.maxConcurrentOperationCount = 2;\n    NSBlockOperation *blockOper_1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@&quot;blockOper_1_%@_%@&quot;,@(1),[NSThread currentThread]);\n    }];\n\n    NSBlockOperation *blockOper_2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@&quot;blockOper_2_%@_%@&quot;,@(2),[NSThread currentThread]);\n    }];\n\n//    blockOper_1.queuePriority = NSOperationQueuePriorityVeryHigh;\n    [blockOper_1 addDependency:blockOper_2];\n    [queue addOperation:blockOper_1];\n    [queue addOperation:blockOper_2];\n}\n</code></pre><h2 id=\"常见使用案列分析\"><a href=\"#常见使用案列分析\" class=\"headerlink\" title=\"常见使用案列分析\"></a>常见使用案列分析</h2><h3 id=\"案例一\"><a href=\"#案例一\" class=\"headerlink\" title=\"案例一\"></a>案例一</h3><pre><code>- (void)case1 {\n    NSLog(@&quot;任务一 - %@&quot;, [NSThread currentThread]);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;同步任务 - %@&quot;,[NSThread currentThread]);\n    });\n    NSLog(@&quot;任务二 - %@&quot;, [NSThread currentThread]);\n}\n\n</code></pre><p>以上<code>- (void)case1</code>默认在当前线程(主线程)执行,  首先执行”任务一”. 然后<code>dispatch_sync</code>阻塞当前线程(主线程), 由于主队列是串行队列, 任务不能并发执行, 同时只能有一个任务在执行. 又因为<strong>“同步任务”后入列, 按照FIFO原则, 必须等到<code>- (void)case1</code>执行完毕才能执行</strong>, 但是<code>- (void)case1</code>中的”任务二”又在等着”同步任务”执行完毕才能执行, 这样就造成同一队列中的两个任务相互等待, 造成死锁. </p>\n<p><img src=\"http://img.souche.com/f2e/5b1729532683ad164c061958d5248a66.png\" alt=\"案例1\"></p>\n<p>有两种解决思路, 一是为当前队列扩容, 让它变成并行队列, 就不会造成阻塞. 第二种解决思路是把同步任务添加到一个新的自定义串行队列中去, 两个队列之间不存在阻塞就避免了死锁问题. </p>\n<h3 id=\"案例二\"><a href=\"#案例二\" class=\"headerlink\" title=\"案例二\"></a>案例二</h3><pre><code>- (void)case2 {\n    NSLog(@&quot;1&quot;);\n    //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行\n    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><p>打印顺序一定为1, 2, 3. 2新开队列, 不会造成死锁. <code>case2</code>和新开的block任务之间没有队列的约束, 但是由于是同步任务,阻塞线程, 所以block先执行, 执行完毕后再回到<code>case2</code>, 接着执行.</p>\n<p><img src=\"http://img.souche.com/f2e/27086c860f921209238d3f60c2f8722c.png\" alt=\"案例2\"></p>\n<h3 id=\"案例三\"><a href=\"#案例三\" class=\"headerlink\" title=\"案例三\"></a>案例三</h3><pre><code>- (void)case3 {\n    dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);\n    NSLog(@&quot;1&quot;); // 任务1\n    dispatch_async(queue, ^{\n        NSLog(@&quot;2&quot;); // 任务2\n        dispatch_sync(queue, ^{\n            NSLog(@&quot;3&quot;); // 任务3\n        });\n        NSLog(@&quot;4&quot;); // 任务4\n    });\n    NSLog(@&quot;5&quot;); // 任务5\n}\n</code></pre><p>控制台输出1, 5, 2. (5, 2的顺序不一定). 可以肯定, 使用的是自定义串行队列. 首先执行任务1, 接下来有一个异步任务, 新开辟线程(将任务2, 同步线程, 任务4加入新线程). 因为是异步线程, 主线程中的任务5不用等待, 所以 2 和 5 的输出顺序不定. 任务2执行完后, 遇到同步任务, 因为是在串行队列, 所以会阻塞当前线程, 任务3执行完后才能执行任务4. 但是任务4比任务3早加入队列, 根据FIFO原则, 任务3要等待任务4执行完后才能执行. 任务3和任务4相互等待造成死锁. </p>\n<p><img src=\"http://img.souche.com/f2e/9c13eaeac28f7fe7105af2feb878d5ef.png\" alt=\"案例三图片\"></p>\n<h3 id=\"案例四\"><a href=\"#案例四\" class=\"headerlink\" title=\"案例四\"></a>案例四</h3><pre><code>- (void)case4 {\n    NSLog(@&quot;1&quot;); // 任务1\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        NSLog(@&quot;2&quot;); // 任务2\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@&quot;3&quot;); // 任务3\n        });\n        NSLog(@&quot;4&quot;); // 任务4\n    });\n    NSLog(@&quot;5&quot;); // 任务5\n}\n</code></pre><p>打印结果是: 1, 5, 2, 3, 4.(2, 5的顺序不定). 首先在主线程中有三个任务, 分别是任务1, 并行队列的异步任务, 任务5. 并行队列的异步任务中又有三个任务, 分别是任务2, 异步任务, 任务4.  </p>\n<p>所以先打印1, 然后把异步任务加入全部并行队列, 由于是异步任务新开辟线程, 不阻塞主线程, 5不用等待. 所以2, 5顺序不定. 然后再分析并行队列中的异步任务, 任务2执行后遇到同步任务, 同步任务被加入到主线程(因为前面已经被加过3个任务, 所以该任务在任务5后面). 因为是同步, 阻塞主线程, 所以4一定在3后面. </p>\n<p><img src=\"http://img.souche.com/f2e/43a48f9de1c0bb336215543157ad875b.png\" alt=\"案例四\"></p>\n<h3 id=\"案例五\"><a href=\"#案例五\" class=\"headerlink\" title=\"案例五\"></a>案例五</h3><pre><code>- (void)case5 {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        NSLog(@&quot;1&quot;); // 任务1\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@&quot;2&quot;); // 任务2\n        });\n        NSLog(@&quot;3&quot;); // 任务3\n    });\n    NSLog(@&quot;4&quot;); // 任务4\n    while (1) {\n    }\n    NSLog(@&quot;5&quot;); // 任务5\n}\n</code></pre><p>打印结果是: 1, 4(顺序不定). 首先主线程中有四个任务, 分别是全局并行队列的异步任务, 任务4, 死循环, 任务5. 全局并行队列的异步任务中又有三个任务, 分别是任务1, 主线程的同步任务(任务2), 任务3. </p>\n<p>由于是异步任务, 不阻塞主线程, 所以全局并行队列的异步任务执行顺序和任务4不定, 全局并行队列的异步任务又是先执行任务1, 所以任务1和任务4的顺序不定. 当任务4执行完后, 进入死循环, 主线程被阻塞. 由于同步任务(任务2)是被加在主线程中, 但是此时主线程已被阻塞, 所以2不会被执行. 任务3又是在任务2后被加入队列, 任务2是同步任务, 所以任务3要等待任务2完成才执行. 所以任务2, 任务3都不会执行. 任务5在死循环后执行, 所以任务5永远不会被执行. 如果没有死循环, 任务2肯定在任务后后面, 任务3肯定在任务2后面. </p>\n<p><img src=\"http://img.souche.com/f2e/0d108cba7a737b62e2f5e1be402bc5d0.png\" alt=\"案例五\"></p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.cocoachina.com/ios/20150731/12819.html\" target=\"_blank\" rel=\"noopener\">关于iOS多线程, 你看我就够了</a></p>\n<p>2.<a href=\"https://bestswifter.com/multithreadconclusion/\" target=\"_blank\" rel=\"noopener\">iOS多线程编程总结</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/51fd1362249e\" target=\"_blank\" rel=\"noopener\">关于iOS多线程, 我说, 你听, 没准你就懂了</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/06a18323d9d2\" target=\"_blank\" rel=\"noopener\">深入理解 GCD</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/6a6722f12fe3\" target=\"_blank\" rel=\"noopener\">关于 iOS 多线程, 都在这里了</a></p>\n<p>6.<a href=\"http://blog.csdn.net/mxsgoden/article/details/8821936\" target=\"_blank\" rel=\"noopener\">进程与线程的区别</a></p>\n<p>7.<a href=\"https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/\" target=\"_blank\" rel=\"noopener\">并发和并行</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"JavaScript第二弹","url":"http://hchong.net/2017/08/22/JavaScript第二弹/","content":"<h1 id=\"JavaScript第二弹\"><a href=\"#JavaScript第二弹\" class=\"headerlink\" title=\"JavaScript第二弹\"></a>JavaScript第二弹</h1><p>第一弹主要是一些基本语法, 数据类型和变量. 这一弹来说一下字符串, 数组和对象. </p>\n<blockquote>\n<p>在 <code>JavaScript</code>中，对象的定义是拥有属性和方法的数据.<br>严格来讲, <code>JavaScript</code>中的所有事物都是对象：字符串, 数字, 数组, 日期，等等.</p>\n</blockquote>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>和OC的没什么太大的区别, 这里只说几点比较特殊的.</p>\n<ul>\n<li>可以使用反引号` <code>...</code> `来标记一串带符号的文本, 例如</li>\n</ul>\n<pre><code>alert(`你好, \n哈哈`);\n</code></pre><p>中间的所有符号都会被保留下来, </p>\n<ul>\n<li>还可以在在` <code>你好 + ${string}</code> `来拼接字符串, 其中<code>${String}</code>代表一个叫做<code>String</code>的变量</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>区别于OC的数组, <code>JavaScript</code>的<code>Array</code>可以包含任意的数据类型, 通过索引来访问每个元素.</p>\n<p>Array属性:</p>\n<blockquote>\n<p>constructor 返回对创建此对象的数组函数的引用.<br>length 设置或返回数组中元素的数目.<br>prototype 使您有能力向对象添加属性和方法.</p>\n</blockquote>\n<p>Array 对象方法:</p>\n<blockquote>\n<p>indexOf() 搜索一个指定的元素的位置.<br>concat() 连接两个或更多的数组，并返回结果.<br>join() 把数组的所有元素放入一个字符串.元素通过指定的分隔符进行分隔.<br>pop() 删除并返回数组的最后一个元素<br>push() 向数组的末尾添加一个或更多元素，并返回新的长度.<br>shift() 删除并返回数组的第一个元素.<br>unshift() 向数组的开头添加一个或更多元素，并返回新的长度.<br>reverse() 颠倒数组中元素的顺序.<br>slice() 从某个已有的数组返回选定的元素.<br>sort() 对数组的元素进行排序.<br>splice(loc, len, newElement, …) 删除元素，并向数组添加新元素.<br>toSource() 返回该对象的源代码.<br>toString() 把数组转换为字符串，并返回结果.<br>toLocaleString() 把数组转换为本地数组，并返回结果.<br>valueOf() 返回数组对象的原始值.</p>\n</blockquote>\n<p>在这里需要注意, 直接使用<code>arr.length</code>是会改变原<code>arr</code>的长度的, 没有被赋值的元素就会变为<code>undefined</code>, 直接通过索引赋值, 也会出现这个问题. 例如:</p>\n<pre><code>var arr1 = [1, 2, 3];\narr1.length; // 3\narr1.length = 6;\narr1; // arr1变为[1, 2, 3, undefined, undefined, undefined]\narr1.length = 2;\narr1; // arr1变为[1, 2]\n\nvar arr2 = [1, 2, 3];\narr2[5] = &#39;x&#39;;\narr2; // arr2变为[1, 2, 3, undefined, undefined, &#39;x&#39;]\n</code></pre><p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界.</p>\n","categories":["JavaScript"],"tags":["基础知识","JavaScript"]},{"title":"JavaScript第一弹","url":"http://hchong.net/2017/08/18/JavaScript第一弹/","content":"<h1 id=\"JavaScript第一弹\"><a href=\"#JavaScript第一弹\" class=\"headerlink\" title=\"JavaScript第一弹\"></a>JavaScript第一弹</h1><p>主要是一些JavaScript的一些基础知识, 和OC的一些区别</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>JavaScript可以嵌在网页的任意地方, 不过通常有两种写法:</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;script&gt;\n        JavaScript代码\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>或者把JavaScript代码放到一个单独的<code>.js</code>文件中, 然后在HTML中引用</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;script src=&quot;.js文件的路径&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>把JavaScript代码放入一个单独的<code>.js</code>文件中更利于维护代码，并且多个页面可以各自引用同一份<code>.js</code>文件。</p>\n<p>可以在同一个页面中引入多个<code>.js</code>文件，还可以在页面中多次编写<code>&lt;script&gt; js代码... &lt;/script&gt;</code>，浏览器按照顺序依次执行。</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型, 这一点和OC是有区别的.</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串是以<code>单引号&#39;</code>或<code>双引号&quot;</code>括起来的任意文本, 这和OC的略有不同. 和OC的字符串初始化不同的是, JS只需用引号括起来就代表一个字符串了.</p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>JavaScript允许对任意数据类型做比较. 要特别注意相等运算符<code>==</code>。JavaScript在设计时，有两种比较运算符：</p>\n<ul>\n<li>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</li>\n<li>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</li>\n</ul>\n<p>由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用<code>===</code>比较。</p>\n<p>这个和<code>OC</code>类似, 如果使用<code>===</code>比较的是两个基本数据类型, 只要值相等就位<code>true</code>. 但是如果是数组, 字典, 对象等其他类型, 那比较的就是内存地址, 而不是元素.</p>\n<pre><code>var arr1 = [1,2,3];\nvar arr2 = [1,2,3];\nalert(arr1 === arr2)//false\n\nvar str1 = &#39;123&#39;;\nvar str2 = &#39;123&#39;;\nalert(str1 === str2);//true\n</code></pre><p>关于数组元素的比较, 如果是OC的话, 可以使用<code>-(BOOL)isEquleToArray:(NSArray *)array;</code>来比较数组中的元素, 然而JS没有这种方法, 常见的做法是先排序, 再转成String, 再比较String是否相等. 参考<a href=\"https://gist.github.com/smallnewer/6535788\" target=\"_blank\" rel=\"noopener\">equalArray.js</a></p>\n<p><code>NaN</code>这个值通过<code>===</code>来比较大小永远为<code>false</code>, 包括与自身比较. 唯一的判断方法就是通过<code>isNaN()</code>函数.</p>\n<h3 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h3><p><code>null</code>表示一个“空”的值类似于OC的<code>nil</code>，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”.</p>\n<p>还有一个和null类似的undefined，它表示“未定义”. JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义.</p>\n<ul>\n<li>大多数情况下，我们都应该用null.</li>\n<li>undefined仅仅在判断函数参数是否传递的情况下有用, 未使用值来声明的变量，其值实际上是 undefined.</li>\n</ul>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量和OC的变量是一样的, 但是命名规则有所不同. 变量名是大小写, 数字, <code>$</code>, 和<code>_</code>组合, 且不能用数字开头. </p>\n<p>和OC一样, 使用<code>=</code>对变量进行赋值, 由于JS是一门动态语言, 在初始化变量时可以不指定变量类型, 这与OC略有不同.</p>\n<p>仅仅声明但是没有赋值的变量, 其值实际上是<code>undefined</code>.</p>\n<pre><code>var carname;\nconsole.log(carname);\n</code></pre><hr>\n<p>1.<a href=\"http://www.bootcss.com/p/underscore/\" target=\"_blank\" rel=\"noopener\">Underscore - 一个JavaScript 工具库</a>.<br>2.<a href=\"https://halfrost.com/lost_in_javascript/\" target=\"_blank\" rel=\"noopener\">JavaScript 新手的踩坑日记</a>.</p>\n","categories":["JavaScript"],"tags":["基础知识","JavaScript"]},{"title":"UIView系列之---iOS的动态高度","url":"http://hchong.net/2017/07/24/UIView系列之---iOS的动态高度/","content":"<h1 id=\"UIView系列之—iOS的动态高度\"><a href=\"#UIView系列之—iOS的动态高度\" class=\"headerlink\" title=\"UIView系列之—iOS的动态高度\"></a>UIView系列之—iOS的动态高度</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<p>不论是UITableViewCell的高度也好, 或者是一个输入框也好, 都会用到动态布局. 实际上就是对一些显示文本内容的控件进行高度计算, 然后根据子视图的约束, 布局来得到父视图的高度并且改变他. </p>\n<h2 id=\"iOS布局机制大概分这么几种常见的方式\"><a href=\"#iOS布局机制大概分这么几种常见的方式\" class=\"headerlink\" title=\"iOS布局机制大概分这么几种常见的方式:\"></a>iOS布局机制大概分这么几种常见的方式:</h2><ul>\n<li><p>frame layout. frame layout最简单直接, 即通过设置view的frame属性值进而控制view的位置(相对于superview的位置)和大小. </p>\n</li>\n<li><p>autoresizing. autoresizing和frame layout一样, 从一开始存在, 它算是对frame layout的的补充,, 基于autoresizing机制, 能够让subview和superview维持一定的布局关系, 譬如让subview的大小适应superview的大小,, 随着后者的改变而改变. </p>\n<p>  站在代码接口的角度来看, autoresizing主要体现在几个属性上, 包括(但不限于):</p>\n<ul>\n<li><p><code>translatesAutoresizingMaskIntoConstraints</code>. 标识view是否愿意被autoresize;</p>\n</li>\n<li><p><code>autoresizingMask</code>. 是一个枚举值, 决定了当superview的size改变时, subview应该做出什么样的调整;</p>\n<p>autoresizing存在的不足是非常显著的, 通过autoresizingMask的可选枚举值可以看出: 基于autoresizing机制, 我们只能让view在superview的大小改变时做些调整; 而无法处理兄弟view之间的关系, 譬如处理与兄弟view的间隔; 更无法反向处理, 譬如让superview依据subview的大小进行调整. </p>\n</li>\n</ul>\n</li>\n<li><p>Auto layout. Auto Layout是随着iOS 6推出来的, 它是一种基于约束的布局系统, 可以根据你在元素(对象)上设置的约束自动调整元素(对象)的位置和大小对于某个view的布局方式. </p>\n<blockquote>\n<p>Auto Layout is a system that lets you lay out your app’s user interface by creating a mathematical description of the relationships between the elements. You define these relationships in terms of constraints either on individual elements, or between sets of elements. Using Auto Layout, you can create a dynamic and versatile interface that responds appropriately to changes in screen size, device orientation, and localization.</p>\n</blockquote>\n</li>\n</ul>\n<p>autoresizing和auto layout只能二选一, 简单来说, 若要对某个view采用auto layout布局, 则需要设置其<code>translatesAutoresizingMaskIntoConstraints</code>属性值为NO.</p>\n<h2 id=\"常见Auto-Layout场景下的运用\"><a href=\"#常见Auto-Layout场景下的运用\" class=\"headerlink\" title=\"常见Auto Layout场景下的运用\"></a>常见Auto Layout场景下的运用</h2><p>下面主要就几种常见场景下, Auto Layout的运用来说明一下用法. 在这里先说明一个概念 <em>Leaf-level views</em>, Leaf-level views指的是不包含任何subview的view, 譬如UILabel, UIButton等. 但是有些view不包含content, 譬如UIView, 这种view被认为「has no intrinsic size」, 它们的intrinsicContentSize返回的值是(-1, -1). </p>\n<h3 id=\"Leaf-level-views高度计算\"><a href=\"#Leaf-level-views高度计算\" class=\"headerlink\" title=\"Leaf-level views高度计算\"></a>Leaf-level views高度计算</h3><p>这类的view往往能够直接计算出content(譬如UILabel的text, UIButton的title, UIImageView的image)的大小. 以UILabel为例:</p>\n<p>假设我们已经设置了UILabel的x, y值约束, 没有设置与size有关的约束. 如果我们要根据UILabel的文本内容来计算最合适的size, 我们可以自定义一个Custom Label, 继承于UILabel, 在Custom Label中重写<code>- (CGSize)intrinsicContentSize</code>方法. 返回我们希望返回的size. 在需要使用UILabel的地方我们就可以通过使用Custom Label来实现搞得的正确计算. </p>\n<p>关于<code>intrinsicContentSize</code>方法的理解是, Auto Layout System在layout时, 不知道该为view分配多大的size, 因此回调view的<code>intrinsicContentSize</code>方法, 该方法会给auto layout system一个合适的size, system根据此size对view的大小进行设置; </p>\n<pre><code>@interface CustomLabel : UILabel\n\n@end\n\n@implementation CustomLabel\n\n- (CGSize)intrinsicContentSize {\n    CGSize size = [super intrinsicContentSize];\n    size.width  += 20;\n    size.height += 20;\n    return size;\n}\n\n@end\n</code></pre><p>以上如果是单行label的话, 实现起来没问题. 但是如果label一行显示不下需要换行的话, 那事情就没这么简单了. 但是怎么计算多行label的高度呢? 有以下几种方法: </p>\n<p>下面几种方法都需要我们首先设置<code>preferredMaxLayoutWidth</code>, 也就是UILabel的Width最大值, label会根据这个最大值来换行. 再设置<code>numberOfLines = 0</code>, 来实现换行. ==注意:== <code>preferredMaxLayoutWidth</code>适用于没有指定UILabel的Width的情况, 如果设置了Width的约束, 又设置了<code>preferredMaxLayoutWidth</code>. 那么计算size会以<code>preferredMaxLayoutWidth</code>为准, 显示则以Width的约束为准.</p>\n<ol>\n<li><p><code>boundingRectWithSize:options:attributes:context:</code></p>\n<p> <code>boundingRectWithSize:options:attributes:context:</code>是NSString的方法. 理解起来也非常简单, 根据一些绘制字符的选项和字符属性(字体, 字号, 字体颜色)等信息返回一个可以容纳字符串内容的CGRect. 它同样也需要一个CGSize来确定绘制区域.<br> size: 通常你可以传一个任意的Size, 它会返回一个它认为最合适的CGSize给你. 不过如果要想把视图的内容显示完全(纵向), 最好是将视图的实际宽度和最大高度<code>CGFLOAT_MAX</code>作为参数传递. 这样返回的才是完全显示内容的Size.<br> options: 默认情况下这个方法不会绘制多行, 如果要绘制多行字符, 那么options参数必须为: <code>NSStringDrawingUsesLineFragmentOrigin</code>.<br> attributes: 字符属性信息也非常重要. 如果要显示UILabel的全部内容, 必须传递这个参数. 以确保绘制的字体大小和UILabel的字体大小一致, </p>\n<p> 最后一个关键点是，这个方法返回的CGRect中Size的width和height都是小数，所以必须使用ceil函数才能确保结果的准确性。</p>\n</li>\n<li><p><span id=\"sizeThatFits\">sizeThatFits:</span></p>\n<blockquote>\n<p>Asks the view to calculate and return the size that best fits the specified size.</p>\n</blockquote>\n<blockquote>\n<p>Return Value<br>A new size that fits the receiver’s subviews.</p>\n</blockquote>\n<blockquote>\n<p>Discussion<br>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.</p>\n</blockquote>\n<p> sizeThatFits: 方法意味着「根据文本计算最适合的size」, 但是并不改变调用者的size. 它需要传入一个CGSize参数这个参数和<code>boundingRectWithSize:options:attributes:context:</code>中size的作用和意义是一样的. </p>\n</li>\n<li><p><span id=\"sizeToFit\">sizeToFit:</span></p>\n<blockquote>\n<p>calls sizeThatFits: with current view bounds and changes bounds size. </p>\n</blockquote>\n<p> <code>sizeToFit</code>内部会调用<code>sizeThatFits:</code>方法, 然后改变调用者的size. sizeToFit的伪代码大致如下：</p>\n<pre><code>// calls sizeThatFits\nCGSize size = [self sizeThatFits:self.bounds.size];\n// change bounds size\nCGRect bounds = self.bounds;\nbounds.size.width = size.width;\nbounds.size.height = size.width;\nself.bounds = bounds;\n</code></pre></li>\n<li><p><span id=\"systemLayoutSizeFittingSize\">systemLayoutSizeFittingSize</span> </p>\n<p> <code>systemLayoutSizeFittingSize</code>, 它也是UIView的方法, 是AutoLayout诞生后的产物. 所以使用它的前提是需要展示内容的控件(这里指的就是UILabel)必须约束完美. 不然就不会起作用。而且必须要设置UILabel的<code>preferredMaxLayoutWidth</code>属性.<br> 这个属性非常重要, 它影响着layout. 如果设置了<code>preferredMaxLayoutWidth</code>, 当内容超过约束区域, 就会自动换行并且更新约束. 在良好约束的前提下, <code>systemLayoutSizeFittingSize</code>同样接受一个CGSize, 不同的是这次不用计算了, 直接使用系统提供的Fitting Size即可:</p>\n<pre><code>const CGSize UILayoutFittingCompressedSize; //在保证适当尺寸的前提下尽量压缩CGSize的大小\nconst CGSize UILayoutFittingExpandedSize; //在保证适当尺寸的前提下尽量扩充CGSize的大小\n</code></pre><p> 所以为了刚好将UILabel的内容显示完全，应该使用UILayoutFittingCompressedSize。代码如下：</p>\n<p> <code>`</code></p>\n</li>\n</ol>\n<ul>\n<li><p>(void)layoutSubviews {<br>  [super layoutSubviews];<br>  self.label.preferredMaxLayoutWidth = CGRectGetWidth(self.label.bounds);<br>  CGSize size = [self.label systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];<br>  self.labelConstraintHeight.constant = size.height + (2 * MARGIN);<br>}<br>  <code>`</code></p>\n<p>  需要注意的是: 约束的上下左右一定要写好, 但是不能约束UILabel的高度. 否则可能会导致返回的CGRect不准确. <code>numberOfLines = 0</code> 让Label可以显示多行内容. 设置<code>preferredMaxLayoutWidth</code>属性, 使UILabel能自适应多行内容. <code>UILayoutFittingCompressedSize</code> 使用这个参数会返回符合条件最合适的Size. 最后也要加上边距, 主要是因为这里我们在内部计算UILabel的Size, 而如果在外部对View调用<code>systemLayoutSizeFittingSize</code>方法, 就会得到整个View视图的Size. </p>\n</li>\n</ul>\n<p><code>sizeThatFits:</code>和<code>boundingRectWithSize:options:attributes:context:</code>这两个API也可以在传统布局(基于Frame)的情况下使用. </p>\n<h3 id=\"非Leaf-level-views高度计算\"><a href=\"#非Leaf-level-views高度计算\" class=\"headerlink\" title=\"非Leaf-level views高度计算\"></a>非Leaf-level views高度计算</h3><p>以UITextView显示文本为例, 让其能够自适应文本, 即根据文本自动调整其大小; 由于<code>intrinsicContentSize</code>的特性, 当其内部含有subView时返回值是(-1, -1), 无法向auto layout system传递我们想要传达的值, 我们可以使用<a href=\"#sizeThatFits\">sizeThatFits</a>或者<a href=\"#sizeToFit\">sizeToFit</a>来计算或者改变UITextView的大小. </p>\n<p>==这里需要注意的是:== 当调用<code>sizeThatFits:</code>的size=(width, height)，当width/height的值为0时，width/height就被认为是无穷大, size就不能被正常的显示. 所以区别于UILabel, 我们的约束一定要设置好Width和height, 否则使用<code>sizeToFit</code>也不能正确计算出. </p>\n<h3 id=\"Leaf-level-views和非Leaf-level-views混合使用下高度计算\"><a href=\"#Leaf-level-views和非Leaf-level-views混合使用下高度计算\" class=\"headerlink\" title=\"Leaf-level views和非Leaf-level views混合使用下高度计算\"></a>Leaf-level views和非Leaf-level views混合使用下高度计算</h3><p>这里我们需要计算的是根据subView来确定superView的frame, 大致分为一下几种情况: </p>\n<ol>\n<li><p>多个纯Leaf-level views的组合使用</p>\n<p> 这个计算起来比较简单, 我们以一个UIView里面添加两个UILabel为例. 我们只需要从上到下, 把subViews的子约束撑满superView. 需要注意, 如果UILabel需要换行, 那么高度约束就不能写, 并且要设置<code>numberOfLines = 0</code>. 虽然我们什么也没做, 但是子控件会通过<code>intrinsicContentSize</code>方法将最合适的size告诉superView. 但是对于superView, 因为它本身是UIVIew, 他的<code>intrinsicContentSize</code>返回是(-1, -1), 那么它是怎么得出正确的结果呢. auto layout system在处理某个view的size时，<span id=\"size\">参考值</span>包括:</p>\n<ul>\n<li>自身的<code>intrinsicContentSize</code>方法返回值;</li>\n<li>subviews的<code>intrinsicContentSize</code>方法返回值;</li>\n<li><p>自身和subviews的constraints;</p>\n<p>系统会将superView的size和subViews的约束以及<code>intrinsicContentSize</code>返回的正确size相加, 然后比较两个值的大小, 然后取最大的一个.<br><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fjvnn0tr2lj30ok0ru0st.jpg\" alt=\"约束\"></p>\n<p>size1, size2, size3, 分别是label1, label2, superView的<code>intrinsicContentSize</code>方法返回的size.<br>width = max{91 + size1.width + 91 + size2.width, size3.width}<br>height = max{60 + size1.height + 36 + size2.height + 58, size3.height}</p>\n</li>\n</ul>\n</li>\n<li><p>多个纯非Leaf-level views的组合使用</p>\n<p> 仍旧以UITextView为例, 如果没有设定UItextView的height属性的话, 由于非Leaf-level views的<code>intrinsicContentSize</code>返回值值为(-1, -1). 设置某个View的size有三个<a href=\"#size\">参考值</a>, 在<code>intrinsicContentSize</code>方法返回值和constraints中取最大值为0, 导致height=0不能正常显示. 解决方案参考<a href=\"#next\">下一个</a>;</p>\n</li>\n<li><p><span id=\"next\">Leaf-level views和非Leaf-level views混合使用</span></p>\n<p> 因为有UItextView这种非Leaf-level views的存在, 会导致superView的size不能得到正常值. 解决方案有两种:</p>\n<ol>\n<li><p>设置非Leaf-level views的height, width约束, 因为<code>intrinsicContentSize</code>方法不能正常的返回size, 但是如果我们设置了width和height约束, constraints就不为0, 那么就可以正常显示了. </p>\n</li>\n<li><p>使用<code>systemLayoutSizeFittingSize:</code>, 具体使用方式可以参考<a href=\"#systemLayoutSizeFittingSize\">systemLayoutSizeFittingSize:</a>.</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Cell的动态高度计算\"><a href=\"#Cell的动态高度计算\" class=\"headerlink\" title=\"Cell的动态高度计算\"></a>Cell的动态高度计算</h3><p>对于使用auto layout机制布局的view, auto layout system会在布局过程中综合各种约束的考虑为之设置一个size, 在布局完成后, 该size的值即为view.frame.size的值; 这包含的另外一层意思, 即在布局完成前, 我们是不能通过view.frame.size准确获取view的size的. 但有时候, 我们需要在auto layout system对view完成布局前就知道它的size, <code>systemLayoutSizeFittingSize:</code>方法正是能够满足这种要求的API. <code>systemLayoutSizeFittingSize:</code>方法会根据其constraints返回一个合适的size值. </p>\n<p>在这里看一下比较知名的cell高度计算库<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\" target=\"_blank\" rel=\"noopener\">UITableView-FDTemplateLayoutCell</a>的核心高度计算方法, 大体上和我们所使用的方法差不多. Auto layout mode using <code>-systemLayoutSizeFittingSize:</code>, Frame layout mode using <code>-sizeThatFits:</code>. </p>\n<pre><code>- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell {\n    CGFloat contentViewWidth = CGRectGetWidth(self.frame);\n\n    // If a cell has accessory view or system accessory type, its content view&#39;s width is smaller\n    // than cell&#39;s by some fixed values.\n    if (cell.accessoryView) {\n        contentViewWidth -= 16 + CGRectGetWidth(cell.accessoryView.frame);\n    } else {\n        static const CGFloat systemAccessoryWidths[] = {\n            [UITableViewCellAccessoryNone] = 0,\n            [UITableViewCellAccessoryDisclosureIndicator] = 34,\n            [UITableViewCellAccessoryDetailDisclosureButton] = 68,\n            [UITableViewCellAccessoryCheckmark] = 40,\n            [UITableViewCellAccessoryDetailButton] = 48\n        };\n        contentViewWidth -= systemAccessoryWidths[cell.accessoryType];\n    }\n\n    // If not using auto layout, you have to override &quot;-sizeThatFits:&quot; to provide a fitting size by yourself.\n    // This is the same height calculation passes used in iOS8 self-sizing cell&#39;s implementation.\n    //\n    // 1. Try &quot;- systemLayoutSizeFittingSize:&quot; first. (skip this step if &#39;fd_enforceFrameLayout&#39; set to YES.)\n    // 2. Warning once if step 1 still returns 0 when using AutoLayout\n    // 3. Try &quot;- sizeThatFits:&quot; if step 1 returns 0\n    // 4. Use a valid height or default row height (44) if not exist one\n\n    CGFloat fittingHeight = 0;\n\n    if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) {\n        // Add a hard width constraint to make dynamic content views (like labels) expand vertically instead\n        // of growing horizontally, in a flow-layout manner.\n        NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth];\n        [cell.contentView addConstraint:widthFenceConstraint];\n\n        // Auto layout engine does its math\n        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;\n        [cell.contentView removeConstraint:widthFenceConstraint];\n\n        [self fd_debugLog:[NSString stringWithFormat:@&quot;calculate using system fitting size (AutoLayout) - %@&quot;, @(fittingHeight)]];\n    }\n\n    if (fittingHeight == 0) {\n#if DEBUG\n        // Warn if using AutoLayout but get zero height.\n        if (cell.contentView.constraints.count &gt; 0) {\n            if (!objc_getAssociatedObject(self, _cmd)) {\n                NSLog(@&quot;[FDTemplateLayoutCell] Warning once only: Cannot get a proper cell height (now 0) from &#39;- systemFittingSize:&#39;(AutoLayout). You should check how constraints are built in cell, making it into &#39;self-sizing&#39; cell.&quot;);\n                objc_setAssociatedObject(self, _cmd, @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n            }\n        }\n#endif\n        // Try &#39;- sizeThatFits:&#39; for frame layout.\n        // Note: fitting height should not include separator view.\n        fittingHeight = [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height;\n\n        [self fd_debugLog:[NSString stringWithFormat:@&quot;calculate using sizeThatFits - %@&quot;, @(fittingHeight)]];\n    }\n\n    // Still zero height after all above.\n    if (fittingHeight == 0) {\n        // Use default row height.\n        fittingHeight = 44;\n    }\n\n    // Add 1px extra space for separator line if needed, simulating default UITableViewCell.\n    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) {\n        fittingHeight += 1.0 / [UIScreen mainScreen].scale;\n    }\n\n    return fittingHeight;\n}\n\n</code></pre><p><a href=\"http://www.cocoachina.com/industry/20140604/8668.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>也有一些常见cell布局的高度计算方法, 可以参考下.</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://zhangbuhuai.com/beginning-auto-layout-part-1/\" target=\"_blank\" rel=\"noopener\">深入理解Auto Layout</a>.</p>\n<p>2.<a href=\"http://www.cocoachina.com/industry/20140604/8668.html\" target=\"_blank\" rel=\"noopener\">动态计算UITableViewCell高度</a></p>\n<p>3.<a href=\"http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/\" target=\"_blank\" rel=\"noopener\">优化UITableViewCell高度计算的那些事</a></p>\n<p>4.<a href=\"http://sylenthwave.github.io/2016/01/02/iOS%E5%8A%A8%E6%80%81%E5%8F%98%E9%AB%98%E6%80%BB%E7%BB%93/\" target=\"_blank\" rel=\"noopener\">iOS动态变高总结</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---如何写一个自定义View","url":"http://hchong.net/2017/07/15/UIView系列之---如何写一个自定义View/","content":"<h1 id=\"UIView系列之—如何写一个自定义View\"><a href=\"#UIView系列之—如何写一个自定义View\" class=\"headerlink\" title=\"UIView系列之—如何写一个自定义View\"></a>UIView系列之—如何写一个自定义View</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<p>这一篇和前面的实际是一个系列, 但是有不太一样, 也稍微偏架构和规范一些. 说一下在实际编程中的写法. </p>\n<h2 id=\"通用的自定义类的function归纳\"><a href=\"#通用的自定义类的function归纳\" class=\"headerlink\" title=\"通用的自定义类的function归纳\"></a>通用的自定义类的function归纳</h2><p>一个自定义类中的代码首先是有序的, 不管是<code>UIVIewControl</code>, <code>UIVIew</code>, 或者<code>NSObject</code>, 都应该把具有相同作用的function归纳为一个类, 我一般按照下面这样来分割代码, 这样看上去会比较有条理: </p>\n<pre><code>#pragma mark - LifeCycle\n这里面是一些类的生命周期的方法, 以及overWrite的父类的方法\n#pragma mark - UIConfig\n这里面是和当前类的UI相关的设置信息\n#pragma mark - HttpRequest\n当前类的网络请求部分\n#pragma mark - XXXDelegate\n当前类响应的代理事件\n#pragma mark - Action\n当前类的EventResponse事件\n#pragma mark - Private\n当前类中所用到的一些工具function, 不过一般不建议写在这里面, 我们应该按照模块新建一个专门的工具类来管理这些function\n#pragma mark - Getter, Setter\n当前类中用到的所有属性的Getter和Setter, 强烈推荐这么些, 这样可以把当前类的子控件的初始化放到Getter中去, 维护了代码的整洁度.\n</code></pre><p>除此之外, 上面这个顺序一般是按照使用者对这个类中所有function的关心程度来排序的, 例如对Lifecycle和UIConfig的关心程度就比Getter和Setter的程度高. 如果这个类还是特别长的话, 那就建议把代码在拆分为各个独立功能的category, 或者把尽量多的Private方法拆分为独立的工具类, 这样不管是对当前类的代码量, 或者后面可能会使用到这些PrivateFunction的人来说都是比较合理的做法. </p>\n<h2 id=\"组合代替继承\"><a href=\"#组合代替继承\" class=\"headerlink\" title=\"组合代替继承\"></a>组合代替继承</h2><p>除此之外, 对于复杂类来说我们要尽量<em>使用组合来代替继承</em>. 例如当前有一个类实现了A功能, 业务发展我们要使用A+B功能, 我们可能会想到写一个A的子类A’, 在里面再加上B功能, 完美解决. 那么后面我们要再使用A+B+C功能, 那么我们可能会写一个A’的子类A’’, 在里面实现C的功能, 又完美实现. 那如果突然有一天, 产品经理突然说要实现A+C功能呢, 傻眼了, 一大坨代码怎么拆分. 所以正确的做法应该是, 我们新建三个类, 分别独立实现A, B, C的功能, 业务方要用哪个就自由组合, 假设后面再来了D, E, F我们也不怕, 我们只用像插件一样, 用到哪个组合哪个就好. </p>\n<h2 id=\"UIView的写法\"><a href=\"#UIView的写法\" class=\"headerlink\" title=\"UIView的写法\"></a>UIView的写法</h2><p>UIView作为直接展示给用户看的层面, 是最重要的部分. 我强烈推荐使用纯代码布局, 使用Frame或者Autolayout都可以. 使用Frame的话, 推荐使用<a href=\"https://github.com/casatwy/HandyAutoLayout\" target=\"_blank\" rel=\"noopener\">这个项目</a>. 如果使用AutoLayout的话, <code>masonry</code>则是很不错的选择. </p>\n<p>objc构建一个对象使用的是两段式, 首先分配内存<code>alloc</code>然后<code>init</code>, 这样的好处就是将内存操作和初始化操作解耦合, 让我们能够在初始化的时候对对象做一些必要的操作. 这是个很好的思路, 我们在做很多事情的时候都可以使用这种两段式的思路. 比如布局一个UIView, 我们可以分成两部, <a href=\"#alloc\">初始化必要的子view和变量</a>, <a href=\"#init\">然后在合适的时机进行布局</a>. 一般来说我们的自定义类继承自UIView, 首先在initWithFrame:方法中将需要的子控件加入view中. 注意, 这里只是加入到view中, 并没有设置各个子控件的尺寸.</p>\n<h3 id=\"初始化必要的子view和变量\"><a href=\"#初始化必要的子view和变量\" class=\"headerlink\" title=\"初始化必要的子view和变量\"></a><span id=\"alloc\">初始化必要的子view和变量</span></h3><p>所以第一步应该是: <code>- (id)initWithFrame:(CGRect)aRect</code>, 那我们为什么不适用<code>- (id)init</code>来完成初始化呢? 如果是这种情况, 那么在init方法中frame是不确定的, 此时如果在initWithFrame:方法中设置尺寸, 那么各个子控件的尺寸都会是0, 因为这个view的frame还没有设置.所以我们应该保证view的frame设置完才会设置它的子控件的尺寸. </p>\n<p>还有就是这个函数是无论你用什么初始化函数都会被调用的一个, 比如你用<code>[UIView new]</code>或者<code>[[UIView alloc] init]</code>都会调用initWithFrame这个函数(有些UIView的子类有特殊情况，比如UITableViewCell), 所以你要是对一个view的变量有初始化的操作尽量往initWithFrame里面放还是非常合适的.  并且这样也能够保证, 以后在使用的时候所有的变量都被正确的初始化过. 而我们一般会在initWithFrame中做些什么呢.</p>\n<ul>\n<li>添加子View</li>\n<li>初始化属性变量</li>\n<li>其他一些共用操作</li>\n</ul>\n<h3 id=\"在合适的时机进行布局\"><a href=\"#在合适的时机进行布局\" class=\"headerlink\" title=\"在合适的时机进行布局\"></a><span id=\"init\">在合适的时机进行布局</span></h3><p>初始化函数中有一个名称withFrame, 大家可能就会以为这个函数使用布局用的. 然而在代码逻辑比较清晰的工程中，几乎很少看到在这个函数中进行界面布局的工作, 因为UIKit给你提供了一个专门的函数<code>layoutSubViews</code>来干这个事情. 而且, 在这个函数中做的界面布局的工作, 是一次性编码, 界面布局没有任何复用性, 如果父View的大小变了之后, 这个View还是傻傻的保持原来的模样. 同时也会造成, 初始化函数臃肿, 导致维护上的困难. 所以在<code>layoutSubViews</code>中对子视图进行布局才是最合理的地方. </p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>一个控件有2种创建方式: </p>\n<ul>\n<li>通过代码创建</li>\n</ul>\n<p>初始化时一定会调用<code>initWithFrame:</code>方法. </p>\n<ul>\n<li>通过xib\\storyboard创建</li>\n</ul>\n<p>初始化时不会调用<code>initWithFrame:</code>方法, 只会调用<code>initWithCoder:</code>方法, 初始化完毕后会调用<code>awakeFromNib</code>方法注意要在在awakeFromNib中初始化子控件</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈</a></p>\n<p>2.<a href=\"https://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1124.html\" target=\"_blank\" rel=\"noopener\">视图类, 如何布局</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---UIView的常见layout方法","url":"http://hchong.net/2017/07/10/UIView系列之---UIView的常见layout方法/","content":"<h2 id=\"UIView系列之—UIView的常见layout方法\"><a href=\"#UIView系列之—UIView的常见layout方法\" class=\"headerlink\" title=\"UIView系列之—UIView的常见layout方法\"></a>UIView系列之—UIView的常见layout方法</h2><ul>\n<li><p><code>init</code> &amp; <code>initWithFrame</code></p>\n<p>  <code>init</code> 和 <code>initWithFrame</code>方法, 实际上都会调用<code>initWithFrame</code>方法来完成初始化, 不同的是在<code>init</code>方法内部获取到的<code>self.frame</code>是<code>CGRectZero</code>, 在<code>initWithFrame</code>中获取到的<code>self.frame</code>就是初始化时, 传入的<code>frame</code>的大小. 不过一般不建议在初始化方法中设置子控件的<code>frame</code>, 因为这时<code>self.frame</code>时机还不是固定的.</p>\n</li>\n<li><p>layoutSubviews</p>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Lays out subviews.<br>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>\n</blockquote>\n<blockquote>\n<p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p>\n</blockquote>\n<blockquote>\n<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>\n</blockquote>\n<p>翻译成人话大概就是: <code>layoutSubviews</code>方法用来布局子视图. 在<code>layoutSubviews</code>方法内部直接给需要改变布局的子视图赋值新frame来改变其<code>frame</code>. 该方法主要应用在封装的自定义<code>view</code>中, 我们通过重写这个方法完成自定义<code>view</code>中子视图的布局. 但是我们不能直接调用他来更新子视图的<code>frame</code>. 只能通过<a href=\"#layoutIfNeeded\">layoutIfNeeded</a>或者<a href=\"#setNeedsLayout\">setNeedsLayout</a>来调用, 或者等待系统触发. 系统触发<code>layoutSubviews</code>的<a href=\"#layoutSubviews\">条件</a>.</p>\n<ul>\n<li><span id=\"setNeedsLayout\">setNeedsLayout</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.</p>\n</blockquote>\n<blockquote>\n<p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.</p>\n</blockquote>\n<p>翻译成人话大概就是: 如果一个layer的sublayer布局发生了改变需要更新布局, 我们通过调用<code>setNeedsLayout</code>方法来标记这个layer. 或者当layer的bounds发生变化或者layer上进行了add或者remove sublayer操作, 系统会自动调用<code>setNeedsLayout</code>方法. 这些被标记需要更新布局的layer会在下一个视图绘制周期(iOS屏幕刷新频率为60HZ, 因此下一个视图绘制周期是1/60s后)触发layoutSubviews完成子视图布局更新.</p>\n<p>如果你想要更新一个视图的子视图布局, 那么可以在主线程中调用这个方法来标记当前视图为需要更新子视图布局的视图. 可以使用这个方法给多个不同的view标记需要更新子视图布局, 然后在下一个视图绘制周期中这些view的subviews就会被一块更新布局, 这样做是可以很大地提高性能和效率的. </p>\n<ul>\n<li><span id=\"layoutIfNeeded\">layoutIfNeeded</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Lays out the subviews immediately.<br>Use this method to force the layout of subviews before drawing. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root.</p>\n</blockquote>\n<p>翻译成人话大概就是: 在下一次绘图周期开始之前使用此方法强制进行子视图的布局更新. 此方法会将receiver作为根视图, 然后从根视图开始遍历根视图的subview链, 判断super layer是否被标记需要更新布局, 直到找到一个super layer没有标记更新布局为止, 然后系统会向所有这些被标记需要更新布局的layer发送<code>layoutSublayers</code>消息. <code>layoutSublayers</code>是<code>setNeedsLayout</code>的一个辅助方法, 调用该方法就意味着不会等到下个绘制周期, 而是立马触发<code>layoutSubviews</code>方法, 完成子视图的布局. </p>\n<p>但是需要注意只有当系统检测到某个view被<code>setNeedsLayout</code>标记之后才会立即触发<code>layoutSubviews</code>, 如果没有检测到<code>setNeedsLayout</code>标记就不会触发<code>layoutSubviews</code>, 所以如果想要立即刷新某个视图的子视图布局, 需要先让该视图调用<code>setNeedsLayout</code>方法标记一下, 然后再调用<code>layoutIfNeeded</code>. 另外所有的视图在第一次显示之前都是默认有<code>setNeedsLayout</code>标记的, 所以视图第一次显示的时候就可以直接调用<code>layoutIfNeeded</code>. 但是当第一次显示完成后, 如果还想要调用<code>layoutIfNeeded</code>就必须先使用<code>setNeedsLayout</code>标记一下. </p>\n<ul>\n<li>setNeedsDisplay</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Marks the receiver’s entire bounds rectangle as needing to be redrawn.<br>You can use this method or the <code>setNeedsDisplayInRect:</code> to notify the system that your view’s contents need to be redrawn. This method makes a note of the request and returns immediately. The view is not actually redrawn until the next drawing cycle, at which point all invalidated views are updated.</p>\n</blockquote>\n<blockquote>\n<p>其他说明:<br>You should only be calling setNeedsDisplay if you override drawRect in a subclass of UIView which is basically a custom view drawing something on the screen, like lines, images, or shapes like a rectangle.</p>\n</blockquote>\n<p>如果我们在自定义的UIView中, 重写了<code>drawRect:</code>方法在屏幕上绘制一些东西, 那就需要在合适的地方调用<code>setNeedsDisplay</code>来标记当前视图, 系统会在下一个绘制周期时触发<code>drawRect:</code>方法. <a href=\"#drawRect\">系统触发drawRect:的条件</a>.</p>\n<p>也可以使用<code>setNeedsDisplayInRect:</code>方法来标记视图的某个区域需要重新绘制.</p>\n<ul>\n<li>drawRect</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Draws the receiver’s image within the passed-in rectangle</p>\n</blockquote>\n<blockquote>\n<p>The default implementation of this method does nothing. Subclasses that use technologies such as Core Graphics and UIKit to draw their view’s content should override this method and implement their drawing code there. You do not need to override this method if your view sets its content in other ways. For example, you do not need to override this method if your view just displays a background color or if your view sets its content directly using the underlying layer object.</p>\n</blockquote>\n<blockquote>\n<p>This method is called when a view is first displayed or when an event occurs that invalidates a visible part of the view. You should never call this method directly yourself. To invalidate part of your view, and thus cause that portion to be redrawn, call the <code>setNeedsDisplay</code> or <code>setNeedsDisplayInRect:</code> method instead.</p>\n</blockquote>\n<p>drawRect使用:</p>\n<p>该方法默认没有做任何操作, 如果视图中包含我们用<code>UIKit</code>或者<code>Core Graphics</code>绘制的内容, 我们需要重写该方法. 当视图第一次出现, 或者是改变约束条件让视图的全部或者一部分在屏幕上发生变化时, 系统都会调用<code>UIView</code>类的<code>drawRect</code>方法. 然后我们在此方法中能过获取到当前图形上下文, 实现我们的绘制内容, 最后系统会在合适的时机自动调用此方法. </p>\n<p><code>drawRect</code>一般调用是在<code>UIView</code>的<code>layoutSubviews</code>方法执行后. 但是, 在我们的视图全部初始化后,如果视图又发生了改变, 此时视图就需要重绘, 但是系统不会再帮我们自动调用<code>drewRect</code>方法. 这个时候就需要我们手动调用<code>UIView</code>类的 <code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect</code>方法. 这两个方法是用来告诉系统, 我们的视图有了更新需要去重绘. 相当于是给系统做了标记, 在系统 runloop 的下一个周期自动调用<code>drawRect</code>方法.</p>\n<p>使用中要注意的地方:</p>\n<ol>\n<li><p>不要直接调用 drawRect 方法,如果强行调用此方法也是无效果的.苹果要求我们调用 UIView 类的 setNeedsDisplay 方法,则程序会自动调用 drawRect 方法进行重绘.</p>\n</li>\n<li><p>因为在绘制时要拿到图形上下文,如果在 UIView 初始化时没有设置 rect 大小, drawRect 方法不会被调用.</p>\n</li>\n<li><p>调用 sizeThatFits 后, 控件 frame 改变, UIView 的 layoutSubviews 被调用, 然后再调用 drawRect 方法. 所以可以先调用 sizeToFit 计算出size. 然后系统自动调用 drawRect 方法.</p>\n</li>\n<li><p>通过设置 contentMode 属性值为 UIViewContentModeRedraw.那么将在每次设置或更改 bounds 的时候自动调用 drawRect.</p>\n</li>\n<li><p>若要实时画图, 如果使用 gestureRecognizer 来刷新屏幕, 需要判断并转化 point 的坐标; 使用 touchbegan 等方法, 只需调用 setNeedsDisplay 实时刷新屏幕.</p>\n</li>\n</ol>\n<p>这里有一篇<a href=\"http://bihongbo.com/2016/01/03/memoryGhostdrawRect/\" target=\"_blank\" rel=\"noopener\">使用drawRect:实现绘制画板功能的内存优化</a>的文章.</p>\n<ul>\n<li>sizeToFit</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622630-sizetofit?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Resizes and moves the receiver view so it just encloses its subviews.</p>\n</blockquote>\n<blockquote>\n<p>Call this method when you want to resize the current view so that it uses the most appropriate amount of space. Specific UIKit views resize themselves according to their own internal needs. In some cases, if a view does not have a superview, it may size itself to the screen bounds. Thus, if you want a given view to size itself to its parent view, you should add it to the parent view before calling this method.<br>You should not override this method. If you want to change the default sizing information for your view, override the sizeThatFits: instead. That method performs any needed calculations and returns them to this method, which then makes the change.</p>\n</blockquote>\n<p>当我们想要resize当前View以便获取他合适的大小时, 我们需要调用该方法. 尤其是<code>UIKit</code>的<code>View</code>视图是根据内部需要进行尺寸调整时. 在某些情况下, 如果当前View没有父视图, 他会根据屏幕的bounds来resize自身大小. 如果你想让一个View根据父视图来调整大小, 必须将该View添加到父视图中.</p>\n<p>一般情况下, 我们不需要重写该方法, 如果你想改变当前View的default size, 我们通过重写<a href=\"#sizeThatFits\">sizeThatFits:</a>来实现. 在<code>sizeThatFits:</code>方法中进行必要的计算, 返回结果, 然后改变他的大小.</p>\n<ul>\n<li><span id=\"sizeThatFits\">sizeThatFits</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Asks the view to calculate and return the size that best fits the specified size.</p>\n</blockquote>\n<blockquote>\n<p>Parameters<br>size<br>The size for which the view should calculate its best-fitting size.</p>\n</blockquote>\n<blockquote>\n<p>Return Value<br>A new size that fits the receiver’s subviews.</p>\n</blockquote>\n<blockquote>\n<p>Discussion<br>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.<br>This method does not resize the receiver.</p>\n</blockquote>\n<p>该方法要求View计算并返回最适合指定大小的大小. 传入的参数就是View需要最合适的大小, 返回值是根据传入的大小, 计算得到的一个最适合receiver子视图的尺寸. </p>\n<p>该方法默认返回视图的现有大小, 子类能够通过重写该方法获得一个基于该子类所有子视图的期望布局的自定义大小. 调用<code>sizeThatFits:</code>并不改变view的size, 它只是让view根据已有content和给定size计算出最合适的view.size. </p>\n<h2 id=\"sizeToFit-vs-sizeThatFits\"><a href=\"#sizeToFit-vs-sizeThatFits\" class=\"headerlink\" title=\"sizeToFit vs sizeThatFits:\"></a>sizeToFit vs sizeThatFits:</h2><ol>\n<li>sizeToFit会自动调用sizeThatFits方法；</li>\n<li>sizeToFit不应该在子类中被重写, 应该重写sizeThatFits</li>\n<li>sizeThatFits传入的参数是receiver当前的size, 返回一个适合subviews的size</li>\n<li>sizeToFit可以被手动直接调用, </li>\n<li>sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己</li>\n<li>调用 sizeToFit() 会去自动调用 sizeThatFits(_ size: CGSize) 方法。</li>\n<li>sizeThatFits 不会改变 receiver 的 size, 调用 sizeToFit() 会改变 receiver 的 size. 此处的receiver一般是方法的调用者. </li>\n</ol>\n<h2 id=\"系统触发layoutSubviews的条件\"><a href=\"#系统触发layoutSubviews的条件\" class=\"headerlink\" title=\"系统触发layoutSubviews的条件\"></a><span id=\"layoutSubviews\">系统触发layoutSubviews的条件</span></h2><ol>\n<li>父视图使用<code>init</code>方法完成初始化时不会触发<code>layoutSubviews</code>. </li>\n<li>父视图用<code>initWithFrame</code>完成初始化并且当frame参数为<code>CGRectZero</code>时不会触发<code>layoutSubviews</code>. 当frame参数不为<code>CGRectZero</code>时则会触发<code>layoutSubviews</code>.</li>\n<li>父视图<code>setFrame</code>的时候会触发<code>layoutSubviews</code>, 当然frame前后值得发生变化.</li>\n<li>父视图<code>addSubview</code>添加子视图时会触发其内部的<code>layoutSubviews</code>.</li>\n<li>子视图从父视图上<code>removeFromSuperView</code>的时候会触发其内部的<code>layoutSubviews</code>. </li>\n<li>滚动ScrollView的时候会触发<code>layoutSubviews</code>. </li>\n<li>旋转屏幕的时候会触发<code>layoutSubviews</code>. </li>\n</ol>\n<h2 id=\"系统出发drawRect-的条件\"><a href=\"#系统出发drawRect-的条件\" class=\"headerlink\" title=\"系统出发drawRect:的条件\"></a><span id=\"drawRect\">系统出发drawRect:的条件</span></h2><ol>\n<li>如果在<code>UIView</code>初始化时没有设置rect大小, 将直接导致<code>drawRect</code>不被自动调用. <code>drawRect</code>调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的. 所以不用担心一进入到控制器中, 这些View的drawRect就开始画了. 这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).</li>\n<li>该方法在调用<code>sizeToFit</code>后被调用, 所以可以先调用<code>sizeToFit</code>计算出size, 然后系统自动调用drawRect:方法. </li>\n<li>通过设置<code>contentMode</code>属性值为<code>UIViewContentModeRedraw</code>. 那么将在每次设置或更改frame的时候自动调用<code>drawRect:</code>.</li>\n<li>直接调用<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>触发<code>drawRect:</code>. 但是有个前提条件是rect不能为<code>CGRectZero</code>.<br>以上1, 2推荐; 而3, 4不提倡. </li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/087529c83747\" target=\"_blank\" rel=\"noopener\">Core Animation 之 CALayer</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/3282c93c1a61\" target=\"_blank\" rel=\"noopener\">UIView几个layout方法的理解</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/b3bb9b08e3da\" target=\"_blank\" rel=\"noopener\">UIView布局深入理解</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/eb2c4bb4e3f1\" target=\"_blank\" rel=\"noopener\">UIViewLayout的几个方法</a></p>\n<p>5.<a href=\"http://zhangbuhuai.com/beginning-auto-layout-part-1/\" target=\"_blank\" rel=\"noopener\">深入理解Auto Layout 第一弹</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---UIView和CALayer","url":"http://hchong.net/2017/07/07/UIView系列之---UIView和CALayer/","content":"<h1 id=\"UIView系列之—UIView和CALayer\"><a href=\"#UIView系列之—UIView和CALayer\" class=\"headerlink\" title=\"UIView系列之—UIView和CALayer\"></a>UIView系列之—UIView和CALayer</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<h2 id=\"UIView和CALayer\"><a href=\"#UIView和CALayer\" class=\"headerlink\" title=\"UIView和CALayer\"></a>UIView和CALayer</h2><ol>\n<li><p><code>UIView</code>继承自<code>UIResponder</code>, 可以相应触摸事件. 而<code>CALayer</code>继承自<code>NSObject</code>, 不能响应触摸.</p>\n</li>\n<li><p><code>UIView</code>主要是对显示内容的管理, 而<code>CALayer</code>则主要侧重显示内容的绘制. 访问<code>UIVIew</code>的与绘图和跟坐标有关的属性, 例如<code>frame</code>, <code>bounds</code>等, 实际上内部都是在访问它所包含的CALayer的相关属性. <code>UIView</code>的<code>frame</code>实际是<code>layer</code>的<code>frame</code>, <code>center</code>, <code>bounds</code>实际也是只是内部<code>layer</code>相对应属性的<code>get</code>和<code>set</code>方法, 当你改变一个<code>view</code>的<code>frame</code>的时候, 你其实改变的是内部<code>layer</code>的<code>frame</code>. CALayer的frame由<code>anchorPoint</code>, <code>position</code>, <code>bounds</code>, <code>transform</code>共同决定. <code>UIView</code>的创建, 实际上是一系列<code>UILayer</code>创建的过程.</p>\n</li>\n<li><p><code>UIView</code>有个重要属性<code>layer</code>. 可以返回它的主<code>CALayer</code>实例. 所有从UIView继承来的对象都继承了这个属性. 这意味着你可以在所有的<code>UIVIew</code>子类上增加动画, 旋转, 缩放等<code>CALayer</code>支持的操作. <code>UIView</code>的<code>layerClass</code>方法, 可以返回主<code>layer</code>所使用的类, <code>UIView</code>的子类可以通过重载这个方法, 来让<code>UIView</code>使用不同的CALayer来显示. 代码示例：</p>\n<pre><code> - (class)layerClass {\n     return ([CAEAGLLayer class]);\n }\n</code></pre></li>\n<li><p><code>UIView</code>的主<code>CALayer</code>是类似于<code>subviews</code>的树形结构, 我们可以通过给主<code>layer</code>添加子<code>layer</code>来完成特殊的绘制效果.</p>\n<p> 在<code>view</code>上添加一个黑色透明<code>layer</code>层的示例代码:</p>\n<pre><code> grayCover = [[CALayer alloc] init];\n grayCover.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];\n [self.layer addSubLayer:grayCover];\n</code></pre></li>\n<li><p><code>UIView</code>的内部, 有三个<code>layer tree</code>: 1.逻辑树, 这里是代码可以操纵的. 2.动画树, 是一个中间层, 系统就在这一层上通过逻辑树来更改属性, 进行各种渲染操作. 3.显示树, 其内容就是当前正被显示在屏幕上得内容. </p>\n</li>\n<li><p><code>UIView</code>实际上是<code>CALayer</code>的<code>CALayerDelegate</code>, 通过实现一系列的代理方法来显示<code>CALayer</code>绘制的内容.</p>\n</li>\n<li><p>在做 iOS 动画的时候, 修改非<code>RootLayer</code>的属性(譬如位置, 背景色等)会默认产生隐式动画, 而修改<code>UIView</code>则不会.</p>\n</li>\n<li><p><code>layer</code>可以设置圆角显示(cornerRadius), 也可以设置阴影(shadowColor). 但是如果<code>layer</code>树中某个<code>layer</code>设置了圆角, 树种所有<code>layer</code>的阴影效果都将不显示了. 因此若是要有圆角又要阴影, 变通方法只能做两个重叠的<code>UIView</code>, 一个的<code>layer</code>显示圆角, 一个<code>layer</code>显示阴影.</p>\n</li>\n<li><p><code>UIView</code> 是<code>UIKit</code>框架下的(只能iOS使用). <code>CALayer</code> 是<code>QuartzCore</code>的(iOS 和macOS通用).</p>\n</li>\n<li><p><code>QuartzCore</code>的渲染能力. 使二维图像可以被自由操纵, 就好像是三维的. 图像可以在一个三维坐标系中以任意角度被旋转, 缩放和倾斜. <code>CATransform3D</code>的一套方法提供了一些魔术般的变换效果. </p>\n</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">详解CALayer 和 UIView的区别和联系</a></p>\n<p>2.<a href=\"http://blog.csdn.net/weiwangchao_/article/details/7771538\" target=\"_blank\" rel=\"noopener\">UIView和CALayer的区别</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"Block用法与原理分析","url":"http://hchong.net/2017/07/04/Block用法与原理分析/","content":"<h1 id=\"Block用法及分析\"><a href=\"#Block用法及分析\" class=\"headerlink\" title=\"Block用法及分析\"></a>Block用法及分析</h1><p>Block的默认格式是这样的: <strong><code>返回值类型 (^Block变量名)(形参列表) = ^返回值类型 (形参列表){ 内容 }</code></strong>. 后面的返回值类型和形参列表可以省略. </p>\n<p>Block用一句话来形容就是带有自动变量(局部变量)的匿名函数. 他可以嵌套定义, 定义Block方法和定义函数方法类似, Block可以定义在方法内部和外部, 必须调用Block, 才会执行<code>{}</code>内部的方法. 本质是对象, 使代码高聚合. 结合<code>clang</code>分析可以发现Block的真实面目.</p>\n<pre><code>struct Block_layout {  \n    void *isa;\n    int flags;\n    int reserved;\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n\nstruct Block_descriptor {  \n    unsigned long int reserved;\n    unsigned long int size;\n    void (*copy)(void *dst, void *src);\n    void (*dispose)(void *);\n};\n</code></pre><p><img src=\"http://img.souche.com/f2e/d71a93dbbbf11a6055810df74fdf309d.png\" alt=\"block的数据结构\"></p>\n<p>可以看到有<code>isa</code>的存在, 由此可以说明, OC处理Block是按照对象来处理的. 在iOS中, isa常见的就是_NSConcreteStackBlock, _NSConcreteMallocBlock, _NSConcreteGlobalBlock这三种类型. </p>\n<h2 id=\"常见的使用方法\"><a href=\"#常见的使用方法\" class=\"headerlink\" title=\"常见的使用方法\"></a>常见的使用方法</h2><p>常见的Block的使用方式有以下几种:</p>\n<h3 id=\"作为变量的用法\"><a href=\"#作为变量的用法\" class=\"headerlink\" title=\"作为变量的用法\"></a>作为变量的用法</h3><p>官方提供的快捷写法(inlineBlock)的示例是这样的:</p>\n<pre><code>&lt;#returnType#&gt;(^&lt;#blockName#&gt;)(&lt;#parameterTypes#&gt;) = ^(&lt;#parameters#&gt;) {\n   &lt;#statements#&gt;\n};\n</code></pre><p>我们举个🌰</p>\n<pre><code>//定义一个block变量sum, 并且赋值(此处省略返回值类型int)\nint(^sum)(int, int) = ^(int a, int b) {\n   return a + b;\n};\n//调用block变量\nint count = sum(2, 3);\nNSLog(@&quot;%d&quot;, count);\n\n也可以吧定义和赋值分开来写, 类似于这样\n\n//定义一个block变量\nint (^sum)(int, int);\n//给block变量赋值(此处没有省略返回值类型)\nsum = ^int(int a, int b) {\n    return a + b;\n};\nint count = sum(2, 3);\n    NSLog(@&quot;%d&quot;, count);    \n</code></pre><h3 id=\"作为属性的用法\"><a href=\"#作为属性的用法\" class=\"headerlink\" title=\"作为属性的用法\"></a>作为属性的用法</h3><p>block作为属性, 可以存在在找那个类的声明周期中, 这样就可以全局的使用, 也比较常用.</p>\n<pre><code>1. 定义一个block属性\n@property (nonatomic, copy) int (^sum)(int a, int b);\n\n也可以使用`typedefBlock`的方式来定义(推荐)\ntypedef int(^Sum)(int, int);\n\n@property (nonatomic, copy) Sum sum;\n\n\n2. 然后在合适的地方写该属性(block)的实现, \nself.sum = ^int(int a, int b) {\n    return a + b;\n};\n\n3. 最后是block的调用\nint count = self.sum(3, 4);\nNSLog(@&quot;%d&quot;, count);\n</code></pre><h3 id=\"作为函数-方法-参数的用法\"><a href=\"#作为函数-方法-参数的用法\" class=\"headerlink\" title=\"作为函数(方法)参数的用法\"></a>作为函数(方法)参数的用法</h3><p>在这里C和OC的还略有不同. </p>\n<p>block作为函数参数的用法也是较常见的, 例如网络请求方法中, 会把网络请求结果处理的代码在block中, 等请求到数据的时候直接调用.</p>\n<p>block的定义也可以分为两种情况, 一种是使用了<code>typedefBlock</code>来定义, 一种是直接定义, 下面例子会给出代码示例. 假设有个下载的网络请求, 会有成功和失败的代码处理被我们封装在block里面, 作为参数在外面被调用.</p>\n<pre><code>\n//.h文件\n#import &lt;Foundation/Foundation.h&gt;\ntypedef void(^SuccessBlock)(id obj);\ntypedef void(^FailBlock)(id obj);\n\n@interface DownLoadManager : NSObject\n\n+ (void)downLoadedSuccess:(SuccessBlock)success fail:(FailBlock)fail;\n\n+ (void)uploadSuccess:(void(^)(id obj))success fail:(void(^)(id obj))fail;\n@end\n\n\n//.m文件\n#import &quot;DownLoadManager.h&quot;\n\n@implementation DownLoadManager\n\n+ (void)downLoadedSuccess:(SuccessBlock)success fail:(FailBlock)fail {\n    //使用延迟来模拟异步数据请求\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        success(@&quot;我是数据&quot;);\n    });\n}\n\n+ (void)uploadSuccess:(void(^)(id obj))success fail:(void(^)(id obj))fail {\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        success(@&quot;我是数据&quot;);\n    });\n}\n@end\n\n\n//在外面调用: \n[DownLoadManager downLoadedSuccess:^(id obj) {\n    NSLog(@&quot;%@&quot;, obj);\n} fail:^(id obj) {\n\n}];\n\n[DownLoadManager uploadSuccess:^(id obj) {\n\n} fail:^(id obj) {\n\n}];\n</code></pre><p>可以看到, 这里的作为参数有两种方式, 一种是使用<code>typedef</code>定义, 一种是直接定义, 这两种方式和作为属性的两种用法基本类似.</p>\n<p>下面是在C中的使用方法. 对比一下可以发现还是有一些差别的, 在OC中直接使用的话, block的name是没有定义的, C中是有的.</p>\n<pre><code>// 实现，不使用 typedef\n// void (^iblock)()作为函数参数类型，iblock函数形参名\nvoid iprint( void (^iblock)() ){ \n    iblock(); // 调用 block参数}\n\n// 实现，使用 typedef\ntypedef void (^IBlock)();\nvoid iprint(IBlock iblock){\n    iblock(); // 调用 block参数\n\n}\n\n// 调用「不管使用不使用 typedef 调用方式一致」\niprint(^{\n    NSLog(@&quot;传入的实参代码块区域&quot;);\n});\n</code></pre><h3 id=\"作为返回值的用法\"><a href=\"#作为返回值的用法\" class=\"headerlink\" title=\"作为返回值的用法\"></a>作为返回值的用法</h3><p>block作为返回值的用法主要使用场景是函数的链式编程中, 可以参考<a href=\"http://hchong.net/2017/12/17/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/\">这篇文章</a>.</p>\n<pre><code>typedef NSString *(^NameBlock)(NSString *inputalue);//定义一个返回值是String, 参数是String类型的block, 名字为NameBlock\n\n@property (nonatomic, copy) NameBlock nameBlock;\n\n//实现属性的get方法\n- (NSString *(^)(NSString *))nameBlock {\n    return ^NSString *(NSString *inputValue) {\n        return [inputValue stringByAppendingString:@&quot;test&quot;];\n    };\n}\n\n//调用方式如下\nNSLog(@&quot;%@&quot;, self.nameBlock(@&quot;block作为返回值&quot;));\n</code></pre><h3 id=\"常见的使用场景\"><a href=\"#常见的使用场景\" class=\"headerlink\" title=\"常见的使用场景\"></a>常见的使用场景</h3><ul>\n<li><p>Enumeration (像我们上面看到的 NSArray 的枚举接口)</p>\n</li>\n<li><p>View Animations (animations)</p>\n</li>\n<li><p>Sorting (在排序时在 Block 中实现比较逻辑)</p>\n</li>\n<li><p>Notification (当某些事件被触发时，执行对应的 Block)</p>\n</li>\n<li><p>Error handlers (作为错误事件的 Handler)</p>\n</li>\n<li><p>Completion handlers (作为某个任务完成时的 Handler)</p>\n</li>\n<li><p>Multithreading (在 Grand Central Dispatch (GCD) API 中使用)</p>\n</li>\n</ul>\n<h2 id=\"捕获外部变量\"><a href=\"#捕获外部变量\" class=\"headerlink\" title=\"捕获外部变量\"></a>捕获外部变量</h2><p>C语言中的变量一共有五种: 自动变量, 函数参数, 静态局部变量, 静态全局变量, 全局变量. 要研究外部变量的捕获就去除掉函数参数这一项. 下面逐一分析.</p>\n<pre><code>static int staticGlobalInt = 0;//静态全局变量\nint globalInt;//全局变量\n\n//测试Block的变量捕获\n- (void)variableTest {\n    static int staticInt = 0;//静态局部变量\n    __block int intNumber = 0;//局部变量\n    globalInt = 0;//全局变量\n    staticGlobalInt = 0;//静态全局变量\n\n    NSLog(@&quot;初始化时---静态全局变量:%d, 全局变量:%d, 静态局部变量:%d, 局部变量:%d&quot;, staticGlobalInt, globalInt, staticInt, intNumber);\n\n    void(^addTest)() = ^(){\n        staticGlobalInt++;\n        globalInt++;\n        staticInt++;\n        intNumber++;\n        NSLog(@&quot;在block中---静态全局变量:%d, 全局变量:%d, 静态局部变量:%d, 局部变量:%d&quot;, staticGlobalInt, globalInt, staticInt, intNumber);\n    };\n    NSLog(@&quot;在block调用结束后---静态全局变量:%d, 全局变量:%d, 静态局部变量:%d, 局部变量:%d&quot;, staticGlobalInt, globalInt, staticInt, intNumber);\n    addTest();\n}\n</code></pre><p>在这里, 如果不加<code>__block</code>的话, 局部变量在block内部使用是会报错的, 原因后面讲. 这里先来说一下结果, 打印的结果是:</p>\n<pre><code>\n初始化时---静态全局变量:0, 全局变量:0, 静态局部变量:0, 局部变量:0\n在block调用结束后---静态全局变量:0, 全局变量:0, 静态局部变量:0, 局部变量:0\n在block中---静态全局变量:1, 全局变量:1, 静态局部变量:1, 局部变量:1\n</code></pre><p>可以发现结果都变了, 但是内部实现实际上不同的.</p>\n<ul>\n<li><p>静态全局变量和静态局部变量, 由于他们是存储在全局区(数据区), 作用域的范围是整个程序的生命周期, 只要程序在运行, 就可以访问到. 所以block直接访问了对应的变量, 而没有把他们copy到block中去</p>\n</li>\n<li><p>静态局部变量也是存储在全局区(数据区), 程序在运行就可以访问的到, 但是他的作用范围仅限于定义他的函数中. 系统是把内存地址传递给block, 所以在block也可以直接修改他的的值.</p>\n</li>\n<li><p>局部变量, 必须使用<code>__block</code>(存储域类说明符)来修饰, 否则在block内部使用会报错. 对于非对象的变量来说, 自动变量的值, 被copy进了Block, 不带<code>__block</code>的自动变量只能在里面被访问, 并不能改变值. 对于对象来说, 在MRC环境下, <code>__block</code>根本不会对指针所指向的对象执行copy操作, 而只是把指针进行的复制. 而在ARC环境下, 对于声明为<code>__block</code>的外部对象, 在block内部会进行retain, 以至于在block环境内能安全的引用外部对象. 对于没有声明<code>__block</code>的外部对象, 在block中也会被retain</p>\n</li>\n</ul>\n<p><em>注意</em>: Block捕获外部变量仅仅只捕获Block闭包里面会用到的值，其他用不到的值，它并不会去捕获.</p>\n<h2 id=\"Block的存储域相关\"><a href=\"#Block的存储域相关\" class=\"headerlink\" title=\"Block的存储域相关\"></a>Block的存储域相关</h2><p>通过之前的源码分析可以看出, Block结构体中是有一个isa指针的, 这也就说明Block实际也是一个OC的对象. 在OC中一般Block分为三种: </p>\n<h3 id=\"NSConcreteStackBlock\"><a href=\"#NSConcreteStackBlock\" class=\"headerlink\" title=\"_NSConcreteStackBlock\"></a>_NSConcreteStackBlock</h3><p>该类对象的存储域在栈上面. 只用到外部局部变量, 成员属性变量, 且没有强指针引用的block都是StackBlock. StackBlock的生命周期由系统控制的. 由于存储在栈上面, 一旦返回之后所属的变量域一旦结束, 就被系统销毁了. 所以他是不安全的 <em>该类型的block不持有对象</em>.</p>\n<p>需要注意, 由于<code>_NSConcreteStackBlock</code>所属的变量域一旦结束, 那么该Block就会被销毁. 在ARC环境下, 编译器会自动的判断, 把Block自动的从栈copy到堆上. </p>\n<h3 id=\"NSConcreteGlobalBlock\"><a href=\"#NSConcreteGlobalBlock\" class=\"headerlink\" title=\"_NSConcreteGlobalBlock\"></a>_NSConcreteGlobalBlock</h3><p>与global变量一样, 该类对象的存储域在数据区(全局区). 一般情况下, 没有用到外界变量或只用到全局变量, 静态变量的block为_NSConcreteGlobalBlock. 由于存储在数据区(全局区), 所以生命周期从创建到应用程序结束. <em>该类型的block不持有对象</em>, 因为要么不引用外部变量, 要么使用的是全局变量或者静态变量.</p>\n<h3 id=\"NSConcreteMallocBlock\"><a href=\"#NSConcreteMallocBlock\" class=\"headerlink\" title=\"_NSConcreteMallocBlock\"></a>_NSConcreteMallocBlock</h3><p>该类对象设置在由malloc函数分配的内存块(堆)中. 有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock, 没有强指针引用即销毁, 生命周期由程序员控制. <em>该类型的block会持有外部对象</em>.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Block本身也是一个对象, 那么他自身的存储域, 生命周期和作用域也是我们要了解的.由于<code>_NSConcreteStackBlock</code>是在栈上面的, 容易被销毁, 所以我们需要把它copy到堆上面进行操作, 在ARC下, 如果有下面几种方式系统会自动把<code>block</code>copy到堆上面去:</p>\n<pre><code>* 手动调用copy \n* Block 作为函数返回值返回时\n* 将 Block 赋值给类的`__strong` 修饰的 id 类型的成员变量时\n* 将 Block 赋值给类 Block 类型成员变量时\n* 向 GCD 的 API 中或方法名中含有 usingBlock 的 Cocoa 框架方法传递 Block 作为参数时\n</code></pre><p>下面两种情况需要我们自己调用copy方法:</p>\n<pre><code>* 在向一般方法或函数传递 Block 作为参数时，传的时候要调用一下 Block 的 copy 方法。除非在方法或函数体中，对传进来的 Block 参数做了 copy 处理\n* 如果不明确情况, 也推荐手动调用 copy.\n</code></pre><p>Block对象如果内部使用了<code>__block</code>修饰的局部变量, 那么当Block从栈上复制到堆上时, <code>__block</code>变量也会被copy到堆上面, 并且Block会持有这个变量. 当堆上的 Block 被废弃时, 那么它所使用的 <code>__block</code> 变量也会被释放.</p>\n<h2 id=\"block几种关键字的用法\"><a href=\"#block几种关键字的用法\" class=\"headerlink\" title=\"block几种关键字的用法\"></a>block几种关键字的用法</h2><h3 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"__block\"></a>__block</h3><p>如果想在 Block 中读写局部变量, 那么需要在局部变量前加 <code>__block</code>. <code>__block</code>实际上是提升了变量的作用域. 如果获得对象（在堆上）, 调用变更该对象的方法是没问题的（存储对象的空间在堆上）, 而直接向截获的变量赋值则会产生编译错误（这个对象的指针是在栈上的）.</p>\n<ol>\n<li><p><code>__block</code>修饰变量<br> ARC环境下, 一旦Block赋值就会触发copy, <code>__block</code>就会copy到堆上, Block也是<code>__NSMallocBlock</code>. ARC环境下也是存在<code>__NSStackBlock</code>的时候, 这种情况下, <code>__block</code>就在栈上.</p>\n<p> MRC环境下, 只有copy, <code>__block</code>才会被复制到堆上, 否则, <code>__block</code>一直都在栈上, block也只是<strong>NSStackBlock, 这个时候`</strong>forwarding`指针就只指向自己了.</p>\n</li>\n<li><p><code>__block</code>修饰对象<br> 对象在OC中, 默认声明自带<code>__strong</code>所有权修饰符的</p>\n<pre><code> __block id block_obj = [[NSObject alloc]init];  \n id obj = [[NSObject alloc]init];\n 等价于\n Objective-C\n __block id __strong block_obj = [[NSObject alloc]init];  \n id __strong obj = [[NSObject alloc]init];\n</code></pre><p> 在ARC环境下, 不仅仅是声明了<code>__block</code>的外部对象, 没有声明<code>__block</code>的对象, 在block内部也会被retain. 因为加了<code>__block</code>, 只是对一个自动变量有影响, 它们是指针, 相当于延长了指针变量的声明周期, 只要访问对象的话还是会retain.</p>\n<p> 在MRC环境下, <code>__block</code>根本不会对指针所指向的对象执行copy操作, 而只是把指针进行的复制. </p>\n</li>\n</ol>\n<h3 id=\"weak\"><a href=\"#weak\" class=\"headerlink\" title=\"__weak\"></a>__weak</h3><p><code>__weak</code>修饰的对象被Block捕获时是对其进行弱引用持有的, 因为<code>__NSConcreteMallocBlock</code>捕获外部对象会在内部持有他, 引用计数会+1. 如果使用<code>__weak</code>修饰外部变量, Block捕获的变量就会是弱引用持有. 当Block所有者的作用域结束时, 他指向的对象没有被其他强引用持有, 所以立即被释放, 这是Block内部持有的弱引用也被置为nil.</p>\n<p><em>注意</em>: block并不会捕获形参到block内部进行持有. 例如下面这样:</p>\n<pre><code>Student *student = [[Student alloc]init];\nstudent.name = @&quot;Hello World&quot;;\n\nstudent.study = ^(NSString * name){\n    NSLog(@&quot;my name is = %@&quot;,name);\n};\nstudent.study(student.name);\n</code></pre><h3 id=\"strong\"><a href=\"#strong\" class=\"headerlink\" title=\"__strong\"></a>__strong</h3><p><code>__strong</code>修饰的对象被Block捕获时是对其进行强引用持有的. 当Block的所有者的作用域结束时, <code>__strong</code>修饰的对象依然被Block强引用持有, 所以不会立即释放.</p>\n<h3 id=\"weakSelf-amp-strongSelf\"><a href=\"#weakSelf-amp-strongSelf\" class=\"headerlink\" title=\"weakSelf &amp; strongSelf\"></a>weakSelf &amp; strongSelf</h3><p>weakSelf 是为了block不持有self，避免Retain Circle循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf. weakSelf有下面两种写法.</p>\n<pre><code>__weak __typeof(self)weakSelf = self;\n#define WEAKSELF typeof(self) __weak weakSelf = self;\n</code></pre><p>strongSelf的目的是因为一旦进入block执行, 假设不允许self在这个执行过程中释放, 就需要加入strongSelf. block执行完后这个strongSelf 会自动释放, 不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf. strongSelf的写法如下:</p>\n<pre><code>__weak __typeof(self)weakSelf = self;\n__strong __typeof(weakSelf)strongSelf = weakSelf\n</code></pre><h3 id=\"避免Block使用的对象被提前释放\"><a href=\"#避免Block使用的对象被提前释放\" class=\"headerlink\" title=\"避免Block使用的对象被提前释放\"></a>避免Block使用的对象被提前释放</h3><p>在 Block 中用异步的方式使用了外部对象, 当对象被释放后, 异步方法回调时访问该对象则会为空, 这时就可能造成程序崩溃了. 解决这个问题的方式则是 <code>__weak</code>/<code>__strong</code>. 例如下面这种样式的: </p>\n<pre><code>@implementation TestBlockViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // Init properties.\n    self.tag = @&quot;tag is OK.&quot;;\n\n    // Init TestService&#39;s block.\n    typeof(self) __weak weakSelf = self;\n    self.myBlock = ^{\n        typeof(weakSelf) __strong strongSelf = weakSelf;\n\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n            NSLog(@&quot;strongSelf is OK.&quot;);\n            NSLog(@&quot;%@&quot;, strongSelf.tag);\n            //NSLog(@&quot;%@&quot;, self.tag); // Retain cycle.\n        });\n    };\n\n}\n- (void)backButtonAction {    \n    self.myBlock();\n    [self.navigationController popViewControllerAnimated:YES];\n}\n- (void)dealloc {\n    NSLog(@&quot;TestBlockViewController dealloc.&quot;);\n}\n@end\n</code></pre><hr>\n<p>参考资料: </p>\n<p>1.<a href=\"https://halfrost.com/ios_block/\" target=\"_blank\" rel=\"noopener\">深入研究 Block 捕获外部变量和 __block 实现原理</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/51d04b7639f1\" target=\"_blank\" rel=\"noopener\">Block技巧与底层解析</a></p>\n<p>3.<a href=\"https://halfrost.com/ios_block_retain_circle/\" target=\"_blank\" rel=\"noopener\">深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/581151493340\" target=\"_blank\" rel=\"noopener\">浅析iOS中Block的用法</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/e03292674e60\" target=\"_blank\" rel=\"noopener\">深入浅出Block</a></p>\n<p>6.<a href=\"http://www.samirchen.com/block-in-objc/\" target=\"_blank\" rel=\"noopener\">Block总结</a></p>\n","categories":["基础知识"],"tags":["基础知识","Block"]},{"title":"自己动手制作Xcode插件","url":"http://hchong.net/2017/06/25/自己动手制作Xcode插件/","content":"<h1 id=\"自己动手制作Xcode插件\"><a href=\"#自己动手制作Xcode插件\" class=\"headerlink\" title=\"自己动手制作Xcode插件\"></a>自己动手制作Xcode插件</h1><p>Xcode8以后, 以前的插件都不能用了. 网上虽然也有方法来解决这个问题, 但是稍显复杂, 这里我们采用曲线救国的方式, 使用Apple官方推荐的方式<em>Xcode Source Editor Extension</em>来自己制作插件. Extension的方式开发的插件, 可以独立上架AppStore, 并且是独立于Xcode工程独立运行的. 但是没有UI交互, 不能在后台运行并且只能在开发者调用的时候直接修改代码.</p>\n<p>在平常的开发过程中, 有些操作是经常遇到的. 下面我们以<em>根据属性自动生成Getter方法</em>和<em>根据选中内容导入头文件</em>两种经常碰到的场景来制作Xcode插件.</p>\n<h2 id=\"新建插件制作工程\"><a href=\"#新建插件制作工程\" class=\"headerlink\" title=\"新建插件制作工程\"></a>新建插件制作工程</h2><ol>\n<li><p>打开Xcode, <code>command + shift + N</code> 选择macOS -&gt; Cocoa Application, 点击Next新建一个工程. 此处我新建的工程名为<em>AutoImportPlugin</em>.</p>\n</li>\n<li><p>在Xcode工具栏中选择Editor -&gt; Add Target -&gt; MacOS -&gt; Xcode Source Editor Extension来新建一个Extension来编写插件的主要代码. 新建的Target名称不能与工程的名字一样. 接下来会有一个弹窗, 提示你是否<em>Activate xxx Scheme</em>, 选择<em>Activate</em>即可, 这一步骤会帮你创建一个和你新建Target对应的Scheme. 完成后你的页面应该是这个样子的.</p>\n</li>\n</ol>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fgyotdiqdbj312w0q03zl.jpg\" alt=\"主工程页面\"></p>\n<h2 id=\"工程环境和参数介绍\"><a href=\"#工程环境和参数介绍\" class=\"headerlink\" title=\"工程环境和参数介绍\"></a>工程环境和参数介绍</h2><p>这里我们会主要用到AutoImport文件夹下面的两个类<code>SourceEditorExtension</code> 和 <code>SourceEditorCommand</code>. </p>\n<p><code>SourceEditorExtension.m</code>中我们可以看到两个方法:</p>\n<ul>\n<li><code>-(void)extensionDidFinishLaunching{}</code>, 注释内容为<code>If your extension needs to do any work at launch, implement this optional method.</code>   指的是指刚刚加载好插件但还未点击插件按钮时，可以执行某些准备工作.</li>\n<li><code>- (NSArray &lt;NSDictionary &lt;XCSourceEditorCommandDefinitionKey, id&gt; *&gt; *)commandDefinitions{}</code>. 返回字典类型的数组, 可以为每个插件重写名字、标识符和自定义类名等信息，和<code>Info.plist</code>文件中对应的<code>XCSourceEditorCommandName</code>、<code>XCSourceEditorCommandIdentifier</code>和<code>XCSourceEditorCommandClassName</code>等信息一致.</li>\n</ul>\n<p><code>SourceEditorCommand.m</code>中只有一个方法:</p>\n<pre><code>- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler\n{\n    // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.\n\n    completionHandler(nil);\n}\n</code></pre><p>关于插件的核心逻辑代码, 就是在这个方法里面实现. <code>XCSourceEditorCommandInvocation</code>类包含了所有的信息.可以通过他的各种属性来拿到原工程中的各种数据, 主要用到的有:</p>\n<ul>\n<li><code>invocation.buffer.lines</code>是一个数组, 包含了使用插件的工程的页面的每一行代码, 艺术组的形式存在. </li>\n<li><code>invocation.buffer.selections</code>是一个数组, 数组的内容是<code>XCSourceTextRange</code>. <code>XCSourceTextRange</code>包含了两个结构体, 用于标记原工程中选中部分的代码的位置信息.<h2 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h2></li>\n</ul>\n<p>此处以自动导入头文件的插件为例. 主要思路是遍历类的所有行, 拿到选中的内容, 判断是否被import过, 没有的话, 在合适位置插入<code>#import</code>;</p>\n<pre><code>- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler\n{\n    XCSourceTextRange *range = [invocation.buffer.selections firstObject];\n\n    NSString *selectedLines = [invocation.buffer.lines objectAtIndex:range.start.line];\n    NSString *selection = [selectedLines substringWithRange:NSMakeRange(range.start.column, range.end.column - range.start.column)];\n\n    for (NSInteger i = 0; i &lt; invocation.buffer.lines.count - 1; i++) {\n        NSString *importString = [invocation.buffer.lines objectAtIndex:i];\n        if ([importString containsString:@&quot;@interface&quot;]) {\n            self.startLineNumber = i;\n            break;\n        }\n    }\n\n    BOOL isImported = NO;\n    for (NSInteger i = 0; i &lt;= self.startLineNumber ; i++) {\n        NSString *importString = [invocation.buffer.lines objectAtIndex:i];\n        if ([importString containsString:[NSString stringWithFormat:@&quot;%@.h&quot;, selection]]) {\n            isImported = YES;\n            break;\n        }\n    }\n    if (isImported == NO) {\n        [invocation.buffer.lines insertObject:[NSString stringWithFormat:@&quot;#import \\&quot;%@.h\\&quot;&quot;, selection] atIndex:self.startLineNumber - 1];\n    }\n    completionHandler(nil);\n}\n</code></pre><h2 id=\"插件使用\"><a href=\"#插件使用\" class=\"headerlink\" title=\"插件使用\"></a>插件使用</h2><h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>我们在插件工程中选中AutoImport的Scheme(新建的那个), <code>command + R</code>运行,这时会出现一个弹窗, 让你选择要运行的工程. 选中要运行的工程后, 正常打开. 在Editor的最下面可以看到我们运行的插件工程, 点击就可以运行插件了. 打断点和调试什么的和正常的Xcode项目一样.</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fgz0hh71w6j30ht0ccdgm.jpg\" alt=\"插件运行调试\"></p>\n<p>需要注意的是, 我们在插件工程中两个Target的Singing一定要保持一致, 并且不能为空. 否则在Xcode中看不到插件.</p>\n<h3 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h3><p>以上我们已经可以在自己电脑上调试和使用Xcode插件了, 那么怎么才能在其他电脑上也使用我们开发的插件呢?</p>\n<ol>\n<li><p>我们可以在插件工程中, 找到Products文件夹下生成的的.app文件</p>\n</li>\n<li><p>右键点击此文件 -&gt; “在Finder中显示” -&gt; 将这个.app文件拷贝到你或者小伙伴电脑上的”应用程序”里</p>\n</li>\n<li><p>在“应用程序”中双击.app文件运行。然后，打开“系统偏好设置” -&gt; “扩展” -&gt; “Xcode Source Editor” -&gt; 确认插件名字前已打钩 -&gt; 此时Xcode中菜单栏Editor下的插件虽然显示，但是为灰色，无法点按，所以要 -&gt; 重启Xcode -&gt; 大功告成！</p>\n</li>\n<li><p>添加快捷键: Xcode -&gt; “Preferences” -&gt; “Key Bindings” -&gt; 搜索插件名字 -&gt; 添加对应的快捷键.</p>\n</li>\n</ol>\n<hr>\n<p>下载地址: <a href=\"https://github.com/HChong3210/AutoGetterPlugin\" target=\"_blank\" rel=\"noopener\">AutoPlugin</a></p>\n<hr>\n<p>参考文章:<br>1.<a href=\"http://www.jianshu.com/p/9c9d0fcc62cc\" target=\"_blank\" rel=\"noopener\">详解一步步实现Xcode 8 插件——Source Editor Extensions</a></p>\n<p>2.<a href=\"http://www.code4app.com/blog-822721-394.html\" target=\"_blank\" rel=\"noopener\">使用 Xcode Source Editor Extension开发Xcode 8 插件</a></p>\n","categories":["插件"],"tags":["基础知识","Xcode"]},{"title":"车","url":"http://hchong.net/2017/06/20/车/","content":"<h1 id=\"十万左右落地\"><a href=\"#十万左右落地\" class=\"headerlink\" title=\"十万左右落地\"></a>十万左右落地</h1><p>数据来自汽车之家, 车主成交价是各地车主成交的真实价格, 和去4S店咨询的价格差不多</p>\n<table><br>   <tr><br>      <td>车系</td><br>      <td>车型</td><br>      <td>车型详情</td><br>      <td>车主成交价</td><br>   </tr><br>   <tr><br>      <td>别克-英朗</td><br>      <td>2017款 15N 自动精英型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28698/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28698/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28698#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28698#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>雪佛兰-科沃兹</td><br>      <td>2016款 1.5L 自动欣悦版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/27573/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/27573/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-27573#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-27573#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>现代-悦动</td><br>      <td>2017款 1.6L 自动悦值版GLS</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29502/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29502/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29502#pvareaid=103597\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29502#pvareaid=103597</a></td><br>   </tr><br>   <tr><br>      <td>东风-标致</td><br>      <td>2017款 1.6L 自动豪华版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29620/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29620/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29620#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29620#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>大众-朗逸</td><br>      <td>2017款 1.6L 自动风尚版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29362/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29362/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29362#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29362#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>大众-捷达</td><br>      <td>2017款 1.5L 自动舒适型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28451/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28451/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28451#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28451#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>东风雪铁龙-爱丽舍</td><br>      <td>2017款 1.6L 自动舒适型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29341/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29341/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/s-98#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/s-98#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪GS</td><br>      <td>2016款 运动版 1.3T 自动领尚型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/26402/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/26402/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-26402#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-26402#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪GL</td><br>      <td>2017款 1.3T 自动尊贵型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/26596/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/26596/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-26596#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-26596#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪</td><br>      <td>2017款 三厢百万款 1.5L CVT向上版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28104/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28104/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28104#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28104#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪</td><br>      <td>2017款 两厢RS百万款 1.5L CVT向上版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28133/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28133/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28133#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28133#pvareaid=103596</a></td><br>   </tr><br></table>\n\n\n","categories":[],"tags":["生活"]},{"title":"基于OpenCV的人脸识别","url":"http://hchong.net/2017/06/16/基于OpenCV的人脸识别/","content":"","categories":[],"tags":[]},{"title":"Python爬虫入门","url":"http://hchong.net/2017/06/14/Python爬虫入门/","content":"<h1 id=\"HCModule\"><a href=\"#HCModule\" class=\"headerlink\" title=\"HCModule\"></a>HCModule</h1><p><a href=\"https://travis-ci.org/HChong3210/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.shields.io/travis/HChong3210/HCModule.svg?style=flat\" alt=\"CI Status\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/v/HCModule.svg?style=flat\" alt=\"Version\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/l/HCModule.svg?style=flat\" alt=\"License\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/p/HCModule.svg?style=flat\" alt=\"Platform\"></a></p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>To run the example project, clone the repo, and run <code>pod install</code> from the Example directory first.</p>\n<h2 id=\"Requirements\"><a href=\"#Requirements\" class=\"headerlink\" title=\"Requirements\"></a>Requirements</h2><h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>HCModule is available through <a href=\"http://cocoapods.org\" target=\"_blank\" rel=\"noopener\">CocoaPods</a>. To install<br>it, simply add the following line to your Podfile:</p>\n<pre><code class=\"ruby\">pod &#39;HCModule&#39;\n</code></pre>\n<h2 id=\"Author\"><a href=\"#Author\" class=\"headerlink\" title=\"Author\"></a>Author</h2><p>HChong3210, <a href=\"mailto:hchong7557@gmail.com\" target=\"_blank\" rel=\"noopener\">hchong7557@gmail.com</a></p>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p>HCModule is available under the MIT license. See the LICENSE file for more info.</p>\n","categories":["Python"],"tags":["爬虫","Python"]},{"title":"Cocoapods实践","url":"http://hchong.net/2017/05/24/Cocoapods实践/","content":"<p>Cocoapods是一个基于Ruby的包管理工具, 类似的还有Carthage. Cocoapods的安装在这里不在详述, 请自行百度, 在这里着重讲一下如何使用Cocoapods制作私有包, 以及Cocoapods的实现原理. </p>\n<h1 id=\"1-Cocoapods的实现原理\"><a href=\"#1-Cocoapods的实现原理\" class=\"headerlink\" title=\"1 Cocoapods的实现原理\"></a>1 Cocoapods的实现原理</h1><p>cocoapods安装成功后, 我们怎么来使用它呢. 这里就要用到cocoapods的核心文件之一<code>Podfile</code>. Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度自定义，你可以根据个人喜好对其做出定制。<a href=\"https://guides.cocoapods.org/syntax/Podfile.html\" target=\"_blank\" rel=\"noopener\">查看更多官方介绍</a>. </p>\n<h2 id=\"1-1-Podfile\"><a href=\"#1-1-Podfile\" class=\"headerlink\" title=\"1.1 Podfile\"></a>1.1 Podfile</h2><p>下面是一个🌰, 我们来挨个分析下他们背后都代表着什么.</p>\n<pre><code class=\"Ruby\">source &#39;http://source.git&#39;\nplatform :ios, &#39;8.0&#39;\n\ntarget &#39;Demo&#39; do\n    pod &#39;AFNetworking&#39;\n    pod &#39;SDWebImage&#39;\n    pod &#39;Masonry&#39;\nend\n</code></pre>\n<p><code>source</code>: Specifies the location of specs. spec的地址.</p>\n<p><code>platform</code>: Specifies the platform for which a static library should be built. 指定构建静态库的平台.</p>\n<p><code>target</code>: Defines a CocoaPods target and scopes dependencies defined within the given block. A target should correspond to an Xcode target. By default the target includes the dependencies defined outside of the block, unless instructed not to inherit them. 定义了CocoaPods在指定target的依赖, 此处的Target应该与Xcode目标相对应。默认情况下，除非表明不继承它们, 否则Target包括在块外部定义的依赖项.</p>\n<p><code>pod</code>: A dependency requirement is defined by the name of the Pod and optionally a list of version requirements. 一个依赖项需求是由Pod的名称和可选的版本需求列表所定义的.</p>\n<p>当你写完<code>Podfile</code>之后, 就需要执行Pod的命令<code>pod install</code>, 来按照<code>Podfile</code>中的配置来配置我么你的工程</p>\n<h2 id=\"1-2-pod-install\"><a href=\"#1-2-pod-install\" class=\"headerlink\" title=\"1.2 pod install\"></a>1.2 pod install</h2><p>当运行 <code>pod install</code> 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 <code>--verbose</code>来查看详细内容。现在运行这个命令 <code>pod install --verbose</code>，可以看到类似如下的内容:</p>\n<pre><code>  Preparing\n\nAnalyzing dependencies\n\nInspecting targets to integrate\n  Using `ARCHS` setting to build architectures of target `Pods-XXX`: (``)\n\nResolving dependencies of `Podfile`\n\nComparing resolved specification to the sandbox manifest\n  A AFNetworking\n  A Masonry\n  A SDWebImage\n\nDownloading dependencies\n\n-&gt; Installing AFNetworking (3.1.0)\n &gt; Git download\n &gt; Git download\n     $ /usr/bin/git clone https://github.com/AFNetworking/AFNetworking.git\n     /var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8\n     --template= --single-branch --depth 1 --branch 3.1.0\n     Cloning into &#39;/var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8&#39;...\n     Note: checking out &#39;88f13053b1d1f20bf657f5c36459b87a5d317ad7&#39;.\n\n     You are in &#39;detached HEAD&#39; state. You can look around, make experimental\n     changes and commit them, and you can discard any commits you make in this\n     state without impacting any branches by performing another checkout.\n\n     If you want to create a new branch to retain commits you create, you may\n     do so (now or later) by using -b with the checkout command again. Example:\n\n       git checkout -b &lt;new-branch-name&gt;\n\n     $ /usr/bin/git -C\n     /var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8\n     submodule update --init --recursive\n  &gt; Copying AFNetworking from\n  `/Users/hc/Library/Caches/CocoaPods/Pods/Release/AFNetworking/3.1.0-5e0e1` to\n  `Pods/AFNetworking`\n\n-&gt; Installing Masonry (1.0.2)\n  &gt; Copying Masonry from\n  `/Users/hc/Library/Caches/CocoaPods/Pods/Release/Masonry/1.0.2-7c429` to\n  `Pods/Masonry`\n\n-&gt; Installing SDWebImage (4.1.0)\n  &gt; Copying SDWebImage from\n  `/Users/hc/Library/Caches/CocoaPods/Pods/Release/SDWebImage/4.1.0-0e435` to\n  `Pods/SDWebImage`\n  - Running pre install hooks\n\nGenerating Pods project\n  - Creating Pods project\n  - Adding source files to Pods project\n  - Adding frameworks to Pods project\n  - Adding libraries to Pods project\n  - Adding resources to Pods project\n  - Linking headers\n  - Installing targets\n    - Installing target `AFNetworking` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/AFNetworking/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/AFNetworking/AFNetworking.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/AFNetworking/AFNetworking-umbrella.h`\n    - Installing target `Masonry` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/Masonry/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/Masonry/Masonry.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/Masonry/Masonry-umbrella.h`\n    - Installing target `SDWebImage` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/SDWebImage/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/SDWebImage/SDWebImage.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/SDWebImage/SDWebImage-umbrella.h`\n    - Installing target `Pods-CarMall` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/Pods-CarMall/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/Pods-CarMall/Pods-CarMall.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/Pods-CarMall/Pods-CarMall-umbrella.h`\n  - Running post install hooks\n  - Writing Xcode project file to `Pods/Pods.xcodeproj`\n    - Generating deterministic UUIDs\n  - Writing Lockfile in `Podfile.lock`\n  - Writing Manifest in `Pods/Manifest.lock`\n\nIntegrating client project\n\n[!] Please close any current Xcode sessions and use `CarMall.xcworkspace` for this project from now on.\n\nIntegrating target `Pods-CarMall` (`CarMall.xcodeproj` project)\n  - Running post install hooks\n    - cocoapods-stats from\n    `/Users/hc/.rvm/gems/ruby-2.4.1/gems/cocoapods-stats-1.0.0/lib/cocoapods_plugin.rb`\n\nSending stats\n      - AFNetworking, 3.1.0\n      - Masonry, 1.0.2\n      - SDWebImage, 4.1.0\n\n-&gt; Pod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed.\n</code></pre><p>先看我们工程的变化, 可以发现工程里面多了三个文件, 一个<code>XXX.xcworkspace</code>文件, 一个<code>Podfile.lock</code>文件, 还有一个<code>Pods</code>文件夹. 我们在通过终端输出的命令来分析, 为什么会生成这几个文件, 以及他们的作用.</p>\n<ol>\n<li>Analyzing dependencies. 弄清楚声明了哪些第三方库.在加载 <code>podspecs</code> 过程中，<code>CocoaPods</code> 就建立了包括版本信息在内的所有的第三方库的列表。<code>Podspecs</code> 被存储在本地路径 <code>~/.cocoapods</code> 中.</li>\n<li>Inspecting targets to integrate. 检查目标集成.</li>\n<li>Resolving dependencies of <code>Podfile</code> 和 Comparing resolved specification to the sandbox manifest. 分析<code>Podfile</code>文件的依赖和将已经解析的Pod与缓存过的Pod进行比对, 是添加还是删除, 还是更新.</li>\n<li>Downloading dependencies. 根据第三部的分析结果来下载依赖到<code>Pods</code>文件夹下面.</li>\n<li>Generating Pods project. 生成Pods的工程. 这一步还包含了许多其他的步骤.<ul>\n<li>Creating Pods project</li>\n<li>Adding source files to Pods project</li>\n<li>Adding frameworks to Pods project</li>\n<li>Adding libraries to Pods project</li>\n<li>Adding resources to Pods project</li>\n<li>Linking headers</li>\n<li>Installing targets</li>\n<li>Running post install hooks</li>\n<li>Writing Xcode project file to <code>Pods/Pods.xcodeproj</code> 如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 Pods.xcodeproj 进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中.</li>\n<li>Writing Lockfile in <code>Podfile.lock</code>. 记录各个Pod的版本号和之家你的依赖关系.</li>\n<li>Writing Manifest in <code>Pods/Manifest.lock</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-3-pod-install-vs-pod-update\"><a href=\"#1-3-pod-install-vs-pod-update\" class=\"headerlink\" title=\"1.3 pod install vs pod update\"></a>1.3 pod install vs pod update</h2><p>引用官方的文档<a href=\"https://guides.cocoapods.org/using/pod-install-vs-update.html\" target=\"_blank\" rel=\"noopener\">https://guides.cocoapods.org/using/pod-install-vs-update.html</a>来说明一下二者的区别, 以及使用场景.</p>\n<p>You will only use pod update when you want to update the version of a specific pod (or all the pods).</p>\n<ul>\n<li><code>pod install</code>主要用在第一次安装pods时, 如果后面你新增, 修改, 删除你的<code>Podfile</code>文件时也可以使用该命令. 每次执行<code>pod install</code>命令会把每一个安装的pod的版本写进<code>Podfile.lock</code>文件中, 来记录和lock这些已经安装Pod的版本. 当执行<code>Pod install</code>. 如果是新增Pod, 那么会搜索与Podfile中描述的匹配的版本; 如果已经存在, 他会下载<code>Podfile.lock</code>文件中明确的版本, 但不会去检查有没有可用的最新版本.</li>\n<li><code>pod update</code>会不关注<code>Podfile.lock</code>中的版本而直接更新到符合<code>Podfile</code>中定义的最新版本.</li>\n</ul>\n<h1 id=\"2-使用CocoaPods创建私有Pod\"><a href=\"#2-使用CocoaPods创建私有Pod\" class=\"headerlink\" title=\"2 使用CocoaPods创建私有Pod\"></a>2 使用CocoaPods创建私有Pod</h1><p>上面我们已经介绍过如何使用CocoaPods了, 下面要讲解的就是如何创建Pod来供别人使用. 在创建私有Pod之前我们需要两个git地址:</p>\n<ul>\n<li>用来保存Spec Repo的内容的Git地址</li>\n<li>用来保存具体Pod内容的Git地址</li>\n</ul>\n<h2 id=\"2-1-创建一个Spec-Repo\"><a href=\"#2-1-创建一个Spec-Repo\" class=\"headerlink\" title=\"2.1 创建一个Spec Repo\"></a>2.1 创建一个Spec Repo</h2><p>在这一步, 我们主要创建第一个Git地址, 并且关联到本地.</p>\n<p><code>Spec Repo</code>是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端. 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的:</p>\n<pre><code>.\n├── Specs\n    └── [SPEC_NAME]\n        └── [VERSION]\n            └── [SPEC_NAME].podspec\n</code></pre><p>如果你要创建私有Pod, 那么你的<code>Spec Repo</code>的远端地址就必须是私有的. 反之如果你要创建一个公有的Pod, 那么就可以使用GitHub来托管你的代码. 当你创建好远端的仓库之后, 执行<code>pod repo add [Spec Repo的仓库名] [Spec Repo的git地址]</code>来把远端的仓库clone到本地. 注意, 这里<code>[Spec Repo的仓库名]</code>不一定是远端Git仓库的名字, 而是clone到本地后, 本地文件加的名字, 但是这个名字会在后面提交<code>PodSpec</code>文件时用到.</p>\n<h2 id=\"2-2-创建Pod工程文件\"><a href=\"#2-2-创建Pod工程文件\" class=\"headerlink\" title=\"2.2 创建Pod工程文件\"></a>2.2 创建Pod工程文件</h2><p>我们在你需要创建Pod的目录下使用<code>pod lib create [Pod名称]</code>来创建对应的Pod模板.  实际上该命令行隐藏了默认参数, 参数补全后应该是<code>pod lib create ProjectName --template-url=https://github.com/CocoaPods/pod-template.git</code>. </p>\n<p>接下来会问你四个问题:</p>\n<ol>\n<li>What language do you want to use?? [ Swift / ObjC ]. 使用什么语言</li>\n<li>Would you like to include a demo application with your library?. 是否需要一个例子工程, 一般选择YES</li>\n<li>Which testing frameworks will you use? [ Specta / Kiwi / None ]. 选择一个测试框架</li>\n<li>Would you like to do view based testing? [ Yes / No ]. 是否基于View测试</li>\n<li>What is your class prefix?. 类的前缀</li>\n</ol>\n<p>根据自己的实际需要来选择后, 就会自动执行<code>Pod install</code>命令来创建项目并且生成依赖. 这是这个Pod的没目录结构应该是这样的:</p>\n<pre><code>  MyLib\n  ├── .travis.yml\n  ├── _Pods.xcproject\n  ├── Example\n  │   ├── MyLib\n  │   ├── MyLib.xcodeproj\n  │   ├── MyLib.xcworkspace\n  │   ├── Podfile\n  │   ├── Podfile.lock\n  │   ├── Pods\n  │   └── Tests\n  ├── LICENSE\n  ├── MyLib.podspec\n  ├── Pod\n  │   ├── Assets\n  │   └── Classes\n  │     └── RemoveMe.[swift/m]\n  └── README.md\n</code></pre><p>接下来, 我们需要创建第二个Git地址, 用来保存Pod的实现代码. 我们进入到Pod文件夹的根目录下, 使用如下代码来关联Pod到远端仓库:</p>\n<pre><code>$ git add .\n$ git commit -s -m &quot;Initial Commit of Library&quot;\n$ git remote add origin [Pod的远端地址]           #添加远端仓库\n$ git push origin master     #提交到远端仓库\n</code></pre><h2 id=\"2-3-编辑Pod文件\"><a href=\"#2-3-编辑Pod文件\" class=\"headerlink\" title=\"2.3 编辑Pod文件\"></a>2.3 编辑Pod文件</h2><p>Pod文件就是这个Pod要实现功能的具体逻辑, 在主工程根目录下面有一个和Pod同名的文件夹, 里面有两个子文件夹. 一个是<code>Assets</code>, 一个是<code>Classes</code>.</p>\n<ul>\n<li>Assets文件主要用来存放资源文件, 例如图片资源和XIB文件.</li>\n<li>Classes则存放主要的功能代码, 类.</li>\n</ul>\n<p>在这里需要注意两个地方:</p>\n<ol>\n<li>当我们要使用<code>Pod</code>中的资源时, 以图片为例, 我们通过<code>[UIImage imageWithName:@&quot;xxx.png&quot;]</code>是取不到Pod中的图片的, 因为<code>imageWithName:</code>方法默认是从<code>mainBundle</code>中来取的, 而Pod不属于<code>mainBundle</code>的范畴, 我们需要先根据<code>class</code>来拿到当前类所在的<code>bundle</code>, 再取该<code>Bundle</code>中的资源.</li>\n<li>每次在Pod文件夹中添加新的文件或者资源时, 都需要在根目录的Example目录下执行<code>pod update</code>命令来重新建立索引.</li>\n</ol>\n<h2 id=\"2-4-编辑Podspec文件\"><a href=\"#2-4-编辑Podspec文件\" class=\"headerlink\" title=\"2.4 编辑Podspec文件\"></a>2.4 编辑Podspec文件</h2><p>关于<code>Podspec</code>文件<a href=\"http://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"noopener\">官方</a>是这样描述的:</p>\n<blockquote>\n<p>A specification describes a version of Pod library. It includes details about where the source should be fetched from, what files to use, the build settings to apply, and other general metadata such as its name, version, and description.</p>\n</blockquote>\n<p><code>pod lib create XXX</code>创建出来的Pod, 初始时的<code>Podspec</code>文件包含了各种信息, 详细的说明我们可以看<a href=\"http://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>, 这里贴上最基础的用法代码:</p>\n<pre><code>Pod::Spec.new do |s|\n  s.name             = &#39;HCPods&#39;\n  #Pod的版本\n  s.version          = &#39;0.1.0&#39;\n  s.summary          = &#39;你在搜索时会呈现&#39;\n\n  s.description      = &lt;&lt;-DESC\n    这里是关于你Pod功能的描述\n                       DESC\n\n  s.homepage         = &#39;https://github.com/HChong3210/HCPods&#39;\n  s.license          = { :type =&gt; &#39;MIT&#39;, :file =&gt; &#39;LICENSE&#39; }\n  s.author           = { &#39;HChong3210&#39; =&gt; &#39;hchong7557@gmail.com&#39; }\n  #Pod的远端仓库地址\n  s.source           = { :git =&gt; &#39;https://github.com/HChong3210/HCPods.git&#39;, :tag =&gt; s.version.to_s }\n\n    #Pod支持的最低版本\n  s.ios.deployment_target = &#39;8.0&#39;\n    #Pod源文件的位置\n  s.source_files = &#39;HCPods/Classes/**/*&#39;\n  #Pod中资源文件的位置\n  s.resource_bundles = {\n    &#39;DFCForms&#39; =&gt; [&#39;HCPods/Assets/*.{png,xib,plist}&#39;]\n  }\n  #对外公开的类\n  s.public_header_files = &#39;DFCForms/Classes/**/*.h&#39;\n\n  #Pod中用到的第三方库\n  s.frameworks = &#39;UIKit&#39;\n  s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39;\n  s.dependency &#39;SDWebImage&#39;\n\nend\n</code></pre><h2 id=\"2-5-提交Pod文件\"><a href=\"#2-5-提交Pod文件\" class=\"headerlink\" title=\"2.5 提交Pod文件\"></a>2.5 提交Pod文件</h2><p>Pod文件编辑好后, 我们要把代码提交到远端服务器, 我们就使用正常的方式来提交代码, 并且给代码打上Tag, <em> 注意, 这里的Tag必须和<code>Podspec</code>文件中的Pod版本号一致 </em>, 因为Podspec会根据Tag从远端来找相应的代码, 否则会出现版本和代码不匹配的现象.</p>\n<p>如果不使用Sourcetree这样的GUI工具, 可以参考下面的Git代码:</p>\n<pre><code># 在根目录下\ngit status\ngit add .\ngit tag -m &#39;备注&#39; 版本号\ngit commit -s -m &#39;备注&#39; \ngit push origin master —tags\n</code></pre><h2 id=\"2-6-提交Podspec文件\"><a href=\"#2-6-提交Podspec文件\" class=\"headerlink\" title=\"2.6 提交Podspec文件\"></a>2.6 提交Podspec文件</h2><p>提交完Pod文件后, 我们只用把<code>Podspec</code>文件也提交上去, 这样就可以在Cocoapods中简历起来索引, 找到自己的Pod了. </p>\n<p>在提交之前我们可以在根目录下使用<code>pod lib lint</code>命令来验证是否编译通过. 也可以直接提交<code>pod repo push [你clone到本地的Spec Repo的仓库名] [Pod名称].podspec      --use-libraries --allow-warnings --sources=&#39;[Podspec远端地址],https://github.com/CocoaPods/Specs&#39; --verbose</code></p>\n<h2 id=\"2-7-subspec的使用\"><a href=\"#2-7-subspec的使用\" class=\"headerlink\" title=\"2.7 subspec的使用\"></a>2.7 subspec的使用</h2><p>有时一个Pod太大了, 而我们又用不到全部的内容, 这时我们就可以使用subspec来解决这个问题. 我们可以在Pod文件夹中, 使用文件夹来分割各个子Pod, 然后在<code>Podspec</code>文件中这样设置:</p>\n<pre><code>  s.subspec &#39;[子Pod名称]&#39; do |pod1|\n      pod1.source_files = &#39;SCCQRCode/Classes/[子文件夹名]/**/*&#39;\n  end\n\n  s.subspec &#39;[子Pod名称]&#39; do |pod2|\n            pod2.source_files = &#39;SCCQRCode/Classes/[子文件夹名]/**/*&#39;\n  end\n</code></pre><p>我们也可以在各个子Pod中分别设置他们的资源路径, 对外暴露的header路径, 以及dependency.</p>\n<p>我们在外面引用该Pod的时候就可以使用<code>pod [Pod/子Pod]</code>的方式来只引用一个子Pod. </p>\n<h1 id=\"3-cocoapods的相关知识\"><a href=\"#3-cocoapods的相关知识\" class=\"headerlink\" title=\"3 cocoapods的相关知识\"></a>3 cocoapods的相关知识</h1><p>这里是CocoaPods的其他相关知识, 做一个备忘.</p>\n<h2 id=\"3-1-Pod的版本说明\"><a href=\"#3-1-Pod的版本说明\" class=\"headerlink\" title=\"3.1 Pod的版本说明\"></a>3.1 Pod的版本说明</h2><p>CocoaPods 使用<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener\">语义版本控制 - Semantic Versioning</a>命名约定来解决对版本的依赖. 常见的版本说明符号有以下这些.</p>\n<ul>\n<li>= 0.1 Version 0.1.</li>\n<li>0.1 Any version higher than 0.1.</li>\n<li><blockquote>\n<p>= 0.1 Version 0.1 and any higher version.</p>\n</blockquote>\n</li>\n<li>&lt; 0.1 Any version lower than 0.1.</li>\n<li>&lt;= 0.1 Version 0.1 and any lower version.</li>\n<li>~&gt; 0.1.2 Version 0.1.2 and the versions up to 0.2, not including 0.2. </li>\n</ul>\n<h2 id=\"3-2-常见Pod依赖的几种写法\"><a href=\"#3-2-常见Pod依赖的几种写法\" class=\"headerlink\" title=\"3.2 常见Pod依赖的几种写法\"></a>3.2 常见Pod依赖的几种写法</h2><ul>\n<li>pod ‘AFNetworking’, :configurations =&gt; [‘Debug’, ‘Beta’]</li>\n<li>pod ‘QueryKit/Attribute’</li>\n<li>pod ‘QueryKit’, :subspecs =&gt; [‘Attribute’, ‘QuerySet’]</li>\n<li>pod ‘AFNetworking’, :path =&gt; ‘~/Documents/AFNetworking’</li>\n<li>pod ‘AFNetworking’, :git =&gt; ‘<a href=\"https://github.com/gowalla/AFNetworking.git&#39;\" target=\"_blank\" rel=\"noopener\">https://github.com/gowalla/AFNetworking.git&#39;</a></li>\n<li>pod ‘JSONKit’, :podspec =&gt; ‘<a href=\"https://example.com/JSONKit.podspec&#39;\" target=\"_blank\" rel=\"noopener\">https://example.com/JSONKit.podspec&#39;</a></li>\n</ul>\n<hr>\n<p>参考文章:<br>1.<a href=\"https://swiftcafe.io/2015/10/25/swift-daily-carthage-package/\" target=\"_blank\" rel=\"noopener\">Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验</a>.</p>\n<p>2.<a href=\"https://bestswifter.com/cocoapods/\" target=\"_blank\" rel=\"noopener\">细聊Cocoapods与Xcode工程配置</a>.</p>\n<p>3.<a href=\"http://guides.cocoapods.org/making/using-pod-lib-create.html\" target=\"_blank\" rel=\"noopener\">Cocoapods官方文档</a>.</p>\n<p>4.<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"noopener\">使用Cocoapods创建私有podspec</a></p>\n<p>5.<a href=\"http://draveness.me/cocoapods.html\" target=\"_blank\" rel=\"noopener\">CocoaPods 都做了什么？</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/d6a592d6fced\" target=\"_blank\" rel=\"noopener\">使用私有Cocoapods仓库中引用.a库</a></p>\n<p>7.<a href=\"https://objccn.io/issue-6-4/\" target=\"_blank\" rel=\"noopener\">深入理解CocoaPods</a></p>\n<p>8.<a href=\"https://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"noopener\">podspec官方文档</a></p>\n<p>9.<a href=\"https://guides.cocoapods.org/syntax/Podfile.html\" target=\"_blank\" rel=\"noopener\">Podfile官方文档</a></p>\n","categories":["模块化"],"tags":["基础知识","模块化"]},{"title":"iOS的组件化实践","url":"http://hchong.net/2017/05/23/iOS的模块化实践/","content":"<h1 id=\"iOS的组件化实践\"><a href=\"#iOS的组件化实践\" class=\"headerlink\" title=\"iOS的组件化实践\"></a>iOS的组件化实践</h1><p>随着工程的变大, 业务的复杂, 开发人员的增多, 如何提高成员间的开发效率和最大程度的复用代码, 成为了亟待解决的问题. 除了更加清晰的结构目录外, 模块化, 应该是一种比较优雅解决方案. 关于组件化我们要达成的一个目标就是<em>重用高度抽象化的代码单元</em>.</p>\n<p>参考文章系列基本上可以代表业界目前对组件化的一些思考, 建议按照顺序阅读. 下面是我结合我司项目中的一些实际应用, 谈一下我对组件化的理解.</p>\n<p>我司的组件化之路, 大致可以分为几个阶段, 下面我就项目的变化历程来分析我司的组件化之路.</p>\n<h2 id=\"大杂烩\"><a href=\"#大杂烩\" class=\"headerlink\" title=\"大杂烩\"></a>大杂烩</h2><p>最开始, 我们的项目所有代码都在工程里面, 每个具体的业务使用独立的文件夹进行分割, 看似十分整洁, 但是也有很多不便之处. 各个模块之间耦合性很强, 责任人不明确. 这个时候可以说完全没有组件化的概念, 十分混乱. </p>\n<p>组件化的引入, 源于和另外一个项目的代码复用. 当时在做一个营销相关的业务, 由于效果十分好, 所以决定在另外一个项目中也接入这块业务. 然而, 并没有想象的那么简单. 由于跨项目, 后台完全不同, 牵涉到网络库调用, 公共组件的使用, 要想把这个业务单独拆分出去, 就必须把这个业务用到的网络库, 公共组件库也拆分出去, 难度非常之大. 这时候, 就想到了使用Cocoapods来管理一些工具类和公共组件, 于是就有了第二阶段.</p>\n<h2 id=\"非业务代码组件化\"><a href=\"#非业务代码组件化\" class=\"headerlink\" title=\"非业务代码组件化\"></a>非业务代码组件化</h2><p>在这一阶段, 我们充分使用Cocoapods的模块化功能, 将一些通用的类, 工具类, 封装成私有的Pod(<a href=\"http://hchong.net/2017/05/24/Cocoapods%E5%AE%9E%E8%B7%B5/\">参考这里</a>). 这样一来, 就把基础代码从项目中抽离出来, 其他的项目要想使用, 只需依赖我们的私有Pod就可以了. 那么上面想要拆分公共业务组件的想法就可以实现了.</p>\n<p>然而, 随着业务的打通. 不同的项目之间需要调用的共同组件越来越多, 组件与组件之间如何进行交互, 组件与项目之间又如何进行交互, 这些问题又出来了. 于是, 又有了现在的完全组件化方案.</p>\n<h2 id=\"完全组件化\"><a href=\"#完全组件化\" class=\"headerlink\" title=\"完全组件化\"></a>完全组件化</h2><p>称之为完全组件化方案, 是因为我司目前采用的就是这样的解决方案, 并且暂时也找不到更加好的解决方案. 完全组件化方案, 实际还是在<em>非业务代码组件化</em>的基础上, 通过引入<a href=\"http://hchong.net/2017/05/23/iOS%E7%9A%84%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AE%9E%E8%B7%B5/\">路由协议</a>来实现的.</p>\n<p>通过路由协议, 相当于我们通过一个中间层来转发我们组件与组件之间的通信, 这样就实现了组件之间的解耦, 而组件内部又是完整的业务逻辑, 属于高内聚, 低耦合.</p>\n<p>至此, 就完成了我们的组件化之路, 解除组件之间相互引用的代码硬依赖, 规范了组件之间的通信接口, 各个组件本身就相当于一个黑盒, 可以独立开发.</p>\n<h2 id=\"其他组件化方案\"><a href=\"#其他组件化方案\" class=\"headerlink\" title=\"其他组件化方案\"></a>其他组件化方案</h2><p>可以将需要封装的代码打包成静态库, 静态库中把需要暴露出来的头文件选择性的暴露出来, 不过这样各个模块之间的耦合性还是比较高的.</p>\n<hr>\n<p>参考文章:<br>1.<a href=\"http://limboy.me/tech/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"noopener\">蘑菇街App的组件化之路</a>.</p>\n<p>2.<a href=\"https://casatwy.com/iOS-Modulization.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈 组件化方案</a>.</p>\n<p>3.<a href=\"http://limboy.me/tech/2016/03/14/mgj-components-continued.html\" target=\"_blank\" rel=\"noopener\">蘑菇街App的组件化之路.续</a>.</p>\n<p>4.<a href=\"http://blog.cnbang.net/tech/3080/\" target=\"_blank\" rel=\"noopener\">iOS组件化方案探讨</a>.</p>\n","categories":["模块化"],"tags":["模块化","cocoapods"]},{"title":"iOS的路由协议实践","url":"http://hchong.net/2017/05/23/iOS的路由协议实践/","content":"<h1 id=\"iOS的路由协议实践\"><a href=\"#iOS的路由协议实践\" class=\"headerlink\" title=\"iOS的路由协议实践\"></a>iOS的路由协议实践</h1><p>路由协议, 是组件化的核心所在. 组件化, 实际就会把代码拆分为一个一个的模块, 无论采用Pod的方式,  文件夹分割的方式, 还是静态库的方式, 实质都是把代码分为一个个的模块. 如何在模块之间和应用之间通信, 就是路由协议需要考虑的问题.</p>\n<p>关于路由协议, 冰霜的<a href=\"https://halfrost.com/ios_router/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>写的实在是太详细了, 看得是男默女泪, 简直是业界良心. 简单说来, 路由协议跳转主要解决这几类问题:</p>\n<ol>\n<li>外部跳转到App内部一个很深层次的一个界面.</li>\n<li>App之间的相互跳转.</li>\n<li>解除App组件之间和App页面之间的耦合性.</li>\n<li>统一iOS和Android两端的页面跳转逻辑, 统一三端的请求资源的方式.</li>\n<li>iOS和Android两边只要共用一套动态下发配置文件来配置App的跳转逻辑.</li>\n<li>在App任何界面都可以调用任意一个界面或者任意一个组件.</li>\n</ol>\n<h2 id=\"应用间路由跳转\"><a href=\"#应用间路由跳转\" class=\"headerlink\" title=\"应用间路由跳转\"></a>应用间路由跳转</h2><p>应用间路由跳转主要有以下几种常见的使用场景: </p>\n<ol>\n<li>使用第三方用户登录，跳转到需授权的App或跳转到分享app的对应页面.</li>\n<li>应用程序推广, 跳转到另一个应用程序(本机已经安装).</li>\n<li>跳转到iTunes并显示应用程序下载页面(本机没有安装).</li>\n<li>第三方支付, 跳转到第三方支付App, 如支付宝支付, 微信支付.</li>\n<li>使用系统内置程序, 如跳转到打电话, 发短信, 发邮件, Safari等.</li>\n</ol>\n<p>应用间的跳转主要有两种方式: URL Scheme和Universal Links. 这两种实现方式并不冲突, 可以共存.</p>\n<h3 id=\"URL-Scheme方式跳转\"><a href=\"#URL-Scheme方式跳转\" class=\"headerlink\" title=\"URL Scheme方式跳转\"></a>URL Scheme方式跳转</h3><p>以A-&gt;B为例, 来说明下如何跳转.<br>首先我们需要分别在两个App的info.plist里面添加对应的URL types - URL Schemes, 如图所示:</p>\n<p><img src=\"http://img.souche.com/f2e/2b762dfb368b3b50621cd5c39b51a86e.png\" alt=\"添加URL types\"></p>\n<p>A的URL Schemes是APPA, B的URL Schemes是APPB. 由于iOS9引入了白名单的概念,<br>如果使用 canOpenURL:方法, 该方法所涉及到的 URL Schemes 必须在”Info.plist”中将它们列为白名单, 否则<code>canOpenURL</code>返回<code>NO</code>, 不能正常跳转. 所以要在A中添加B的URL Schemes, B中添加A的Schemes. key叫做<code>LSApplicationQueriesSchemes</code>, 键值内容是上一步对应应用程序的URL Schemes. </p>\n<pre><code>\n- jumpToAppB:(id)sender {\n   // 1.获取应用程序App-B的URL Scheme\n   NSURL *appBUrl = [NSURL URLWithString:@&quot;zacharyB1://&quot;];\n   // 2.判断手机中是否安装了对应程序\n   if ([[UIApplication sharedApplication] canOpenURL:appBUrl]) {\n       // 3. 打开应用程序App-B\n       //[[UIApplication sharedApplication] openURL:appBUrl];//iOS 9之后被废弃\n       [[UIApplication sharedApplication] openURL:appBUrl options:@{UIApplicationOpenURLOptionUniversalLinksOnly : @YES} completionHandler:^(BOOL success) {\n\n        }];\n   } else {\n       NSLog(@&quot;没有安装&quot;);\n   }\n}\n</code></pre><p>options目前可传入参数Key在UIApplication头文件只有一个:UIApplicationOpenURLOptionUniversalLinksOnly, 其对应的Value为布尔值, 默认为False. 如该Key对应的Value为True, 那么打开所传入的Universal Link时, 只允许通过这个Link所代表的iOS应用跳转的方式打开这个链接, 否则就会返回success为false, 也就是说只有安装了Link所对应的App的情况下才能打开这个Universal Link, 而不是通过启动Safari方式打开这个Link的代表的网站. </p>\n<p>至此, 就可以正常跳转了, 如果我们不希望某个APP通过URL Scheme的方式打开我们的应用, 我们可以在<code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code>方法中判断指定的Scheme然后返回<code>NO</code>, 如下所示, 只有<code>com.tencent.weixin</code>的Scheme才能打开我们的APP. </p>\n<pre><code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {\n    NSLog(@&quot;sourceApplication: %@&quot;, sourceApplication);\n    NSLog(@&quot;URL scheme:%@&quot;, [url scheme]);\n    NSLog(@&quot;URL query: %@&quot;, [url query]);\n\n    if ([sourceApplication isEqualToString:@&quot;com.tencent.weixin&quot;]){\n        // 允许打开\n        return YES;\n    }else{\n        return NO;\n    }\n}\n\n</code></pre><h3 id=\"Universal-Links方式跳转\"><a href=\"#Universal-Links方式跳转\" class=\"headerlink\" title=\"Universal Links方式跳转\"></a>Universal Links方式跳转</h3><p>使用这个功能可以使我们的App通过HTTP链接来启动App, 通用链接就是HTTP协议的普通URL, 通过在服务器上配置一些文件, 配合应用. 实现客户点击网页链接之后直接打开应用. 客户在微信\\QQ中点击链接时不再需要点击右上’在Safari浏览器打开’才能打开软件, 实现客户操作的无缝跳转, 让客户体验更加连贯, 更顺畅. </p>\n<ol>\n<li><p>如果安装过App, 不管在微信里面http链接还是在Safari浏览器, 还是其他第三方浏览器, 都可以打开App. </p>\n</li>\n<li><p>如果没有安装过App, 就会打开网页. </p>\n</li>\n</ol>\n<p>具体设置需要3步: </p>\n<ol>\n<li><p>App需要开启Associated Domains服务, 并设置Domains, 注意必须要applinks：开头. 这里需要在APP使用的证书中设置这个选项, 否则在APP设置中看不到Associated Domains服务. </p>\n</li>\n<li><p>域名必须要支持HTTPS. </p>\n</li>\n<li><p>上传内容是Json格式的文件, 文件名为apple-app-site-association到自己域名的根目录下, 或者.well-known目录下. iOS自动会去读取这个文件. 具体的文件内容请查看<a href=\"https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>. </p>\n</li>\n</ol>\n<p><a href=\"http://www.jianshu.com/p/c83164c2aec2\" target=\"_blank\" rel=\"noopener\">参考文章一</a></p>\n<p><a href=\"http://www.jianshu.com/p/1970fd59de12\" target=\"_blank\" rel=\"noopener\">参考文章二</a></p>\n<h2 id=\"应用内路由协议设计思路\"><a href=\"#应用内路由协议设计思路\" class=\"headerlink\" title=\"应用内路由协议设计思路\"></a>应用内路由协议设计思路</h2><p><em>页面间跳转</em> 和 <em>组件间调用</em>, 是应用内路由协议要解决的两大问题, 举个例子来说明一下:</p>\n<ul>\n<li><em>页面跳转</em>, 如果以传统的Push来说, 我们怎么才能从任一界面push到另外任一界面, 各个界面之间的跳转必然要相互<code>Import</code>, 这些怎么解决.</li>\n<li><em>组件见调用</em>, 随着业务的模块化拆分, 各个模块之间有业务调用怎么办, 本身独立的模块, 为了相互调用必然又增加接口供外部调用, 本身相对独立的业务模块, 瞬间又变得相互耦合了.</li>\n</ul>\n<p>而路由协议正是为了解决这一类问题, 现在比较流行的路由协议有如下几种:</p>\n<ul>\n<li><a href=\"https://github.com/joeldev/JLRoutes\" target=\"_blank\" rel=\"noopener\">JLRouts</a></li>\n<li><a href=\"https://github.com/clayallsopp/routable-ios\" target=\"_blank\" rel=\"noopener\">Routable</a></li>\n<li><a href=\"https://github.com/lightory/HHRouter\" target=\"_blank\" rel=\"noopener\">HHRouter</a></li>\n<li><a href=\"https://github.com/meili/MGJRouter\" target=\"_blank\" rel=\"noopener\">MGJRouter</a></li>\n<li><a href=\"https://github.com/casatwy/CTMediator\" target=\"_blank\" rel=\"noopener\">CTMediator</a></li>\n</ul>\n<p><img src=\"https://ob6mci30g.qnssl.com/Blog/ArticleImage/40_15.png\" alt=\"URL资源\"></p>\n<p>通过上面应用间的跳转, 我们可以发现iOS 系统里面使用的是URL Scheme方式. 对于一个资源的访问，苹果也是用URL的方式来访问的, 那么我们就可以想办法通过URL来统一三端的跳转. 一段标准的URL的格式, 每一部分都代表不同的含义. 我们可以按照规则来解析接受到的URL, 从而获得有用的信息. 下面说一下我的解决方案. </p>\n<p>大致的解决思路如下:</p>\n<ol>\n<li><p>在APP开始加载时设置Module的<code>Scheme</code>, 并且初始化Module的核心类<code>HCModuleCore</code>.</p>\n<p> <code>Scheme</code>是用来标记当前APP, 每个APP的<code>Scheme</code>不尽相同, 他和应用间跳转时设置的<code>Scheme</code>是一个东西. <code>HCModuleCore</code>是个单例, 它存在于整个APP的生命周期中. </p>\n</li>\n<li><p>有一个<code>HCModuleProtocol</code>协议, 里面有几个必须要实现的方法.</p>\n<p> 如果某个类想要通过协议被跳转就必须实现该协议, 并且实现协议中的<code>@required</code>方法. <code>@optional</code>方法根据实际需要选择实现.</p>\n<pre><code> HCModuleProtocol.h\n\n @required\n /**\n 该方法返回当前类的标签, 该标签是当前类的唯一标识, 不可重复\n @return 字符串类型\n */\n + (NSString *)moduleName;\n\n @optional\n /**\n 如果是通过push方式打开, 就实现该方法, 返回当前类的self\n\n @param params 传入的参数\n @param callback 传入的block回调\n @return 实现跳转协议类的self\n */\n - (id)open:(NSDictionary *)params callback:(void(^)(NSDictionary *))callback;\n\n /**\n如果是通过present方式打开, 就实现该方法, 返回当前类的self\n\n @param params 传入的参数\n @param callback 传入的block回调\n @return 实现跳转协议类的self\n */\n - (id)open_present:(NSDictionary *)params callback:(void(^)(NSDictionary *))callback;\n\n</code></pre></li>\n<li><p><code>HCModuleCore</code>是个单例, 在初始化的时候, 通过runtime提供的方法把遵守<code></code>的类名缓存起来, 缓存信息存储在单例中, 存在于整个APP的生命周期中.</p>\n<pre><code> HCModuleCore.m\n\n + (instancetype)moduleCore {\n     static HCModuleCore *moduleCore;\n     static dispatch_once_t onceToken;\n     dispatch_once(&amp;onceToken, ^{\n         moduleCore = [[HCModuleCore alloc] init];\n     });\n     return moduleCore;\n }\n\n - (instancetype)init {\n     self = [super init];\n     if (self) {\n         [self cacheModuleProrocolClasses];\n     }\n     return self;\n }\n\n /**\n 把遵守HCModuleProtocol的类缓存起来\n */\n - (void)cacheModuleProrocolClasses {\n     if (_cache.count != 0) {\n         return;\n     }\n     NSMutableDictionary *tmpCache = [NSMutableDictionary dictionary];\n     Class *classes;\n     unsigned int outCount;\n     classes = objc_copyClassList(&amp;outCount);//获取全部类\n     for (int i = 0; i &lt; outCount; i++) {\n         Class class = classes[i];\n\n         //实现了HCModuleProtocol的类\n         if (class_conformsToProtocol(class, @protocol(HCModuleProtocol))) {\n             NSString *moduleName = [class moduleName];\n             //重复检查\n             NSCAssert([tmpCache objectForKey:moduleName] == nil, @&quot;in class %@, module %@ has defined, please check!&quot;, NSStringFromClass(class), moduleName);\n             [tmpCache setObject:NSStringFromClass(class) forKey:moduleName];\n         }\n     }\n     free(classes);\n     self.cache = [tmpCache copy];\n}\n</code></pre></li>\n<li><p>主要是通过传入的moduleName或者URl来获取到被打开页面的唯一标识, 再通过唯一标识从单例中缓存的遵守跳转协议的类中去找. 如果找到的话, <code>performSelector:withObject:withObject:</code>方法的返回值是响应的方法的返回值, 通过该函数获取到被跳转的类的实例. </p>\n<pre><code> HCModuleCore.m\n\n //根据moduleName返回对应注册的类\n - (id)moduleName:(NSString *)moduleName openWithParams:(NSDictionary *)params callback:(void(^)(NSDictionary *moduleInfo))callback {\n     NSCAssert(moduleName != nil, @&quot;moduleName can not be nil!&quot;);\n     id module = [self moduleName:moduleName performSelectorName:@&quot;open:callback:&quot; withParams:params callback:callback];\n     if (module == nil) {\n         module = [self moduleName:moduleName performSelectorName:@&quot;open_present:callback:&quot; withParams:params callback:callback];\n     }\n     return module;\n }\n\n //获取缓存起来的响应相应协议方法的类\n - (id)moduleName:(NSString *)moduleName performSelectorName:(NSString *)selectorName withParams:(NSDictionary *)params callback:(void(^)(NSDictionary *moduleInfo))callback {\n     NSCAssert(moduleName != nil &amp;&amp; selectorName != nil, @&quot;moduleName and selectorName can not be nil!&quot;);\n     id module;\n     NSString *clsName = self.cache[moduleName];\n     if (clsName.length) {\n         Class class = NSClassFromString(clsName);//根据缓存的类名字创建类\n         SEL selec = NSSelectorFromString(selectorName);\n         if (class) {\n             id target = [[class alloc] init];//初始化一个类的对象\n             if ([target respondsToSelector:selec]) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;\n                 //performSelector:withObject:withObject:的返回值是响应的方法的返回值\n                 module = [target performSelector:selec withObject:params withObject:callback];\n#pragma clang diagnostic pop\n             }\n         }\n     }\n     return module;\n }\n</code></pre></li>\n<li><p>然后有两个category, 分别是<code>UINavigationController+HCModuleCore</code>和<code>UIViewController+HCModuleCore</code>. 分别对应push和present的情况. 因为上面已经拿到了要跳转到的页面的实例, 这里就可以通过push或者present的方法跳转过去.   </p>\n</li>\n</ol>\n<h2 id=\"远程调用和本地调用的区分以及安全防范\"><a href=\"#远程调用和本地调用的区分以及安全防范\" class=\"headerlink\" title=\"远程调用和本地调用的区分以及安全防范\"></a>远程调用和本地调用的区分以及安全防范</h2><p>远程调用和本地调用, 如果是其他APP打开本地APP可以通过设置白名单的方式, 因为每个APP的Scheme都是不同的, 如果是网络层面上劫持协议, 可以通过HTTPS的方式来防止网络劫持.</p>\n<h2 id=\"模块间的方法调用\"><a href=\"#模块间的方法调用\" class=\"headerlink\" title=\"模块间的方法调用\"></a>模块间的方法调用</h2><p>我们可以选择对外暴露一个方法, 方法有两个参数, 一个是ModuleName, 一个是要执行的方法. 这样我们可以根据ModuleName在注册的类中找到这个类的实例, 然后通过NSInvocation来调用将要执行的方法.</p>\n<hr>\n<p>参考文章:<br>1.<a href=\"https://halfrost.com/ios_router/\" target=\"_blank\" rel=\"noopener\">iOS 组件化 —— 路由设计思路分析</a></p>\n<p>2.<a href=\"http://awhisper.github.io/2016/06/12/%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%80%9D%E8%80%83/\" target=\"_blank\" rel=\"noopener\">路由跳转的思考</a></p>\n<p>3.<a href=\"http://wereadteam.github.io/2016/03/19/iOS-Component/\" target=\"_blank\" rel=\"noopener\">iOS组件化方案探讨</a></p>\n<p>4.<a href=\"https://casatwy.com/iOS-Modulization.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈-组件化方案</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/bb3f42fdbc31\" target=\"_blank\" rel=\"noopener\">iOS10跳转系统设置的正确姿势</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/32ca4bcda3d1\" target=\"_blank\" rel=\"noopener\">关于 iOS 系统功能的 URL 汇总列表</a></p>\n<p>7.<a href=\"http://www.jianshu.com/p/b5e8ef8c76a3\" target=\"_blank\" rel=\"noopener\">iOS应用间相互跳转</a></p>\n<p>8.<a href=\"http://www.jianshu.com/p/c83164c2aec2\" target=\"_blank\" rel=\"noopener\">从微信直接跳转到我们的APP</a></p>\n<p>9.<a href=\"http://www.jianshu.com/p/1970fd59de12\" target=\"_blank\" rel=\"noopener\">iOS Universal Links(通用链接)的使用</a></p>\n","categories":["模块化"],"tags":["模块化","路由"]},{"title":"Xcode自动化打包脚本","url":"http://hchong.net/2017/05/17/Xcode自动化打包脚本/","content":"<h1 id=\"Xcode自动化打包脚本\"><a href=\"#Xcode自动化打包脚本\" class=\"headerlink\" title=\"Xcode自动化打包脚本\"></a>Xcode自动化打包脚本</h1><p>自动化打包脚本是配合<a href=\"http://hchong.net/2017/03/12/%E5%A4%9ATarget%E5%AE%9E%E7%8E%B0/\">多渠道包和多环境包的自动化实现</a>使用的, 实际上脚本语言都可以做到, 我这里选用了Shell和Python两种实现方式. 对比下来发现, Python更好懂一点, 但是Shell更加简洁.</p>\n<h2 id=\"打包的基本思路\"><a href=\"#打包的基本思路\" class=\"headerlink\" title=\"打包的基本思路\"></a>打包的基本思路</h2><p>这里说一下打包脚本的基本实现思路:</p>\n<ol>\n<li>需要传入的参数有Scheme(用来指定打哪个环境的包), 如果使用Fir来作为内测分发工具的话, 还需要传入Fir的Token.</li>\n<li>在脚本内需要指定工程的路径, 工程名, Archive包的路径, IPA包的路径.</li>\n<li>通过Xcodebuild命令行生成Archive包.</li>\n<li>根据生成的Archive包导出IPA包.</li>\n<li>上传IPA包到Fir.</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>Xcode8.3后, 需要一个打包参数配置的plist文件, 生成Archive包时会用到.</li>\n<li>shell脚本需要给权限<code>chomd 777 xx.sh</code>.</li>\n<li>Archive导出为IPA有时会报错<code>Code=14 &quot;No applicable devices found.&quot;</code>, 这个多少是Ruby的路径没有指定导致, 找了一大圈有两个解决方案:<ol>\n<li>通过<code>sudo gem install CFPropertyList</code>, <code>rvm list</code>, <code>rvm use system</code>来解决, Python或者Shell都可以使用这种方式.</li>\n<li>Shell下还有另外的解决方案, 在shell脚本前加入如下代码, 指定路径.<pre><code>[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot;\nrvm use system\nxcodebuild &quot;$@&quot;\n</code></pre></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Xcode8-3后的plist文件\"><a href=\"#Xcode8-3后的plist文件\" class=\"headerlink\" title=\"Xcode8.3后的plist文件\"></a>Xcode8.3后的plist文件</h2><p>使用<code>xcodebuild -help</code> 可以查看Xcodebuild相关介绍</p>\n<pre><code>Available keys for -exportOptionsPlist:\n\n    compileBitcode : Bool\n\n        For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.\n\n    embedOnDemandResourcesAssetPacksInBundle : Bool\n\n        For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.\n\n    iCloudContainerEnvironment\n\n        For non-App Store exports, if the app is using CloudKit, this configures the &quot;com.apple.developer.icloud-container-environment&quot; entitlement. Available options: Development and Production. Defaults to Development.\n\n    manifest : Dictionary\n\n        For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.\n\n    method : String\n\n        Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.\n\n    onDemandResourcesAssetPacksBaseURL : String\n\n        For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn&#39;t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.\n\n    teamID : String\n\n        The Developer Portal team to use for this export. Defaults to the team used to build the archive.\n\n    thinning : String\n\n        For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. &quot;iPhone7,1&quot;). Defaults to &lt;none&gt;.\n\n    uploadBitcode : Bool\n\n        For App Store exports, should the package include bitcode? Defaults to YES.\n\n    uploadSymbols : Bool\n\n        For App Store exports, should the package include symbols? Defaults to YES.\n\n</code></pre><p>我们在工程中新建一个plist文件, 可以看出, 大部分是有默认值的, 所以我们不用每个选项都填, 只写一些必填的就可以. </p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;\n&lt;plist version=&quot;1.0&quot;&gt;\n    &lt;dict&gt;\n        &lt;key&gt;method&lt;/key&gt;\n        &lt;string&gt;enterprise&lt;/string&gt;\n        &lt;key&gt;uploadSymbols&lt;/key&gt;\n        &lt;true/&gt;\n        &lt;key&gt;uploadBitcode&lt;/key&gt;\n        &lt;false/&gt;\n    &lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre><hr>\n<p><a href=\"https://github.com/HChong3210/buildScript.git\" target=\"_blank\" rel=\"noopener\">附件下载</a></p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"https://diaojunxian.github.io/2016/10/21/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%B8%83/\" target=\"_blank\" rel=\"noopener\">自动化测试-持续集成(7)</a></p>\n<p>2.<a href=\"http://stackoverflow.com/questions/33041109/xcodebuild-no-applicable-devices-found-when-exporting-archive\" target=\"_blank\" rel=\"noopener\">xcodebuild: “No applicable devices found.” when exporting archive</a></p>\n<p>3.<a href></a></p>\n","categories":["自动化打包"],"tags":["自动化打包","Target","解决方案"]},{"title":"Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系","url":"http://hchong.net/2017/05/16/Settings关系/","content":"<h1 id=\"Xcode中的Workspace-Scheme-Project-Target和Build-Settings的关系\"><a href=\"#Xcode中的Workspace-Scheme-Project-Target和Build-Settings的关系\" class=\"headerlink\" title=\"Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系\"></a>Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系</h1><h2 id=\"Xcode-Workspace\"><a href=\"#Xcode-Workspace\" class=\"headerlink\" title=\"Xcode Workspace\"></a>Xcode Workspace</h2><p>官方文档如下: </p>\n<blockquote>\n<p>A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets.</p>\n</blockquote>\n<p>workspace是Xcode的一种文件，用来管理工程和里面的文件，一个workspace可以包含若干个工程，甚至可以添加任何你想添加的文件。workspace提供了工程和工程里面的target之间隐式和显式依赖关系，用来管理和组织工程里面的所有文件.</p>\n<p> 一个workspace可以管理多个Project, <code>pod install</code>的过程就是生成了一个workspace和一个全是Pod组件的Project, 然后我们通过生成的workspace来管理新生成的Project和原本的Project.</p>\n<h2 id=\"Xcode-Project\"><a href=\"#Xcode-Project\" class=\"headerlink\" title=\"Xcode Project\"></a>Xcode Project</h2><p>官方文档如下:</p>\n<blockquote>\n<p>An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings).</p>\n</blockquote>\n<p>project就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。</p>\n<p>Xcode中的 project里面包含了所有的源文件，资源文件和构建一个或者多个product的信息。project利用他们去编译我们所需的product，也帮我们组织它们之间的关系。一个project可以包含一个或者多个target。project定义了一些基本的编译设置，每个target都继承了project的默认设置，每个target可以通过重新设置target的编译选项来定义自己的特殊编译选项。</p>\n<p>project包含了以下信息：</p>\n<ul>\n<li>源文件<ul>\n<li>代码的头文件和实现文件</li>\n<li>静态库，动态库，</li>\n<li>资源文件(如文本，xml，plist等)</li>\n<li>图片资源</li>\n<li>界面资源文件(xib， storyboard等)</li>\n</ul>\n</li>\n<li>在文件结构的导航中，采用group去组织文件(实际开发中，尽量使用实体文件夹)</li>\n<li>project的编译级别配置文件如(debug， release)</li>\n<li>target</li>\n<li>运行环境如：debug，test</li>\n</ul>\n<p>project可以单独存在，或者存在于一个workspace中.<br>​    </p>\n<h2 id=\"Xcode-Target\"><a href=\"#Xcode-Target\" class=\"headerlink\" title=\"Xcode Target\"></a>Xcode Target</h2><p>官方文档如下:</p>\n<blockquote>\n<p>A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.</p>\n</blockquote>\n<p>target 定义了生成的唯一 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product.</p>\n<p>这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode 的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;Build Phases)中进行查看和编辑。target 中的 build setting 参数继承自 project 的 build settings, 但是你可以在 target 中修改任意 settings 来重写 project settings，这样，最终生效的 settings 参数以在 target 中设置的为准. Project 可包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效.</p>\n<p>target 和其生成的 product 可与另一个 target 有关，如果一个 target 的 build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个 target .如果这些 target 在同一个 workspace 中，那么 Xcode 能够发现这种依赖关系，从而使其以我们期望的顺序生成 products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets 之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。</p>\n<p>指定 targets 之间的依赖关系的地方在 Project Editor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置.</p>\n<h2 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h2><p>官方文档如下:</p>\n<blockquote>\n<p>An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.</p>\n</blockquote>\n<p>一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。指定了编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等。可以通过scheme editor来编辑scheme.</p>\n<blockquote>\n<p>You can have as many schemes as you want, but only one can be active at a time. You can specify whether a scheme should be stored in a project—in which case it’s available in every workspace that includes that project, or in the workspace—in which case it’s available only in that workspace. When you select an active scheme, you also select a run destination (that is, the architecture of the hardware for which the products are built).</p>\n</blockquote>\n<p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>\n<h2 id=\"Build-Settings\"><a href=\"#Build-Settings\" class=\"headerlink\" title=\"Build Settings\"></a>Build Settings</h2><p>官方文档如下:</p>\n<blockquote>\n<p>A build setting is a variable that contains information about how a particular aspect of a product’s build process should be performed. For example, the information in a build setting can specify which options Xcode passes to the compiler.</p>\n</blockquote>\n<p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>\n<p>build setting 中包含了 product 生成过程中所需的参数信息。你可以在 project-level 和 target-level 层指定 build settings。project-level 的 build settings 适用于 project 中的所有targets，但是当 target-level 的 build settings 重写了 project-level 的 build settings，以 target-level 中的 build settings 中的值为准</p>\n<p>一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 build configarations, 分别用于生成 debug 和 release 模式下的 product。</p>\n<p>除了创建工程时生成的默认 build settings，你也可以自定义 project-level 或者 target-level 的 build settings.</p>\n<p>关于继承关系，<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html#BuildSettingInheritance\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a> 这里也有详细的说明，强烈建议阅读。</p>\n<p>动态环境配置就是使用自定义的 build settings 来实现的.</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/\" target=\"_blank\" rel=\"noopener\">Xcode使用xcconfig文件配置环境</a>.<br>​<br>2.<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html\" target=\"_blank\" rel=\"noopener\">Apple官方文档</a>.</p>\n<p>3.<a href=\"https://xiuchundao.me/post/xcode-scheme-and-build-configuration\" target=\"_blank\" rel=\"noopener\">Xcode中的Scheme和Build Configuration</a>.</p>\n<p>4.<a href=\"http://www.jianshu.com/p/1f312abafeff\" target=\"_blank\" rel=\"noopener\">Xcode workSpace 多个project联编</a></p>\n<p>5.<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html#BuildSettingInheritance\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a></p>\n","categories":["基础知识"],"tags":["基础知识","Target"]},{"title":"通讯录数据的读取和性能优化","url":"http://hchong.net/2017/04/23/通讯录数据的读取和性能优化/","content":"<h1 id=\"通讯录数据的读取和性能优化\"><a href=\"#通讯录数据的读取和性能优化\" class=\"headerlink\" title=\"通讯录数据的读取和性能优化\"></a>通讯录数据的读取和性能优化</h1><p>前段时间再做一个关于通讯录相关的项目, 记录一下通讯录相关的基础和读取优化的部分. 在本篇文章中, 我主要侧重读取通讯录数据方面, 至于调用原生的界面在这里则不做阐述. 关于通讯录的API, 在iOS9之后做了较大的调整, 使用<code>Contacts Framework</code>替代<code>AddressBookFramework</code>. 下面我将就iOS9和iOS8两种API进行分析.</p>\n<h2 id=\"通讯录的授权\"><a href=\"#通讯录的授权\" class=\"headerlink\" title=\"通讯录的授权\"></a>通讯录的授权</h2><p>既然要读取通讯录, 那么通讯录授权状态的查询, 要放在在前面, 这里也区分iOS9和iOS8系统.</p>\n<h3 id=\"iOS8查询通讯录授权状态\"><a href=\"#iOS8查询通讯录授权状态\" class=\"headerlink\" title=\"iOS8查询通讯录授权状态\"></a>iOS8查询通讯录授权状态</h3><pre><code>+ (void)checkAddressBookAuthorization:(void (^)(bool isAuthorized))block {\n    ABAddressBookRef addressBookRef =  ABAddressBookCreateWithOptions(NULL, NULL);\n    switch (ABAddressBookGetAuthorizationStatus()) {\n        case kABAuthorizationStatusNotDetermined: {\n            NSLog(@&quot;未询问用户是否授权&quot;);\n            ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) {\n                if (granted) {\n                    NSLog(@&quot;授权可以读取&quot;);\n                    block(YES);\n                } else {\n                    NSLog(@&quot;授权不能读取&quot;);\n                    block(NO);\n                }\n            });\n        } break;\n        case kABAuthorizationStatusAuthorized: {\n            NSLog(@&quot;同意授权通讯录&quot;);\n            block(YES);\n        } break;\n        case kABAuthorizationStatusDenied: {\n            block(NO);\n            NSLog(@&quot;未授权，用户拒绝造成的&quot;);\n        } break;\n        case kABAuthorizationStatusRestricted: {\n            block(NO);\n            NSLog(@&quot;未授权，例如家长控制&quot;);\n        } break;\n        default: {\n        } break;\n    }\n}\n</code></pre><h3 id=\"iOS9查询通讯录授权状态\"><a href=\"#iOS9查询通讯录授权状态\" class=\"headerlink\" title=\"iOS9查询通讯录授权状态\"></a>iOS9查询通讯录授权状态</h3><pre><code>- (void)addressBookEmpowerCheck {\n    CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts];\n    switch (status) {\n        case CNAuthorizationStatusNotDetermined: {\n            [[[CNContactStore alloc]init] requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n                NSLog(@&quot;还没问&quot;);\n                if (granted) {\n                    NSLog(@&quot;点击了同意&quot;);\n                } else {\n                    NSLog(@&quot;点击了拒绝&quot;);\n                }\n            }];\n        }\n        break;\n        case CNAuthorizationStatusRestricted: {\n            NSLog(@&quot;未授权, 例如家长控制&quot;);\n        }\n        break;\n        case CNAuthorizationStatusDenied: {\n            NSLog(@&quot;未授权, 用户拒绝所致&quot;);\n        }\n        break;\n        case CNAuthorizationStatusAuthorized: {\n            NSLog(@&quot;已经授权&quot;);\n        }\n        break;\n        default: {\n        }\n        break;\n    }\n}\n</code></pre><p>注意: 如果是iOS10的系统需要在<code>Info.plist</code>配置<code>NSContactsUsageDescription</code></p>\n<pre><code>&lt;key&gt;NSContactsUsageDescription&lt;/key&gt;\n&lt;string&gt;请求访问通讯录&lt;/string&gt;\n</code></pre><h2 id=\"通讯录数据写入和删除\"><a href=\"#通讯录数据写入和删除\" class=\"headerlink\" title=\"通讯录数据写入和删除\"></a>通讯录数据写入和删除</h2><p>当通讯录数据少时, 数据的读取耗时较少, 为了更好地测试大量数据下的性能问题, 我们先写入大量的数据来进行测试. </p>\n<h3 id=\"iOS8写入联系人\"><a href=\"#iOS8写入联系人\" class=\"headerlink\" title=\"iOS8写入联系人\"></a>iOS8写入联系人</h3><pre><code>- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone {\n    if((name.length &lt; 1)||(phone.length &lt; 1)){\n        NSLog(@&quot;输入属性不能为空&quot;);\n        return;\n    }\n    CFErrorRef error = NULL;\n\n    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, &amp;error);\n    ABRecordRef newRecord = ABPersonCreate();\n    ABRecordSetValue(newRecord, kABPersonFirstNameProperty, (__bridge CFTypeRef)name, &amp;error);\n\n    ABMutableMultiValueRef multi = ABMultiValueCreateMutable(kABMultiStringPropertyType);\n    ABMultiValueAddValueAndLabel(multi, (__bridge CFTypeRef)name, kABPersonPhoneMobileLabel, NULL);\n\n    ABRecordSetValue(newRecord, kABPersonPhoneProperty, multi, &amp;error);\n    CFRelease(multi);\n\n    ABAddressBookAddRecord(addressBook, newRecord, &amp;error);\n    CFRelease(newRecord);\n    CFRelease(addressBook);\n}\n</code></pre><p>需要注意的是, 在本例中, 只填写了<code>FirstName</code>和<code>phone</code>, 实际还有许多其他属性可供选择, 具体参照<code>ABAddressBookRef</code>和<code>ABRecordRef</code>需要调用<code>CFRelease</code>来释放内存.</p>\n<h3 id=\"iOS9写入联系人\"><a href=\"#iOS9写入联系人\" class=\"headerlink\" title=\"iOS9写入联系人\"></a>iOS9写入联系人</h3><pre><code>- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone {\n    // 创建对象\n    CNMutableContact * contact = [[CNMutableContact alloc]init];\n    contact.givenName = name?:@&quot;defaultname&quot;;\n    CNLabeledValue *phoneNumber = [CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberMobile value:[CNPhoneNumber phoneNumberWithStringValue:phone?:@&quot;10086&quot;]];\n    contact.phoneNumbers = @[phoneNumber];\n\n    // 把对象加到请求中\n    CNSaveRequest * saveRequest = [[CNSaveRequest alloc]init];\n    [saveRequest addContact:contact toContainerWithIdentifier:nil];\n\n    // 执行请求\n    CNContactStore * store = [[CNContactStore alloc]init];\n    [store executeSaveRequest:saveRequest error:nil];\n}\n</code></pre><p>更稳健一点的写法, 是可以把请求放在通讯录授权判断的block中</p>\n<pre><code>    CNContactStore *store = [[CNContactStore alloc] init];\n    [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!granted) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                //失败原因\n            });\n            return;\n        }\n        //do something\n    }];\n</code></pre><p>使用下面这种方式</p>\n<pre><code> - (void)addContactWithName:(NSString *)name {\n\n    CNContactStore *store = [[CNContactStore alloc] init];\n    [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!granted) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                //失败原因\n            });\n            return;\n        }\n\n        CNMutableContact *contact = [[CNMutableContact alloc] init];\n        contact.familyName = @&quot;Doe&quot;;\n        contact.givenName = @&quot;John&quot;;\n\n        CNLabeledValue *homePhone = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:[CNPhoneNumber phoneNumberWithStringValue:@&quot;312-555-1212&quot;]];\n        contact.phoneNumbers = @[homePhone];\n\n        CNSaveRequest *request = [[CNSaveRequest alloc] init];\n        [request addContact:contact toContainerWithIdentifier:nil];\n\n        // save it\n        NSError *saveError;\n        if (![store executeSaveRequest:request error:&amp;saveError]) {\n            NSLog(@&quot;error = %@&quot;, saveError);\n        }\n    }];\n}\n</code></pre><h3 id=\"iOS8删除联系人\"><a href=\"#iOS8删除联系人\" class=\"headerlink\" title=\"iOS8删除联系人\"></a>iOS8删除联系人</h3><pre><code>- (void)removeItemWithName:(NSString *)name phone:(NSString *)phone {\n    ABAddressBookRef addressbook = ABAddressBookCreate();\n    CFStringRef nameRef = (__bridge CFStringRef) name;\n    CFArrayRef  allSearchRecords = ABAddressBookCopyPeopleWithName(addressbook, nameRef);\n    if (allSearchRecords != NULL)\n    {\n        CFIndex count = CFArrayGetCount(allSearchRecords);\n        for (int i = 0; i &lt; count; ++i)\n        {\n            ABRecordRef contact = CFArrayGetValueAtIndex(allSearchRecords, i);\n            ABAddressBookRemoveRecord(addressbook, contact, nil);\n        }\n    }\n    ABAddressBookSave(addressbook, nil);\n    CFRelease(addressbook);\n}\n</code></pre><h3 id=\"iOS9删除联系人\"><a href=\"#iOS9删除联系人\" class=\"headerlink\" title=\"iOS9删除联系人\"></a>iOS9删除联系人</h3><pre><code>- (void)removeContactWithName:(NSString *)name {\n    CNContactStore *store = [[CNContactStore alloc] init];\n    NSPredicate *predicate = [CNContact predicateForContactsMatchingName:name];\n    NSArray *contacts = [store unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey, CNContactFamilyNameKey] error:nil];\n\n    for (CNMutableContact *contact in contacts) {\n        CNSaveRequest *request = [[CNSaveRequest alloc] init];\n        [request deleteContact:contact];\n        // save it\n        NSError *saveError;\n        if (![store executeSaveRequest:request error:&amp;saveError]) {\n            NSLog(@&quot;error = %@&quot;, saveError);\n        }\n    }\n}\n</code></pre><h2 id=\"通讯录数据读取\"><a href=\"#通讯录数据读取\" class=\"headerlink\" title=\"通讯录数据读取\"></a>通讯录数据读取</h2><p>通过上面的一通操作, 我们已经可以创建和删除通讯录了, 那么我们就通过批量写入通讯录数据, 来进行通讯录数据的读取, 并且按照姓名和首字母分组排序. 相应的, 此处我们也区分<code>iOS8</code>和<code>iOS9</code>下面两个不同的框架.</p>\n<h3 id=\"iOS8读取联系人\"><a href=\"#iOS8读取联系人\" class=\"headerlink\" title=\"iOS8读取联系人\"></a>iOS8读取联系人</h3><pre><code>+ (NSArray *)getAllContact {\n    NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];\n\n    CFErrorRef *error = NULL;\n    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, error);\n\n    CFIndex numberOfPeople = ABAddressBookGetPersonCount(addressBook);\n    CFArrayRef people = ABAddressBookCopyArrayOfAllPeople(addressBook);\n    if (numberOfPeople == 0) {\n        CFRelease(people);\n        CFRelease(addressBook);\n        return @[];\n    }\n    for ( int i = 0; i &lt; numberOfPeople; i++){\n        AddressBookContact *contact = [[AddressBookContact alloc] init];\n\n        ABRecordRef person = CFArrayGetValueAtIndex(people, i);\n\n        //姓名\n        NSString *firstName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonFirstNameProperty));\n        NSString *lastName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonLastNameProperty));\n        NSString *name = [NSString stringWithFormat:@&quot;%@%@&quot;, lastName, firstName;\n        contact.name = name;\n\n        //第一次添加该条记录的时间戳\n        NSDate *createDate = (NSDate *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonCreationDateProperty));\n        NSTimeInterval timeIn = [createDate timeIntervalSince1970];\n        NSInteger createTime = round(timeIn);\n        contact.createTime = [NSString stringWithFormat:@&quot;%010ld&quot;, (long)createTime];\n\n        //读取电话多值\n        ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty);\n        NSArray *arr = (NSArray *)CFBridgingRelease(ABMultiValueCopyArrayOfAllValues(phone));\n        contact.phone = [AddressBookData filterPhoneFormate:[arr lastObject]];\n\n        if (contact.phone.length &gt; 0) {\n            [array addObject:contact];\n        }\n    }\n    CFRelease(people);\n    CFRelease(addressBook);\n    return array;\n}\n\n//剔除手机号中的特殊字符\n+ (NSString *)filterPhoneFormate:(NSString *)phoneNumber {\n    NSCharacterSet *notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];\n    NSString *resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@&quot;&quot;];\n    return resultString;\n}\n</code></pre><h3 id=\"iOS9读取联系人\"><a href=\"#iOS9读取联系人\" class=\"headerlink\" title=\"iOS9读取联系人\"></a>iOS9读取联系人</h3><pre><code>    // 创建通信录对象\n    CNContactStore *contactStore = [[CNContactStore alloc] init];\n\n    // 创建获取通信录的请求对象\n    // 拿到所有打算获取的属性对应的key\n    NSArray *keys = @[CNContactGivenNameKey, CNContactFamilyNameKey, CNContactPhoneNumbersKey];\n\n    // 创建CNContactFetchRequest对象\n    CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:keys];\n\n    // 遍历所有的联系人\n    [contactStore enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) {\n        // 获取联系人的姓名\n        NSString *lastname = contact.familyName;\n        NSString *firstname = contact.givenName;\n        NSLog(@&quot;%@ %@&quot;, lastname, firstname);\n\n        // 获取联系人的电话号码\n        NSArray *phoneNums = contact.phoneNumbers;\n        for (CNLabeledValue *labeledValue in phoneNums) {\n            // 获取电话号码的KEY\n            NSString *phoneLabel = labeledValue.label;\n\n            // 获取电话号码\n            CNPhoneNumber *phoneNumer = labeledValue.value;\n            NSString *phoneValue = phoneNumer.stringValue;\n\n            NSLog(@&quot;%@ %@&quot;, phoneLabel, phoneValue);\n            AddressBookContact *contact = [[AddressBookContact alloc] init];\n            contact.name = [NSString stringWithFormat:@&quot;%@%@&quot;,lastname,firstname];\n            person.phone = phoneValue;\n            [_addressBookArray addObject:contact];\n        }\n    }];\n</code></pre><p>我们通过上面的方法拿到的数据是一个元素是我们自定义数据模型<code>AddressBookContact</code>的数组, 所有的数据都在这一个数组里面, 没有分组, 相同首字母的联系人按照创建时间来排序.显然这样的数据是不能满足我们业务需求的. 常见的是按照首字母来分组, 下面我们就以iOS8为例来对数据进行分组排序和展示, 类似于系统通讯录列表.</p>\n<h3 id=\"通讯录分组\"><a href=\"#通讯录分组\" class=\"headerlink\" title=\"通讯录分组\"></a>通讯录分组</h3><pre><code>//返回包含分组信息和分组后通讯录数据的字典\n+ (NSDictionary *)dealDataWithArray:(NSArray *)array {\n    if (array.count == 0) {\n        return nil;\n    }\n    NSMutableArray *titleArray = [NSMutableArray arrayWithCapacity:0];\n    NSMutableArray *data = [NSMutableArray arrayWithCapacity:0];\n    NSMutableArray * tmpArray = [[NSMutableArray alloc]init];\n    for (NSInteger i =0; i &lt;27; i++) {\n        //给临时数组创建27个数组作为元素，用来存放A-Z和#开头的联系人\n        NSMutableArray * array = [[NSMutableArray alloc]init];\n        [tmpArray addObject:array];\n    }\n\n    for (AddressBookContact * model in array) {\n        //AddressMode是联系人的数据模型\n        //转化为首拼音并取首字母\n        NSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\n        if (nickName.length == 0) {\n            //如果不是，就放到最后一个代表#的数组\n            NSMutableArray * array =[tmpArray lastObject];\n            [array addObject:model];\n        } else {\n            int firstWord = [nickName characterAtIndex:0];\n            //把字典放到对应的数组中去\n\n            if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n                //如果首字母是A-Z，直接放到对应数组\n                NSMutableArray * array = tmpArray[firstWord - 65];\n                [array addObject:model];\n\n            } else {\n                //如果不是，就放到最后一个代表#的数组\n                NSMutableArray * array =[tmpArray lastObject];\n                [array addObject:model];\n            }\n        }\n    }\n\n    //此时数据已按首字母排序并分组\n    //遍历数组，删掉空数组\n    for (NSMutableArray * mutArr in tmpArray) {\n        //如果数组不为空就添加到数据源当中\n        if (mutArr.count != 0) {\n            [data addObject:mutArr];\n            AddressBookContact * model = mutArr[0];\n            NSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\n            if (nickName.length != 0) {\n                int firstWord = [nickName characterAtIndex:0];\n                //取出其中的首字母放入到标题数组，暂时不考虑非A-Z的情况\n                if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n                    [titleArray addObject:nickName];\n                }\n            }\n        }\n    }\n\n    //判断是否需要加#\n    if (titleArray.count != data.count) {\n        [titleArray addObject:@&quot;#&quot;];\n    }\n\n    NSDictionary *dic = @{@&quot;source&quot;: [AddressBookDataManager sortedArray:data],\n                          @&quot;title&quot;: titleArray};\n    return dic;\n}\n\n+ (NSArray *)sortedArray:(NSArray *)data {\n    NSMutableArray *sortedArray = [NSMutableArray array];\n    for (NSInteger index = 0; index &lt; data.count; index++) {\n        NSMutableArray *personArrayForSection = data[index];\n        NSArray *temp = [personArrayForSection sortedArrayUsingComparator:^NSComparisonResult(AddressBookContact * contact1, AddressBookContact * contact2) {\n            return [contact1.name compare:contact2.name];\n        }];\n        sortedArray[index] = temp;\n    }\n    return sortedArray;\n}\n\n\n#pragma mark - Tool\n+ (BOOL)objectIsNull:(id)obj{\n    return ([obj isKindOfClass:[NSNull class]] || obj == nil) ? YES : NO;\n}\n\n+ (NSString*)strNoNull:(id)str{\n    if ([AddressBookDataManager objectIsNull:str]) {\n        str = @&quot;&quot;;\n    }\n    return str;\n}\n\n//汉字转拼音并取得关键字\n+ (NSString *)returnFirstWordWithString:(NSString *)str {\n    NSMutableString * mutStr = [NSMutableString stringWithString:str];\n\n    //将mutStr中的汉字转化为带音标的拼音（如果是汉字就转换，如果不是则保持原样）\n    CFStringTransform((__bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformMandarinLatin, NO);\n    //将带有音标的拼音转换成不带音标的拼音（这一步是从上一步的基础上来的，所以这两句话一句也不能少）\n    CFStringTransform((__bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformStripCombiningMarks, NO);\n    if (mutStr.length &gt; 0) {\n        //全部转换为大写    取出首字母并返回\n        NSString * res = [[mutStr uppercaseString] substringToIndex:1];\n        return res;\n    } else {\n        return @&quot;&quot;;\n    }\n}\n\n//剔除手机号中的特殊字符\n+ (NSString *)filterPhoneFormate:(NSString *)phoneNumber {\n    NSCharacterSet *notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];\n    NSString *resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@&quot;&quot;];\n    return resultString;\n}\n\n</code></pre><p><img src=\"http://ohjcp7fjy.bkt.clouddn.com/IMG_0277.PNG\" alt=\"数据截图\"><br>至此, 我们可以得到符合业务需求的通讯录页面, 已经按照姓名首字母分组, 并且实现了快速索引. 我的通讯录测试数据有2700+条数据, 每次通讯录打开都要耗时特别久, 为了更好的用户体验, 这时就会想到要优化一下代码了.</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>说道性能优化, 首先就要进行性能分析, 知道我们需要优化的地方在哪里. Xcode提供了一个强大的分析工具Instruments, 具体一些常见的分析可以参考<a href=\"http://hchong.net/2017/04/13/Xcode%E7%A5%9E%E5%99%A8-Instruments%E5%A4%A7%E6%B3%95/\">这里</a>.<br>我们主要使用Instruments的Time ProFiler来分析一下, 究竟耗时的代码在哪里, 并且做一下优化.<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1ffevnuzt0zj30pg0e2wfj.jpg\" alt=\"耗时操作\"><br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1ffevnwtfovj317m0q440f.jpg\" alt=\"耗时操作的具体代码\"><br>通过分析可以发现, 目前的瓶颈主要出现在汉字转拼音取首字母的方法上, 可以发现我们使用的是<code>CFStringTransform</code>类, 我们先对这个进行一些优化</p>\n<pre><code>//汉字首字母\n+ (NSString *)returnFirstWordWithString:(NSString *)str {\n    NSMutableString *mutableString = [NSMutableString stringWithString:str];\n    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);\n    mutableString = (NSMutableString *)[mutableString stringByFoldingWithOptions:NSDiacriticInsensitiveSearch locale:[NSLocale currentLocale]];\n    NSString *string = [mutableString stringByReplacingOccurrencesOfString:@&quot;&#39;&quot; withString:@&quot;&quot;];\n    return [[string uppercaseString] substringToIndex:1];\n}\n</code></pre><p>再使用Instruments分析发现, 并没有什么太大的效果. 分析一下发现, 发现我们取首字母主要有两个用途.一个是把全部通讯录按照首字母的方式进行分组, 另一个用途就是为了在列表页生成索引数组. </p>\n<h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><p>一番查找发现, 系统针对这种情况已经有API可供我们调用了(贴心的Apple).下面就要介绍本次优化的关键类<code>UILocalizedIndexedCollation</code>.</p>\n<blockquote>\n<p>返回传入object对象指定selector在[UILocalizedIndexedCollation currentCollation]中的匹配的索引<br>// Returns the index of the section that will contain the object.<br>// selector must not take any arguments and return an NSString.</p>\n<pre><code>- (NSInteger)sectionForObject:(id)object collationStringSelector:(SEL)selector;\n</code></pre></blockquote>\n<blockquote>\n<p>返回传入object对象指定selector在[UILocalizedIndexedCollation currentCollation]中的匹配的索引<br>// Returns the index of the section that will contain the object.<br>// selector must not take any arguments and return an NSString.</p>\n<pre><code>- (NSInteger)sectionForObject:(id)object collationStringSelector:(SEL)selector;\n- \n</code></pre></blockquote>\n<pre><code>+ (NSDictionary *)dealDataWithArray:(NSArray *)array {\n\n    // 1.初始化一个索引，根据不同国家语言，会初始化出不同的索引，中文的是“A~Z,#”\n    UILocalizedIndexedCollation *collation = [UILocalizedIndexedCollation currentCollation];\n    // 2.获取索引的数量，并初始化对应数量的空数组，用于存放筛选数据\n    NSInteger sectionTitlesCount = [[collation sectionTitles] count];\n    NSMutableArray *sectionArrays = [NSMutableArray arrayWithCapacity:sectionTitlesCount];\n    for (int i = 0; i &lt; sectionTitlesCount; i++) {\n        NSMutableArray *sectionArray = [NSMutableArray arrayWithCapacity:1];\n        [sectionArrays addObject:sectionArray];\n    }\n    // 3.排序的方法\n    SEL sorter = ABPersonGetSortOrdering() == kABPersonSortByFirstName ? NSSelectorFromString(@&quot;name&quot;) : NSSelectorFromString(@&quot;name&quot;);\n    // 4.分组\n    for (AddressBookContact *contact in array) {\n        //获取name属性的值所在的位置，比如&quot;小白鼠&quot;，首字母是X，在A~Z中排第23（第一位是0），sectionNumber就为23\n        NSInteger sectionNumber = [collation sectionForObject:contact collationStringSelector:sorter];\n        //把name为“小白鼠”的contact加入newSectionsArray中的第23个数组中去\n        NSMutableArray *sectionNames = sectionArrays[sectionNumber];\n        [sectionNames addObject:contact];\n    }\n    //5.排序\n    for (NSInteger i = 0; i &lt; sectionTitlesCount; i++) {\n        NSMutableArray *personArrayForSection = sectionArrays[i];\n        NSArray *sortedPersonArrayForSection = [collation sortedArrayFromArray:personArrayForSection collationStringSelector:@selector(name)];\n        sectionArrays[i] = sortedPersonArrayForSection;\n    }\n\n    NSArray *titleArray = [[[UILocalizedIndexedCollation currentCollation] sectionTitles] copy];\n    NSDictionary *dic = @{@&quot;source&quot;: sectionArrays,\n                          @&quot;title&quot;: titleArray};\n    return dic;\n    }\n</code></pre><p>分析一下上面的代码, 我们使用<code>UILocalizedIndexedCollation</code>提供的方法, 按照A-Z来快读数据进行分组, 并且排序. 索引数组也直接使用<code>UILocalizedIndexedCollation</code>自带的方法.这样就避免了大量的循环遍历和取姓名拼音首字母造成的开销.</p>\n<p>相应的, 列表展示页面的title和索引也要做调整</p>\n<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{\n    if ([self.dataArray[section] count] == 0 || self.dataArray.count == 0) {\n        return 0.01;\n    }\n    return 22;\n}\n\n// 按照索引个数配置tableview区数\n- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {\n    if ([self.dataArray[section] count] == 0 || self.dataArray.count == 0) {\n        return @&quot;&quot;;\n    }\n    return [[UILocalizedIndexedCollation currentCollation] sectionTitles][section];\n}\n\n// 配置索引内容，就是通讯录中右侧的那一列“A~Z、#”\n- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView {\n    return [[UILocalizedIndexedCollation currentCollation] sectionIndexTitles];\n}\n\n// 索引点击响应\n- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index {\n    return [[UILocalizedIndexedCollation currentCollation] sectionForSectionIndexTitleAtIndex:index];\n}\n\n</code></pre><p>至此优化结束, 再通过Time Profiler来分析下发现时间已经从5.8s到2.6s, 优化效果还是很明显的. 2.6s中数组排序大概耗时1.7s, 我们使用的已经是系统推荐的排序方法, 除非采用复杂度更低的排序算法, 这里已经没办法再优化了.</p>\n<p>这里有三种不同实现的排序方法, 测试了下, 优化效果都不明显</p>\n<pre><code>+ (NSArray *)sortedArray:(NSArray *)data {\n    //        NSMutableArray *sortedArray = [NSMutableArray array];\n    //        //对每个section中的数组按照name属性排序\n    //        for (NSInteger index = 0; index &lt; data.count; index++) {\n    //            NSMutableArray *personArrayForSection = data[index];\n    //            NSSortDescriptor *nameDesc    = [NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot;\n    //                                                                          ascending:YES];\n    //            NSArray *descriptorArray = @[nameDesc];//此处可以按照多个排序规则, 顺序比较, 比较的顺序就是数组里面元素的顺序\n    //\n    //            NSArray *temp = [personArrayForSection sortedArrayUsingDescriptors: descriptorArray];\n    //            sortedArray[index] = temp;\n    //        }\n\n\n    NSMutableArray *sortedArray = [NSMutableArray array];\n    for (NSInteger index = 0; index &lt; data.count; index++) {\n        NSMutableArray *personArrayForSection = data[index];\n        NSArray *temp = [personArrayForSection sortedArrayUsingComparator:^NSComparisonResult(AddressBookContact * contact1, AddressBookContact * contact2) {\n            return [contact1.name compare:contact2.name];\n        }];\n        sortedArray[index] = temp;\n    }\n\n\n\n    //    UILocalizedIndexedCollation *collation = [UILocalizedIndexedCollation currentCollation];\n    //    NSMutableArray *sortedArray = [NSMutableArray array];\n    //    //对每个section中的数组按照name属性排序\n    //    for (NSInteger index = 0; index &lt; data.count; index++) {\n    //        NSMutableArray *personArrayForSection = data[index];\n    //        NSArray *sortedPersonArrayForSection = [collation sortedArrayFromArray:personArrayForSection collationStringSelector:@selector(name)];\n    //        sortedArray[index] = sortedPersonArrayForSection;\n    //    }\n    return sortedArray;\n}\n</code></pre><h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><p>至于第二种优化方案, 我们需要借助本地化存储SQL来实现. 当然如果没有本地化存储的需求, 则方案一就够用了.</p>\n<p>因为主要耗时的操作在分组和排序上, 我么你可以利用SQL的快速查找和排序来实现.在3000条左右数据时和方案一的效果差不多, 此处就不再贴代码了, 只提供一下思路.</p>\n<h2 id=\"监听通讯录数据变化\"><a href=\"#监听通讯录数据变化\" class=\"headerlink\" title=\"监听通讯录数据变化\"></a>监听通讯录数据变化</h2><p>此处仍然区分iOS8和iOS9的API, 但是需要注意监听规则:<br>1.当App活跃（前台+后台包活期间）的时候, 当通讯录修改的时候, 会收到通知.<br>2.当App不活跃的时候(挂起的时候), App收不到通知; 而是, 当App到前台的时候收到延迟的通知.<br>3.当App被杀掉进程后, App收不到通知; 当再次进入App时依然没有通知.</p>\n<h3 id=\"ios8监听通讯录变化\"><a href=\"#ios8监听通讯录变化\" class=\"headerlink\" title=\"ios8监听通讯录变化\"></a>ios8监听通讯录变化</h3><pre><code>@property (nonatomic, assign) ABAddressBookRef addresBook;\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        _addresBook = ABAddressBookCreateWithOptions(NULL, NULL);\n        ABAddressBookRegisterExternalChangeCallback(_addresBook, addressBookChanged, nil);\n    }\n    return self;\n}\n\n//监听通讯录变化\nvoid addressBookChanged(ABAddressBookRef addressBook, CFDictionaryRef info, void *context) {\n    NSLog(@&quot;通讯录变化啦....&quot;);\n    //    VC1 *myVC = (__bridge VC1 *)context;\n    //    [myVC getPersonOutOfAddressBook];\n}\n\n- (void)dealloc {\n    NSLog(@&quot;%@-------------------dealloc&quot;, self);\n    ABAddressBookUnregisterExternalChangeCallback(_addresBook, addressBookChanged, nil);\n}\n\n</code></pre><h3 id=\"ios9监听通讯录变化\"><a href=\"#ios9监听通讯录变化\" class=\"headerlink\" title=\"ios9监听通讯录变化\"></a>ios9监听通讯录变化</h3><pre><code>- (instancetype)init {\n    self = [super init];\n    if (self) {\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(addressBookDidChange:) name:CNContactStoreDidChangeNotification object:nil];\n\n    }\n    return self;\n}\n\n\n- (void)dealloc {\n    NSLog(@&quot;%@-------------------dealloc&quot;, self);\n    [[NSNotificationCenter defaultCenter] removeObserver:self name:CNContactStoreDidChangeNotification object:nil];\n}\n\n- (void)addressBookDidChange:(NSNotification*)notification{\n    NSLog(@&quot;通讯录变化啦....&quot;);\n}\n</code></pre><p>参考文档:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/47189c71543b\" target=\"_blank\" rel=\"noopener\">iOS9下全新的通讯录框架</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/94e8444f1ad6\" target=\"_blank\" rel=\"noopener\">iOS学习笔记29-系统服务(二)通讯录</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/6acad14cf3c9\" target=\"_blank\" rel=\"noopener\">iOS通讯录开发</a></p>\n<p>4.<a href=\"https://developer.apple.com/reference/contacts/cncontact\" target=\"_blank\" rel=\"noopener\">CNContact官方文档</a></p>\n<p>5.<a href=\"https://developer.apple.com/reference/addressbook\" target=\"_blank\" rel=\"noopener\">AddressBook官方文档</a></p>\n<p>6.<a href=\"http://www.bijishequ.com/detail/320846?p=\" target=\"_blank\" rel=\"noopener\">UILocalizedIndexedCollation——本地化索引排序</a></p>\n<p>7.<a href=\"http://www.olinone.com/?p=131\" target=\"_blank\" rel=\"noopener\">iOS开发中如何快速的实现汉字转拼音</a></p>\n<p>8.<a href=\"http://www.jianshu.com/p/d0a752bcda3f\" target=\"_blank\" rel=\"noopener\">iOS通讯录数据变化监听</a></p>\n","categories":["基础知识","性能优化"],"tags":["通讯录"]},{"title":"Xcode神器-Instruments大法","url":"http://hchong.net/2017/04/13/Xcode神器-Instruments大法/","content":"<h1 id=\"Xcode调试神器-Instruments大法\"><a href=\"#Xcode调试神器-Instruments大法\" class=\"headerlink\" title=\"Xcode调试神器-Instruments大法\"></a>Xcode调试神器-Instruments大法</h1><p>用户体验, 是每个App开发很重要的点, 是每个程序猿都应该时刻被想到的点. 好的用户体验就必然要有好的性能. Xcode给我们提供了强大的性能分析工具Instruments.</p>\n<p>打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1ffevnub9j1j316s0q2wfd.jpg\" alt=\"Instruments首界面\"><br>这里我们主要介绍三个常用的工具Core Animation(检测帧率), Leaks(内存泄漏), Time Profiler(检查耗时操作)</p>\n<h2 id=\"Core-Animation\"><a href=\"#Core-Animation\" class=\"headerlink\" title=\"Core Animation\"></a>Core Animation</h2><p>Core Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿.<br><img src=\"http://ww1.sinaimg.cn/large/006tNbRwgy1ffffmifexvj310w0nxwfn.jpg\" alt=\"帧率\"><br>在屏幕的下方有一个Debug Options按钮, 点击展开菜单中可以选择一些更加具体的UI性能的检测,<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffffp2z37cj30xk0i474v.jpg\" alt=\"选项\"><br>我们可以使用这些选项，来监测更加具体的图形性能, 具体参考如下:</p>\n<ul>\n<li><code>Color Blended Layers</code>，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。</li>\n<li><code>Color Hits Green and Misses Red</code>，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。</li>\n<li><code>Color Copied Images</code>，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。</li>\n<li><code>Color Non-Standard Surface Formats</code>, 不标准的表面颜色格式.</li>\n<li><code>Color Immediately</code>，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</li>\n<li><code>Color Misaligned Images</code>，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。</li>\n<li><code>Color Offscreen-Rendered Yellow</code>，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。</li>\n<li><code>Color Compositing Fast Path Blue</code>，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。</li>\n<li><code>Flash Updated Regions</code>，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。</li>\n</ul>\n<p>使用时要注意Xcode和手机系统的版本号匹配, 否则会出现设备off line 无法被选中的情况.</p>\n<h2 id=\"Leaks\"><a href=\"#Leaks\" class=\"headerlink\" title=\"Leaks\"></a>Leaks</h2><p>关于内存方面的监控, 有<code>Leaks</code>用来检测内存泄漏, <code>Zombies</code>用来检测僵尸对象. 关于内存泄漏常见的几种情况, <a href=\"http://www.jianshu.com/p/d465831aebbf\" target=\"_blank\" rel=\"noopener\">这里</a>讲的特别清晰和全面.</p>\n<h2 id=\"Time-Profiler\"><a href=\"#Time-Profiler\" class=\"headerlink\" title=\"Time Profiler\"></a>Time Profiler</h2><p>这个主要是用来统计各个方法消耗的时间.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1fffhjy18vij31kw0zi44c.jpg\" alt=\"Time Profiler\"><br>如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的.</p>\n<p>在下方的call Tree中有一些选项菜单, 选择不同的菜单, 可以查看不同的状态, 具体如下:</p>\n<ul>\n<li><code>Separate byt Thread</code>（建议选择）：通过线程分类来查看那些纯种占用CPU最多。</li>\n<li><code>Invert Call Tree</code>（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。</li>\n<li><code>Hide Missing Symbols</code>（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。</li>\n<li><code>Hide System Libraries</code>（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。</li>\n<li><code>Flatten Recursion</code>（一般不选）：选上它会将调用栈里递归函数作为一个入口。</li>\n<li><code>Top Functions</code>（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><p>在调试过程中也遇到一些问题, 记录下来.</p>\n<h3 id=\"设备灰色不可选\"><a href=\"#设备灰色不可选\" class=\"headerlink\" title=\"设备灰色不可选\"></a>设备灰色不可选</h3><p>解决方案：重启<br>我最终的解决步骤：<br>1.拔掉iPhone的USB线，重启iPhone<br>2.关闭Xcode和Instruments<br>3.重新连接iPhone到Mac上<br>4.重启Xcode并启动Profile<br>5.成功</p>\n<p>参考这个<a href=\"http://stackoverflow.com/questions/32878283/unable-to-profile-app-on-device-with-ios-9-0-1-using-xcode-7-7-0-1-or-7-1-beta\" target=\"_blank\" rel=\"noopener\">帖子</a>.</p>\n<h3 id=\"Time-Profiler无法定位到代码\"><a href=\"#Time-Profiler无法定位到代码\" class=\"headerlink\" title=\"Time Profiler无法定位到代码\"></a>Time Profiler无法定位到代码</h3><p>Time Profliter 都是地址符号，往深里也一直是地址符号，根本没法判断是哪些代码的执行时间, 无法定位代码</p>\n<p>解决方法:</p>\n<ol>\n<li>Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File</li>\n<li>Profile要在debug模式下运行, BuildConfiguration要选择debug.</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://blog.leancloud.cn/2835/\" target=\"_blank\" rel=\"noopener\">iOS 性能优化：Instruments 工具的救命三招</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/439e158b44de\" target=\"_blank\" rel=\"noopener\">Instruments性能优化-Core Animation</a></p>\n<p>3.<a href=\"http://www.samirchen.com/use-instruments/\" target=\"_blank\" rel=\"noopener\">使用 Instruments 做 iOS 程序性能调试</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/d465831aebbf\" target=\"_blank\" rel=\"noopener\">关于内存泄漏，还有哪些是你不知道的？</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/c0aa12d91f05\" target=\"_blank\" rel=\"noopener\">使用Instruments定位iOS应用的Memory Leaks</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/21d29be26479\" target=\"_blank\" rel=\"noopener\">instrument Time Profiler总结</a></p>\n<p>7.<a href=\"http://stackoverflow.com/questions/32878283/unable-to-profile-app-on-device-with-ios-9-0-1-using-xcode-7-7-0-1-or-7-1-beta\" target=\"_blank\" rel=\"noopener\">Unable to profile app on device with iOS 9.0.1 using Xcode 7, 7.0.1 or 7.1 beta</a></p>\n","categories":["基础知识"],"tags":["基础知识","调试"]},{"title":"iOS逆向-下载历史版本","url":"http://hchong.net/2017/04/06/iOS逆向-下载历史版本/","content":"<h1 id=\"iOS逆向-下载历史版本\"><a href=\"#iOS逆向-下载历史版本\" class=\"headerlink\" title=\"iOS逆向-下载历史版本\"></a>iOS逆向-下载历史版本</h1><p>目前App Store默认只能下载最新版, 而我们的目的是要能够下载到App Store中的历史版, 那就要借助一些其他工具来实现.<br>原理如下:</p>\n<blockquote>\n<p>通过Charles来获取下载链接, 通过分析来得到每个版本在连接中所对应的字段, 再通过Charles来截取和替换下载链接中的参数, 来达到下载特定版本App的目的.</p>\n</blockquote>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装Charles.</li>\n<li>为了Charles能够抓取HTTPS类型的链接, 需要安装Charles的证书, 参考这里<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.</li>\n</ol>\n<h2 id=\"开始抓包\"><a href=\"#开始抓包\" class=\"headerlink\" title=\"开始抓包\"></a>开始抓包</h2><p>安装了Charles之后, 我们就可以获取App的下载链接了, 并且从中分析出我们需要的参数.</p>\n<h3 id=\"获取APP的下载链接和版本号对应的参数\"><a href=\"#获取APP的下载链接和版本号对应的参数\" class=\"headerlink\" title=\"获取APP的下载链接和版本号对应的参数\"></a>获取APP的下载链接和版本号对应的参数</h3><p>下面我们以iOS上一款比较好用的看书软件<em>追书神器</em>为例来说明.</p>\n<ol>\n<li>首先打开ITunes来下载软件, 点击下载, 通过Charles来确定下载软件的链接.<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4m4udoqj30zo0iwdhx.jpg\" alt=\"点击下载\"></li>\n<li>在Charles中观察发现, ITunes使用的是HTTPS链接, 无法直接查看request内容.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4n5nyodj30f707e74h.jpg\" alt=\"无法直接查看HTTPS\"></li>\n<li>我们通过添加SSL Proxying来查看request内容, 并且通过给链接加断点来详细分析请求的参数.</li>\n</ol>\n<p><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4nt57ykj30b60jr74v.jpg\" alt=\"添加SSL Proxy\"><br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4ogb7edj30bg0lkab0.jpg\" alt=\"添加断点\"></p>\n<h3 id=\"推断控制版本的关键字段\"><a href=\"#推断控制版本的关键字段\" class=\"headerlink\" title=\"推断控制版本的关键字段\"></a>推断控制版本的关键字段</h3><p>观察response, 推断<code>softwareVersionExternalIdentifiers</code>展示的是全部的APP对应的版本, <code>softwareVersionExternalIdentifier</code>是用来标记当前版本.<em>追书神器</em>目前的版本标记是<code>820420814</code><br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4pltv74j310w0qjq5r.jpg\" alt=\"字段分析\"><br>通过在request中搜索<code>820420814</code>发现,<code>appExtVrsId</code>是来标记要下载哪个版本.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4p2c1jqj30be08wwew.jpg\" alt=\"推断关键字\"></p>\n<h3 id=\"修改Request参数下载历史版本\"><a href=\"#修改Request参数下载历史版本\" class=\"headerlink\" title=\"修改Request参数下载历史版本\"></a>修改Request参数下载历史版本</h3><p>我们在<code>softwareVersionExternalIdentifiers</code>中任选一个版本号, 此处我以<code>819147298</code>为例</p>\n<ol>\n<li>删除刚才下载好的软件, 重新下载.</li>\n<li>因为我们在下载链接中加的有断点, 再次下载时Charles会停在断点的位置</li>\n<li>点击<code>Edit Request</code>来编辑<code>appExtVrsId</code>字段<br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4qg1avyj30yf0o60v0.jpg\" alt=\"Edit Request\"></li>\n<li>执行断点, 继续下载.</li>\n<li>在ITunes中看到更新的标志说明下载成功<br><img src=\"https://ww1.sinaimg.cn/large/006tNbRwgy1fel4komzx2j30p00c8t9i.jpg\" alt=\"下载成功\"></li>\n</ol>\n<h2 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h2><p>通过ITunes来安装下载好的软件到手机.</p>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.<br>2.<a href=\"http://www.jianshu.com/p/edfed1b1822c\" target=\"_blank\" rel=\"noopener\">iOS秘籍-下载历史版本App超详细教程</a>.</p>\n","categories":["iOS逆向"],"tags":["Charles","iOS逆向"]},{"title":"使用Jenkins实现持续集成","url":"http://hchong.net/2017/03/23/Jenkins自动化打包/","content":"<h1 id=\"使用Jenkins实现持续集成\"><a href=\"#使用Jenkins实现持续集成\" class=\"headerlink\" title=\"使用Jenkins实现持续集成\"></a>使用Jenkins实现持续集成</h1><p>什么是持续集成, 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>\n<p>常见的持续集成的工具有<a href=\"http://jenkins-ci.org/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>  <a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis</a>  <a href=\"http://hudson-ci.org/\" target=\"_blank\" rel=\"noopener\">Hudson</a>  <a href=\"https://circleci.com/\" target=\"_blank\" rel=\"noopener\">Circle</a>. 然而好多我并没有实践过, 😂. <a href=\"http://www.infoq.com/cn/articles/ios-code-server-jenkins-travis-fastlane\" target=\"_blank\" rel=\"noopener\">这里</a>有一篇文章, 对比讲解了主流iOS持续化集成方案, 包括了Xcode Server.</p>\n<p>Code review, 单元测试, 打包与分发, 这些构成了一个APP开发生命周期. 所以一个完整持续化集成应该包含以上的而全部信息, 这里我们主要讲解一下打包与分发的持续化集成方案. 关于我们为什么选择Jenkins, 而不使用其他的持续化方案, <a href=\"http://www.infoq.com/cn/articles/ios-code-server-jenkins-travis-fastlane\" target=\"_blank\" rel=\"noopener\">这篇文章</a>已经讲解的很清楚了. 下面就跟随我一步步的搭建Jenkins, 实现一个简单但强大的持续化集成方案. 本文均以Jenkins2.35为例.</p>\n<h2 id=\"安装Jenkins\"><a href=\"#安装Jenkins\" class=\"headerlink\" title=\"安装Jenkins\"></a>安装Jenkins</h2><p>首先, 我们要安装Jenkins. 安装Jenkins一般有两种方式. </p>\n<p>第一种我们可以从<a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">官网</a>上下载最新的pkg安装包。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vhnmh9bj30h80c7dgr.jpg\" alt=\"安装步骤1\"></p>\n<p>一路点击继续, 直到安装成功为止.</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vikplwxj30hb0c5q35.jpg\" alt=\"安装完成\"></p>\n<p>第二种方式也可以下载<code>brew install jenkins</code>, 切换到切换到 <code>cd /usr/local/Cellar/jenkins/版本号/libexec/jenkins.war</code>,  然后运行Java -jar jenkins.war，进行安装.<br>注意: 如果brew无效要先安装homebrew, <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>\n<p>安装完成后, 重启电脑, 你会发现多了一个Jenkins的用户, 但是他的登录密码我们并不知道. 我们应该打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>, 此时可以看到Jenkins的初始界面. </p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vod9epvj30yg0jet93.jpg\" alt=\"Jenkins初始界面\"><br>注意, 由于Jenkins是由Java开发的, 所以Jenkins的运行必须是在Java环境下, 如果你打开界面为空白的话, 那就说明你需要安装Java环境了.</p>\n<p>按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录, 由于非Jenkins用户没有查看权限, 所以需要我们右键 -&gt; 显示简介, 给这个文件夹赋予读写权限. 按照提示找到<em>initialAdminPassword</em>文件, 复制出密码，就可以填到网页上去重置密码了.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fh5vsrxh73j30yg0je0t5.jpg\" alt=\"重置密码\"></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fh5vt9bk89j30yg0jemxk.jpg\" alt=\"开始安装\"></p>\n<p>然后一路安装下去, 输入用户名，密码，邮件这些，就算安装完成了。</p>\n<h2 id=\"Jenkins插件配置-amp-系统设置\"><a href=\"#Jenkins插件配置-amp-系统设置\" class=\"headerlink\" title=\"Jenkins插件配置&amp;系统设置\"></a>Jenkins插件配置&amp;系统设置</h2><p>打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>页面, 我们需要安装一些辅助插件, 选择<em>系统管理</em> -&gt; <em>管理插件</em>. 下面我列一下我安装到的一些常用的插件: </p>\n<ul>\n<li><p>GitLab Plugin, Gitlab Hook Plugin. 用于连接到GitLab, 如果你的源码在Gitlab上托管, 这连个插件必须要安装.</p>\n</li>\n<li><p>Xcode integration. 这个看名字就知道必须安装了.</p>\n</li>\n<li><p>Environment Injector Plugin. 自定义全局变量的插件, 必须安装.</p>\n</li>\n<li><p>Keychains and Provisioning Profiles Management. 用于管理钥匙串和描述文件, 必须安装.</p>\n</li>\n<li><p>build timeout plugin. 如果构建超时, 自动停止Jenkins当前的构建, 可选.</p>\n</li>\n<li><p>Email Extension Plugin. 用于发邮件, 可选.</p>\n<h2 id=\"Jenkins打包配置准备工作\"><a href=\"#Jenkins打包配置准备工作\" class=\"headerlink\" title=\"Jenkins打包配置准备工作\"></a>Jenkins打包配置准备工作</h2></li>\n</ul>\n<p>首先, 我们需要明确在这一步我们的目的: 把指定代码的指定分支打包为签名过的IPA包, 并且生成一个可供下载的链接. 那么明确了我们的目的, 接下来就一步一步的来实现它. 打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>页面, 接下来我们开始新建一个打包项目. 点击左侧工具栏<em>新建</em>, 选择<em>构建一个自由风格的软件项目</em>, 注意这里最好使用英文, 不要出现中文和特殊字符.</p>\n<p>进入项目配置页面, 接下来我将从<em>General</em>, <em>源码管理</em>, <em>构建触发器</em>, <em>构建环境</em>, <em>构建</em>, 和<em>构建后操作</em>几个方面来配置打包项目.</p>\n<p>在项目配置之前, 我们需要先配置一些其他全局的变量, 这些变量在项目的配置中会使用到.</p>\n<h3 id=\"gitlab代码地址配置\"><a href=\"#gitlab代码地址配置\" class=\"headerlink\" title=\"gitlab代码地址配置\"></a>gitlab代码地址配置</h3><p>Jenkins系统管理 -&gt; 系统设置 -&gt; Gitlab选项, 因为我们的代码托管在gitlab上面, 所以在这里需要配置相关信息. 点击<em>增加</em>. 填写相关信息.<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fh93xkbelyj31ei0qk75f.jpg\" alt=\"gitlab地址配置\"></p>\n<p>注: 这里会报一个<em>API Token for Gitlab access required</em>的错误, 可以暂时忽略, 是因为gitlab一般都是私有的仓库, Jenkins没有连接的权限导致的.</p>\n<h3 id=\"添加与gitlab连接的证书\"><a href=\"#添加与gitlab连接的证书\" class=\"headerlink\" title=\"添加与gitlab连接的证书\"></a>添加与gitlab连接的证书</h3><p>Jenkins -&gt; Credentials -&gt; Add Credentials, <a href=\"http://localhost:8080/credentials/store/system/domain/_/newCredentials\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/credentials/store/system/domain/_/newCredentials</a>增加一个新的证书, 用来连接gitlab. </p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fh94ryjjgvj31kw0qngml.jpg\" alt=\"连接gitlab的证书\"></p>\n<p><em>kind</em> , <em>Scope</em> 和 <em>Private Key</em> 就按照如图所示选择好. <em>UserName</em> 表示这个证书的名字, <em>ID</em> 自动生成, 用来标记这个证书. <em>Description</em>是关于这个证书的描述. <em>key</em> 那里填写SSH的Private Key, <em>Passphrase</em> 那里填写生成SSH时填写的密码.  <a href=\"https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5\" target=\"_blank\" rel=\"noopener\">关于SSH的申请</a>.</p>\n<p>注意: 这里记得要在你的gitlab的Profile Settings -&gt; SSH Keys中添加上一步生成的Public Key, </p>\n<h3 id=\"添加钥匙串和描述文件\"><a href=\"#添加钥匙串和描述文件\" class=\"headerlink\" title=\"添加钥匙串和描述文件\"></a>添加钥匙串和描述文件</h3><p>在Jenkins -&gt; 系统管理 -&gt; KeyChain and Provisioning Profiles Management 中添加 keychains 和 Provisioning Profile文件.<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fha7tvmt2uj30yg08ljrq.jpg\" alt=\"添加钥匙串和描述文件\"></p>\n<p>分别上传keychains 和 Provisioning Profile.</p>\n<ul>\n<li><p>keychains的路径在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。</p>\n</li>\n<li><p>Provisioning Profiles文件在~/Library/MobileDevice/Provisioning Profiles 目录下, 这里面可能会有许多描述文件, 找到我们需要的, 上传并且拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下.</p>\n</li>\n</ul>\n<p>注: 如果 Jenkins 下保存 keychain 和 Provision profile 的目录不存在可以手动创建. 我们可以邮件查看要打包工程*.xcodeproj的包内容, 查看project.pbxproj文件, 通过搜索找到描述文件的ID, 再在~/Library/MobileDevice/Provisioning Profiles文件夹中根据ID来找到具体的描述文件.</p>\n<h3 id=\"Xcode-Builder\"><a href=\"#Xcode-Builder\" class=\"headerlink\" title=\"Xcode Builder\"></a>Xcode Builder</h3><p>在Jenkins -&gt; 系统设置 -&gt; Xcode Builder -&gt; 新增, 如下图所示.<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fha9gi02fyj30nu0fz74v.jpg\" alt=\"Xcode Builder\"></p>\n<p>Keychain Name是要打包的证书的名字, 在钥匙串中找到该证书, 点击右键 显示简介, 复制过来就好.</p>\n<p>Keychain password是开机密码.</p>\n<h2 id=\"Jenkins打包配置\"><a href=\"#Jenkins打包配置\" class=\"headerlink\" title=\"Jenkins打包配置\"></a>Jenkins打包配置</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fha9o70e7wj31kw0t4758.jpg\" alt=\"Jenkins打包工程的配置\"></p>\n<h3 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h3><p>配置一些通用的选项. 项目名称和项目描述如其字面意思一样. <code>GitLab connection</code>是源码的地址, 在外面配置好的选项, 在这里可选.</p>\n<ul>\n<li><p>节流构建，通过设置时间段内允许并发的次数来实现构建的控制</p>\n</li>\n<li><p>丢弃旧的构建, 按需选择.</p>\n</li>\n<li><p>参数化构建过程, 在Jenkins开始打包之前, 填写需要你传入的参数.</p>\n</li>\n<li><p>关闭构建, 在必要的时候并发构建. 可选</p>\n</li>\n</ul>\n<h2 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h2><p>根据自己的实际需求, 不管是SVN或者Git. 因为我使用的是Git, 在一开始安装了Git管理的插件, 所以这里选择Git.<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fhab3vad6rj30tm0f3q3d.jpg\" alt></p>\n<ol>\n<li><p>这里的 <em>Credentials</em> 如果使用的是SSH模式, 那上面的 <em>Repository URL</em>就要使用SSH类型的地址. 如果是账号密码模式, 那上面的源码就要使用HTTP形式的地址. 两者必须保持一致.</p>\n</li>\n<li><p>指定代码, 我们可以拉取指定git地址的代码. 因为分支是个变量, 它不像git地址那样一成不变, 所以最好是外部传入, 那就用到了全局环境变量. </p>\n</li>\n</ol>\n<h2 id=\"构建触发器\"><a href=\"#构建触发器\" class=\"headerlink\" title=\"构建触发器\"></a>构建触发器</h2><p>构建触发器是设置自动化构建的地方, 如果想设置自动化构建, 例如监测到git有更新就打包, 或者每隔固定时间就打一次包.</p>\n<ul>\n<li><p>Poll SCM (poll source code management) 轮询源码管理. 需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次</p>\n</li>\n<li><p>Build periodically (定时build) 一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的.</p>\n</li>\n</ul>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fhfrpjn2twj31kw0cegma.jpg\" alt=\"构建触发器\"></p>\n<h2 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h2><p>构建环境, 主要是对构建时一些环境变量的配置.<br><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fhgvjboomwj31a60eujrv.jpg\" alt=\"构建环境\"></p>\n<p>在该模块中 主要设置 xcode build 打包时需要的 keychains 和 Provision Profiles 配置文件。<br>如果不配置 就会使用 xcode 自动的配置，来去系统中查找相应的配置，不过有一点需要注意,就是钥匙串中，登陆钥匙串中的证书 要复制到 系统钥匙串中，因为jenkins 访问的是系统中的钥匙串 这样在第一次打包的时候，会提示 是否授权访问钥匙串，点击始终允许就可以了。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fhjnx3dnwvj31gg0jo755.jpg\" alt=\"Keychains and Code Signing Identities\"><br><em>Keychains and Code Signing Identities</em> 中的选项, 因为在前面已经选择过了 <em> Keychain </em> 和 <em>Code Signing Identity</em>在前面已经填写过, 此处只用根据当前工程来选择正确的选项.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fhjo37irdyj31g20hojs1.jpg\" alt=\"Mobile Provisioning Profiles\"></p>\n<p><em>Mobile Provisioning Profiles</em>由于前面已经填写过描述文件, 此处只需要选择与当前打包工程相匹配的描述文件.</p>\n<h2 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h2><p>在这里才进入了自动化集成的关键步骤, 前面的都是一些准备工作. 我们选择<em>增加构建步骤</em>, 按照自己的实际需求, 选择打包脚本的类型. 因为Jenkins自带Shell脚本集成, 所以此处我选择<em>Execute shell</em>, 使用shell脚本来进行构建.</p>\n<pre><code>export PATH\n#######执行脚本命令#######\nrm -rf Users/Shared/Jenkins/Library/ipa/JenkinsTest/JenkinsTest.ipa\nsecurity unlock-keychain  -p &quot;HChong&quot; ~/Library/Keychains/login.keychain\nsh /Users/Shared/Jenkins/Library/BuildScript/build.sh JenkinsTest 4c86cf7c8b4d00013c59b30b0c8d5e77\nfir p /Users/Shared/Jenkins/Library/ipa/JenkinsTest/JenkinsTest.ipa -T 4c86cf7c8b4d00013c59b30b0c8d5e77\n</code></pre><p>shell脚本的具体内容如下</p>\n<pre><code>#!/bin/bash\n\n#=================项目路径配置===============\nPROJECT_PATH=&#39;/Users/Shared/Jenkins/Home/workspace/iOSPackage&#39;\nWORKSPACE_NAME=&#39;JenkinsTest.xcworkspace&#39;\nArchive_PATH=&#39;/Users/Shared/Jenkins/Library/archive&#39;\nIPA_PATH=&#39;/Users/Shared/Jenkins/Library/ipa&#39;\nPLIST_PATH=&#39;/Users/Shared/Jenkins/Home/workspace/iOSPackage/exportArchive.plist&#39;\n\n\n#===================================脚本开始=================================================\n#使用帮助\nif [ $# == 0 ];then\necho &quot;===========================如何使用=============================&quot;\necho &quot; eg: ./build [scheme] [token] &#39;版本描述中间不要留空格&#39;, 不传token默认用当前已经登录的fir token&quot;\necho &quot; scheme list:&quot;\necho &quot; JenkinsTest&quot;\necho &quot; token list:&quot;\necho &quot;================================================================&quot;\nexit\nfi\n\n#update code from gitlab\ncd $PROJECT_PATH\n#git pull\n\n#update pod\n#pod install --repo-update\n#pod update\n\n#删除旧的编译目录\nAPP_BUILD_LOCATION=${PROJECT_PATH}/Build/\nrm -rf ${APP_BUILD_LOCATION}\n#创建dfc目录\n\n#key auth\nsecurity unlock-keychain &quot;-p&quot; &quot;钥匙串密码&quot; &quot;/Users/hc/Library/Keychains/login.keychain&quot;\n\n#创建ARCHIVE目录\nmkdir -p IPA_PATH\n#Archive_NAME = $1.xcarchive\n\n#开始打包\ncd ${PROJECT_PATH}\npwd\n\nXCCONFIG_PATH=${PROJECT_PATH}/dfc_v2/appconfig\n\n#xcodebuild -workspace ${WORKSPACE_NAME} -scheme Enterprise -xcconfig ${XCCONFIG_PATH}/$1.xcconfig -archivePath ${Archive_PATH}/$1.xcarchive archive\nxcodebuild -workspace ${WORKSPACE_NAME} -scheme $1 -config $1 -archivePath ${Archive_PATH}/$1.xcarchive archive\necho &quot;--------------------------------------------&quot;${Archive_PATH}/$1.xcarchive\n\n#创建ipa\nIPA_LOCATION=${IPA_PATH}/$1\n\n#删除旧的ipa\nrm -rf IPA_LOCATION\nmkdir -p ${IPA_PATH}/$1\nxcodebuild -exportArchive -exportOptionsPlist ${PLIST_PATH} -archivePath ${Archive_PATH}/$1.xcarchive -exportPath ${IPA_LOCATION}\n\n\nIPA_FILE_LOCATION=${IPA_PATH}/$1/$1.ipa\n\n#检查ipa是否创建成功\nif [ -f $IPA_FILE_LOCATION ]; then\necho &quot;ipa已经创建:&quot;${IPA_FILE_LOCATION}\nelse\necho &quot;打包失败&quot;\nexit 0\nfi\n\n</code></pre><h2 id=\"构建后的操作\"><a href=\"#构建后的操作\" class=\"headerlink\" title=\"构建后的操作\"></a>构建后的操作</h2><p>顾名思义, 就是构建之后进行的操作. 在这里我们可以选择<em>Execute a set of scripts</em>, 通过脚本来实现构建后的操作. 常见的是将构建的结果, 上传到内测平台或者内部下载地址. 但是如果构建操作的脚本中包含有这一项, 这一个步骤也就可以忽略掉了.</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><h3 id=\"找不到Fir命令\"><a href=\"#找不到Fir命令\" class=\"headerlink\" title=\"找不到Fir命令\"></a>找不到Fir命令</h3><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fhjsalg3fej31b80cewfp.jpg\" alt=\"找不到Fir命令\"><br>出现如图所示的Error, 一般是由于没有安装fit-cli命令导致, 通过安装<code>gem install fir-cli -V --no-ri --no-rdoc</code>来解决. 如果提示安装成功, 但是还是报错的话, 那就在安装命令前加上<code>sudo</code>, 覆盖安装即可.</p>\n<h3 id=\"fir-cli-jenkins-fir-command-not-found\"><a href=\"#fir-cli-jenkins-fir-command-not-found\" class=\"headerlink\" title=\"fir-cli jenkins fir:command not found\"></a>fir-cli jenkins fir:command not found</h3><p>这个错误是由于没有导入fir-cli安装目录导致的, 可以先在终端输入<code>echo $PATH</code>, 然后把输出结果复制下来, 在Jenkins -&gt; 系统管理 -&gt; 添加全局变量. 然后在工程构建步骤, 先引入全局变量<code>export ${PATH}</code>. 如果没有设置全局变量的话, 也可以直接使用<code>export PATH=</code>echo $PATH 的输出结果<code></code></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fhk9pyt7nsj31dg0cmwen.jpg\" alt=\"添加Path全局变量\"></p>\n<h3 id=\"证书配置文件没有找到\"><a href=\"#证书配置文件没有找到\" class=\"headerlink\" title=\"证书配置文件没有找到\"></a>证书配置文件没有找到</h3><p>No iOS profile matching ‘xxxxxx/xxxxxxx’ found:Xcode couldn’t find a profile<br>matching ‘xxxxxx/xxxxxxx’.<br>Install the profile (by dragging and dropping it onto Xcode’s dock item)<br>or select a different one in the General tab of the target editor.<br>Code signing is required for product type ‘Application’ in SDK ‘iOS 10.3’ </p>\n<p>是因为Archive时没有找到profile导致的. 解决办法是, 把系统的<code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code>整个Provisioning Profiles文件夹复制到<code>/Users/Shared/Jenkins/Library/MobileDevice</code>目录下, 并且在Jenkins -&gt; Keychains and Provisioning Profiles Management 的Provisioning Profiles Directory Path中, 设置好profile的存放目录.</p>\n<h3 id=\"Command-usr-bin-codesign-failed-with-exit-code-1\"><a href=\"#Command-usr-bin-codesign-failed-with-exit-code-1\" class=\"headerlink\" title=\"Command/usr/bin/codesign failed with exit code 1\"></a>Command/usr/bin/codesign failed with exit code 1</h3><h2 id=\"这个是由于没有给钥匙串开锁权限导致-编译之前添加-security-unlock-keychain-p-quot-你的密码-quot-quot-path-to-keychain-login-keychain-quot-解决\"><a href=\"#这个是由于没有给钥匙串开锁权限导致-编译之前添加-security-unlock-keychain-p-quot-你的密码-quot-quot-path-to-keychain-login-keychain-quot-解决\" class=\"headerlink\" title=\"这个是由于没有给钥匙串开锁权限导致, 编译之前添加 security unlock-keychain -p &quot;你的密码&quot; &quot;path to keychain/login.keychain&quot;解决.\"></a>这个是由于没有给钥匙串开锁权限导致, 编译之前添加 <code>security unlock-keychain -p &quot;你的密码&quot; &quot;path to keychain/login.keychain&quot;</code>解决.</h2><h2 id=\"待解决\"><a href=\"#待解决\" class=\"headerlink\" title=\"待解决\"></a>待解决</h2><p>使用Tomcat, 把Jenkins发布出去, 这个是下一步要解决的问题.<br>参考文章:</p>\n<p>1.<a href=\"https://runningyoung.github.io/2016/04/01/2016-04-05-jenkins2/\" target=\"_blank\" rel=\"noopener\">iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 2)</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/c69deb29720d\" target=\"_blank\" rel=\"noopener\">一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e19c8327b167\" target=\"_blank\" rel=\"noopener\">Jenkins/git/KeyChains &amp; Provisioning, 记录CI中的一些坑</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/e19c8327b167\" target=\"_blank\" rel=\"noopener\">使用 Jenkins 持续集成 iOS 项目时碰到的一些问题</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/41ecb06ae95f\" target=\"_blank\" rel=\"noopener\">手把手教你利用Jenkins持续集成iOS项目</a></p>\n","categories":["自动化打包","持续集成"],"tags":["自动化打包","Jenkins","持续集成"]},{"title":"多渠道包和多环境包的自动化实现","url":"http://hchong.net/2017/03/12/多Target实现/","content":"<h1 id=\"多渠道包和多环境包的自动化实现\"><a href=\"#多渠道包和多环境包的自动化实现\" class=\"headerlink\" title=\"多渠道包和多环境包的自动化实现\"></a>多渠道包和多环境包的自动化实现</h1><p>在App的开发过程中, 肯定会有很多后台环境的区分. 例如开发时, 我们用的是开发环境. 测试时使用的是测试环境. 在预发布之前肯定要有个缓冲的环境, 也就是预发布环境. 最后还有一个线上的环境, 也称为生产环境. 那么这么多环境, 问题就来了, 该怎么在各个环境之间无缝切换呢?  </p>\n<p>首先我们会想到在代码中建一个单独的类, 把用到的所有服务按照环境列一个遍, 每次需要运行什么环境就按照什么环境从类里面去取相关环境代码. 于是有了方案一.</p>\n<h2 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h2><p>方案一的伪代码, 大概是这个样子的:</p>\n<pre><code class=\"objective-c\">+ (void)getHttpHostWithStatus:(NSInteger)status {\n    switch (status) {\n        case 0: {\n            Host1 = @&quot;开发环境&quot;;\n            Host2 = @&quot;开发环境&quot;;\n        }\n            break;\n        case 1: {\n            Host1 = @&quot;测试环境&quot;;\n            Host2 = @&quot;测试环境&quot;;\n        }\n            break;\n        case 2: {\n            Host1 = @&quot;预发布环境&quot;;\n            Host2 = @&quot;预发布环境&quot;;\n        }\n            break;\n        case 3: {\n            Host1 = @&quot;线上环境&quot;;\n            Host2 = @&quot;线上环境&quot;;\n        }\n            break;\n        default:\n            break;\n    }\n}\n</code></pre>\n<p>在App每次启动时调用这个方法, 来获取各个Host的地址, 完美解决. </p>\n<p>测试每次想要个新的包来测试, 都会有如下对话, “帮我打个包吧”, “你要什么环境的”, “预发环境”, “好的”. 于是 ,我们一同操作, 传入预发的status, 调用动态取Host的方法, 然后Product-&gt;Archive, 等个十几二十分钟, 打包完毕, 生成一个IPA文件, 自己拿ITunes安装. 嗯, 虽然辛苦点, 但是目前看来, 一切都很完美嘛, 打包的时候还能喝个茶.</p>\n<p>然而, 随着我司测试流程的规范化, 逐渐推进使用<a href>Jenkins持续集成</a>来打包, 那么问题就来了. 你让测试也装个Xcode, 每次切换一下环境, 手动Archive吗, 呵呵. 于是我们有了方案二.</p>\n<h2 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h2><p>我们先来理一下方案二主要解决的问题: <em>测试要能够在不改代码的前提下使用Jenkins打不同环境的包</em>. 听起来有点复杂呢, 我们来逐个分析下.</p>\n<ol>\n<li>使用Jenkins来打包, 那就是跑脚本嘛, xcodebuild已经寂寞难耐.</li>\n<li>既然搞Jenkins了, 不能再用IPA自己安装的方式了, Low, 蒲公英和Fir简直不要太方便.</li>\n<li>既然要用脚本来打包了, 那不能每次跑脚本之前, 先改一下代码吧, 于是想到我们应该有一个参数来在工程中区分不同的环境, </li>\n</ol>\n<p>以上就是我们方案二要解决的主要问题, 下面我们来逐个分析和解决.</p>\n<h3 id=\"打包脚本\"><a href=\"#打包脚本\" class=\"headerlink\" title=\"打包脚本\"></a>打包脚本</h3><p>关于打包的脚本, 版本很多, 有Python流, 有Shell流, 可以<a href>参考这里</a>. 但说到底, 无非用的是xcodebuild来实现的, 在终端中输入<code>xcodebuild -help</code>可以查看xcodebuild的相关操作<a href=\"http://www.jianshu.com/p/4f4d16326152\" target=\"_blank\" rel=\"noopener\">这篇文章</a>将的也比较全面, 可以参考下.</p>\n<p>在这里, 我们主要用到的命令有两个.</p>\n<pre><code class=\"objective-c\">//编译\nxcodebuild -workspace &lt;workspacename&gt; -scheme &lt;schemeName&gt; [-destination &lt;destinationspecifier&gt;]... [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...\n\n//生成IPA\nxcodebuild -exportArchive -archivePath &lt;xcarchivepath&gt; -exportPath &lt;destinationpath&gt; -exportOptionsPlist &lt;plistpath&gt;\n</code></pre>\n<p>到这一步, 我们的打包脚本仅仅完成了第一步, 生成了IPA文件. </p>\n<h3 id=\"内测分发平台\"><a href=\"#内测分发平台\" class=\"headerlink\" title=\"内测分发平台\"></a>内测分发平台</h3><p>生成IPA之后, 我们要提供一个可供下载安装的链接. 此处我们使用的是<a href=\"https://fir.im/\" target=\"_blank\" rel=\"noopener\">Fir</a>, 它提供的也有<a href=\"https://github.com/FIRHQ/fir-cli/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">命令行操作</a>, 可以直接上传IPA文件, 生成可供下载的二维码.👍</p>\n<p>当然有条件的公司也可以自己搭建一个下载地址, 制作一个管理后台, 用来管理自己的内测.</p>\n<h3 id=\"APP配置多个环境变量\"><a href=\"#APP配置多个环境变量\" class=\"headerlink\" title=\"APP配置多个环境变量\"></a>APP配置多个环境变量</h3><p>接下来这个, 才是本次解决方案的重点, 明确了我们的目的, 就是配置多环境变量, 那么我们就开始吧. 关于多环境变量的配置, 冰霜大神的<a href=\"http://www.jianshu.com/p/83b6e781eb51\" target=\"_blank\" rel=\"noopener\">这篇文章</a>讲解的比较详细. 但是我们采用的方案和他的又略有区别, 一开始我们使用的是多Target的方式, 后来感觉不够轻量化, 并且每个Target的Seeting也基本你没有大的不同, 于是就采用了多Scheme的方式来解决.</p>\n<p>具体步骤如下:<br>1.新建Scheme. 注意这里一定要把Scheme的名字和编译方式区分开，选择了一个Scheme，只是相当于选择了一个环境，并不是代表这Debug还是Release, 此处以<code>PrePublish</code>为例.<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8ovbi6rj318o0aq0t6.jpg\" alt=\"新建Scheme\"></p>\n<p>2.新建xcconfig文件, 名字与Scheme对应. 在新建时, 一定要在Target那里勾选上(默认是非勾选状态).<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8qe5nx2j313k13umy6.jpg\" alt=\"新建xcconfig\"></p>\n<p>3.Project -&gt; Info -&gt; Configurations 新建Configurations文件. 注意, 如果有使用Pod的话, 此处需要立马执行<code>pod install</code>, 生成对应的Pod的xcconfig文件<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8s76f92j318u0h2aap.jpg\" alt=\"新建Configurations\"></p>\n<p>4.修改Configurations文件, 使之与对应的Scheme相关联.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1ffl8vld5eyj31c00g4mxp.jpg\" alt=\"修改Configurations\"></p>\n<p>5.Edit Scheme<br><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgy1ffl92zbnlhj31ds0s0q3p.jpg\" alt=\"Edit Scheme\"></p>\n<p>6.编辑PrePublish.xcconfig文件, 设置自定义字段. 具体如下:</p>\n<pre><code>#include &quot;Pods/Target Support Files/Pods-MultipleChannel/Pods-MultipleChannel.prepublish.xcconfig&quot;\n\nHOST1 = @&quot;HOST1/PrePublish&quot;\n\nHOST2 = @&quot;HOST2/PrePublish&quot;\n\nGCC_PREPROCESSOR_DEFINITIONS = $(inherited) HOST2=&#39;$(HOST2)&#39; HOST1=&#39;$(HOST1)&#39;\n</code></pre><p>注意, 此处必须要引入<code>pod install</code>生成的对应的Pod的xcconfig, 否则会报错.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1ffl9102hzij30ji0aoglq.jpg\" alt=\"报错\"><br>7.Manage Schemes</p>\n<p>因为一般是多人合作开发, 所以此处的Scheme需要设置为Share状态<br><img src=\"http://ww1.sinaimg.cn/large/006tNbRwgy1ffl969kivwj316o0o0jrt.jpg\" alt></p>\n<p>至此, 已经可以在工程中使用我们在xcconfig中自定义的字段了. 因为我们使用了<code>GCC_PREPROCESSOR_DEFINITIONS</code>, 他会在编译时生成一个宏定义, 所以我们可以直接使用宏定义</p>\n<pre><code>NSLog(@&quot;----------%@&quot;, HOST1);\nNSLog(@&quot;----------%@&quot;, HOST2);\n</code></pre><p>注: 此外, 还有另外一种使用方式. 我们可以每个Scheme新建一个plist(也可使用Info.plist)文件与之对应, 在plist文件中新增<code>key-value</code>来与xcconfig中的自定义字段对应.</p>\n<p>使用方法如下:</p>\n<p>1.在plist中新增与xcconfig中自定义字段对应的<code>key-value</code><br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl9dzmseoj310y0nqjsm.jpg\" alt=\"plist文件新增\"></p>\n<p>2.使用方式如下:</p>\n<pre><code>    NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];\n    NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithContentsOfFile:bundlePath];\n    NSLog(@&quot;----------%@&quot;, [dict objectForKey:@&quot;HOST1&quot;]);\n    NSLog(@&quot;----------%@&quot;, [dict objectForKey:@&quot;HOST2&quot;]);\n</code></pre><p>至此, 我们已经实现不同Scheme下, 参数的动态化配置的两种方案, 下面我们分析下原理:</p>\n<p>首先, 我们先来区分一下Xcode Workspace、Xcode Scheme、Xcode Project、Xcode Target、Build Settings 这5者的关系, 由于篇幅较长, <a href=\"http://hchong.net/2017/05/16/Settings%E5%85%B3%E7%B3%BB/\">另开一文</a>.<br>这5者的关系在苹果官方文档上其实都已经说明的很清楚了。详情见文档<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html\" target=\"_blank\" rel=\"noopener\">Xcode Concepts</a>。 </p>\n<p>总结起来, 一个Workspace可以包含多个Project,一个Project可以包含多个Target，Scheme包含了所有的Target集合，这个集合指定了，编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等.</p>\n<p>xcconfig文件是一个用来保存Build Settings键值对的纯文本文件, 这些键值对会覆盖Build Settings中的值. xcconifg支持可以根据不同的Configuration选项配置不同的文件. 不同的xcconfig可以指定不同的Build Settings里的属性值.</p>\n<h2 id=\"方案三\"><a href=\"#方案三\" class=\"headerlink\" title=\"方案三\"></a>方案三</h2><p>我们的初衷是用这个来动态配置App的环境. 既然已经可以通过xcconfig和Scheme来配合修改Build Seetings的值, 那么就会有一些更加高级的玩法. 例如我们可以在<code>Images.xcassets</code>中新建新的icon和launch Image的分类, 通过<code>ASSETCATALOG_COMPILER_APPICON_NAME</code>和<code>ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME</code>中的设置, 以及<code>Display Name</code>,<code>Bundle Identifier</code>, <code>Provisioning Profile</code>等一些配置(此处Build Settings中的值可以直接<code>command + C</code>来copy)来管理大量的相似APP.</p>\n<p>Info.plist中的值, 需要在Value中使用${Value}来动态配置, 参考域名的配置.</p>\n<p>xcconfig还能动态配置Build Settings里面的很多参数。这其实类似于cocopods的做法。但是有一个大神的做法很优雅。值得大家感兴趣的人去学习学习。iOS大神Justin Spahr-Summers的开源库提供了一个类权威的<a href=\"https://github.com/jspahrsummers/xcconfigs\" target=\"_blank\" rel=\"noopener\">模板</a>.</p>\n<p>那么伴随着业务的发展, 就有有问题了. 如果我想管理大量相似的APP, 每次发布新版本, 我就要打N多个新包. 每次跑脚本, 数量多了时间也很长, 那这就不是一杯茶的功夫了, 甚至要一两个小时. 并且我还要管理N多个Scheme, 这些Scheme明明只有很少的差别, 真的好烦啊. 有没有更加优雅的解决方案呢, 来看下方案四.</p>\n<h2 id=\"方案四\"><a href=\"#方案四\" class=\"headerlink\" title=\"方案四\"></a>方案四</h2><p>首先, 还是先来明确下我们这个方案要解决的问题:</p>\n<ol>\n<li>Scheme太多, 每个渠道一个Scheme, 管理起来费劲.</li>\n<li>新版本发布时, 各个渠道的包, 跑脚本跑到手软.</li>\n</ol>\n<hr>\n<p>附件下载地址:</p>\n<p>1.<a href>打包脚本</a>    </p>\n<p>2.<a href=\"https://github.com/HChong3210/MultipleChannel\" target=\"_blank\" rel=\"noopener\">Demo</a>    </p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/4f4d16326152\" target=\"_blank\" rel=\"noopener\">xcodebuild命令说明</a></p>\n<p>2.<a href=\"https://fir.im/\" target=\"_blank\" rel=\"noopener\">Fir.im</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/83b6e781eb51\" target=\"_blank\" rel=\"noopener\">手把手教你给一个iOS app配置多个环境变量</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/9a6f3019d81f\" target=\"_blank\" rel=\"noopener\">Xcode 配置文件 xcconfig</a></p>\n<p>5.<a href=\"http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/\" target=\"_blank\" rel=\"noopener\">Xcode使用xcconfig文件配置环境</a></p>\n<p>6.<a href=\"http://blog.csdn.net/vbirdbest/article/details/53454014\" target=\"_blank\" rel=\"noopener\">iOS Xcode使用xcconfig配置环境参数(Debug&amp;Release)</a></p>\n<p>7.<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a></p>\n","categories":["自动化打包"],"tags":["自动化打包","Target"]},{"title":"Charles抓包Https请求","url":"http://hchong.net/2017/02/28/Charles抓包Https请求/","content":"<h1 id=\"Charles抓包HTTPS请求\"><a href=\"#Charles抓包HTTPS请求\" class=\"headerlink\" title=\"Charles抓包HTTPS请求\"></a>Charles抓包HTTPS请求</h1><p>有时我们会对手机里面的App进行一些分析, 产看App的请求包, 这时我们就需要祭出神器<a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">Charles</a>了.<br>下面跟着我来教你从零开始抓取App的请求包.</p>\n<h2 id=\"安装Charles\"><a href=\"#安装Charles\" class=\"headerlink\" title=\"安装Charles\"></a>安装Charles</h2><p>这个纯属占坑(废话).</p>\n<h2 id=\"抓取HTTP请求\"><a href=\"#抓取HTTP请求\" class=\"headerlink\" title=\"抓取HTTP请求\"></a>抓取HTTP请求</h2><p>我们先拿一个简单的HTTP请求来练一下手.</p>\n<h3 id=\"查看本地IP地址和Charles端口号\"><a href=\"#查看本地IP地址和Charles端口号\" class=\"headerlink\" title=\"查看本地IP地址和Charles端口号\"></a>查看本地IP地址和Charles端口号</h3><p>查看IP地址的方法比较多, 这里只介绍两种比较常用的:</p>\n<ol>\n<li>可以在网络偏好设置-&gt;高级-&gt;TCP/IP下查看对应网络的IP.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd5z8oku1vj311a0lwgpb.jpg\" alt=\"网络偏好设置中查看\"></li>\n<li>option+左键单击屏幕上方的WiFi标志也可以查看.<br> <img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65kx0mjhj308c0eft9q.jpg\" alt=\"option+左键查看\"></li>\n</ol>\n<h3 id=\"查看Charles的端口号\"><a href=\"#查看Charles的端口号\" class=\"headerlink\" title=\"查看Charles的端口号\"></a>查看Charles的端口号</h3><p>打开Charles-&gt;Proxy-&gt;Proxy Settings查看端口号, 默认一般是<code>8888</code>. 注意不要随意修改端口号, 以避免被占用.</p>\n<h3 id=\"在iPhone中设置\"><a href=\"#在iPhone中设置\" class=\"headerlink\" title=\"在iPhone中设置\"></a>在iPhone中设置</h3><p>打开手机, 连上WiFi, 注意此处的WiFi最好和Mac连接的WiFi是同一个, 避免出现不在一个网段的情况.<br>打开设置-&gt;无线局域网-&gt;点击对应WiFi后的更多.<br><img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd65mobyrjj30b40jrq3k.jpg\" alt=\"WiFi列表\"><br>点击手动, 设置HTTP代理地址(与Mac的IP地址一致)和端口号(与Charles中代理的端口号一致)<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65mo3y0aj30b40jrmxm.jpg\" alt=\"设置HTTP代理地址和端口号\"></p>\n<p>至此, 就可以轻松的抓取App中的HTTP请求啦.</p>\n<h2 id=\"抓取HTTPS请求\"><a href=\"#抓取HTTPS请求\" class=\"headerlink\" title=\"抓取HTTPS请求\"></a>抓取HTTPS请求</h2><p>HTTPS的请求抓取, 略微复杂, 他的原理大致是这样的.</p>\n<blockquote>\n<p>Charles能进行https协议抓包分析，是使用了中间人代理的方法（man-in-the-middle，也常作为一个黑客攻击手段）。Charles代替你的app接受server的证书，然后使用这个证书通过SSL和server通信；同时，Charles会动态的生成一个对应的证书（用Charles的CA证书签名），然后使用这个证书和你的app通信，这样就完成了一个中间人代理，从而可以把app和server的https包给抓到和解码出来。</p>\n</blockquote>\n<p>从里面我们可以看到一些关键字: <code>证书</code>, <code>代理</code>, 等. 那么我们就通过这些手段来抓取HTTPS的请求.</p>\n<h3 id=\"设置代理地址和端口号\"><a href=\"#设置代理地址和端口号\" class=\"headerlink\" title=\"设置代理地址和端口号\"></a>设置代理地址和端口号</h3><p>这一步骤, 和抓取HTTP的方法一样, 这里不再赘述, 需要设置端口号和IP地址.</p>\n<h3 id=\"Mac安装证书\"><a href=\"#Mac安装证书\" class=\"headerlink\" title=\"Mac安装证书\"></a>Mac安装证书</h3><p>安装Charles的证书到Mac, 信任该证书, 以便Charles能够通过该证书进行通信. 具体步骤如下: </p>\n<ol>\n<li>打开Charles, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd607vw0k6j30pk094gmj.jpg\" alt=\"安装根证书\"></li>\n<li>信任该证书<br><img src=\"http://upload-images.jianshu.io/upload_images/1552510-461959c476a2d9d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书不被信任时\"></li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1552510-8c43e95be0a35b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"信任Charles证书\"></p>\n<h3 id=\"iPhone安装证书\"><a href=\"#iPhone安装证书\" class=\"headerlink\" title=\"iPhone安装证书\"></a>iPhone安装证书</h3><p>安装Charles证书到手机, 信任该证书, 以便Charles能够截获网络请求. 具体步骤如下:</p>\n<ol>\n<li>在Charles中, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser, 来查看当前IP地址下, 手机下载证书的网址.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd60jpjcgvj30nx094my0.jpg\" alt=\"步骤一:选择生成手机下载证书的网址\"></li>\n<li>在手机中用Safari打开网址(如图所示的网址)<br> <img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd60l2cz81j30nz06t3yl.jpg\" alt=\"步骤二:输入生成的网址\"></li>\n<li>打开网址后自动跳转到证书安装界面, 安装并信任该证书.<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd65rnpokjj30b40jrgly.jpg\" alt=\"步骤三:安装并信任该证书\"></li>\n<li>打开Charles选择Proxy-&gt;SSL Proxying Settings-&gt;SSL Proxying(因为Charles默认是不会抓取任何域名下的HTTPS, 所以需要我们添加域名到Location下)勾选Enable SSL Proxying, 单击Add, 添加域名和端口(用*来表示所有).<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd60zndgejj30gj0cb0st.jpg\" alt=\"步骤四:设置抓取的域名和端口\"></li>\n</ol>\n<p>至此, 我们再打开手机App就会发现, 之前<code>Unknown</code>的HTTPS接口, 就都可以正常现实啦.</p>\n<p>参考资料:<br>1.<a href=\"http://www.jianshu.com/p/a0215dd2047f\" target=\"_blank\" rel=\"noopener\">HTTP/HTTPS抓包工具Charles</a><br>2.<a href=\"http://www.jianshu.com/p/a83b19a36a8b\" target=\"_blank\" rel=\"noopener\">使用Charles进行https抓包</a><br>3.<a href=\"http://blog.devtang.com/2015/11/14/charles-introduction/\" target=\"_blank\" rel=\"noopener\">Charles 从入门到精通</a></p>\n","categories":["iOS逆向"],"tags":["逆向","安全","Charles"]},{"title":"统计打点的AOP实现","url":"http://hchong.net/2017/02/13/统计打点的AOP实现/","content":"<h1 id=\"统计打点的AOP实现\"><a href=\"#统计打点的AOP实现\" class=\"headerlink\" title=\"统计打点的AOP实现\"></a>统计打点的AOP实现</h1><p>每一个App, 必然会有大量的分析数据来统计用户行为. 而这些统计对应在客户端就是, 统计打点, 又称埋点.<br>关于埋点的本质, 我理解的就是用户出发一个行为后, 调用一个特定的接口. 服务端拿到我们的请求后, 根据客户端传的参数也就是事件ID来区分是什么操作(注意, 这里的事件ID是具有唯一性的, 不同的ID对应用户不同的操作). 有时也可能会需要其他的信息, 比如操作人的ID等. 服务端拿到这些信息之后, 再整理筛选, 通过视图, 报表的形式展现出来.<br>因为埋点是和业务紧密相连的, 所以一般我们的埋点代码(就是调用特定网络接口的代码)分散在整个项目的各个地方. 当业务越来越复杂, 工程越来越大时, 我们的埋点代码就会变得很难维护, 埋点事件分散在各个地方, 很难有个清晰的逻辑. 并且把埋点事件和业务代码高度耦合在一起, 也不是一个明智的选择.<br>这个时候, 就会想到, 要是能用AOP的方式来解决埋点的实现, 把埋点事件和业务代码解耦开来, 那我们维护起来就会方便好多.</p>\n<blockquote>\n<p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP与OOP是面向不同领域的两种设计思想。<br>OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。<br>AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。<br>AOP可以用在日志记录，性能统计，安全控制，事务处理，异常处理等等，本篇文章主要讲的是埋点也就是日志记录</p>\n</blockquote>\n<p>在Objective-C中使用AOP主要指的是使用Objective-C的Runtime特性, 给指定的方法添加自定义代码. 有很多方式来实现AOP, MethodSwizzling只是其中之一.而又有一些第三方库, 将Runtime进行了很好地封装, 让我们不用了解Runtime的知识, 就能很好地使用AOP.<br>我们主要使用的是<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a>这个第三方库, 关于Aspects的内部实现, 可以参考这篇博文<a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"noopener\">iOS 如何实现Aspect Oriented Programming</a>.<br>由以上的解释, 可以基本了解, 我们主要是通过Aspect来Hook对应事件的方法, 传递事件唯一的ID给服务端来标记此事件响应过一次.所以, 我们的代码大致应该是这样.<br>首先有一个类用来记录埋点事件ID和需要Hook的类和方法, 并且将他们一一对应.</p>\n<p>根据记录埋点事件的复杂程度, 我们大致可以将埋点分为简单埋点和复杂埋点两种:</p>\n<ol>\n<li>简单埋点: 只用记录某个操作事件响应次数</li>\n<li>复杂埋点:<ul>\n<li>需要传除了事件ID外的参数</li>\n<li>需要根据服务端返回的数据来响应不同的事件</li>\n<li>埋点事件ID放在服务端返回的字段中</li>\n</ul>\n</li>\n</ol>\n<p>我们新建两个类, 一个用来记录Hook的类<code>HYZTrackList</code>, Hook的方法和与之对应的事件ID. 另外一个类<code>HYZTrackManager</code>, 用来实现埋点事件的具体操作方法.</p>\n<h2 id=\"简单埋点的实现\"><a href=\"#简单埋点的实现\" class=\"headerlink\" title=\"简单埋点的实现\"></a>简单埋点的实现</h2><p>我们在<code>HYZTrackList</code>中实现<code>trackList</code>方法, 返回一个数组. 数组的元素是一个个的字典, 用对记录每一个事件的相关信息.</p>\n<pre><code>+ (NSArray *)trackList {\n    NSArray *trackList = @[\n  //=======================================简单埋点==========================================\n                           //HYZViewController1简单埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;simpleTrack:para2:&quot;,\n                             kEventType:HYZViewController1SimpleButtonClick,\n                             kIsLightEvent:@(YES)},\n                           //HYZViewController1复杂埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;blockButtonAction:&quot;,\n                             kEventType:HYZViewController1BlockButtonClick,\n                             kIsLightEvent:@(YES)},\n                           //HYZViewController1block埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;complexButtonAction:&quot;,\n                             kEventType:HYZViewController1ComplexButtonClick,\n                             kIsLightEvent:@(YES)},\n\n//=======================================复杂埋点==========================================\n                           @{kClassName:@&quot;HYZViewController3&quot;,\n                             kHookFunction:@&quot;trackWithTag:&quot;,\n                             kHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,\n                             kIsLightEvent:@(NO)}];\n    return trackList;\n}\n</code></pre><p>如上所示, 我们是要记录<code>HYZViewController1</code>类里面的<code>simpleTrack:para2:</code>方法的点击事件, 事件ID是<code>HYZViewController1SimpleButtonClick</code>.<br>我们在<code>APPDelegate</code>的<code>application:didFinishLaunchingWithOptions:</code>方法中, 来hook所有的在<code>trackList</code>中记录的方法.<br>在<code></code>中, 实现如下相关代码.</p>\n<pre><code>+ (void)setup {\n    //实现和替换hook的block方法\n    NSMutableDictionary *blockDict = [[NSMutableDictionary alloc] init];\n    [HYZTrackManager weightEventEntry:blockDict];\n\n    [[HYZTrackList trackList] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        BOOL isLightEvent = [obj[kIsLightEvent] boolValue];\n        NSString *className = obj[kClassName];\n        NSString *functionName = obj[kHookFunction];\n        NSString *eventName = obj[kEventType];\n        Class class = NSClassFromString(className);\n        SEL selector = NSSelectorFromString(functionName);\n        if (isLightEvent == YES) {\n            if (!functionName) {\n                return;\n            }\n            [HYZTrackManager lightTrackTarget:class selector:selector functionName:functionName trackId:eventName];\n        } else {\n            NSString *blockName = obj[kHandlerBlock];\n            id handleBlock = [blockDict objectForKey:blockName];\n            if (!handleBlock) {\n                return;\n            }\n            [HYZTrackManager complexTrackTarget:class selector:selector usingBlock:handleBlock];\n        }\n    }];\n}\n</code></pre><p>针对简单埋点, 我们直接使用</p>\n<pre><code>//简单埋点虽然可以拿到对应方法的参数, 但是如果需要把该参数传到埋点请求的网络事件中的话, 必须使用复杂埋点来处理\n+ (void)lightTrackTarget:(Class)target selector:(SEL)selector functionName:(NSString *)functionName trackId:(NSString *)trackId {\n    NSError *error;\n    NSInteger functionParamCount = [[functionName componentsSeparatedByString:@&quot;:&quot;] count] - 1;\n    switch (functionParamCount) {\n        case 0: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo){\n                [HYZTrackManager trackRequestWithTrackId:trackId, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 1: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 2: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 3: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 4: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3, id p4){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, p4, nil];\n            }error:&amp;error];\n        }\n            break;\n        default:\n            break;\n    }\n}\n\n</code></pre><p>简单埋点虽然也可以拿到Hook的方法的参数, 但是由于通用性, 所以不能用来传递可变的参数.</p>\n<p>真正的埋点请求是这样的</p>\n<pre><code>+ (void)trackRequestWithTrackId:(NSString *)trackId, ... NS_REQUIRES_NIL_TERMINATION{\n    // 定义一个指向个数可变的参数列表指针；\n    va_list args;\n    // 用于存放取出的参数\n    NSString *arg;\n    // 初始化变量刚定义的va_list变量，这个宏的第二个参数是第一个可变参数的前一个参数，是一个固定的参数\n    va_start(args, trackId);\n    // 遍历全部参数 va_arg返回可变的参数(a_arg的第二个参数是你要返回的参数的类型)\n    while ((arg = va_arg(args, NSString *))) {\n        NSLog(@&quot;%@&quot;, arg);\n    }\n    // 清空参数列表，并置参数指针args无效\n    va_end(args);\n    NSLog(@&quot;此处用来实现埋点事件记录%@的网络请求&quot;, trackId);\n}\n</code></pre><p>至此, 实现了简单埋点的方法Hook.</p>\n<h2 id=\"复杂埋点\"><a href=\"#复杂埋点\" class=\"headerlink\" title=\"复杂埋点\"></a>复杂埋点</h2><p>复杂埋点, 因为要传参数进来, 所以我们利用<code>+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;</code>可以传block参数来实现.<br>首先, 我们在<code>HYZTrackList</code>中把类名, 方法名和需要定义的Block关联起来,如下所示.</p>\n<pre><code>{kClassName:@&quot;HYZViewController3&quot;,\nkHookFunction:@&quot;trackWithTag:&quot;,\nkHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,\nkIsLightEvent:@(NO)}\n</code></pre><p>在<code>APPDelegate</code>中初始化时, 需要在<code>HYZTrackManager</code>中实现Block的定义, </p>\n<pre><code>//hook的block在这里定义和实现\n+ (void)weightEventEntry:(NSMutableDictionary*)blockDict{\n    [HYZTrackManager trackButtonAction:blockDict];\n}\n\n//block的内部实现\n+ (void)trackButtonAction:(NSMutableDictionary *)blockDict {\n    void(^HYZViewController3TrackHandleBlock)(id, NSInteger tag) = ^(id &lt;AspectInfo&gt;aspectInfo, NSInteger tag) {\n        switch (tag) {\n                case 1: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 2: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 3: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 4: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n            default:\n                break;\n        }\n    };\n    [blockDict setObject:[HYZViewController3TrackHandleBlock copy] forKey:@&quot;HYZViewController3TrackHandleBlock&quot;];\n}\n</code></pre><p>然后Hook原方法;</p>\n<pre><code>//复杂的埋点,\n+ (void)complexTrackTarget:(Class)target selector:(SEL)selector usingBlock:(id)block {\n    NSError *error;\n    [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:block error:&amp;error];\n}\n</code></pre><p><a href=\"https://github.com/HChong3210/AOPTrack\" target=\"_blank\" rel=\"noopener\">Demo</a><br>参考资料: </p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"noopener\">iOS 如何实现Aspect Oriented Programming</a></li>\n<li><a href=\"http://www.vienta.me/2016/09/21/AOP%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%80%E7%BB%9F%E8%AE%A1%E5%9F%8B%E7%82%B9/\" target=\"_blank\" rel=\"noopener\">AOP在iOS中的实践——统计埋点</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20160421/15912.html\" target=\"_blank\" rel=\"noopener\">可复用且高度解耦的iOS用户统计实现</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150120/10959.html\" target=\"_blank\" rel=\"noopener\">Method Swizzling和AOP(面向切面编程)实践</a></li>\n</ol>\n","categories":["统计打点"],"tags":["解决方案","AOP","统计打点"]},{"title":"设计模式-工厂模式","url":"http://hchong.net/2017/02/08/设计模式-工厂模式/","content":"<h1 id=\"设计模式-工厂模式\"><a href=\"#设计模式-工厂模式\" class=\"headerlink\" title=\"设计模式-工厂模式\"></a>设计模式-工厂模式</h1><p>下面有一个case, 要编写一个简单的计算器程序, 用来实现加减乘除的运算操作, 并且展示出来.我们就拿这个最简单的例子来一步一步见识一下”工厂模式”的魅力.</p>\n<h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>版本一:我们首先想到的最简单的模式就是我们先从业务上来拆分, 把计算器程序分成两部分<em>计算</em>和<em>展示</em>两个类来写代码.OC作为一门面向对象的语言, 在这里我们已经可以清楚地意识到我们已经使用了<em>封装</em>这面向对象语言的一大特性.但是随着业务的发展, 我们发现可能会增加其他的业务(例如增加其他的运算操作),这是我们每次都要修改<em>计算</em>这个类, 慢慢的代码就会越来越多, 不利于维护.而且在新加逻辑的过程中有可能会修改到老的代码, 维护成本很高.这是我们就会想到其他两个特性<em>继承</em>和<em>多态</em>.于是, 就有了版本二.</p>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>这时我们发现,把所有的运算写到一个类中是有些不妥当的, 那么要怎么来修改呢.我们自然地想到, 每一种运算可以单独度的封装为一个类, 只用于实现固定的计算.于是我们可以得到<em>加</em>,<em>减</em>,<em>乘</em>,<em>除</em>四个类, 每个类都三个属性, 分别是<em>操作数</em>和<em>结果</em>.哪里怪怪的呢, 有没有一丝”坏代码”的味道呢.通过提炼我们发现四个类都有相同的三个属性,那么我们可以这样做新建一个<code>Operation</code>操作类, 包含三个<code>Public</code>属性</p>\n<pre><code>@interface Operation : NSObject\n\n@property (nonatomic, assign) CGFloat numberA;\n@property (nonatomic, assign) CGFloat numberB;\n@property (nonatomic, assign) CGFloat numberResult;\n\n- (CGFloat)getResult;\n@end\n</code></pre><p>这样的话, 只需要每一个单独的计算类继承于<code>Operation</code>类, 就会自带父类的三个属性, 只用在他们内部实现自己独有的计算方法, 返回计算结果就可以了.到这里, 我们会发现代码变得更加有意思了.<br>但是我们又发现了一个新的问题, 那就是我们该何时初始化哪个类呢, 毕竟我们现在有了四个计算子类.我们只好计算结果的地方写<code>Switch</code>条件来判断到底要初始化那一个子类.</p>\n<p>可是仍然感觉哪里还是怪怪的.我们不是还有<em>多态</em>这种特性没有使用的嘛.仔细一想, 于是又有了版本三.</p>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><blockquote>\n<p>多态:多态表示不同的对象可以执行相同的操作, 但要通过他们自己的实现代码来执行.<br>这是我们需要增加一个工厂类<code>OperationFactory</code>, 用来判断要初始化哪一个子类.</p>\n</blockquote>\n<p><code>OperationFactory.h</code>代码如下:</p>\n<pre><code>@class Operation;\n@interface OperationFactory : NSObject\n\n+ (Operation *)createOperationWithOperate:(NSString *)operate;\n@end\n\n</code></pre><p><code>OperationFactory.m</code>代码如下:</p>\n<pre><code>@implementation OperationFactory\n\n//传入计算符号, 初始化不同的子类\n+ (Operation *)createOperationWithOperate:(NSString *)operate {\n    if ([operate isEqualToString:@&quot;+&quot;]) {\n        OperationAdd *add = [[OperationAdd alloc] init];\n        return add;\n    }\n\n    if ([operate isEqualToString:@&quot;-&quot;]) {\n        OperationSubtraction *subtraction = [[OperationSubtraction alloc] init];\n        return subtraction;\n    }\n\n    ...\n    return nil;\n}\n\n@end\n</code></pre><p>此时展示的地方, 代码就变得很简单了:</p>\n<pre><code>@interface ViewController ()\n\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    Operation *operation = [OperationFactory createOperationWithOperate:@&quot;-&quot;];//子类以父类的身份出现\n    operation.numberA = 3;\n    operation.numberB = 5;\n    CGFloat result = [operation getResult];//子类在工作时以自己的方式实现\n    NSLog(@&quot;%f&quot;, result);\n    NSLog(@&quot;%f&quot;, operation.numberResult);\n}\n@end\n</code></pre><p>如上我们可以发现, 整个工厂模式的关键就在于<code>OperationFactory</code>这个工厂类的实现.我们在调用的时候不用关心我们要实现哪一个类, <code>CGFloat result = [operation getResult];</code>, 只用调用父类的方法就可以, 而内部则是子类自己的实现.<br>这里面还有几点要注意:</p>\n<blockquote>\n<ol>\n<li>子类以父类的身份出现</li>\n<li>子类在工作时以自己的方式实现</li>\n<li>子类独有的方法和属性不可以使用</li>\n</ol>\n</blockquote>\n<p>在这里解释一下就是, 我们在展示的时候初始化的实际上是父类<code>Operation</code>.但是在获取计算结果时, 我们使用的是子类的计算方法<code>CGFloat result = [operation getResult];</code>, 因为我们在子类里面复写了父类的方法, 所以实际上走的还是子类各自自己的方法.</p>\n","categories":["设计模式"],"tags":["架构","设计模式"]},{"title":"常见的代码\"坏味道\"","url":"http://hchong.net/2016/12/28/常见的代码坏味道/","content":"<h1 id=\"常见的代码”坏味道”\"><a href=\"#常见的代码”坏味道”\" class=\"headerlink\" title=\"常见的代码”坏味道”\"></a><strong>常见的代码”坏味道”</strong></h1><p>正所谓优雅的代码是相似的, 不优雅的代码却各有各的丑. 最近在拜读&lt;重构- 改善既有代码的设计&gt;一书, 虽然书中大量示例是用Java编写的, 但是也给了我很多启发.<br>见贤思齐, 耗时把感想记录下来, 督促自己的成长. </p>\n<h2 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a><strong>重复代码</strong></h2><p>坏味道行列中 ,最常见的就是Duplicated Code. 如果你在一个以上的地点看到相同的程序结构, 那么可以肯定: 把他们合而为一, 会使得代码变得更好.</p>\n<ol>\n<li><p>最单纯的Duplicated Code就是”同一个类的两个函数有相同的表达式”, 解决办法就是:</p>\n<ul>\n<li>采用Extract Method(提炼函数)提炼出重复的代码, 然后这两个地方都调用提炼出来的那一段代码.</li>\n</ul>\n</li>\n<li><p>两个互为兄弟的子类内包含相同的表达式, 解决办法就是:</p>\n<ul>\n<li>对两个类都是用Extract Method(提炼函数), 再对提炼出来的代码使用Pull Up Method(函数上移)</li>\n<li>如果代码只是类似而不完全相同, 那就要先使用Extract Method(提炼函数)将相似和差异的代码分隔开, 构造成一个单独的函数, 然后再<em>塑造模板函数</em></li>\n</ul>\n</li>\n<li><p>如果两个毫不相关的类出现Duplicated Code, 应该把重复代码提炼到一个独立类中, 然后再另一个类中使用这个新类</p>\n</li>\n</ol>\n<blockquote>\n<p>函数上移(Pull Up Method): 若干个身处子类中的函数, 他们又可以通过某种形式的参数调整成为相同的函数. 这时候, 最简单的方法就是首先分别调整这些函数的参数, 然后再将他们概括到父类中去. 特殊情况: 当子类的函数覆写了父类的函数, 但却仍然做相同的工作.</p>\n</blockquote>\n<blockquote>\n<p>塑造模板函数(Form Template Method): 两个函数以相同顺序执行大致相近的操作, 但是各操作不完全相同. 这种情况下我们可以将执行操作的序列移至父类, 并借助多态保证各操仍得以保持差异性.</p>\n</blockquote>\n<h2 id=\"过长函数-Long-Method\"><a href=\"#过长函数-Long-Method\" class=\"headerlink\" title=\"过长函数(Long Method)\"></a><strong>过长函数(Long Method)</strong></h2><p>程序愈长愈难理解.<br>我们应该积极地分解函数, 只要你感觉需要在一个地方加注释, 我们就要把需要说明的东西写进一个独立函数, 并以其用途(而非实现手法)命名. 哪怕替换后的函数调用动作比函数自身还长, 只要函数名称能够解释其用途, 我们就应该毫不犹豫地那么做, 关键不在于函数的长度, 而在于”做什么”和”如何做”之间的语义距离.</p>\n<ol>\n<li>大多数场合, 把函数变小, 只需使用Extract Method(提炼函数). 找到函数中适合集中在一起的部分, 将他们提炼出来一个新函数.</li>\n<li>如果函数中有大量的参数和临时变量, 他们会对你的函数提炼形成阻碍. 如果</li>\n</ol>\n<h2 id=\"过大的类-Large-Class\"><a href=\"#过大的类-Large-Class\" class=\"headerlink\" title=\"过大的类(Large Class)\"></a><strong>过大的类(Large Class)</strong></h2><h2 id=\"过长参数列-Long-Parameter-List\"><a href=\"#过长参数列-Long-Parameter-List\" class=\"headerlink\" title=\"过长参数列(Long Parameter List)\"></a><strong>过长参数列(Long Parameter List)</strong></h2><h2 id=\"发散式变化-Divergent-Change\"><a href=\"#发散式变化-Divergent-Change\" class=\"headerlink\" title=\"发散式变化(Divergent Change)\"></a><strong>发散式变化(Divergent Change)</strong></h2><h2 id=\"霰弹式修改-Shotgun-Surgery\"><a href=\"#霰弹式修改-Shotgun-Surgery\" class=\"headerlink\" title=\"霰弹式修改(Shotgun Surgery)\"></a><strong>霰弹式修改(Shotgun Surgery)</strong></h2><h2 id=\"依恋情结-Feature-Envy\"><a href=\"#依恋情结-Feature-Envy\" class=\"headerlink\" title=\"依恋情结(Feature Envy)\"></a><strong>依恋情结(Feature Envy)</strong></h2><h2 id=\"数据泥团-Data-Clumps\"><a href=\"#数据泥团-Data-Clumps\" class=\"headerlink\" title=\"数据泥团(Data Clumps)\"></a><strong>数据泥团(Data Clumps)</strong></h2><h2 id=\"基本类型偏执-Primitive-Obsession\"><a href=\"#基本类型偏执-Primitive-Obsession\" class=\"headerlink\" title=\"基本类型偏执(Primitive Obsession)\"></a><strong>基本类型偏执(Primitive Obsession)</strong></h2><h2 id=\"Switch-惊悚现身-Switch-Statements\"><a href=\"#Switch-惊悚现身-Switch-Statements\" class=\"headerlink\" title=\"Switch 惊悚现身(Switch Statements)\"></a><strong>Switch 惊悚现身(Switch Statements)</strong></h2><h2 id=\"平行继承体系-Parallel-Inheritance-Hierarchies\"><a href=\"#平行继承体系-Parallel-Inheritance-Hierarchies\" class=\"headerlink\" title=\"平行继承体系(Parallel Inheritance Hierarchies)\"></a><strong>平行继承体系(Parallel Inheritance Hierarchies)</strong></h2><h2 id=\"冗赘类-Lazy-Class\"><a href=\"#冗赘类-Lazy-Class\" class=\"headerlink\" title=\"冗赘类(Lazy Class)\"></a><strong>冗赘类(Lazy Class)</strong></h2><h2 id=\"夸夸其谈未来性-Speculative-Generatlity\"><a href=\"#夸夸其谈未来性-Speculative-Generatlity\" class=\"headerlink\" title=\"夸夸其谈未来性(Speculative Generatlity)\"></a><strong>夸夸其谈未来性(Speculative Generatlity)</strong></h2><h2 id=\"令人迷惑的暂时字段-Temporary-Field\"><a href=\"#令人迷惑的暂时字段-Temporary-Field\" class=\"headerlink\" title=\"令人迷惑的暂时字段(Temporary Field)\"></a><strong>令人迷惑的暂时字段(Temporary Field)</strong></h2><h2 id=\"过度耦合的消息链-Message-Chains\"><a href=\"#过度耦合的消息链-Message-Chains\" class=\"headerlink\" title=\"过度耦合的消息链(Message Chains)\"></a><strong>过度耦合的消息链(Message Chains)</strong></h2><h2 id=\"中间人-Middle-Man\"><a href=\"#中间人-Middle-Man\" class=\"headerlink\" title=\"中间人(Middle Man)\"></a><strong>中间人(Middle Man)</strong></h2><h2 id=\"狎昵关系-Inappropriate-Intimacy\"><a href=\"#狎昵关系-Inappropriate-Intimacy\" class=\"headerlink\" title=\"狎昵关系(Inappropriate Intimacy)\"></a><strong>狎昵关系(Inappropriate Intimacy)</strong></h2><h2 id=\"异曲同工的类-AlertNative-Classes-with-Different-Interfaces\"><a href=\"#异曲同工的类-AlertNative-Classes-with-Different-Interfaces\" class=\"headerlink\" title=\"异曲同工的类(AlertNative Classes with Different Interfaces)\"></a><strong>异曲同工的类(AlertNative Classes with Different Interfaces)</strong></h2><h2 id=\"不完美的库类-Incomplete-Library-Class\"><a href=\"#不完美的库类-Incomplete-Library-Class\" class=\"headerlink\" title=\"不完美的库类(Incomplete Library Class)\"></a><strong>不完美的库类(Incomplete Library Class)</strong></h2><h2 id=\"纯稚的数据类-Data-Class\"><a href=\"#纯稚的数据类-Data-Class\" class=\"headerlink\" title=\"纯稚的数据类(Data Class)\"></a><strong>纯稚的数据类(Data Class)</strong></h2><h2 id=\"被拒绝的遗赠-Refused-Bequest\"><a href=\"#被拒绝的遗赠-Refused-Bequest\" class=\"headerlink\" title=\"被拒绝的遗赠(Refused Bequest)\"></a><strong>被拒绝的遗赠(Refused Bequest)</strong></h2><h2 id=\"过多的注释-COmments\"><a href=\"#过多的注释-COmments\" class=\"headerlink\" title=\"过多的注释(COmments)\"></a><strong>过多的注释(COmments)</strong></h2>","categories":["架构"],"tags":["重构","架构"]},{"title":"代码重构与拆分","url":"http://hchong.net/2016/12/26/代码重构与拆分/","content":"<h1 id=\"代码的重构与拆分\"><a href=\"#代码的重构与拆分\" class=\"headerlink\" title=\"代码的重构与拆分\"></a><strong>代码的重构与拆分</strong></h1><p>最近项目中有一块代码, 几经人手, 流落到我这里. 代码的业务逻辑十分复杂, 而且随着业务的扩张, 被不同的人加入而不同风格的代码, 最初的架构已经不适合现有业务的发展了, 维护起来也是相当的困难. 于是, 我就走上了重构和拆分之路.</p>\n<p>实际上来讲, 重构和拆分是两个不同的概念, 但是又都是相辅相成, 下面我简单讲一下我的理解.</p>\n<blockquote>\n<p>重构: 对软件内部结构的一种调整, 目的是在不改变软件可观察行为的前提下, 提高其可理解性, 降低其修改成本.</p>\n</blockquote>\n<ul>\n<li>拆分: 整体项目的架构, 降低代码的耦合性, 使得团队中的成员协作使用起来更加容易.</li>\n</ul>\n<p>不管重构还是拆分, 都是为了让代码能够跟上业务发展的水平, 不至于变得一团乱麻, 让团队之间的协作开发更加有效.</p>\n","categories":["架构"],"tags":["重构","拆分"]},{"title":"hexo常见问题","url":"http://hchong.net/2016/12/21/hexo常见问题/","content":"<h1 id=\"hexo常见问题\"><a href=\"#hexo常见问题\" class=\"headerlink\" title=\"hexo常见问题\"></a><strong>hexo常见问题</strong></h1><p>在使用hexo的过程中遇到了一些问题, 在这里列出来, 做一个记录.</p>\n<h2 id=\"hexo的常见发布流程\"><a href=\"#hexo的常见发布流程\" class=\"headerlink\" title=\"hexo的常见发布流程\"></a><strong>hexo的常见发布流程</strong></h2><ul>\n<li>hexo新建一篇文章使用<code>hexo new type name</code>, <code>type</code>有三种, 最常使用的是<code>post</code>, <code>name</code>是新建文档的名字.</li>\n<li><p>hexo新建完成, 编辑之后发布会经常使用到下面几个命令:</p>\n<ul>\n<li><code>hexo clean</code>清除之前缓存的一些信息, 例如主题之类的, 不是每次都必须执行.</li>\n<li><code>hexo g</code>相当于编译.</li>\n<li><code>hexo s</code>发布到本地服务器, 把<em>.md</em>文件生成讲台html用于展示, 也可做调试用.</li>\n<li><code>hexo d</code>推本地的文件到服务器, 这里指的是github上面, 如果绑定的有域名, 就直接发布到Internet. 每次推送前, 要确保<code>hexo g</code>和<code>hexo s</code>没有问题, 否则可造成Internet上面无法正常显示.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"hexo目录结构分析\"><a href=\"#hexo目录结构分析\" class=\"headerlink\" title=\"hexo目录结构分析\"></a><strong>hexo目录结构分析</strong></h2><h3 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a><strong>根目录</strong></h3><ul>\n<li>_config.yml: 位于本地博客的根目录下, 在这里面对整个博客的内容进行一些设置.</li>\n<li>source文件夹: 里面存储一些博客使用的文件资源, 例如<em>category(分类)</em>, <em>tag(标签)</em>, <em>link(链接)</em>, <em>about(关于)</em>, <em>project(工程)</em>, <em>search(搜索)</em>, *_posts(使用post格式新建的文章.md文件存储在这里).需要说明一下的是, 这些文件夹的名称和数量不固定, 要看你使用的主题里面的模块大概有几个 ,我使用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"noopener\">fexo</a>.还有一些坑, 后面再详述.</li>\n<li>public文件夹: 里面存储的是之前发布过得一些归档数据, 如果要删除之前的测试数据的话, 记得清理里面响应的内容.</li>\n<li>scaffolds文件夹: 存储.md文档的类型.</li>\n<li>themes文件夹: 里面是你下载的主题内容, 如果有多个主题, 就会有多个文件夹, 但只能同时使用一种样式的主题.这个后面会着重分析一下.</li>\n</ul>\n<h3 id=\"themes文件夹\"><a href=\"#themes文件夹\" class=\"headerlink\" title=\"themes文件夹\"></a><strong>themes文件夹</strong></h3><p>这里面主要会进行一些主题相关的设置.</p>\n<ul>\n<li>_config.yml: 位于主题目录下, 在这里面对当前只用主题的内容进行一些配置, 不同主题的配置可能不太一样, 我是用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"noopener\">fexo</a></li>\n</ul>\n<ul>\n<li>source文件夹: 该文件夹下面是该主题相关的一些资源, 例如一些静态的图片之类的.</li>\n<li>layout文件夹: 该文件夹下面是静态页面显示的相关配置. 代码高亮的设置也是在该文件夹下面. 其他的例如静态页面的展示, 可以修改相关的js文件.</li>\n</ul>\n<h2 id=\"修改代码高亮\"><a href=\"#修改代码高亮\" class=\"headerlink\" title=\"修改代码高亮\"></a><strong>修改代码高亮</strong></h2><p>代码高亮的展示, 不同的主题有不同的使用方式, 但是代码高亮的theme可以参考这里, 我使用的是<a href=\"https://highlightjs.org/static/demo/\" target=\"_blank\" rel=\"noopener\">HighLight</a>, 它提供了多种Theme, 基本上能满足各种需求.</p>\n<p>修改步骤如下:</p>\n<p>1.修改博客根目录下的<em>_config.yml</em>文件, 关闭hexo自带的代码高亮.</p>\n<pre><code class=\"js\">highlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n</code></pre>\n<p>2.<code>cd 博客根目录/themes/fexo/layout/_partial</code>打开<em>head.ejs</em>文件, 最好是在<code>&lt;head&gt;&lt;/head&gt;</code>之间开头处插入代码</p>\n<pre><code class=\"html5\">  &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css&quot;&gt;\n  &lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>也可以使用下面的写法:</p>\n<pre><code class=\"h5\">&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/styles/default.css&quot;&gt;\n&lt;script src=&quot;/path/to/highlight.pack.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>二者的区别在于, 第一种写法使用的是CDN创建的<a href=\"http://www.bootcdn.cn/?\" target=\"_blank\" rel=\"noopener\">在线文档地址</a>, 该地址还保存了其他一些常见的文档, 非常强大.而第二种写法则是把文件下载到本地, 从本地读取代码高亮的配置.</p>\n<hr>\n<p>修改过程中, 我参考了以下两篇博文, 还趟过不少坑, 贴上博文的地址:</p>\n<ol>\n<li><a href=\"http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-highlight/\" target=\"_blank\" rel=\"noopener\">地址一</a></li>\n<li><a href=\"http://jumpbyte.cn/2016/07/02/use-and-install-prettify/\" target=\"_blank\" rel=\"noopener\">地址二</a></li>\n</ol>\n","categories":["hexo"],"tags":["hexo","个人博客"]},{"title":"属性修饰符之copy和strong","url":"http://hchong.net/2016/09/21/属性修饰符之copy和strong/","content":"<h1 id=\"属性修饰符之copy和strong\"><a href=\"#属性修饰符之copy和strong\" class=\"headerlink\" title=\"属性修饰符之copy和strong\"></a>属性修饰符之copy和strong</h1><p>在了解属性修饰符的copy和strong的区分之前, 我们先来了解下浅拷贝和深拷贝的区别.</p>\n<h2 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h2><p>浅复制并不是拷贝对象本身, 仅仅是拷贝指向对象的指针; 深复制是直接拷贝整个对象内存到另一块内存中. 简单地说:</p>\n<ul>\n<li><strong>浅复制就是指针拷贝,  不会产生新的对象，指向的是同一个对象; </strong></li>\n<li><strong>深复制就是内容拷贝，会产生新的对象, 不同的对象, 内容相同.</strong></li>\n</ul>\n<p><img src=\"http://7s1ssm.com1.z0.glb.clouddn.com/image_note50592_1.png\" alt=\"浅复制和深复制\"></p>\n<h2 id=\"copy和mutableCopy\"><a href=\"#copy和mutableCopy\" class=\"headerlink\" title=\"copy和mutableCopy\"></a>copy和mutableCopy</h2><p><code>copy</code>就是复制了一个imutable对象, <code>mutableCopy</code>就是复制了一个mutable对象.</p>\n<p>一个<code>NSObject</code>对象要想使用这两个函数, 必须实现<code>NSCopying</code>协议和<code>NSMutableCopying</code>协议, 并且分别实现<code>- (id)copyWithZone:(nullable NSZone *)zone;</code>和<code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code>方法.但是常见的<code>NSString</code>, <code>NSArray</code>, <code>NADictionary</code>等常用的系统提供的结构体都已经实现. </p>\n<h3 id=\"系统的非容器类对象\"><a href=\"#系统的非容器类对象\" class=\"headerlink\" title=\"系统的非容器类对象\"></a>系统的非容器类对象</h3><p>这里指的是<code>NSString</code>, <code>NSNumber</code>等等一类的对象.下面以<code>NSString</code>为例.</p>\n<p>对<code>NSString</code>进行copy和mutableCop操作:</p>\n<pre><code class=\"objective-c\">NSString *originString = @&quot;origin&quot;;\nNSString *originStringCopy = [originString copy];\nNSMutableString *originStringMutableCopy = [originString mutableCopy];\nNSLog(@&quot;%p, %p, %p&quot;, originString, originStringCopy, originStringMutableCopy);\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originString\n(__NSCFConstantString *) $0 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringCopy\n(__NSCFConstantString *) $1 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringMutableCopy\n(__NSCFString *) $2 = 0x0000608000262800 @&quot;origin&quot;\n</code></pre>\n<hr>\n<p>对<code>NSMutableString</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginString = [NSMutableString stringWithString:@&quot;mutableOrigin&quot;];\nNSString *mutableOriginStringCopy = [mutableOriginString copy];\nNSMutableString *mutableOriginStringMutableCopy = [mutableOriginString mutableCopy];\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p mutableOriginString\n(__NSCFString *) $0 = 0x000060800026aa40 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringCopy\n(__NSCFString *) $1 = 0x0000608000222340 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringMutableCopy\n(__NSCFString *) $2 = 0x000060800026a700 @&quot;mutableOrigin&quot;\n</code></pre>\n<p>这里要注意的是:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginStringCopy = [mutableOriginString copy];\n[mutableOriginStringCopy appendString:@&quot;123&quot;];\n</code></pre>\n<p>这样写是会crash的, 因为copy生成的是imutable对象, 不管声明是什么样的, 依旧是imutable的.</p>\n<p><strong>综上, 对于系统的非容器类对象:</strong></p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n</ul>\n<h3 id=\"系统的容器类对象\"><a href=\"#系统的容器类对象\" class=\"headerlink\" title=\"系统的容器类对象\"></a>系统的容器类对象</h3><p>容器类对象指的是<code>NSArray</code>, <code>NSDictionary</code>, <code>NSSet</code>等系统提供的结构体, 下面以<code>NSArray</code>为例.</p>\n<p>对<code>NSArray</code>进行copy操作:</p>\n<pre><code class=\"objective-c\">NSArray *originArray = [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayI *) $0 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x00006080002403c0 @&quot;3 elements&quot;\n</code></pre>\n<p>可以看出, copy是浅复制, mutableCopy是深复制. 需要注意的是,mutableCopy的对象是一个可变对象,  数组内元素全都是浅复制.</p>\n<hr>\n<p>对<code>NSMutableArray</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>打印内存地址如下:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayM *) $0 = 0x000060800005eae0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x000060800005e9f0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x000060800005e900 @&quot;3 elements&quot;\n</code></pre>\n<p>可以发现可以看出, copy是浅复制, mutableCopy是深复制. 数组内元素都是浅复制.</p>\n<p>需要注意的是, mutable对象copy的对象是imutable对象, 如果当做可变对象来用是会崩溃的.</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSMutableArray *originArrayCopy1 = [originArray copy];\n[originArrayCopy1 addObject:@&quot;d&quot;];//crash\n</code></pre>\n<p>综上, 对于容器类对象:</p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n<li><strong>元素对象是浅复制.</strong></li>\n</ul>\n<h3 id=\"系统类对象的完全深复制\"><a href=\"#系统类对象的完全深复制\" class=\"headerlink\" title=\"系统类对象的完全深复制\"></a>系统类对象的完全深复制</h3><p>对于容器类对象而言, 元素对象始终是浅复制, 要想深复制可通过如下方法:</p>\n<pre><code class=\"objective-c\">NSArray *array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],[NSString stringWithString:@&quot;b&quot;],@&quot;c&quot;,nil];\nNSArray *deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];\nNSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject: array]];\n</code></pre>\n<p>打印元素内存地址可以发现, trueDeepCopyArray的元素都是深复制, 而deepCopyArray由于第一个元素是可变对象, 所以是深复制, 其他的元素都是浅复制.</p>\n<p><strong>综上, 要想实现容器对象所有元素的深复制, 只能通过归档来实现.</strong></p>\n<blockquote>\n<p>If you need a true deep copy, such as when you have an array of arrays, you can archive and then unarchive the collection, provided the contents all conform to the <code>NSCoding</code> protocol</p>\n</blockquote>\n<pre><code class=\"objective-c\">@protocol NSCoding\n\n- (void)encodeWithCoder:(NSCoder *)aCoder;\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER\n\n@end\n</code></pre>\n<h3 id=\"自定义对象\"><a href=\"#自定义对象\" class=\"headerlink\" title=\"自定义对象\"></a>自定义对象</h3><p>对于自定义对象, 我们要实现<code>NSCopying</code>, <code>NSMutableCopying</code>协议, 这样我们就能调用copy和mutableCopy了.假设有一个<code>Person</code>类, 继承于<code>NSObject</code>.</p>\n<p><code>person.h</code></p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n@interface Person : NSobject\n\n@property (nonatomic, assign) NSInteger age;\n@end\n</code></pre>\n<p><code>person.m</code></p>\n<pre><code class=\"objective-c\">\n#import &quot;Person.h&quot;\n@interface Person()&lt;NSCopying&gt;\n@end\n\n@implementation Person\n\n- (id)copyWithZone:(NSZone *)zone {\n    Person *person = [[Person allocWithZone:zone] init];\n      person.age = self.age;\n    return person;\n}\n@end\n</code></pre>\n<p>这样当我们在外面调用的时候:</p>\n<pre><code class=\"objective-c\">Person *p = [[Person alloc] init];\np.age = 20;\n\nPerson *copyP = [p copy];\nNSLog(@&quot;p = %p copyP = %p&quot;, p, copyP);\nNSLog(@&quot;age = %ld&quot;, copyP.age);\n</code></pre>\n<p>通过打印地址:</p>\n<pre><code class=\"objective-c\">(lldb) p p\n(Person *) $0 = 0x000060800002a1e0\n(lldb) p copyP\n(Person *) $1 = 0x000060800002a2e0\n(lldb) p p.age\n(NSInteger) $2 = 20\n(lldb) p copyP.age\n(NSInteger) $4 = 20\n</code></pre>\n<p>我们可以发现, 自定义对象内部的属性都被浅拷贝, 自定义对象本身被深拷贝.</p>\n<p>需要注意的是, 如果我们的自定义对象不实现<code>NSCopying</code>协议而直接copy时, 是会crash的.</p>\n<h2 id=\"属性修饰之copy与strong\"><a href=\"#属性修饰之copy与strong\" class=\"headerlink\" title=\"属性修饰之copy与strong\"></a>属性修饰之copy与strong</h2><p>我们新建一个<code>Person</code>类, 添加几个属性来看一下copy和strong对属性使用的影响.</p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface Person : NSObject\n\n@property (nonatomic, strong) NSString *strongName;\n@property (nonatomic, copy) NSString *copyName;\n\n@end\n</code></pre>\n<p>在外面调用<code>Person</code>类, 代码如下:</p>\n<pre><code class=\"objective-c\">Person *person = [[Person alloc] init];\nNSMutableString *testString = [NSMutableString stringWithString:@&quot;test&quot;];\nperson.nameCopy = testString;\nperson.nameStrong = testString;\n[testString appendString:@&quot;copy&amp;&amp;strong&quot;];\n</code></pre>\n<p>打印<code>testString</code>改变前后属性</p>\n<pre><code class=\"objective-c\">//testString改变前\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $1 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $2 = 0x0000600000260540 @&quot;test&quot;\n//testString改变后\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $3 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $4 = 0x0000600000260540 @&quot;testcopy&amp;&amp;strong&quot;\n</code></pre>\n<p>由以上可以看出:</p>\n<p>对源头是<code>NSMutableString</code>的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的，它也会跟着改变, 相当于浅拷贝; 而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>\n<p>当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>\n<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>\n<p>综上可以发现, 如果property是<code>NSString</code>或者<code>NSArray</code>及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。</p>\n<p>参考文档:</p>\n<p>1.<a href=\"http://www.fanliugen.com/?p=278\" target=\"_blank\" rel=\"noopener\">copy与mutableCopy</a></p>\n<p>2.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3\" target=\"_blank\" rel=\"noopener\">Copying Collections</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e6a7cdcc705d\" target=\"_blank\" rel=\"noopener\">iOS浅谈: 深.浅拷贝与copy.strong</a></p>\n<p>4.<a href=\"http://www.cocoachina.com/ios/20150512/11805.html\" target=\"_blank\" rel=\"noopener\">NSString属性什么时候用copy，什么时候用strong?</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"内存分配","url":"http://hchong.net/2016/09/18/内存分配/","content":"<h1 id=\"iOS开发的内存分配\"><a href=\"#iOS开发的内存分配\" class=\"headerlink\" title=\"iOS开发的内存分配\"></a>iOS开发的内存分配</h1><p>计算机系统中, 应用程序的数据都保存在内存中, 不同类型的数据, 保存的区域不同.</p>\n<h2 id=\"RAM-ROM\"><a href=\"#RAM-ROM\" class=\"headerlink\" title=\"RAM ROM\"></a>RAM ROM</h2><blockquote>\n<p>RAM: 运行内存, 不能掉电存储.ROM: 存储型内存, 可以掉电存储, 例如内存卡, FLash.<br>    由于RAM类型不具备掉电存储的能力, 所以App程序一般存放在RMO中. RAM的访问速度和价格都高于ROM.</p>\n</blockquote>\n<h2 id=\"App程序启动\"><a href=\"#App程序启动\" class=\"headerlink\" title=\"App程序启动\"></a>App程序启动</h2><blockquote>\n<p>App程序启动, 系统会把开启的那个App程序从Flash或ROM里面拷贝到内存(RAM)中, 然后从内存里面执行代码.<br>    另外一个原因是CPU不能直接从内存卡里面读取指令(需要Flash驱动等等)</p>\n</blockquote>\n<h2 id=\"内存分区\"><a href=\"#内存分区\" class=\"headerlink\" title=\"内存分区\"></a>内存分区</h2><h3 id=\"栈区-stack\"><a href=\"#栈区-stack\" class=\"headerlink\" title=\"栈区(stack)\"></a>栈区(stack)</h3><p>栈区由编译器自动分配并且释放, 存放局部变量, 函数的参数值, 函数跳转地址, 现场保护等.栈是系统数据结构, 对应线程/进程是唯一的. iPhone的栈区大小是512K.</p>\n<p>栈空间分配分为静态分配和动态分配两种.</p>\n<ul>\n<li>静态分配是由便一起完成, 比如自动变量<code>auto</code>的分配. 动态分配由<code>alloca</code>函数完成.</li>\n<li>栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配.</li>\n</ul>\n<p>关于栈还需要注意:</p>\n<ul>\n<li>不需要我们管理栈区变量的内存</li>\n<li>栈区地址从高到低分配</li>\n<li>先进后出</li>\n</ul>\n<h3 id=\"堆区-heap\"><a href=\"#堆区-heap\" class=\"headerlink\" title=\"堆区(heap)\"></a>堆区(heap)</h3><p>堆区由我们分配(iOS下的<code>alloc</code>)和释放, 如果不释放, 在程序结束时, 可能会由系统回收(iOS的ARC下). 灵活方便, 数据适应面广, 但是因为顺序随意, 所以效率有一定降低.<br>关于堆还需要注意:</p>\n<ul>\n<li>堆区的内存分配使用<code>alloc</code>.</li>\n<li>需要程序猿管理.</li>\n<li>ARC下的内存管理由编译器自动添加<code>retain</code>, <code>release</code>, <code>autorelease</code>等关键字.</li>\n<li>堆区的地址由低到高分配.</li>\n<li>不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理).</li>\n<li>堆空间的分配总是动态的.</li>\n</ul>\n<h3 id=\"全局区-static\"><a href=\"#全局区-static\" class=\"headerlink\" title=\"全局区(static)\"></a>全局区(static)</h3><p>全局区也叫作静态区. 全局变量和静态变量在内存中是放在一起的, 初始化的全局变量和静态变量放在一块区域, 未初始化的全局变量和静态变量放在相邻的另一块区域. 程序结束后由系统释放</p>\n<pre><code>int a;//未初始化的\nint b = 10;//初始化的\n</code></pre><h3 id=\"常量区\"><a href=\"#常量区\" class=\"headerlink\" title=\"常量区\"></a>常量区</h3><p>常量字符串就存放在这里, 程序结束后由系统自己释放.</p>\n<h3 id=\"代码区\"><a href=\"#代码区\" class=\"headerlink\" title=\"代码区\"></a>代码区</h3><p>代码区也叫作函数区, 存放函数的二进制代码, App的代码. 程序结束后由系统释放</p>\n<h2 id=\"内存申请后的系统响应\"><a href=\"#内存申请后的系统响应\" class=\"headerlink\" title=\"内存申请后的系统响应\"></a>内存申请后的系统响应</h2><p>1.栈: 存储的函数在执行的时候都会向操作系统索要资源, 栈区就是函数运行时的内训, 栈区中的变量由编译器负责释放和分配, 内存随着函数的运行和结束而分配和释放, 由系统完成. 只要剩余的栈空间大于申请空间, 系统将会为程序提供内存, 否则将报异常提示栈溢出.<br>2.堆: 操作系统有一个记录空闲地址的链表, 当系统收到程序申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序. 由于找到的堆节点大小不一定正合适, 系统会将多余的那部分重新放入空闲链表.</p>\n<h2 id=\"申请内存后系统的响应\"><a href=\"#申请内存后系统的响应\" class=\"headerlink\" title=\"申请内存后系统的响应\"></a>申请内存后系统的响应</h2><ol>\n<li><p>栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.</p>\n</li>\n<li><p>堆: 操作系统有一个记录空闲内存地址的链表. 当系统收到申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从链表中删除, 并将该结点的空间分配给程序. 由于找到的堆结点不一定和申请的大小刚好一致, 系统会将多余的那一部分重新放回到链表中去.  堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.</p>\n</li>\n</ol>\n<h2 id=\"申请大小的限制\"><a href=\"#申请大小的限制\" class=\"headerlink\" title=\"申请大小的限制\"></a>申请大小的限制</h2><ol>\n<li><p>栈: 栈是向低地址扩展的数据结构, 是一块儿连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的, 栈的大小是2M(也有的说是1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间时, 将提示overflow. 因此, 能从栈获得的空间较小.</p>\n</li>\n<li><p>堆: 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储空闲的内存地址的, 自然是不连续的, 而链表的遍历是由低地址到高地址. 堆的大小受限于计算机系统中有效的虚拟内存. 堆获得的空间比较灵活, 也比较大. </p>\n</li>\n</ol>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>如图所示: 代码区的地址最低, 栈区最高. 但是区与区之间的地址不连续.<br><img src=\"http://upload-images.jianshu.io/upload_images/1156719-1d0de5ca1edc35af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"内存地址示意图\"></p>\n<ul>\n<li>栈：由系统自动分配, 速度较快, 不会产生内存碎片. 堆：是由alloc分配的内存, 速度比较慢, 而且容易产生内存碎片, 不过用起来最方便.</li>\n<li>在iOS中, 堆区的内存是程序间共享, 堆区的内存分配是系统负责的.</li>\n<li>系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容).</li>\n<li>变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回.</li>\n<li>当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃.</li>\n<li>栈由系统自动分配, 速度快, 不会产生内存碎片, 先进后出.</li>\n<li>堆由<code>alloc</code>分配内存, 速度慢, 而且容易产生碎片, FIFO, 不过使用起来方便.</li>\n</ul>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://www.jianshu.com/p/f3c1b920e8eb\" target=\"_blank\" rel=\"noopener\">iOS程序中的内存分配</a><br>2.<a href=\"http://www.jianshu.com/p/7bbbe5d55440\" target=\"_blank\" rel=\"noopener\">深入浅出-iOS内存分配</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"属性的修饰符解析","url":"http://hchong.net/2016/09/16/属性的修饰符解析/","content":"<h1 id=\"属性的修饰符解析\"><a href=\"#属性的修饰符解析\" class=\"headerlink\" title=\"属性的修饰符解析\"></a>属性的修饰符解析</h1><h2 id=\"属性的修饰符\"><a href=\"#属性的修饰符\" class=\"headerlink\" title=\"属性的修饰符\"></a>属性的修饰符</h2><ol>\n<li>线程安全的: atomic, nonatomic </li>\n<li>访问权限的: readonly， readwrite </li>\n<li>内存管理（ARC）: assign，strong，weak，copy </li>\n<li>内存管理（MRC）:assign， retain，copy </li>\n<li>指定方法名称: setter= getter=</li>\n</ol>\n<hr>\n<p>默认的修饰符是:</p>\n<ul>\n<li>基本数据类型使用<code>atomic</code>, <code>readwrite</code>, <code>assign</code>.</li>\n<li>对于普通的Objective-C对象使用<code>atomic</code>, <code>readwrite</code>, <code>strong</code>.</li>\n</ul>\n<h2 id=\"weak-amp-assign\"><a href=\"#weak-amp-assign\" class=\"headerlink\" title=\"weak &amp; assign\"></a>weak &amp; assign</h2><p>assign修饰基本数据类型和结构体, weak修饰一个对象</p>\n<hr>\n<p>assign修饰的对象编译时会产生一个警告:Assigning retained object to unsafe_unretained variable; object will be released after assignment(Assign修饰的对象无法被保留). 并且在释放之后指针的地址还是存在的, 也就是说指针并没有被置为nil, 造成野指针. 对象分配一般分配在堆上的某块内存(详见<a href=\"http://hchong.net/2016/09/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/\">内存分配</a>), 如果在后续的内存分配中, 刚好分到了这块地址, 程序就会导致EXC_BAD_ACCESS(调用已释放的内存空间)崩溃掉.</p>\n<p>assign修饰的基本数据类型或者结构体因为技术数据类型和结构体一般分配在栈上, 栈的内存会由系统自己自动处理, 不会造成野指针.</p>\n<hr>\n<p>weak修饰的对象在释放之后, 指针会被置为nil, 所以一般弱引用指的就是用weak.</p>\n<p>weak主要使用在以下两个方面:</p>\n<ul>\n<li>在ARC下, 有可能出现循环引用的地方, 比如delegate<br><code>@property (nonatomic, weak) id XXXDelegate;</code></li>\n<li>自身已经被强引用过一次, 比如xib文件汇总的属性<br><code>@property (nonatomic, weak) IBOutlet UIButton *button;</code></li>\n</ul>\n<hr>\n<h2 id=\"copy关键字的使用\"><a href=\"#copy关键字的使用\" class=\"headerlink\" title=\"copy关键字的使用\"></a>copy关键字的使用</h2><p>copy和strong一样都会使引用计数加1, 但是strong是两个指针指向同一个内训地址, copy则会在内存里拷贝一份对象, 两个指针指向不同的内存地址.</p>\n<p>copy关键字主要有以下使用场景:</p>\n<ul>\n<li>不确定赋值过程中用的是可变还是不可变的变量. 例如NSString, NSArray, NSDictionary等等常使用关键字copy, 因为他们有对应的可变类型.<a href=\"http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/\">关于copy和strong的详解</a></li>\n<li>block也经常使用copy关键字. 用copy修饰block时要知道是在ARC还是MRC.<ul>\n<li>ARC下只要block访问了外部局部变量, block就会放到堆区里面, 使用strong或者copy都可以, 但是strong的性能可能会更好.</li>\n<li>MRC下, 如果block访问外部局部变量, block是在栈区的. 如果block访问了一个整个APP生命周期都存在的变量, 那他肯定在全局区. 只有使用copy属性才能把block放到堆区.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>参考内容:<br>1.<a href=\"http://www.jianshu.com/p/3e0f12e5faaa\" target=\"_blank\" rel=\"noopener\">@property 关键字的区别详解</a><br>2.<a href=\"http://bihongbo.com/2014/05/20/IOSassignandweak/\" target=\"_blank\" rel=\"noopener\">iOS开发中ARC下的assign和weak区别</a><br>3.<a href=\"http://www.jianshu.com/p/3aa1c650a967\" target=\"_blank\" rel=\"noopener\">整理一下OC中的那些属性修饰符</a><br>4.<a href=\"http://blog.csdn.net/qq_32744055/article/details/53443805\" target=\"_blank\" rel=\"noopener\">@property 后面可以有哪些修饰符</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Hello World","url":"http://hchong.net/2016/08/16/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"Wiki","url":"http://hchong.net/Wiki/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://hchong.net/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://hchong.net/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://hchong.net/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://hchong.net/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://hchong.net/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://hchong.net/tag/index.html","content":"","categories":[],"tags":[]}]