[{"title":"设计模式-工厂模式","url":"http://hchong.net/2017/02/08/设计模式-工厂模式/","content":"<h1 id=\"设计模式-工厂模式\"><a href=\"#设计模式-工厂模式\" class=\"headerlink\" title=\"设计模式-工厂模式\"></a>设计模式-工厂模式</h1><p>下面有一个case, 要编写一个简单的计算器程序, 用来实现加减乘除的运算操作, 并且展示出来.我们就拿这个最简单的例子来一步一步见识一下”工厂模式”的魅力.</p>\n<h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>版本一:我们首先想到的最简单的模式就是我们先从业务上来拆分, 把计算器程序分成两部分<em>计算</em>和<em>展示</em>两个类来写代码.OC作为一门面向对象的语言, 在这里我们已经可以清楚地意识到我们已经使用了<em>封装</em>这面向对象语言的一大特性.但是随着业务的发展, 我们发现可能会增加其他的业务(例如增加其他的运算操作),这是我们每次都要修改<em>计算</em>这个类, 慢慢的代码就会越来越多, 不利于维护.而且在新加逻辑的过程中有可能会修改到老的代码, 维护成本很高.这是我们就会想到其他两个特性<em>继承</em>和<em>多态</em>.于是, 就有了版本二.</p>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>这时我们发现,把所有的运算写到一个类中是有些不妥当的, 那么要怎么来修改呢.我们自然地想到, 每一种运算可以单独度的封装为一个类, 只用于实现固定的计算.于是我们可以得到<em>加</em>,<em>减</em>,<em>乘</em>,<em>除</em>四个类, 每个类都三个属性, 分别是<em>操作数</em>和<em>结果</em>.哪里怪怪的呢, 有没有一丝”坏代码”的味道呢.通过提炼我们发现四个类都有相同的三个属性,那么我们可以这样做新建一个<code>Operation</code>操作类, 包含三个<code>Public</code>属性</p>\n<pre><code>@interface Operation : NSObject\n\n@property (nonatomic, assign) CGFloat numberA;\n@property (nonatomic, assign) CGFloat numberB;\n@property (nonatomic, assign) CGFloat numberResult;\n\n- (CGFloat)getResult;\n@end\n</code></pre><p>这样的话, 只需要每一个单独的计算类继承于<code>Operation</code>类, 就会自带父类的三个属性, 只用在他们内部实现自己独有的计算方法, 返回计算结果就可以了.到这里, 我们会发现代码变得更加有意思了.<br>但是我们又发现了一个新的问题, 那就是我们该何时初始化哪个类呢, 毕竟我们现在有了四个计算子类.我们只好计算结果的地方写<code>Switch</code>条件来判断到底要初始化那一个子类.</p>\n<p>可是仍然感觉哪里还是怪怪的.我们不是还有<em>多态</em>这种特性没有使用的嘛.仔细一想, 于是又有了版本三.</p>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><blockquote>\n<p>多态:多态表示不同的对象可以执行相同的操作, 但要通过他们自己的实现代码来执行.<br>这是我们需要增加一个工厂类<code>OperationFactory</code>, 用来判断要初始化哪一个子类.</p>\n</blockquote>\n<p><code>OperationFactory.h</code>代码如下:</p>\n<pre><code>@class Operation;\n@interface OperationFactory : NSObject\n\n+ (Operation *)createOperationWithOperate:(NSString *)operate;\n@end\n</code></pre><p><code>OperationFactory.m</code>代码如下:</p>\n<pre><code>@implementation OperationFactory\n\n//传入计算符号, 初始化不同的子类\n+ (Operation *)createOperationWithOperate:(NSString *)operate {\n    if ([operate isEqualToString:@&quot;+&quot;]) {\n        OperationAdd *add = [[OperationAdd alloc] init];\n        return add;\n    }\n\n    if ([operate isEqualToString:@&quot;-&quot;]) {\n        OperationSubtraction *subtraction = [[OperationSubtraction alloc] init];\n        return subtraction;\n    }\n\n    ...\n    return nil;\n}\n\n@end\n</code></pre><p>此时展示的地方, 代码就变得很简单了:</p>\n<pre><code>@interface ViewController ()\n\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    Operation *operation = [OperationFactory createOperationWithOperate:@&quot;-&quot;];//子类以父类的身份出现\n    operation.numberA = 3;\n    operation.numberB = 5;\n    CGFloat result = [operation getResult];//子类在工作时以自己的方式实现\n    NSLog(@&quot;%f&quot;, result);\n    NSLog(@&quot;%f&quot;, operation.numberResult);\n}\n@end\n</code></pre><p>如上我们可以发现, 整个工厂模式的关键就在于<code>OperationFactory</code>这个工厂类的实现.我们在调用的时候不用关心我们要实现哪一个类, <code>CGFloat result = [operation getResult];</code>, 只用调用父类的方法就可以, 而内部则是子类自己的实现.<br>这里面还有几点要注意:</p>\n<blockquote>\n<ol>\n<li>子类以父类的身份出现</li>\n<li>子类在工作时以自己的方式实现</li>\n<li>子类独有的方法和属性不可以使用</li>\n</ol>\n</blockquote>\n<p>在这里解释一下就是, 我们在展示的时候初始化的实际上是父类<code>Operation</code>.但是在获取计算结果时, 我们使用的是子类的计算方法<code>CGFloat result = [operation getResult];</code>, 因为我们在子类里面复写了父类的方法, 所以实际上走的还是子类各自自己的方法.</p>\n","categories":["设计模式"],"tags":["架构","设计模式"]},{"title":"常见的代码\"坏味道\"","url":"http://hchong.net/2016/12/28/常见的代码坏味道/","content":"<h1 id=\"常见的代码”坏味道”\"><a href=\"#常见的代码”坏味道”\" class=\"headerlink\" title=\"常见的代码”坏味道”\"></a><strong>常见的代码”坏味道”</strong></h1><p>正所谓优雅的代码是相似的, 不优雅的代码却各有各的丑. 最近在拜读&lt;重构- 改善既有代码的设计&gt;一书, 虽然书中大量示例是用Java编写的, 但是也给了我很多启发.<br>见贤思齐, 耗时把感想记录下来, 督促自己的成长. </p>\n<h2 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a><strong>重复代码</strong></h2><p>坏味道行列中 ,最常见的就是Duplicated Code. 如果你在一个以上的地点看到相同的程序结构, 那么可以肯定: 把他们合而为一, 会使得代码变得更好.</p>\n<ol>\n<li><p>最单纯的Duplicated Code就是”同一个类的两个函数有相同的表达式”, 解决办法就是:</p>\n<ul>\n<li>采用Extract Method(提炼函数)提炼出重复的代码, 然后这两个地方都调用提炼出来的那一段代码.</li>\n</ul>\n</li>\n<li><p>两个互为兄弟的子类内包含相同的表达式, 解决办法就是:</p>\n<ul>\n<li>对两个类都是用Extract Method(提炼函数), 再对提炼出来的代码使用Pull Up Method(函数上移)</li>\n<li>如果代码只是类似而不完全相同, 那就要先使用Extract Method(提炼函数)将相似和差异的代码分隔开, 构造成一个单独的函数, 然后再<em>塑造模板函数</em></li>\n</ul>\n</li>\n<li><p>如果两个毫不相关的类出现Duplicated Code, 应该把重复代码提炼到一个独立类中, 然后再另一个类中使用这个新类</p>\n</li>\n</ol>\n<blockquote>\n<p>函数上移(Pull Up Method): 若干个身处子类中的函数, 他们又可以通过某种形式的参数调整成为相同的函数. 这时候, 最简单的方法就是首先分别调整这些函数的参数, 然后再将他们概括到父类中去. 特殊情况: 当子类的函数覆写了父类的函数, 但却仍然做相同的工作.</p>\n<p>塑造模板函数(Form Template Method): 两个函数以相同顺序执行大致相近的操作, 但是各操作不完全相同. 这种情况下我们可以将执行操作的序列移至父类, 并借助多态保证各操仍得以保持差异性.</p>\n</blockquote>\n<h2 id=\"过长函数-Long-Method\"><a href=\"#过长函数-Long-Method\" class=\"headerlink\" title=\"过长函数(Long Method)\"></a><strong>过长函数(Long Method)</strong></h2><p>程序愈长愈难理解.<br>我们应该积极地分解函数, 只要你感觉需要在一个地方加注释, 我们就要把需要说明的东西写进一个独立函数, 并以其用途(而非实现手法)命名. 哪怕替换后的函数调用动作比函数自身还长, 只要函数名称能够解释其用途, 我们就应该毫不犹豫地那么做, 关键不在于函数的长度, 而在于”做什么”和”如何做”之间的语义距离.</p>\n<ol>\n<li>大多数场合, 把函数变小, 只需使用Extract Method(提炼函数). 找到函数中适合集中在一起的部分, 将他们提炼出来一个新函数.</li>\n<li>如果函数中有大量的参数和临时变量, 他们会对你的函数提炼形成阻碍. 如果</li>\n</ol>\n<h2 id=\"过大的类-Large-Class\"><a href=\"#过大的类-Large-Class\" class=\"headerlink\" title=\"过大的类(Large Class)\"></a><strong>过大的类(Large Class)</strong></h2><h2 id=\"过长参数列-Long-Parameter-List\"><a href=\"#过长参数列-Long-Parameter-List\" class=\"headerlink\" title=\"过长参数列(Long Parameter List)\"></a><strong>过长参数列(Long Parameter List)</strong></h2><h2 id=\"发散式变化-Divergent-Change\"><a href=\"#发散式变化-Divergent-Change\" class=\"headerlink\" title=\"发散式变化(Divergent Change)\"></a><strong>发散式变化(Divergent Change)</strong></h2><h2 id=\"霰弹式修改-Shotgun-Surgery\"><a href=\"#霰弹式修改-Shotgun-Surgery\" class=\"headerlink\" title=\"霰弹式修改(Shotgun Surgery)\"></a><strong>霰弹式修改(Shotgun Surgery)</strong></h2><h2 id=\"依恋情结-Feature-Envy\"><a href=\"#依恋情结-Feature-Envy\" class=\"headerlink\" title=\"依恋情结(Feature Envy)\"></a><strong>依恋情结(Feature Envy)</strong></h2><h2 id=\"数据泥团-Data-Clumps\"><a href=\"#数据泥团-Data-Clumps\" class=\"headerlink\" title=\"数据泥团(Data Clumps)\"></a><strong>数据泥团(Data Clumps)</strong></h2><h2 id=\"基本类型偏执-Primitive-Obsession\"><a href=\"#基本类型偏执-Primitive-Obsession\" class=\"headerlink\" title=\"基本类型偏执(Primitive Obsession)\"></a><strong>基本类型偏执(Primitive Obsession)</strong></h2><h2 id=\"Switch-惊悚现身-Switch-Statements\"><a href=\"#Switch-惊悚现身-Switch-Statements\" class=\"headerlink\" title=\"Switch 惊悚现身(Switch Statements)\"></a><strong>Switch 惊悚现身(Switch Statements)</strong></h2><h2 id=\"平行继承体系-Parallel-Inheritance-Hierarchies\"><a href=\"#平行继承体系-Parallel-Inheritance-Hierarchies\" class=\"headerlink\" title=\"平行继承体系(Parallel Inheritance Hierarchies)\"></a><strong>平行继承体系(Parallel Inheritance Hierarchies)</strong></h2><h2 id=\"冗赘类-Lazy-Class\"><a href=\"#冗赘类-Lazy-Class\" class=\"headerlink\" title=\"冗赘类(Lazy Class)\"></a><strong>冗赘类(Lazy Class)</strong></h2><h2 id=\"夸夸其谈未来性-Speculative-Generatlity\"><a href=\"#夸夸其谈未来性-Speculative-Generatlity\" class=\"headerlink\" title=\"夸夸其谈未来性(Speculative Generatlity)\"></a><strong>夸夸其谈未来性(Speculative Generatlity)</strong></h2><h2 id=\"令人迷惑的暂时字段-Temporary-Field\"><a href=\"#令人迷惑的暂时字段-Temporary-Field\" class=\"headerlink\" title=\"令人迷惑的暂时字段(Temporary Field)\"></a><strong>令人迷惑的暂时字段(Temporary Field)</strong></h2><h2 id=\"过度耦合的消息链-Message-Chains\"><a href=\"#过度耦合的消息链-Message-Chains\" class=\"headerlink\" title=\"过度耦合的消息链(Message Chains)\"></a><strong>过度耦合的消息链(Message Chains)</strong></h2><h2 id=\"中间人-Middle-Man\"><a href=\"#中间人-Middle-Man\" class=\"headerlink\" title=\"中间人(Middle Man)\"></a><strong>中间人(Middle Man)</strong></h2><h2 id=\"狎昵关系-Inappropriate-Intimacy\"><a href=\"#狎昵关系-Inappropriate-Intimacy\" class=\"headerlink\" title=\"狎昵关系(Inappropriate Intimacy)\"></a><strong>狎昵关系(Inappropriate Intimacy)</strong></h2><h2 id=\"异曲同工的类-AlertNative-Classes-with-Different-Interfaces\"><a href=\"#异曲同工的类-AlertNative-Classes-with-Different-Interfaces\" class=\"headerlink\" title=\"异曲同工的类(AlertNative Classes with Different Interfaces)\"></a><strong>异曲同工的类(AlertNative Classes with Different Interfaces)</strong></h2><h2 id=\"不完美的库类-Incomplete-Library-Class\"><a href=\"#不完美的库类-Incomplete-Library-Class\" class=\"headerlink\" title=\"不完美的库类(Incomplete Library Class)\"></a><strong>不完美的库类(Incomplete Library Class)</strong></h2><h2 id=\"纯稚的数据类-Data-Class\"><a href=\"#纯稚的数据类-Data-Class\" class=\"headerlink\" title=\"纯稚的数据类(Data Class)\"></a><strong>纯稚的数据类(Data Class)</strong></h2><h2 id=\"被拒绝的遗赠-Refused-Bequest\"><a href=\"#被拒绝的遗赠-Refused-Bequest\" class=\"headerlink\" title=\"被拒绝的遗赠(Refused Bequest)\"></a><strong>被拒绝的遗赠(Refused Bequest)</strong></h2><h2 id=\"过多的注释-COmments\"><a href=\"#过多的注释-COmments\" class=\"headerlink\" title=\"过多的注释(COmments)\"></a><strong>过多的注释(COmments)</strong></h2>","categories":["架构"],"tags":["重构","架构"]},{"title":"代码重构与拆分","url":"http://hchong.net/2016/12/26/代码重构与拆分/","content":"<h1 id=\"代码的重构与拆分\"><a href=\"#代码的重构与拆分\" class=\"headerlink\" title=\"代码的重构与拆分\"></a><strong>代码的重构与拆分</strong></h1><p>最近项目中有一块代码, 几经人手, 流落到我这里. 代码的业务逻辑十分复杂, 而且随着业务的扩张, 被不同的人加入而不同风格的代码, 最初的架构已经不适合现有业务的发展了, 维护起来也是相当的困难. 于是, 我就走上了重构和拆分之路.</p>\n<p>实际上来讲, 重构和拆分是两个不同的概念, 但是又都是相辅相成, 下面我简单讲一下我的理解.</p>\n<blockquote>\n<p>重构: 对软件内部结构的一种调整, 目的是在不改变软件可观察行为的前提下, 提高其可理解性, 降低其修改成本.</p>\n</blockquote>\n<ul>\n<li>拆分: 整体项目的架构, 降低代码的耦合性, 使得团队中的成员协作使用起来更加容易.</li>\n</ul>\n<p>不管重构还是拆分, 都是为了让代码能够跟上业务发展的水平, 不至于变得一团乱麻, 让团队之间的协作开发更加有效.</p>\n","categories":["架构"],"tags":["重构","拆分"]},{"title":"hexo常见问题","url":"http://hchong.net/2016/12/21/hexo常见问题/","content":"<h1 id=\"hexo常见问题\"><a href=\"#hexo常见问题\" class=\"headerlink\" title=\"hexo常见问题\"></a><strong>hexo常见问题</strong></h1><p>在使用hexo的过程中遇到了一些问题, 在这里列出来, 做一个记录.</p>\n<h2 id=\"hexo的常见发布流程\"><a href=\"#hexo的常见发布流程\" class=\"headerlink\" title=\"hexo的常见发布流程\"></a><strong>hexo的常见发布流程</strong></h2><ul>\n<li>hexo新建一篇文章使用<code>hexo new type name</code>, <code>type</code>有三种, 最常使用的是<code>post</code>, <code>name</code>是新建文档的名字.</li>\n<li><p>hexo新建完成, 编辑之后发布会经常使用到下面几个命令:</p>\n<ul>\n<li><code>hexo clean</code>清除之前缓存的一些信息, 例如主题之类的, 不是每次都必须执行.</li>\n<li><code>hexo g</code>相当于编译.</li>\n<li><code>hexo s</code>发布到本地服务器, 把<em>.md</em>文件生成讲台html用于展示, 也可做调试用.</li>\n<li><code>hexo d</code>推本地的文件到服务器, 这里指的是github上面, 如果绑定的有域名, 就直接发布到Internet. 每次推送前, 要确保<code>hexo g</code>和<code>hexo s</code>没有问题, 否则可造成Internet上面无法正常显示.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"hexo目录结构分析\"><a href=\"#hexo目录结构分析\" class=\"headerlink\" title=\"hexo目录结构分析\"></a><strong>hexo目录结构分析</strong></h2><h3 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a><strong>根目录</strong></h3><ul>\n<li>_config.yml: 位于本地博客的根目录下, 在这里面对整个博客的内容进行一些设置.</li>\n<li>source文件夹: 里面存储一些博客使用的文件资源, 例如<em>category(分类)</em>, <em>tag(标签)</em>, <em>link(链接)</em>, <em>about(关于)</em>, <em>project(工程)</em>, <em>search(搜索)</em>, *_posts(使用post格式新建的文章.md文件存储在这里).需要说明一下的是, 这些文件夹的名称和数量不固定, 要看你使用的主题里面的模块大概有几个 ,我使用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"external\">fexo</a>.还有一些坑, 后面再详述.</li>\n<li>public文件夹: 里面存储的是之前发布过得一些归档数据, 如果要删除之前的测试数据的话, 记得清理里面响应的内容.</li>\n<li>scaffolds文件夹: 存储.md文档的类型.</li>\n<li>themes文件夹: 里面是你下载的主题内容, 如果有多个主题, 就会有多个文件夹, 但只能同时使用一种样式的主题.这个后面会着重分析一下.</li>\n</ul>\n<h3 id=\"themes文件夹\"><a href=\"#themes文件夹\" class=\"headerlink\" title=\"themes文件夹\"></a><strong>themes文件夹</strong></h3><p>这里面主要会进行一些主题相关的设置.</p>\n<ul>\n<li>_config.yml: 位于主题目录下, 在这里面对当前只用主题的内容进行一些配置, 不同主题的配置可能不太一样, 我是用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"external\">fexo</a></li>\n</ul>\n<ul>\n<li>source文件夹: 该文件夹下面是该主题相关的一些资源, 例如一些静态的图片之类的.</li>\n<li>layout文件夹: 该文件夹下面是静态页面显示的相关配置. 代码高亮的设置也是在该文件夹下面. 其他的例如静态页面的展示, 可以修改相关的js文件.</li>\n</ul>\n<h2 id=\"修改代码高亮\"><a href=\"#修改代码高亮\" class=\"headerlink\" title=\"修改代码高亮\"></a><strong>修改代码高亮</strong></h2><p>代码高亮的展示, 不同的主题有不同的使用方式, 但是代码高亮的theme可以参考这里, 我使用的是<a href=\"https://highlightjs.org/static/demo/\" target=\"_blank\" rel=\"external\">HighLight</a>, 它提供了多种Theme, 基本上能满足各种需求.</p>\n<p>修改步骤如下:</p>\n<p>1.修改博客根目录下的<em>_config.yml</em>文件, 关闭hexo自带的代码高亮.</p>\n<pre><code class=\"js\">highlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n</code></pre>\n<p>2.<code>cd 博客根目录/themes/fexo/layout/_partial</code>打开<em>head.ejs</em>文件, 最好是在<code>&lt;head&gt;&lt;/head&gt;</code>之间开头处插入代码</p>\n<pre><code class=\"html5\">  &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css&quot;&gt;\n  &lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>也可以使用下面的写法:</p>\n<pre><code class=\"h5\">&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/styles/default.css&quot;&gt;\n&lt;script src=&quot;/path/to/highlight.pack.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>二者的区别在于, 第一种写法使用的是CDN创建的<a href=\"http://www.bootcdn.cn/?\" target=\"_blank\" rel=\"external\">在线文档地址</a>, 该地址还保存了其他一些常见的文档, 非常强大.而第二种写法则是把文件下载到本地, 从本地读取代码高亮的配置.</p>\n<hr>\n<p>修改过程中, 我参考了以下两篇博文, 还趟过不少坑, 贴上博文的地址:</p>\n<ol>\n<li><a href=\"http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-highlight/\" target=\"_blank\" rel=\"external\">地址一</a></li>\n<li><a href=\"http://jumpbyte.cn/2016/07/02/use-and-install-prettify/\" target=\"_blank\" rel=\"external\">地址二</a></li>\n</ol>\n","categories":["hexo"],"tags":["hexo","个人博客"]},{"title":"属性修饰符之copy和strong","url":"http://hchong.net/2016/09/21/属性修饰符之copy和strong/","content":"<h1 id=\"属性修饰符之copy和strong\"><a href=\"#属性修饰符之copy和strong\" class=\"headerlink\" title=\"属性修饰符之copy和strong\"></a>属性修饰符之copy和strong</h1><p>在了解属性修饰符的copy和strong的区分之前, 我们先来了解下浅拷贝和深拷贝的区别.</p>\n<h2 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h2><p>浅复制并不是拷贝对象本身, 仅仅是拷贝指向对象的指针; 深复制是直接拷贝整个对象内存到另一块内存中. 简单地说:</p>\n<ul>\n<li><strong>浅复制就是指针拷贝,  不会产生新的对象，指向的是同一个对象; </strong></li>\n<li><strong>深复制就是内容拷贝，会产生新的对象, 不同的对象, 内容相同.</strong></li>\n</ul>\n<p><img src=\"http://7s1ssm.com1.z0.glb.clouddn.com/image_note50592_1.png\" alt=\"浅复制和深复制\"></p>\n<h2 id=\"copy和mutableCopy\"><a href=\"#copy和mutableCopy\" class=\"headerlink\" title=\"copy和mutableCopy\"></a>copy和mutableCopy</h2><p><code>copy</code>就是复制了一个imutable对象, <code>mutableCopy</code>就是复制了一个mutable对象.</p>\n<p>一个<code>NSObject</code>对象要想使用这两个函数, 必须实现<code>NSCopying</code>协议和<code>NSMutableCopying</code>协议, 并且分别实现<code>- (id)copyWithZone:(nullable NSZone *)zone;</code>和<code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code>方法.但是常见的<code>NSString</code>, <code>NSArray</code>, <code>NADictionary</code>等常用的系统提供的结构体都已经实现. </p>\n<h3 id=\"系统的非容器类对象\"><a href=\"#系统的非容器类对象\" class=\"headerlink\" title=\"系统的非容器类对象\"></a>系统的非容器类对象</h3><p>这里指的是<code>NSString</code>, <code>NSNumber</code>等等一类的对象.下面以<code>NSString</code>为例.</p>\n<p>对<code>NSString</code>进行copy和mutableCop操作:</p>\n<pre><code class=\"objective-c\">NSString *originString = @&quot;origin&quot;;\nNSString *originStringCopy = [originString copy];\nNSMutableString *originStringMutableCopy = [originString mutableCopy];\nNSLog(@&quot;%p, %p, %p&quot;, originString, originStringCopy, originStringMutableCopy);\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originString\n(__NSCFConstantString *) $0 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringCopy\n(__NSCFConstantString *) $1 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringMutableCopy\n(__NSCFString *) $2 = 0x0000608000262800 @&quot;origin&quot;\n</code></pre>\n<hr>\n<p>对<code>NSMutableString</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginString = [NSMutableString stringWithString:@&quot;mutableOrigin&quot;];\nNSString *mutableOriginStringCopy = [mutableOriginString copy];\nNSMutableString *mutableOriginStringMutableCopy = [mutableOriginString mutableCopy];\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p mutableOriginString\n(__NSCFString *) $0 = 0x000060800026aa40 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringCopy\n(__NSCFString *) $1 = 0x0000608000222340 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringMutableCopy\n(__NSCFString *) $2 = 0x000060800026a700 @&quot;mutableOrigin&quot;\n</code></pre>\n<p>这里要注意的是:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginStringCopy = [mutableOriginString copy];\n[mutableOriginStringCopy appendString:@&quot;123&quot;];\n</code></pre>\n<p>这样写是会crash的, 因为copy生成的是imutable对象, 不管声明是什么样的, 依旧是imutable的.</p>\n<p><strong>综上, 对于系统的非容器类对象:</strong></p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n</ul>\n<h3 id=\"系统的容器类对象\"><a href=\"#系统的容器类对象\" class=\"headerlink\" title=\"系统的容器类对象\"></a>系统的容器类对象</h3><p>容器类对象指的是<code>NSArray</code>, <code>NSDictionary</code>, <code>NSSet</code>等系统提供的结构体, 下面以<code>NSArray</code>为例.</p>\n<p>对<code>NSArray</code>进行copy操作:</p>\n<pre><code class=\"objective-c\">NSArray *originArray = [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayI *) $0 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x00006080002403c0 @&quot;3 elements&quot;\n</code></pre>\n<p>可以看出, copy是浅复制, mutableCopy是深复制. 需要注意的是,mutableCopy的对象是一个可变对象,  数组内元素全都是浅复制.</p>\n<hr>\n<p>对<code>NSMutableArray</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>打印内存地址如下:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayM *) $0 = 0x000060800005eae0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x000060800005e9f0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x000060800005e900 @&quot;3 elements&quot;\n</code></pre>\n<p>可以发现可以看出, copy是浅复制, mutableCopy是深复制. 数组内元素都是浅复制.</p>\n<p>需要注意的是, mutable对象copy的对象是imutable对象, 如果当做可变对象来用是会崩溃的.</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSMutableArray *originArrayCopy1 = [originArray copy];\n[originArrayCopy1 addObject:@&quot;d&quot;];//crash\n</code></pre>\n<p>综上, 对于容器类对象:</p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n<li><strong>元素对象是浅复制.</strong></li>\n</ul>\n<h3 id=\"系统类对象的完全深复制\"><a href=\"#系统类对象的完全深复制\" class=\"headerlink\" title=\"系统类对象的完全深复制\"></a>系统类对象的完全深复制</h3><p>对于容器类对象而言, 元素对象始终是浅复制, 要想深复制可通过如下方法:</p>\n<pre><code class=\"objective-c\">NSArray *array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],[NSString stringWithString:@&quot;b&quot;],@&quot;c&quot;,nil];\nNSArray *deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];\nNSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject: array]];\n</code></pre>\n<p>打印元素内存地址可以发现, trueDeepCopyArray的元素都是深复制, 而deepCopyArray由于第一个元素是可变对象, 所以是深复制, 其他的元素都是浅复制.</p>\n<p><strong>综上, 要想实现容器对象所有元素的深复制, 只能通过归档来实现.</strong></p>\n<blockquote>\n<p>If you need a true deep copy, such as when you have an array of arrays, you can archive and then unarchive the collection, provided the contents all conform to the <code>NSCoding</code> protocol</p>\n</blockquote>\n<pre><code class=\"objective-c\">@protocol NSCoding\n\n- (void)encodeWithCoder:(NSCoder *)aCoder;\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER\n\n@end\n</code></pre>\n<h3 id=\"自定义对象\"><a href=\"#自定义对象\" class=\"headerlink\" title=\"自定义对象\"></a>自定义对象</h3><p>对于自定义对象, 我们要实现<code>NSCopying</code>, <code>NSMutableCopying</code>协议, 这样我们就能调用copy和mutableCopy了.假设有一个<code>Person</code>类, 继承于<code>NSObject</code>.</p>\n<p><code>person.h</code></p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n@interface Person : NSobject\n\n@property (nonatomic, assign) NSInteger age;\n@end\n</code></pre>\n<p><code>person.m</code></p>\n<pre><code class=\"objective-c\">\n#import &quot;Person.h&quot;\n@interface Person()&lt;NSCopying&gt;\n@end\n\n@implementation Person\n\n- (id)copyWithZone:(NSZone *)zone {\n    Person *person = [[Person allocWithZone:zone] init];\n      person.age = self.age;\n    return person;\n}\n@end\n</code></pre>\n<p>这样当我们在外面调用的时候:</p>\n<pre><code class=\"objective-c\">Person *p = [[Person alloc] init];\np.age = 20;\n\nPerson *copyP = [p copy];\nNSLog(@&quot;p = %p copyP = %p&quot;, p, copyP);\nNSLog(@&quot;age = %ld&quot;, copyP.age);\n</code></pre>\n<p>通过打印地址:</p>\n<pre><code class=\"objective-c\">(lldb) p p\n(Person *) $0 = 0x000060800002a1e0\n(lldb) p copyP\n(Person *) $1 = 0x000060800002a2e0\n(lldb) p p.age\n(NSInteger) $2 = 20\n(lldb) p copyP.age\n(NSInteger) $4 = 20\n</code></pre>\n<p>我们可以发现, 自定义对象内部的属性都被浅拷贝, 自定义对象本身被深拷贝.</p>\n<p>需要注意的是, 如果我们的自定义对象不实现<code>NSCopying</code>协议而直接copy时, 是会crash的.</p>\n<h2 id=\"属性修饰之copy与strong\"><a href=\"#属性修饰之copy与strong\" class=\"headerlink\" title=\"属性修饰之copy与strong\"></a>属性修饰之copy与strong</h2><p>我们新建一个<code>Person</code>类, 添加几个属性来看一下copy和strong对属性使用的影响.</p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface Person : NSObject\n\n@property (nonatomic, strong) NSString *strongName;\n@property (nonatomic, copy) NSString *copyName;\n\n@end\n</code></pre>\n<p>在外面调用<code>Person</code>类, 代码如下:</p>\n<pre><code class=\"objective-c\">Person *person = [[Person alloc] init];\nNSMutableString *testString = [NSMutableString stringWithString:@&quot;test&quot;];\nperson.nameCopy = testString;\nperson.nameStrong = testString;\n[testString appendString:@&quot;copy&amp;&amp;strong&quot;];\n</code></pre>\n<p>打印<code>testString</code>改变前后属性</p>\n<pre><code class=\"objective-c\">//testString改变前\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $1 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $2 = 0x0000600000260540 @&quot;test&quot;\n//testString改变后\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $3 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $4 = 0x0000600000260540 @&quot;testcopy&amp;&amp;strong&quot;\n</code></pre>\n<p>由以上可以看出:</p>\n<p>对源头是<code>NSMutableString</code>的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的，它也会跟着改变, 相当于浅拷贝; 而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>\n<p>当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>\n<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>\n<p>综上可以发现, 如果property是<code>NSString</code>或者<code>NSArray</code>及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。</p>\n<p>参考文档:</p>\n<p>1.<a href=\"http://www.fanliugen.com/?p=278\" target=\"_blank\" rel=\"external\">copy与mutableCopy</a></p>\n<p>2.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3\" target=\"_blank\" rel=\"external\">Copying Collections</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e6a7cdcc705d\" target=\"_blank\" rel=\"external\">iOS浅谈: 深.浅拷贝与copy.strong</a></p>\n<p>4.<a href=\"http://www.cocoachina.com/ios/20150512/11805.html\" target=\"_blank\" rel=\"external\">NSString属性什么时候用copy，什么时候用strong?</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"内存分配","url":"http://hchong.net/2016/09/18/内存分配/","content":"<h1 id=\"iOS开发的内存分配\"><a href=\"#iOS开发的内存分配\" class=\"headerlink\" title=\"iOS开发的内存分配\"></a>iOS开发的内存分配</h1><p>计算机系统中, 应用程序的数据都保存在内存中, 不同类型的数据, 保存的区域不同.</p>\n<h2 id=\"RAM-ROM\"><a href=\"#RAM-ROM\" class=\"headerlink\" title=\"RAM ROM\"></a>RAM ROM</h2><blockquote>\n<p>RAM: 运行内存, 不能掉电存储.ROM: 存储型内存, 可以掉电存储, 例如内存卡, FLash.<br>    由于RAM类型不具备掉电存储的能力, 所以App程序一般存放在RMO中. RAM的访问速度和价格都高于ROM.</p>\n</blockquote>\n<h2 id=\"App程序启动\"><a href=\"#App程序启动\" class=\"headerlink\" title=\"App程序启动\"></a>App程序启动</h2><blockquote>\n<p>App程序启动, 系统会把开启的那个App程序从Flash或ROM里面拷贝到内存(RAM)中, 然后从内存里面执行代码.<br>    另外一个原因是CPU不能直接从内存卡里面读取指令(需要Flash驱动等等)</p>\n</blockquote>\n<h2 id=\"内存分区\"><a href=\"#内存分区\" class=\"headerlink\" title=\"内存分区\"></a>内存分区</h2><h3 id=\"栈区-stack\"><a href=\"#栈区-stack\" class=\"headerlink\" title=\"栈区(stack)\"></a>栈区(stack)</h3><p>栈区由编译器自动分配并且释放, 存放局部变量, 函数的参数值, 函数跳转地址, 现场保护等.栈是系统数据结构, 对应线程/进程是唯一的.</p>\n<p>栈空间分配分为静态分配和动态分配两种.</p>\n<ul>\n<li>静态分配是由便一起完成, 比如自动变量<code>auto</code>的分配. 动态分配由<code>alloca</code>函数完成.</li>\n<li>栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配.</li>\n</ul>\n<p>关于栈还需要注意:</p>\n<ul>\n<li>不需要我们管理栈区变量的内存</li>\n<li>栈区地址从高到低分配</li>\n<li>先进后出</li>\n</ul>\n<h3 id=\"堆区-heap\"><a href=\"#堆区-heap\" class=\"headerlink\" title=\"堆区(heap)\"></a>堆区(heap)</h3><p>堆区由我们分配(iOS下的<code>alloc</code>)和释放, 如果不释放, 在程序结束时, 可能会由系统回收(iOS的ARC下). 灵活方便, 数据适应面广, 但是因为顺序随意, 所以效率有一定降低.<br>关于堆还需要注意:</p>\n<ul>\n<li>堆区的内存分配使用<code>alloc</code>.</li>\n<li>需要程序猿管理.</li>\n<li>ARC下的内存管理由编译器自动添加<code>retain</code>, <code>release</code>, <code>autorelease</code>等关键字.</li>\n<li>堆区的地址由低到高分配.</li>\n<li>不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理).</li>\n<li>堆空间的分配总是动态的.</li>\n</ul>\n<h3 id=\"全局区-static\"><a href=\"#全局区-static\" class=\"headerlink\" title=\"全局区(static)\"></a>全局区(static)</h3><p>全局区也叫作静态区. 全局变量和静态变量在内存中是放在一起的, 初始化的全局变量和静态变量放在一块区域, 未初始化的全局变量和静态变量放在相邻的另一块区域.</p>\n<pre><code>int a;//未初始化的\nint b = 10;//初始化的\n</code></pre><h3 id=\"常量区\"><a href=\"#常量区\" class=\"headerlink\" title=\"常量区\"></a>常量区</h3><p>常量字符串就存放在这里, 程序结束后由系统自己释放.</p>\n<h3 id=\"代码区\"><a href=\"#代码区\" class=\"headerlink\" title=\"代码区\"></a>代码区</h3><p>代码区也叫作函数区, 存放函数的二进制代码, App的代码.</p>\n<h2 id=\"内存申请后的系统响应\"><a href=\"#内存申请后的系统响应\" class=\"headerlink\" title=\"内存申请后的系统响应\"></a>内存申请后的系统响应</h2><p>1.栈: 存储的函数在执行的时候都会向操作系统索要资源, 栈区就是函数运行时的内训, 栈区中的变量由编译器负责释放和分配, 内存随着函数的运行和结束而分配和释放, 由系统完成. 只要剩余的栈空间大于申请空间, 系统将会为程序提供内存, 否则将报异常提示栈溢出.<br>2.堆: 操作系统有一个记录空闲地址的链表, 当系统收到程序申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序. 由于找到的堆节点大小不一定正合适, 系统会将多余的那部分重新放入空闲链表.</p>\n<h2 id=\"内存大小的限制\"><a href=\"#内存大小的限制\" class=\"headerlink\" title=\"内存大小的限制\"></a>内存大小的限制</h2><p>1.栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.<br>2.堆: 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>如图所示: 代码区的地址最低, 栈区最高. 但是区与区之间的地址不连续.<br><img src=\"http://upload-images.jianshu.io/upload_images/1156719-1d0de5ca1edc35af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"内存地址示意图\"></p>\n<ul>\n<li>在iOS中, 堆区的内存是程序间共享, 堆区的内存分配是系统负责的.</li>\n<li>系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容).</li>\n<li>变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回.</li>\n<li>当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃.</li>\n<li>栈由系统自动分配, 速度快, 不会产生内存碎片, 先进后出.</li>\n<li>堆由<code>alloc</code>分配内存, 速度慢, 而且容易产生碎片, FIFO, 不过使用起来方便.</li>\n</ul>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://www.jianshu.com/p/f3c1b920e8eb\" target=\"_blank\" rel=\"external\">iOS程序中的内存分配</a><br>2.<a href=\"http://www.jianshu.com/p/7bbbe5d55440\" target=\"_blank\" rel=\"external\">深入浅出-iOS内存分配</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"属性的修饰符解析","url":"http://hchong.net/2016/09/16/属性的修饰符解析/","content":"<h1 id=\"属性的修饰符解析\"><a href=\"#属性的修饰符解析\" class=\"headerlink\" title=\"属性的修饰符解析\"></a>属性的修饰符解析</h1><h2 id=\"属性的修饰符\"><a href=\"#属性的修饰符\" class=\"headerlink\" title=\"属性的修饰符\"></a>属性的修饰符</h2><ol>\n<li>线程安全的: atomic, nonatomic </li>\n<li>访问权限的: readonly， readwrite </li>\n<li>内存管理（ARC）: assign，strong，weak，copy </li>\n<li>内存管理（MRC）:assign， retain，copy </li>\n<li>指定方法名称: setter= getter=</li>\n</ol>\n<hr>\n<p>默认的修饰符是:</p>\n<ul>\n<li>基本数据类型使用<code>atomic</code>, <code>readwrite</code>, <code>assign</code>.</li>\n<li>对于普通的Objective-C对象使用<code>atomic</code>, <code>readwrite</code>, <code>strong</code>.</li>\n</ul>\n<h2 id=\"weak-amp-assign\"><a href=\"#weak-amp-assign\" class=\"headerlink\" title=\"weak &amp; assign\"></a>weak &amp; assign</h2><p>assign修饰基本数据类型和结构体, weak修饰一个对象</p>\n<hr>\n<p>assign修饰的对象编译时会产生一个警告:Assigning retained object to unsafe_unretained variable; object will be released after assignment(Assign修饰的对象无法被保留). 并且在释放之后指针的地址还是存在的, 也就是说指针并没有被置为nil, 造成野指针. 对象分配一般分配在堆上的某块内存(详见<a href=\"http://hchong.net/2016/09/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/\">内存分配</a>), 如果在后续的内存分配中, 刚好分到了这块地址, 程序就会导致EXC_BAD_ACCESS(调用已释放的内存空间)崩溃掉.</p>\n<p>assign修饰的基本数据类型或者结构体因为技术数据类型和结构体一般分配在栈上, 栈的内存会由系统自己自动处理, 不会造成野指针.</p>\n<hr>\n<p>weak修饰的对象在释放之后, 指针会被置为nil, 所以一般弱引用指的就是用weak.</p>\n<p>weak主要使用在以下两个方面:</p>\n<ul>\n<li>在ARC下, 有可能出现循环引用的地方, 比如delegate<br><code>@property (nonatomic, weak) id XXXDelegate;</code></li>\n<li>自身已经被强引用过一次, 比如xib文件汇总的属性<br><code>@property (nonatomic, weak) IBOutlet UIButton *button;</code></li>\n</ul>\n<hr>\n<h2 id=\"copy关键字的使用\"><a href=\"#copy关键字的使用\" class=\"headerlink\" title=\"copy关键字的使用\"></a>copy关键字的使用</h2><p>copy和strong一样都会使引用计数加1, 但是strong是两个指针指向同一个内训地址, copy则会在内存里拷贝一份对象, 两个指针指向不同的内存地址.</p>\n<p>copy关键字主要有以下使用场景:</p>\n<ul>\n<li>不确定赋值过程中用的是可变还是不可变的变量. 例如NSString, NSArray, NSDictionary等等常使用关键字copy, 因为他们有对应的可变类型.<a href=\"http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/\">关于copy和strong的详解</a></li>\n<li>block也经常使用copy关键字. 用copy修饰block时要知道是在ARC还是MRC.<ul>\n<li>ARC下只要block访问了外部局部变量, block就会放到堆区里面, 使用strong或者copy都可以, 但是strong的性能可能会更好.</li>\n<li>MRC下, 如果block访问外部局部变量, block是在栈区的. 如果block访问了一个整个APP生命周期都存在的变量, 那他肯定在全局区. 只有使用copy属性才能把block放到堆区.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>参考内容:<br>1.<a href=\"http://www.jianshu.com/p/3e0f12e5faaa\" target=\"_blank\" rel=\"external\">@property 关键字的区别详解</a><br>2.<a href=\"http://bihongbo.com/2014/05/20/IOSassignandweak/\" target=\"_blank\" rel=\"external\">iOS开发中ARC下的assign和weak区别</a><br>3.<a href=\"http://www.jianshu.com/p/3aa1c650a967\" target=\"_blank\" rel=\"external\">整理一下OC中的那些属性修饰符</a><br>4.<a href=\"http://blog.csdn.net/qq_32744055/article/details/53443805\" target=\"_blank\" rel=\"external\">@property 后面可以有哪些修饰符</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Hello World","url":"http://hchong.net/2016/08/16/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"about","url":"http://hchong.net/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://hchong.net/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://hchong.net/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://hchong.net/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://hchong.net/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://hchong.net/tag/index.html","content":"","categories":[],"tags":[]}]