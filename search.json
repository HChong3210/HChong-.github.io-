[{"title":"Xcode神器-Instruments大法","url":"http://hchong.net/2017/04/23/Xcode神器-Instruments大法/","content":"<h1 id=\"Xcode调试神器-Instruments大法\"><a href=\"#Xcode调试神器-Instruments大法\" class=\"headerlink\" title=\"Xcode调试神器-Instruments大法\"></a>Xcode调试神器-Instruments大法</h1>","categories":["基础知识"],"tags":["基础知识","调试"]},{"title":"通讯录数据的读取和性能优化","url":"http://hchong.net/2017/04/23/通讯录数据的读取和性能优化/","content":"<h1 id=\"通讯录数据的读取和性能优化\"><a href=\"#通讯录数据的读取和性能优化\" class=\"headerlink\" title=\"通讯录数据的读取和性能优化\"></a>通讯录数据的读取和性能优化</h1><p>前段时间再做一个关于通讯录相关的项目, 记录一下通讯录相关的基础和读取优化的部分. 在本篇文章中, 我主要侧重读取通讯录数据方面, 至于调用原生的界面在这里则不做阐述. 关于通讯录的API, 在iOS9之后做了较大的调整, 使用<code>Contacts Framework</code>替代<code>AddressBookFramework</code>. 下面我将就iOS9和iOS8两种API进行分析.</p>\n<h2 id=\"通讯录的授权\"><a href=\"#通讯录的授权\" class=\"headerlink\" title=\"通讯录的授权\"></a>通讯录的授权</h2><p>既然要读取通讯录, 那么通讯录授权状态的查询, 要放在在前面, 这里也区分iOS9和iOS8系统.</p>\n<h3 id=\"iOS8查询通讯录授权状态\"><a href=\"#iOS8查询通讯录授权状态\" class=\"headerlink\" title=\"iOS8查询通讯录授权状态\"></a>iOS8查询通讯录授权状态</h3><pre><code>+ (void)checkAddressBookAuthorization:(void (^)(bool isAuthorized))block {\n    ABAddressBookRef addressBookRef =  ABAddressBookCreateWithOptions(NULL, NULL);\n    switch (ABAddressBookGetAuthorizationStatus()) {\n        case kABAuthorizationStatusNotDetermined: {\n            NSLog(@&quot;未询问用户是否授权&quot;);\n            ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) {\n                if (granted) {\n                    NSLog(@&quot;授权可以读取&quot;);\n                    block(YES);\n                } else {\n                    NSLog(@&quot;授权不能读取&quot;);\n                    block(NO);\n                }\n            });\n        } break;\n        case kABAuthorizationStatusAuthorized: {\n            NSLog(@&quot;同意授权通讯录&quot;);\n            block(YES);\n        } break;\n        case kABAuthorizationStatusDenied: {\n            block(NO);\n            NSLog(@&quot;未授权，用户拒绝造成的&quot;);\n        } break;\n        case kABAuthorizationStatusRestricted: {\n            block(NO);\n            NSLog(@&quot;未授权，例如家长控制&quot;);\n        } break;\n        default: {\n        } break;\n    }\n}\n</code></pre><h3 id=\"iOS9查询通讯录授权状态\"><a href=\"#iOS9查询通讯录授权状态\" class=\"headerlink\" title=\"iOS9查询通讯录授权状态\"></a>iOS9查询通讯录授权状态</h3><pre><code>- (void)addressBookEmpowerCheck {\n    CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts];\n    switch (status) {\n        case CNAuthorizationStatusNotDetermined: {\n            [[[CNContactStore alloc]init] requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n                NSLog(@&quot;还没问&quot;);\n                if (granted) {\n                    NSLog(@&quot;点击了同意&quot;);\n                } else {\n                    NSLog(@&quot;点击了拒绝&quot;);\n                }\n            }];\n        }\n        break;\n        case CNAuthorizationStatusRestricted: {\n            NSLog(@&quot;未授权, 例如家长控制&quot;);\n        }\n        break;\n        case CNAuthorizationStatusDenied: {\n            NSLog(@&quot;未授权, 用户拒绝所致&quot;);\n        }\n        break;\n        case CNAuthorizationStatusAuthorized: {\n            NSLog(@&quot;已经授权&quot;);\n        }\n        break;\n        default: {\n        }\n        break;\n    }\n}\n</code></pre><p>注意: 如果是iOS10的系统需要在<code>Info.plist</code>配置<code>NSContactsUsageDescription</code></p>\n<pre><code>&lt;key&gt;NSContactsUsageDescription&lt;/key&gt;\n&lt;string&gt;请求访问通讯录&lt;/string&gt;\n</code></pre><h2 id=\"通讯录数据写入和删除\"><a href=\"#通讯录数据写入和删除\" class=\"headerlink\" title=\"通讯录数据写入和删除\"></a>通讯录数据写入和删除</h2><p>当通讯录数据少时, 数据的读取耗时较少, 为了更好地测试大量数据下的性能问题, 我们先写入大量的数据来进行测试. </p>\n<h3 id=\"iOS8写入联系人\"><a href=\"#iOS8写入联系人\" class=\"headerlink\" title=\"iOS8写入联系人\"></a>iOS8写入联系人</h3><pre><code>- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone {\n    if((name.length &lt; 1)||(phone.length &lt; 1)){\n        NSLog(@&quot;输入属性不能为空&quot;);\n        return;\n    }\n    CFErrorRef error = NULL;\n\n    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, &amp;error);\n    ABRecordRef newRecord = ABPersonCreate();\n    ABRecordSetValue(newRecord, kABPersonFirstNameProperty, (__bridge CFTypeRef)name, &amp;error);\n\n    ABMutableMultiValueRef multi = ABMultiValueCreateMutable(kABMultiStringPropertyType);\n    ABMultiValueAddValueAndLabel(multi, (__bridge CFTypeRef)name, kABPersonPhoneMobileLabel, NULL);\n\n    ABRecordSetValue(newRecord, kABPersonPhoneProperty, multi, &amp;error);\n    CFRelease(multi);\n\n    ABAddressBookAddRecord(addressBook, newRecord, &amp;error);\n    CFRelease(newRecord);\n    CFRelease(addressBook);\n}\n</code></pre><p>需要注意的是, 在本例中, 只填写了<code>FirstName</code>和<code>phone</code>, 实际还有许多其他属性可供选择, 具体参照<code>ABAddressBookRef</code>和<code>ABRecordRef</code>需要调用<code>CFRelease</code>来释放内存.</p>\n<h3 id=\"iOS9写入联系人\"><a href=\"#iOS9写入联系人\" class=\"headerlink\" title=\"iOS9写入联系人\"></a>iOS9写入联系人</h3><pre><code>- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone {\n    // 创建对象\n    CNMutableContact * contact = [[CNMutableContact alloc]init];\n    contact.givenName = name?:@&quot;defaultname&quot;;\n    CNLabeledValue *phoneNumber = [CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberMobile value:[CNPhoneNumber phoneNumberWithStringValue:phone?:@&quot;10086&quot;]];\n    contact.phoneNumbers = @[phoneNumber];\n\n    // 把对象加到请求中\n    CNSaveRequest * saveRequest = [[CNSaveRequest alloc]init];\n    [saveRequest addContact:contact toContainerWithIdentifier:nil];\n\n    // 执行请求\n    CNContactStore * store = [[CNContactStore alloc]init];\n    [store executeSaveRequest:saveRequest error:nil];\n}\n</code></pre><p>更稳健一点的写法, 是可以把请求放在通讯录授权判断的block中</p>\n<pre><code>    CNContactStore *store = [[CNContactStore alloc] init];\n    [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!granted) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                //失败原因\n            });\n            return;\n        }\n        //do something\n    }];\n</code></pre><p>使用下面这种方式</p>\n<pre><code> - (void)addContactWithName:(NSString *)name {\n\n    CNContactStore *store = [[CNContactStore alloc] init];\n    [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!granted) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                //失败原因\n            });\n            return;\n        }\n\n        CNMutableContact *contact = [[CNMutableContact alloc] init];\n        contact.familyName = @&quot;Doe&quot;;\n        contact.givenName = @&quot;John&quot;;\n\n        CNLabeledValue *homePhone = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:[CNPhoneNumber phoneNumberWithStringValue:@&quot;312-555-1212&quot;]];\n        contact.phoneNumbers = @[homePhone];\n\n        CNSaveRequest *request = [[CNSaveRequest alloc] init];\n        [request addContact:contact toContainerWithIdentifier:nil];\n\n        // save it\n        NSError *saveError;\n        if (![store executeSaveRequest:request error:&amp;saveError]) {\n            NSLog(@&quot;error = %@&quot;, saveError);\n        }\n    }];\n}\n</code></pre><h3 id=\"iOS8删除联系人\"><a href=\"#iOS8删除联系人\" class=\"headerlink\" title=\"iOS8删除联系人\"></a>iOS8删除联系人</h3><pre><code>- (void)removeItemWithName:(NSString *)name phone:(NSString *)phone {\n    ABAddressBookRef addressbook = ABAddressBookCreate();\n    CFStringRef nameRef = (__bridge CFStringRef) name;\n    CFArrayRef  allSearchRecords = ABAddressBookCopyPeopleWithName(addressbook, nameRef);\n    if (allSearchRecords != NULL)\n    {\n        CFIndex count = CFArrayGetCount(allSearchRecords);\n        for (int i = 0; i &lt; count; ++i)\n        {\n            ABRecordRef contact = CFArrayGetValueAtIndex(allSearchRecords, i);\n            ABAddressBookRemoveRecord(addressbook, contact, nil);\n        }\n    }\n    ABAddressBookSave(addressbook, nil);\n    CFRelease(addressbook);\n}\n</code></pre><h3 id=\"iOS9删除联系人\"><a href=\"#iOS9删除联系人\" class=\"headerlink\" title=\"iOS9删除联系人\"></a>iOS9删除联系人</h3><pre><code>- (void)removeContactWithName:(NSString *)name {\n    CNContactStore *store = [[CNContactStore alloc] init];\n    NSPredicate *predicate = [CNContact predicateForContactsMatchingName:name];\n    NSArray *contacts = [store unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey, CNContactFamilyNameKey] error:nil];\n\n    for (CNMutableContact *contact in contacts) {\n        CNSaveRequest *request = [[CNSaveRequest alloc] init];\n        [request deleteContact:contact];\n        // save it\n        NSError *saveError;\n        if (![store executeSaveRequest:request error:&amp;saveError]) {\n            NSLog(@&quot;error = %@&quot;, saveError);\n        }\n    }\n}\n</code></pre><h2 id=\"通讯录数据读取\"><a href=\"#通讯录数据读取\" class=\"headerlink\" title=\"通讯录数据读取\"></a>通讯录数据读取</h2><p>通过上面的一通操作, 我们已经可以创建和删除通讯录了, 那么我们就通过批量写入通讯录数据, 来进行通讯录数据的读取, 并且按照姓名和首字母分组排序. 相应的, 此处我们也区分<code>iOS8</code>和<code>iOS9</code>下面两个不同的框架.</p>\n<h3 id=\"iOS8读取联系人\"><a href=\"#iOS8读取联系人\" class=\"headerlink\" title=\"iOS8读取联系人\"></a>iOS8读取联系人</h3><pre><code>+ (NSArray *)getAllContact {\n    NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];\n\n    CFErrorRef *error = NULL;\n    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, error);\n\n    CFIndex numberOfPeople = ABAddressBookGetPersonCount(addressBook);\n    CFArrayRef people = ABAddressBookCopyArrayOfAllPeople(addressBook);\n    if (numberOfPeople == 0) {\n        CFRelease(people);\n        CFRelease(addressBook);\n        return @[];\n    }\n    for ( int i = 0; i &lt; numberOfPeople; i++){\n        AddressBookContact *contact = [[AddressBookContact alloc] init];\n\n        ABRecordRef person = CFArrayGetValueAtIndex(people, i);\n\n        //姓名\n        NSString *firstName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonFirstNameProperty));\n        NSString *lastName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonLastNameProperty));\n        NSString *name = [NSString stringWithFormat:@&quot;%@%@&quot;, lastName, firstName;\n        contact.name = name;\n\n        //第一次添加该条记录的时间戳\n        NSDate *createDate = (NSDate *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonCreationDateProperty));\n        NSTimeInterval timeIn = [createDate timeIntervalSince1970];\n        NSInteger createTime = round(timeIn);\n        contact.createTime = [NSString stringWithFormat:@&quot;%010ld&quot;, (long)createTime];\n\n        //读取电话多值\n        ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty);\n        NSArray *arr = (NSArray *)CFBridgingRelease(ABMultiValueCopyArrayOfAllValues(phone));\n        contact.phone = [AddressBookData filterPhoneFormate:[arr lastObject]];\n\n        if (contact.phone.length &gt; 0) {\n            [array addObject:contact];\n        }\n    }\n    CFRelease(people);\n    CFRelease(addressBook);\n    return array;\n}\n\n//剔除手机号中的特殊字符\n+ (NSString *)filterPhoneFormate:(NSString *)phoneNumber {\n    NSCharacterSet *notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];\n    NSString *resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@&quot;&quot;];\n    return resultString;\n}\n</code></pre><h3 id=\"iOS9读取联系人\"><a href=\"#iOS9读取联系人\" class=\"headerlink\" title=\"iOS9读取联系人\"></a>iOS9读取联系人</h3><pre><code>    // 创建通信录对象\n    CNContactStore *contactStore = [[CNContactStore alloc] init];\n\n    // 创建获取通信录的请求对象\n    // 拿到所有打算获取的属性对应的key\n    NSArray *keys = @[CNContactGivenNameKey, CNContactFamilyNameKey, CNContactPhoneNumbersKey];\n\n    // 创建CNContactFetchRequest对象\n    CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:keys];\n\n    // 遍历所有的联系人\n    [contactStore enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) {\n        // 获取联系人的姓名\n        NSString *lastname = contact.familyName;\n        NSString *firstname = contact.givenName;\n        NSLog(@&quot;%@ %@&quot;, lastname, firstname);\n\n        // 获取联系人的电话号码\n        NSArray *phoneNums = contact.phoneNumbers;\n        for (CNLabeledValue *labeledValue in phoneNums) {\n            // 获取电话号码的KEY\n            NSString *phoneLabel = labeledValue.label;\n\n            // 获取电话号码\n            CNPhoneNumber *phoneNumer = labeledValue.value;\n            NSString *phoneValue = phoneNumer.stringValue;\n\n            NSLog(@&quot;%@ %@&quot;, phoneLabel, phoneValue);\n            AddressBookContact *contact = [[AddressBookContact alloc] init];\n            contact.name = [NSString stringWithFormat:@&quot;%@%@&quot;,lastname,firstname];\n            person.phone = phoneValue;\n            [_addressBookArray addObject:contact];\n        }\n    }];\n</code></pre><p>我们通过上面的方法拿到的数据是一个元素是我们自定义数据模型<code>AddressBookContact</code>的数组, 所有的数据都在这一个数组里面, 没有分组, 相同首字母的联系人按照创建时间来排序.显然这样的数据是不能满足我们业务需求的. 常见的是按照首字母来分组, 下面我们就以iOS8为例来对数据进行分组排序和展示, 类似于系统通讯录列表.</p>\n<h3 id=\"通讯录分组\"><a href=\"#通讯录分组\" class=\"headerlink\" title=\"通讯录分组\"></a>通讯录分组</h3><pre><code>//返回包含分组信息和分组后通讯录数据的字典\n+ (NSDictionary *)dealDataWithArray:(NSArray *)array {\n    if (array.count == 0) {\n        return nil;\n    }\n    NSMutableArray *titleArray = [NSMutableArray arrayWithCapacity:0];\n    NSMutableArray *data = [NSMutableArray arrayWithCapacity:0];\n    NSMutableArray * tmpArray = [[NSMutableArray alloc]init];\n    for (NSInteger i =0; i &lt;27; i++) {\n        //给临时数组创建27个数组作为元素，用来存放A-Z和#开头的联系人\n        NSMutableArray * array = [[NSMutableArray alloc]init];\n        [tmpArray addObject:array];\n    }\n\n    for (AddressBookContact * model in array) {\n        //AddressMode是联系人的数据模型\n        //转化为首拼音并取首字母\n        NSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\n        if (nickName.length == 0) {\n            //如果不是，就放到最后一个代表#的数组\n            NSMutableArray * array =[tmpArray lastObject];\n            [array addObject:model];\n        } else {\n            int firstWord = [nickName characterAtIndex:0];\n            //把字典放到对应的数组中去\n\n            if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n                //如果首字母是A-Z，直接放到对应数组\n                NSMutableArray * array = tmpArray[firstWord - 65];\n                [array addObject:model];\n\n            } else {\n                //如果不是，就放到最后一个代表#的数组\n                NSMutableArray * array =[tmpArray lastObject];\n                [array addObject:model];\n            }\n        }\n    }\n\n    //此时数据已按首字母排序并分组\n    //遍历数组，删掉空数组\n    for (NSMutableArray * mutArr in tmpArray) {\n        //如果数组不为空就添加到数据源当中\n        if (mutArr.count != 0) {\n            [data addObject:mutArr];\n            AddressBookContact * model = mutArr[0];\n            NSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\n            if (nickName.length != 0) {\n                int firstWord = [nickName characterAtIndex:0];\n                //取出其中的首字母放入到标题数组，暂时不考虑非A-Z的情况\n                if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n                    [titleArray addObject:nickName];\n                }\n            }\n        }\n    }\n\n    //判断是否需要加#\n    if (titleArray.count != data.count) {\n        [titleArray addObject:@&quot;#&quot;];\n    }\n\n    NSDictionary *dic = @{@&quot;source&quot;: [AddressBookDataManager sortedArray:data],\n                          @&quot;title&quot;: titleArray};\n    return dic;\n}\n\n+ (NSArray *)sortedArray:(NSArray *)data {\n    NSMutableArray *sortedArray = [NSMutableArray array];\n    for (NSInteger index = 0; index &lt; data.count; index++) {\n        NSMutableArray *personArrayForSection = data[index];\n        NSArray *temp = [personArrayForSection sortedArrayUsingComparator:^NSComparisonResult(AddressBookContact * contact1, AddressBookContact * contact2) {\n            return [contact1.name compare:contact2.name];\n        }];\n        sortedArray[index] = temp;\n    }\n    return sortedArray;\n}\n\n\n#pragma mark - Tool\n+ (BOOL)objectIsNull:(id)obj{\n    return ([obj isKindOfClass:[NSNull class]] || obj == nil) ? YES : NO;\n}\n\n+ (NSString*)strNoNull:(id)str{\n    if ([AddressBookDataManager objectIsNull:str]) {\n        str = @&quot;&quot;;\n    }\n    return str;\n}\n\n//汉字转拼音并取得关键字\n+ (NSString *)returnFirstWordWithString:(NSString *)str {\n    NSMutableString * mutStr = [NSMutableString stringWithString:str];\n\n    //将mutStr中的汉字转化为带音标的拼音（如果是汉字就转换，如果不是则保持原样）\n    CFStringTransform((__bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformMandarinLatin, NO);\n    //将带有音标的拼音转换成不带音标的拼音（这一步是从上一步的基础上来的，所以这两句话一句也不能少）\n    CFStringTransform((__bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformStripCombiningMarks, NO);\n    if (mutStr.length &gt; 0) {\n        //全部转换为大写    取出首字母并返回\n        NSString * res = [[mutStr uppercaseString] substringToIndex:1];\n        return res;\n    } else {\n        return @&quot;&quot;;\n    }\n}\n\n//剔除手机号中的特殊字符\n+ (NSString *)filterPhoneFormate:(NSString *)phoneNumber {\n    NSCharacterSet *notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];\n    NSString *resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@&quot;&quot;];\n    return resultString;\n}\n</code></pre><p><img src=\"http://ohjcp7fjy.bkt.clouddn.com/IMG_0277.PNG\" alt=\"数据截图\"><br>至此, 我们可以得到符合业务需求的通讯录页面, 已经按照姓名首字母分组, 并且实现了快速索引. 我的通讯录测试数据有2700+条数据, 每次通讯录打开都要耗时特别久, 为了更好的用户体验, 这时就会想到要优化一下代码了.</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>说道性能优化, 首先就要进行性能分析, 知道我们需要优化的地方在哪里. Xcode提供了一个强大的分析工具Instruments, 具体一些常见的分析可以参考<a href=\"\">这里</a>.<br>我们主要使用Instruments的Time ProFiler来分析一下, 究竟耗时的代码在哪里, 并且做一下优化.</p>\n<h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><h2 id=\"监听通讯录数据变化\"><a href=\"#监听通讯录数据变化\" class=\"headerlink\" title=\"监听通讯录数据变化\"></a>监听通讯录数据变化</h2><p>参考文档:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/47189c71543b\" target=\"_blank\" rel=\"external\">iOS9下全新的通讯录框架</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/94e8444f1ad6\" target=\"_blank\" rel=\"external\">iOS学习笔记29-系统服务(二)通讯录</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/6acad14cf3c9\" target=\"_blank\" rel=\"external\">iOS通讯录开发</a></p>\n<p>4.<a href=\"https://developer.apple.com/reference/contacts/cncontact\" target=\"_blank\" rel=\"external\">CNContact官方文档</a></p>\n<p>5.<a href=\"https://developer.apple.com/reference/addressbook\" target=\"_blank\" rel=\"external\">AddressBook官方文档</a></p>\n","categories":["基础知识","性能优化"],"tags":["通讯录"]},{"title":"iOS逆向-下载历史版本","url":"http://hchong.net/2017/04/06/iOS逆向-下载历史版本/","content":"<h1 id=\"iOS逆向-下载历史版本\"><a href=\"#iOS逆向-下载历史版本\" class=\"headerlink\" title=\"iOS逆向-下载历史版本\"></a>iOS逆向-下载历史版本</h1><p>目前App Store默认只能下载最新版, 而我们的目的是要能够下载到App Store中的历史版, 那就要借助一些其他工具来实现.<br>原理如下:</p>\n<blockquote>\n<p>通过Charles来获取下载链接, 通过分析来得到每个版本在连接中所对应的字段, 再通过Charles来截取和替换下载链接中的参数, 来达到下载特定版本App的目的.</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装Charles.</li>\n<li>为了Charles能够抓取HTTPS类型的链接, 需要安装Charles的证书, 参考这里<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.</li>\n</ol>\n</blockquote>\n<h2 id=\"开始抓包\"><a href=\"#开始抓包\" class=\"headerlink\" title=\"开始抓包\"></a>开始抓包</h2><p>安装了Charles之后, 我们就可以获取App的下载链接了, 并且从中分析出我们需要的参数.</p>\n<h3 id=\"获取APP的下载链接和版本号对应的参数\"><a href=\"#获取APP的下载链接和版本号对应的参数\" class=\"headerlink\" title=\"获取APP的下载链接和版本号对应的参数\"></a>获取APP的下载链接和版本号对应的参数</h3><p>下面我们以iOS上一款比较好用的看书软件<em>追书神器</em>为例来说明.</p>\n<ol>\n<li>首先打开ITunes来下载软件, 点击下载, 通过Charles来确定下载软件的链接.<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4m4udoqj30zo0iwdhx.jpg\" alt=\"点击下载\"></li>\n<li>在Charles中观察发现, ITunes使用的是HTTPS链接, 无法直接查看request内容.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4n5nyodj30f707e74h.jpg\" alt=\"无法直接查看HTTPS\"></li>\n<li>我们通过添加SSL Proxying来查看request内容, 并且通过给链接加断点来详细分析请求的参数.</li>\n</ol>\n<p><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4nt57ykj30b60jr74v.jpg\" alt=\"添加SSL Proxy\"><br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4ogb7edj30bg0lkab0.jpg\" alt=\"添加断点\"></p>\n<h3 id=\"推断控制版本的关键字段\"><a href=\"#推断控制版本的关键字段\" class=\"headerlink\" title=\"推断控制版本的关键字段\"></a>推断控制版本的关键字段</h3><p>观察response, 推断<code>softwareVersionExternalIdentifiers</code>展示的是全部的APP对应的版本, <code>softwareVersionExternalIdentifier</code>是用来标记当前版本.<em>追书神器</em>目前的版本标记是<code>820420814</code><br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4pltv74j310w0qjq5r.jpg\" alt=\"字段分析\"><br>通过在request中搜索<code>820420814</code>发现,<code>appExtVrsId</code>是来标记要下载哪个版本.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4p2c1jqj30be08wwew.jpg\" alt=\"推断关键字\"></p>\n<h3 id=\"修改Request参数下载历史版本\"><a href=\"#修改Request参数下载历史版本\" class=\"headerlink\" title=\"修改Request参数下载历史版本\"></a>修改Request参数下载历史版本</h3><p>我们在<code>softwareVersionExternalIdentifiers</code>中任选一个版本号, 此处我以<code>819147298</code>为例</p>\n<ol>\n<li>删除刚才下载好的软件, 重新下载.</li>\n<li>因为我们在下载链接中加的有断点, 再次下载时Charles会停在断点的位置</li>\n<li>点击<code>Edit Request</code>来编辑<code>appExtVrsId</code>字段<br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4qg1avyj30yf0o60v0.jpg\" alt=\"Edit Request\"></li>\n<li>执行断点, 继续下载.</li>\n<li>在ITunes中看到更新的标志说明下载成功<br><img src=\"https://ww1.sinaimg.cn/large/006tNbRwgy1fel4komzx2j30p00c8t9i.jpg\" alt=\"下载成功\"></li>\n</ol>\n<h2 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h2><p>通过ITunes来安装下载好的软件到手机.</p>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.<br>2.<a href=\"http://www.jianshu.com/p/edfed1b1822c\" target=\"_blank\" rel=\"external\">iOS秘籍-下载历史版本App超详细教程</a>.</p>\n","categories":["iOS逆向"],"tags":["Charles","iOS逆向"]},{"title":"Jenkins自动化打包","url":"http://hchong.net/2017/03/23/Jenkins自动化打包/","content":"","categories":["自动化打包"],"tags":["自动化打包","Target"]},{"title":"多Target实现","url":"http://hchong.net/2017/03/12/多Target实现/","content":"","categories":["自动化打包"],"tags":["自动化打包","Target"]},{"title":"Charles抓包Https请求","url":"http://hchong.net/2017/02/28/Charles抓包Https请求/","content":"<h1 id=\"Charles抓包HTTPS请求\"><a href=\"#Charles抓包HTTPS请求\" class=\"headerlink\" title=\"Charles抓包HTTPS请求\"></a>Charles抓包HTTPS请求</h1><p>有时我们会对手机里面的App进行一些分析, 产看App的请求包, 这时我们就需要祭出神器<a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"external\">Charles</a>了.<br>下面跟着我来教你从零开始抓取App的请求包.</p>\n<h2 id=\"安装Charles\"><a href=\"#安装Charles\" class=\"headerlink\" title=\"安装Charles\"></a>安装Charles</h2><p>这个纯属占坑(废话).</p>\n<h2 id=\"抓取HTTP请求\"><a href=\"#抓取HTTP请求\" class=\"headerlink\" title=\"抓取HTTP请求\"></a>抓取HTTP请求</h2><p>我们先拿一个简单的HTTP请求来练一下手.</p>\n<h3 id=\"查看本地IP地址和Charles端口号\"><a href=\"#查看本地IP地址和Charles端口号\" class=\"headerlink\" title=\"查看本地IP地址和Charles端口号\"></a>查看本地IP地址和Charles端口号</h3><p>查看IP地址的方法比较多, 这里只介绍两种比较常用的:</p>\n<ol>\n<li>可以在网络偏好设置-&gt;高级-&gt;TCP/IP下查看对应网络的IP.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd5z8oku1vj311a0lwgpb.jpg\" alt=\"网络偏好设置中查看\"></li>\n<li>option+左键单击屏幕上方的WiFi标志也可以查看.<br> <img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65kx0mjhj308c0eft9q.jpg\" alt=\"option+左键查看\"></li>\n</ol>\n<h3 id=\"查看Charles的端口号\"><a href=\"#查看Charles的端口号\" class=\"headerlink\" title=\"查看Charles的端口号\"></a>查看Charles的端口号</h3><p>打开Charles-&gt;Proxy-&gt;Proxy Settings查看端口号, 默认一般是<code>8888</code>. 注意不要随意修改端口号, 以避免被占用.</p>\n<h3 id=\"在iPhone中设置\"><a href=\"#在iPhone中设置\" class=\"headerlink\" title=\"在iPhone中设置\"></a>在iPhone中设置</h3><p>打开手机, 连上WiFi, 注意此处的WiFi最好和Mac连接的WiFi是同一个, 避免出现不在一个网段的情况.<br>打开设置-&gt;无线局域网-&gt;点击对应WiFi后的更多.<br><img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd65mobyrjj30b40jrq3k.jpg\" alt=\"WiFi列表\"><br>点击手动, 设置HTTP代理地址(与Mac的IP地址一致)和端口号(与Charles中代理的端口号一致)<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65mo3y0aj30b40jrmxm.jpg\" alt=\"设置HTTP代理地址和端口号\"></p>\n<p>至此, 就可以轻松的抓取App中的HTTP请求啦.</p>\n<h2 id=\"抓取HTTPS请求\"><a href=\"#抓取HTTPS请求\" class=\"headerlink\" title=\"抓取HTTPS请求\"></a>抓取HTTPS请求</h2><p>HTTPS的请求抓取, 略微复杂, 他的原理大致是这样的.</p>\n<blockquote>\n<p>Charles能进行https协议抓包分析，是使用了中间人代理的方法（man-in-the-middle，也常作为一个黑客攻击手段）。Charles代替你的app接受server的证书，然后使用这个证书通过SSL和server通信；同时，Charles会动态的生成一个对应的证书（用Charles的CA证书签名），然后使用这个证书和你的app通信，这样就完成了一个中间人代理，从而可以把app和server的https包给抓到和解码出来。</p>\n</blockquote>\n<p>从里面我们可以看到一些关键字: <code>证书</code>, <code>代理</code>, 等. 那么我们就通过这些手段来抓取HTTPS的请求.</p>\n<h3 id=\"设置代理地址和端口号\"><a href=\"#设置代理地址和端口号\" class=\"headerlink\" title=\"设置代理地址和端口号\"></a>设置代理地址和端口号</h3><p>这一步骤, 和抓取HTTP的方法一样, 这里不再赘述, 需要设置端口号和IP地址.</p>\n<h3 id=\"Mac安装证书\"><a href=\"#Mac安装证书\" class=\"headerlink\" title=\"Mac安装证书\"></a>Mac安装证书</h3><p>安装Charles的证书到Mac, 信任该证书, 以便Charles能够通过该证书进行通信. 具体步骤如下: </p>\n<ol>\n<li>打开Charles, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd607vw0k6j30pk094gmj.jpg\" alt=\"安装根证书\"></li>\n<li>信任该证书<br><img src=\"http://upload-images.jianshu.io/upload_images/1552510-461959c476a2d9d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书不被信任时\"></li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1552510-8c43e95be0a35b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"信任Charles证书\"></p>\n<h3 id=\"iPhone安装证书\"><a href=\"#iPhone安装证书\" class=\"headerlink\" title=\"iPhone安装证书\"></a>iPhone安装证书</h3><p>安装Charles证书到手机, 信任该证书, 以便Charles能够截获网络请求. 具体步骤如下:</p>\n<ol>\n<li>在Charles中, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser, 来查看当前IP地址下, 手机下载证书的网址.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd60jpjcgvj30nx094my0.jpg\" alt=\"步骤一:选择生成手机下载证书的网址\"></li>\n<li>在手机中用Safari打开网址(如图所示的网址)<br> <img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd60l2cz81j30nz06t3yl.jpg\" alt=\"步骤二:输入生成的网址\"></li>\n<li>打开网址后自动跳转到证书安装界面, 安装并信任该证书.<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd65rnpokjj30b40jrgly.jpg\" alt=\"步骤三:安装并信任该证书\"></li>\n<li>打开Charles选择Proxy-&gt;SSL Proxying Settings-&gt;SSL Proxying(因为Charles默认是不会抓取任何域名下的HTTPS, 所以需要我们添加域名到Location下)勾选Enable SSL Proxying, 单击Add, 添加域名和端口(用*来表示所有).<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd60zndgejj30gj0cb0st.jpg\" alt=\"步骤四:设置抓取的域名和端口\"></li>\n</ol>\n<p>至此, 我们再打开手机App就会发现, 之前<code>Unknown</code>的HTTPS接口, 就都可以正常现实啦.</p>\n<p>参考资料:<br>1.<a href=\"http://www.jianshu.com/p/a0215dd2047f\" target=\"_blank\" rel=\"external\">HTTP/HTTPS抓包工具Charles</a><br>2.<a href=\"http://www.jianshu.com/p/a83b19a36a8b\" target=\"_blank\" rel=\"external\">使用Charles进行https抓包</a><br>3.<a href=\"http://blog.devtang.com/2015/11/14/charles-introduction/\" target=\"_blank\" rel=\"external\">Charles 从入门到精通</a></p>\n","categories":["iOS逆向"],"tags":["逆向","安全","Charles"]},{"title":"统计打点的AOP实现","url":"http://hchong.net/2017/02/13/统计打点的AOP实现/","content":"<h1 id=\"统计打点的AOP实现\"><a href=\"#统计打点的AOP实现\" class=\"headerlink\" title=\"统计打点的AOP实现\"></a>统计打点的AOP实现</h1><p>每一个App, 必然会有大量的分析数据来统计用户行为. 而这些统计对应在客户端就是, 统计打点, 又称埋点.<br>关于埋点的本质, 我理解的就是用户出发一个行为后, 调用一个特定的接口. 服务端拿到我们的请求后, 根据客户端传的参数也就是事件ID来区分是什么操作(注意, 这里的事件ID是具有唯一性的, 不同的ID对应用户不同的操作). 有时也可能会需要其他的信息, 比如操作人的ID等. 服务端拿到这些信息之后, 再整理筛选, 通过视图, 报表的形式展现出来.<br>因为埋点是和业务紧密相连的, 所以一般我们的埋点代码(就是调用特定网络接口的代码)分散在整个项目的各个地方. 当业务越来越复杂, 工程越来越大时, 我们的埋点代码就会变得很难维护, 埋点事件分散在各个地方, 很难有个清晰的逻辑. 并且把埋点事件和业务代码高度耦合在一起, 也不是一个明智的选择.<br>这个时候, 就会想到, 要是能用AOP的方式来解决埋点的实现, 把埋点事件和业务代码解耦开来, 那我们维护起来就会方便好多.</p>\n<blockquote>\n<p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP与OOP是面向不同领域的两种设计思想。<br>OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。<br>AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。<br>AOP可以用在日志记录，性能统计，安全控制，事务处理，异常处理等等，本篇文章主要讲的是埋点也就是日志记录</p>\n</blockquote>\n<p>在Objective-C中使用AOP主要指的是使用Objective-C的Runtime特性, 给指定的方法添加自定义代码. 有很多方式来实现AOP, MethodSwizzling只是其中之一.而又有一些第三方库, 将Runtime进行了很好地封装, 让我们不用了解Runtime的知识, 就能很好地使用AOP.<br>我们主要使用的是<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"external\">Aspects</a>这个第三方库, 关于Aspects的内部实现, 可以参考这篇博文<a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"external\">iOS 如何实现Aspect Oriented Programming</a>.<br>由以上的解释, 可以基本了解, 我们主要是通过Aspect来Hook对应事件的方法, 传递事件唯一的ID给服务端来标记此事件响应过一次.所以, 我们的代码大致应该是这样.<br>首先有一个类用来记录埋点事件ID和需要Hook的类和方法, 并且将他们一一对应.</p>\n<p>根据记录埋点事件的复杂程度, 我们大致可以将埋点分为简单埋点和复杂埋点两种:</p>\n<ol>\n<li>简单埋点: 只用记录某个操作事件响应次数</li>\n<li>复杂埋点:<ul>\n<li>需要传除了事件ID外的参数</li>\n<li>需要根据服务端返回的数据来响应不同的事件</li>\n<li>埋点事件ID放在服务端返回的字段中</li>\n</ul>\n</li>\n</ol>\n<p>我们新建两个类, 一个用来记录Hook的类<code>HYZTrackList</code>, Hook的方法和与之对应的事件ID. 另外一个类<code>HYZTrackManager</code>, 用来实现埋点事件的具体操作方法.</p>\n<h2 id=\"简单埋点的实现\"><a href=\"#简单埋点的实现\" class=\"headerlink\" title=\"简单埋点的实现\"></a>简单埋点的实现</h2><p>我们在<code>HYZTrackList</code>中实现<code>trackList</code>方法, 返回一个数组. 数组的元素是一个个的字典, 用对记录每一个事件的相关信息.</p>\n<pre><code>+ (NSArray *)trackList {\n    NSArray *trackList = @[\n  //=======================================简单埋点==========================================\n                           //HYZViewController1简单埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;simpleTrack:para2:&quot;,\n                             kEventType:HYZViewController1SimpleButtonClick,\n                             kIsLightEvent:@(YES)},\n                           //HYZViewController1复杂埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;blockButtonAction:&quot;,\n                             kEventType:HYZViewController1BlockButtonClick,\n                             kIsLightEvent:@(YES)},\n                           //HYZViewController1block埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;complexButtonAction:&quot;,\n                             kEventType:HYZViewController1ComplexButtonClick,\n                             kIsLightEvent:@(YES)},\n\n//=======================================复杂埋点==========================================\n                           @{kClassName:@&quot;HYZViewController3&quot;,\n                             kHookFunction:@&quot;trackWithTag:&quot;,\n                             kHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,\n                             kIsLightEvent:@(NO)}];\n    return trackList;\n}\n</code></pre><p>如上所示, 我们是要记录<code>HYZViewController1</code>类里面的<code>simpleTrack:para2:</code>方法的点击事件, 事件ID是<code>HYZViewController1SimpleButtonClick</code>.<br>我们在<code>APPDelegate</code>的<code>application:didFinishLaunchingWithOptions:</code>方法中, 来hook所有的在<code>trackList</code>中记录的方法.<br>在``中, 实现如下相关代码.</p>\n<pre><code>+ (void)setup {\n    //实现和替换hook的block方法\n    NSMutableDictionary *blockDict = [[NSMutableDictionary alloc] init];\n    [HYZTrackManager weightEventEntry:blockDict];\n\n    [[HYZTrackList trackList] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        BOOL isLightEvent = [obj[kIsLightEvent] boolValue];\n        NSString *className = obj[kClassName];\n        NSString *functionName = obj[kHookFunction];\n        NSString *eventName = obj[kEventType];\n        Class class = NSClassFromString(className);\n        SEL selector = NSSelectorFromString(functionName);\n        if (isLightEvent == YES) {\n            if (!functionName) {\n                return;\n            }\n            [HYZTrackManager lightTrackTarget:class selector:selector functionName:functionName trackId:eventName];\n        } else {\n            NSString *blockName = obj[kHandlerBlock];\n            id handleBlock = [blockDict objectForKey:blockName];\n            if (!handleBlock) {\n                return;\n            }\n            [HYZTrackManager complexTrackTarget:class selector:selector usingBlock:handleBlock];\n        }\n    }];\n}\n</code></pre><p>针对简单埋点, 我们直接使用</p>\n<pre><code>//简单埋点虽然可以拿到对应方法的参数, 但是如果需要把该参数传到埋点请求的网络事件中的话, 必须使用复杂埋点来处理\n+ (void)lightTrackTarget:(Class)target selector:(SEL)selector functionName:(NSString *)functionName trackId:(NSString *)trackId {\n    NSError *error;\n    NSInteger functionParamCount = [[functionName componentsSeparatedByString:@&quot;:&quot;] count] - 1;\n    switch (functionParamCount) {\n        case 0: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo){\n                [HYZTrackManager trackRequestWithTrackId:trackId, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 1: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 2: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 3: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 4: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3, id p4){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, p4, nil];\n            }error:&amp;error];\n        }\n            break;\n        default:\n            break;\n    }\n}\n</code></pre><p>简单埋点虽然也可以拿到Hook的方法的参数, 但是由于通用性, 所以不能用来传递可变的参数.</p>\n<p>真正的埋点请求是这样的</p>\n<pre><code>+ (void)trackRequestWithTrackId:(NSString *)trackId, ... NS_REQUIRES_NIL_TERMINATION{\n    // 定义一个指向个数可变的参数列表指针；\n    va_list args;\n    // 用于存放取出的参数\n    NSString *arg;\n    // 初始化变量刚定义的va_list变量，这个宏的第二个参数是第一个可变参数的前一个参数，是一个固定的参数\n    va_start(args, trackId);\n    // 遍历全部参数 va_arg返回可变的参数(a_arg的第二个参数是你要返回的参数的类型)\n    while ((arg = va_arg(args, NSString *))) {\n        NSLog(@&quot;%@&quot;, arg);\n    }\n    // 清空参数列表，并置参数指针args无效\n    va_end(args);\n    NSLog(@&quot;此处用来实现埋点事件记录%@的网络请求&quot;, trackId);\n}\n</code></pre><p>至此, 实现了简单埋点的方法Hook.</p>\n<h2 id=\"复杂埋点\"><a href=\"#复杂埋点\" class=\"headerlink\" title=\"复杂埋点\"></a>复杂埋点</h2><p>复杂埋点, 因为要传参数进来, 所以我们利用<code>+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;</code>可以传block参数来实现.<br>首先, 我们在<code>HYZTrackList</code>中把类名, 方法名和需要定义的Block关联起来,如下所示.</p>\n<pre><code>{kClassName:@&quot;HYZViewController3&quot;,\nkHookFunction:@&quot;trackWithTag:&quot;,\nkHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,\nkIsLightEvent:@(NO)}\n</code></pre><p>在<code>APPDelegate</code>中初始化时, 需要在<code>HYZTrackManager</code>中实现Block的定义, </p>\n<pre><code>//hook的block在这里定义和实现\n+ (void)weightEventEntry:(NSMutableDictionary*)blockDict{\n    [HYZTrackManager trackButtonAction:blockDict];\n}\n\n//block的内部实现\n+ (void)trackButtonAction:(NSMutableDictionary *)blockDict {\n    void(^HYZViewController3TrackHandleBlock)(id, NSInteger tag) = ^(id &lt;AspectInfo&gt;aspectInfo, NSInteger tag) {\n        switch (tag) {\n                case 1: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 2: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 3: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 4: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n            default:\n                break;\n        }\n    };\n    [blockDict setObject:[HYZViewController3TrackHandleBlock copy] forKey:@&quot;HYZViewController3TrackHandleBlock&quot;];\n}\n</code></pre><p>然后Hook原方法;</p>\n<pre><code>//复杂的埋点,\n+ (void)complexTrackTarget:(Class)target selector:(SEL)selector usingBlock:(id)block {\n    NSError *error;\n    [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:block error:&amp;error];\n}\n</code></pre><p><a href=\"https://github.com/HChong3210/AOPTrack\" target=\"_blank\" rel=\"external\">Demo</a><br>参考资料: </p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"external\">iOS 如何实现Aspect Oriented Programming</a></li>\n<li><a href=\"http://www.vienta.me/2016/09/21/AOP%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%80%E7%BB%9F%E8%AE%A1%E5%9F%8B%E7%82%B9/\" target=\"_blank\" rel=\"external\">AOP在iOS中的实践——统计埋点</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20160421/15912.html\" target=\"_blank\" rel=\"external\">可复用且高度解耦的iOS用户统计实现</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150120/10959.html\" target=\"_blank\" rel=\"external\">Method Swizzling和AOP(面向切面编程)实践</a></li>\n</ol>\n","categories":["统计打点"],"tags":["AOP","统计打点","解决方案"]},{"title":"设计模式-工厂模式","url":"http://hchong.net/2017/02/08/设计模式-工厂模式/","content":"<h1 id=\"设计模式-工厂模式\"><a href=\"#设计模式-工厂模式\" class=\"headerlink\" title=\"设计模式-工厂模式\"></a>设计模式-工厂模式</h1><p>下面有一个case, 要编写一个简单的计算器程序, 用来实现加减乘除的运算操作, 并且展示出来.我们就拿这个最简单的例子来一步一步见识一下”工厂模式”的魅力.</p>\n<h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>版本一:我们首先想到的最简单的模式就是我们先从业务上来拆分, 把计算器程序分成两部分<em>计算</em>和<em>展示</em>两个类来写代码.OC作为一门面向对象的语言, 在这里我们已经可以清楚地意识到我们已经使用了<em>封装</em>这面向对象语言的一大特性.但是随着业务的发展, 我们发现可能会增加其他的业务(例如增加其他的运算操作),这是我们每次都要修改<em>计算</em>这个类, 慢慢的代码就会越来越多, 不利于维护.而且在新加逻辑的过程中有可能会修改到老的代码, 维护成本很高.这是我们就会想到其他两个特性<em>继承</em>和<em>多态</em>.于是, 就有了版本二.</p>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>这时我们发现,把所有的运算写到一个类中是有些不妥当的, 那么要怎么来修改呢.我们自然地想到, 每一种运算可以单独度的封装为一个类, 只用于实现固定的计算.于是我们可以得到<em>加</em>,<em>减</em>,<em>乘</em>,<em>除</em>四个类, 每个类都三个属性, 分别是<em>操作数</em>和<em>结果</em>.哪里怪怪的呢, 有没有一丝”坏代码”的味道呢.通过提炼我们发现四个类都有相同的三个属性,那么我们可以这样做新建一个<code>Operation</code>操作类, 包含三个<code>Public</code>属性</p>\n<pre><code>@interface Operation : NSObject\n\n@property (nonatomic, assign) CGFloat numberA;\n@property (nonatomic, assign) CGFloat numberB;\n@property (nonatomic, assign) CGFloat numberResult;\n\n- (CGFloat)getResult;\n@end\n</code></pre><p>这样的话, 只需要每一个单独的计算类继承于<code>Operation</code>类, 就会自带父类的三个属性, 只用在他们内部实现自己独有的计算方法, 返回计算结果就可以了.到这里, 我们会发现代码变得更加有意思了.<br>但是我们又发现了一个新的问题, 那就是我们该何时初始化哪个类呢, 毕竟我们现在有了四个计算子类.我们只好计算结果的地方写<code>Switch</code>条件来判断到底要初始化那一个子类.</p>\n<p>可是仍然感觉哪里还是怪怪的.我们不是还有<em>多态</em>这种特性没有使用的嘛.仔细一想, 于是又有了版本三.</p>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><blockquote>\n<p>多态:多态表示不同的对象可以执行相同的操作, 但要通过他们自己的实现代码来执行.<br>这是我们需要增加一个工厂类<code>OperationFactory</code>, 用来判断要初始化哪一个子类.</p>\n</blockquote>\n<p><code>OperationFactory.h</code>代码如下:</p>\n<pre><code>@class Operation;\n@interface OperationFactory : NSObject\n\n+ (Operation *)createOperationWithOperate:(NSString *)operate;\n@end\n</code></pre><p><code>OperationFactory.m</code>代码如下:</p>\n<pre><code>@implementation OperationFactory\n\n//传入计算符号, 初始化不同的子类\n+ (Operation *)createOperationWithOperate:(NSString *)operate {\n    if ([operate isEqualToString:@&quot;+&quot;]) {\n        OperationAdd *add = [[OperationAdd alloc] init];\n        return add;\n    }\n\n    if ([operate isEqualToString:@&quot;-&quot;]) {\n        OperationSubtraction *subtraction = [[OperationSubtraction alloc] init];\n        return subtraction;\n    }\n\n    ...\n    return nil;\n}\n\n@end\n</code></pre><p>此时展示的地方, 代码就变得很简单了:</p>\n<pre><code>@interface ViewController ()\n\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    Operation *operation = [OperationFactory createOperationWithOperate:@&quot;-&quot;];//子类以父类的身份出现\n    operation.numberA = 3;\n    operation.numberB = 5;\n    CGFloat result = [operation getResult];//子类在工作时以自己的方式实现\n    NSLog(@&quot;%f&quot;, result);\n    NSLog(@&quot;%f&quot;, operation.numberResult);\n}\n@end\n</code></pre><p>如上我们可以发现, 整个工厂模式的关键就在于<code>OperationFactory</code>这个工厂类的实现.我们在调用的时候不用关心我们要实现哪一个类, <code>CGFloat result = [operation getResult];</code>, 只用调用父类的方法就可以, 而内部则是子类自己的实现.<br>这里面还有几点要注意:</p>\n<blockquote>\n<ol>\n<li>子类以父类的身份出现</li>\n<li>子类在工作时以自己的方式实现</li>\n<li>子类独有的方法和属性不可以使用</li>\n</ol>\n</blockquote>\n<p>在这里解释一下就是, 我们在展示的时候初始化的实际上是父类<code>Operation</code>.但是在获取计算结果时, 我们使用的是子类的计算方法<code>CGFloat result = [operation getResult];</code>, 因为我们在子类里面复写了父类的方法, 所以实际上走的还是子类各自自己的方法.</p>\n","categories":["设计模式"],"tags":["架构","设计模式"]},{"title":"常见的代码\"坏味道\"","url":"http://hchong.net/2016/12/28/常见的代码坏味道/","content":"<h1 id=\"常见的代码”坏味道”\"><a href=\"#常见的代码”坏味道”\" class=\"headerlink\" title=\"常见的代码”坏味道”\"></a><strong>常见的代码”坏味道”</strong></h1><p>正所谓优雅的代码是相似的, 不优雅的代码却各有各的丑. 最近在拜读&lt;重构- 改善既有代码的设计&gt;一书, 虽然书中大量示例是用Java编写的, 但是也给了我很多启发.<br>见贤思齐, 耗时把感想记录下来, 督促自己的成长. </p>\n<h2 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a><strong>重复代码</strong></h2><p>坏味道行列中 ,最常见的就是Duplicated Code. 如果你在一个以上的地点看到相同的程序结构, 那么可以肯定: 把他们合而为一, 会使得代码变得更好.</p>\n<ol>\n<li><p>最单纯的Duplicated Code就是”同一个类的两个函数有相同的表达式”, 解决办法就是:</p>\n<ul>\n<li>采用Extract Method(提炼函数)提炼出重复的代码, 然后这两个地方都调用提炼出来的那一段代码.</li>\n</ul>\n</li>\n<li><p>两个互为兄弟的子类内包含相同的表达式, 解决办法就是:</p>\n<ul>\n<li>对两个类都是用Extract Method(提炼函数), 再对提炼出来的代码使用Pull Up Method(函数上移)</li>\n<li>如果代码只是类似而不完全相同, 那就要先使用Extract Method(提炼函数)将相似和差异的代码分隔开, 构造成一个单独的函数, 然后再<em>塑造模板函数</em></li>\n</ul>\n</li>\n<li><p>如果两个毫不相关的类出现Duplicated Code, 应该把重复代码提炼到一个独立类中, 然后再另一个类中使用这个新类</p>\n</li>\n</ol>\n<blockquote>\n<p>函数上移(Pull Up Method): 若干个身处子类中的函数, 他们又可以通过某种形式的参数调整成为相同的函数. 这时候, 最简单的方法就是首先分别调整这些函数的参数, 然后再将他们概括到父类中去. 特殊情况: 当子类的函数覆写了父类的函数, 但却仍然做相同的工作.</p>\n<p>塑造模板函数(Form Template Method): 两个函数以相同顺序执行大致相近的操作, 但是各操作不完全相同. 这种情况下我们可以将执行操作的序列移至父类, 并借助多态保证各操仍得以保持差异性.</p>\n</blockquote>\n<h2 id=\"过长函数-Long-Method\"><a href=\"#过长函数-Long-Method\" class=\"headerlink\" title=\"过长函数(Long Method)\"></a><strong>过长函数(Long Method)</strong></h2><p>程序愈长愈难理解.<br>我们应该积极地分解函数, 只要你感觉需要在一个地方加注释, 我们就要把需要说明的东西写进一个独立函数, 并以其用途(而非实现手法)命名. 哪怕替换后的函数调用动作比函数自身还长, 只要函数名称能够解释其用途, 我们就应该毫不犹豫地那么做, 关键不在于函数的长度, 而在于”做什么”和”如何做”之间的语义距离.</p>\n<ol>\n<li>大多数场合, 把函数变小, 只需使用Extract Method(提炼函数). 找到函数中适合集中在一起的部分, 将他们提炼出来一个新函数.</li>\n<li>如果函数中有大量的参数和临时变量, 他们会对你的函数提炼形成阻碍. 如果</li>\n</ol>\n<h2 id=\"过大的类-Large-Class\"><a href=\"#过大的类-Large-Class\" class=\"headerlink\" title=\"过大的类(Large Class)\"></a><strong>过大的类(Large Class)</strong></h2><h2 id=\"过长参数列-Long-Parameter-List\"><a href=\"#过长参数列-Long-Parameter-List\" class=\"headerlink\" title=\"过长参数列(Long Parameter List)\"></a><strong>过长参数列(Long Parameter List)</strong></h2><h2 id=\"发散式变化-Divergent-Change\"><a href=\"#发散式变化-Divergent-Change\" class=\"headerlink\" title=\"发散式变化(Divergent Change)\"></a><strong>发散式变化(Divergent Change)</strong></h2><h2 id=\"霰弹式修改-Shotgun-Surgery\"><a href=\"#霰弹式修改-Shotgun-Surgery\" class=\"headerlink\" title=\"霰弹式修改(Shotgun Surgery)\"></a><strong>霰弹式修改(Shotgun Surgery)</strong></h2><h2 id=\"依恋情结-Feature-Envy\"><a href=\"#依恋情结-Feature-Envy\" class=\"headerlink\" title=\"依恋情结(Feature Envy)\"></a><strong>依恋情结(Feature Envy)</strong></h2><h2 id=\"数据泥团-Data-Clumps\"><a href=\"#数据泥团-Data-Clumps\" class=\"headerlink\" title=\"数据泥团(Data Clumps)\"></a><strong>数据泥团(Data Clumps)</strong></h2><h2 id=\"基本类型偏执-Primitive-Obsession\"><a href=\"#基本类型偏执-Primitive-Obsession\" class=\"headerlink\" title=\"基本类型偏执(Primitive Obsession)\"></a><strong>基本类型偏执(Primitive Obsession)</strong></h2><h2 id=\"Switch-惊悚现身-Switch-Statements\"><a href=\"#Switch-惊悚现身-Switch-Statements\" class=\"headerlink\" title=\"Switch 惊悚现身(Switch Statements)\"></a><strong>Switch 惊悚现身(Switch Statements)</strong></h2><h2 id=\"平行继承体系-Parallel-Inheritance-Hierarchies\"><a href=\"#平行继承体系-Parallel-Inheritance-Hierarchies\" class=\"headerlink\" title=\"平行继承体系(Parallel Inheritance Hierarchies)\"></a><strong>平行继承体系(Parallel Inheritance Hierarchies)</strong></h2><h2 id=\"冗赘类-Lazy-Class\"><a href=\"#冗赘类-Lazy-Class\" class=\"headerlink\" title=\"冗赘类(Lazy Class)\"></a><strong>冗赘类(Lazy Class)</strong></h2><h2 id=\"夸夸其谈未来性-Speculative-Generatlity\"><a href=\"#夸夸其谈未来性-Speculative-Generatlity\" class=\"headerlink\" title=\"夸夸其谈未来性(Speculative Generatlity)\"></a><strong>夸夸其谈未来性(Speculative Generatlity)</strong></h2><h2 id=\"令人迷惑的暂时字段-Temporary-Field\"><a href=\"#令人迷惑的暂时字段-Temporary-Field\" class=\"headerlink\" title=\"令人迷惑的暂时字段(Temporary Field)\"></a><strong>令人迷惑的暂时字段(Temporary Field)</strong></h2><h2 id=\"过度耦合的消息链-Message-Chains\"><a href=\"#过度耦合的消息链-Message-Chains\" class=\"headerlink\" title=\"过度耦合的消息链(Message Chains)\"></a><strong>过度耦合的消息链(Message Chains)</strong></h2><h2 id=\"中间人-Middle-Man\"><a href=\"#中间人-Middle-Man\" class=\"headerlink\" title=\"中间人(Middle Man)\"></a><strong>中间人(Middle Man)</strong></h2><h2 id=\"狎昵关系-Inappropriate-Intimacy\"><a href=\"#狎昵关系-Inappropriate-Intimacy\" class=\"headerlink\" title=\"狎昵关系(Inappropriate Intimacy)\"></a><strong>狎昵关系(Inappropriate Intimacy)</strong></h2><h2 id=\"异曲同工的类-AlertNative-Classes-with-Different-Interfaces\"><a href=\"#异曲同工的类-AlertNative-Classes-with-Different-Interfaces\" class=\"headerlink\" title=\"异曲同工的类(AlertNative Classes with Different Interfaces)\"></a><strong>异曲同工的类(AlertNative Classes with Different Interfaces)</strong></h2><h2 id=\"不完美的库类-Incomplete-Library-Class\"><a href=\"#不完美的库类-Incomplete-Library-Class\" class=\"headerlink\" title=\"不完美的库类(Incomplete Library Class)\"></a><strong>不完美的库类(Incomplete Library Class)</strong></h2><h2 id=\"纯稚的数据类-Data-Class\"><a href=\"#纯稚的数据类-Data-Class\" class=\"headerlink\" title=\"纯稚的数据类(Data Class)\"></a><strong>纯稚的数据类(Data Class)</strong></h2><h2 id=\"被拒绝的遗赠-Refused-Bequest\"><a href=\"#被拒绝的遗赠-Refused-Bequest\" class=\"headerlink\" title=\"被拒绝的遗赠(Refused Bequest)\"></a><strong>被拒绝的遗赠(Refused Bequest)</strong></h2><h2 id=\"过多的注释-COmments\"><a href=\"#过多的注释-COmments\" class=\"headerlink\" title=\"过多的注释(COmments)\"></a><strong>过多的注释(COmments)</strong></h2>","categories":["架构"],"tags":["重构","架构"]},{"title":"代码重构与拆分","url":"http://hchong.net/2016/12/26/代码重构与拆分/","content":"<h1 id=\"代码的重构与拆分\"><a href=\"#代码的重构与拆分\" class=\"headerlink\" title=\"代码的重构与拆分\"></a><strong>代码的重构与拆分</strong></h1><p>最近项目中有一块代码, 几经人手, 流落到我这里. 代码的业务逻辑十分复杂, 而且随着业务的扩张, 被不同的人加入而不同风格的代码, 最初的架构已经不适合现有业务的发展了, 维护起来也是相当的困难. 于是, 我就走上了重构和拆分之路.</p>\n<p>实际上来讲, 重构和拆分是两个不同的概念, 但是又都是相辅相成, 下面我简单讲一下我的理解.</p>\n<blockquote>\n<p>重构: 对软件内部结构的一种调整, 目的是在不改变软件可观察行为的前提下, 提高其可理解性, 降低其修改成本.</p>\n</blockquote>\n<ul>\n<li>拆分: 整体项目的架构, 降低代码的耦合性, 使得团队中的成员协作使用起来更加容易.</li>\n</ul>\n<p>不管重构还是拆分, 都是为了让代码能够跟上业务发展的水平, 不至于变得一团乱麻, 让团队之间的协作开发更加有效.</p>\n","categories":["架构"],"tags":["重构","拆分"]},{"title":"hexo常见问题","url":"http://hchong.net/2016/12/21/hexo常见问题/","content":"<h1 id=\"hexo常见问题\"><a href=\"#hexo常见问题\" class=\"headerlink\" title=\"hexo常见问题\"></a><strong>hexo常见问题</strong></h1><p>在使用hexo的过程中遇到了一些问题, 在这里列出来, 做一个记录.</p>\n<h2 id=\"hexo的常见发布流程\"><a href=\"#hexo的常见发布流程\" class=\"headerlink\" title=\"hexo的常见发布流程\"></a><strong>hexo的常见发布流程</strong></h2><ul>\n<li>hexo新建一篇文章使用<code>hexo new type name</code>, <code>type</code>有三种, 最常使用的是<code>post</code>, <code>name</code>是新建文档的名字.</li>\n<li><p>hexo新建完成, 编辑之后发布会经常使用到下面几个命令:</p>\n<ul>\n<li><code>hexo clean</code>清除之前缓存的一些信息, 例如主题之类的, 不是每次都必须执行.</li>\n<li><code>hexo g</code>相当于编译.</li>\n<li><code>hexo s</code>发布到本地服务器, 把<em>.md</em>文件生成讲台html用于展示, 也可做调试用.</li>\n<li><code>hexo d</code>推本地的文件到服务器, 这里指的是github上面, 如果绑定的有域名, 就直接发布到Internet. 每次推送前, 要确保<code>hexo g</code>和<code>hexo s</code>没有问题, 否则可造成Internet上面无法正常显示.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"hexo目录结构分析\"><a href=\"#hexo目录结构分析\" class=\"headerlink\" title=\"hexo目录结构分析\"></a><strong>hexo目录结构分析</strong></h2><h3 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a><strong>根目录</strong></h3><ul>\n<li>_config.yml: 位于本地博客的根目录下, 在这里面对整个博客的内容进行一些设置.</li>\n<li>source文件夹: 里面存储一些博客使用的文件资源, 例如<em>category(分类)</em>, <em>tag(标签)</em>, <em>link(链接)</em>, <em>about(关于)</em>, <em>project(工程)</em>, <em>search(搜索)</em>, *_posts(使用post格式新建的文章.md文件存储在这里).需要说明一下的是, 这些文件夹的名称和数量不固定, 要看你使用的主题里面的模块大概有几个 ,我使用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"external\">fexo</a>.还有一些坑, 后面再详述.</li>\n<li>public文件夹: 里面存储的是之前发布过得一些归档数据, 如果要删除之前的测试数据的话, 记得清理里面响应的内容.</li>\n<li>scaffolds文件夹: 存储.md文档的类型.</li>\n<li>themes文件夹: 里面是你下载的主题内容, 如果有多个主题, 就会有多个文件夹, 但只能同时使用一种样式的主题.这个后面会着重分析一下.</li>\n</ul>\n<h3 id=\"themes文件夹\"><a href=\"#themes文件夹\" class=\"headerlink\" title=\"themes文件夹\"></a><strong>themes文件夹</strong></h3><p>这里面主要会进行一些主题相关的设置.</p>\n<ul>\n<li>_config.yml: 位于主题目录下, 在这里面对当前只用主题的内容进行一些配置, 不同主题的配置可能不太一样, 我是用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"external\">fexo</a></li>\n</ul>\n<ul>\n<li>source文件夹: 该文件夹下面是该主题相关的一些资源, 例如一些静态的图片之类的.</li>\n<li>layout文件夹: 该文件夹下面是静态页面显示的相关配置. 代码高亮的设置也是在该文件夹下面. 其他的例如静态页面的展示, 可以修改相关的js文件.</li>\n</ul>\n<h2 id=\"修改代码高亮\"><a href=\"#修改代码高亮\" class=\"headerlink\" title=\"修改代码高亮\"></a><strong>修改代码高亮</strong></h2><p>代码高亮的展示, 不同的主题有不同的使用方式, 但是代码高亮的theme可以参考这里, 我使用的是<a href=\"https://highlightjs.org/static/demo/\" target=\"_blank\" rel=\"external\">HighLight</a>, 它提供了多种Theme, 基本上能满足各种需求.</p>\n<p>修改步骤如下:</p>\n<p>1.修改博客根目录下的<em>_config.yml</em>文件, 关闭hexo自带的代码高亮.</p>\n<pre><code class=\"js\">highlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n</code></pre>\n<p>2.<code>cd 博客根目录/themes/fexo/layout/_partial</code>打开<em>head.ejs</em>文件, 最好是在<code>&lt;head&gt;&lt;/head&gt;</code>之间开头处插入代码</p>\n<pre><code class=\"html5\">  &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css&quot;&gt;\n  &lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>也可以使用下面的写法:</p>\n<pre><code class=\"h5\">&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/styles/default.css&quot;&gt;\n&lt;script src=&quot;/path/to/highlight.pack.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>二者的区别在于, 第一种写法使用的是CDN创建的<a href=\"http://www.bootcdn.cn/?\" target=\"_blank\" rel=\"external\">在线文档地址</a>, 该地址还保存了其他一些常见的文档, 非常强大.而第二种写法则是把文件下载到本地, 从本地读取代码高亮的配置.</p>\n<hr>\n<p>修改过程中, 我参考了以下两篇博文, 还趟过不少坑, 贴上博文的地址:</p>\n<ol>\n<li><a href=\"http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-highlight/\" target=\"_blank\" rel=\"external\">地址一</a></li>\n<li><a href=\"http://jumpbyte.cn/2016/07/02/use-and-install-prettify/\" target=\"_blank\" rel=\"external\">地址二</a></li>\n</ol>\n","categories":["hexo"],"tags":["hexo","个人博客"]},{"title":"属性修饰符之copy和strong","url":"http://hchong.net/2016/09/21/属性修饰符之copy和strong/","content":"<h1 id=\"属性修饰符之copy和strong\"><a href=\"#属性修饰符之copy和strong\" class=\"headerlink\" title=\"属性修饰符之copy和strong\"></a>属性修饰符之copy和strong</h1><p>在了解属性修饰符的copy和strong的区分之前, 我们先来了解下浅拷贝和深拷贝的区别.</p>\n<h2 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h2><p>浅复制并不是拷贝对象本身, 仅仅是拷贝指向对象的指针; 深复制是直接拷贝整个对象内存到另一块内存中. 简单地说:</p>\n<ul>\n<li><strong>浅复制就是指针拷贝,  不会产生新的对象，指向的是同一个对象; </strong></li>\n<li><strong>深复制就是内容拷贝，会产生新的对象, 不同的对象, 内容相同.</strong></li>\n</ul>\n<p><img src=\"http://7s1ssm.com1.z0.glb.clouddn.com/image_note50592_1.png\" alt=\"浅复制和深复制\"></p>\n<h2 id=\"copy和mutableCopy\"><a href=\"#copy和mutableCopy\" class=\"headerlink\" title=\"copy和mutableCopy\"></a>copy和mutableCopy</h2><p><code>copy</code>就是复制了一个imutable对象, <code>mutableCopy</code>就是复制了一个mutable对象.</p>\n<p>一个<code>NSObject</code>对象要想使用这两个函数, 必须实现<code>NSCopying</code>协议和<code>NSMutableCopying</code>协议, 并且分别实现<code>- (id)copyWithZone:(nullable NSZone *)zone;</code>和<code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code>方法.但是常见的<code>NSString</code>, <code>NSArray</code>, <code>NADictionary</code>等常用的系统提供的结构体都已经实现. </p>\n<h3 id=\"系统的非容器类对象\"><a href=\"#系统的非容器类对象\" class=\"headerlink\" title=\"系统的非容器类对象\"></a>系统的非容器类对象</h3><p>这里指的是<code>NSString</code>, <code>NSNumber</code>等等一类的对象.下面以<code>NSString</code>为例.</p>\n<p>对<code>NSString</code>进行copy和mutableCop操作:</p>\n<pre><code class=\"objective-c\">NSString *originString = @&quot;origin&quot;;\nNSString *originStringCopy = [originString copy];\nNSMutableString *originStringMutableCopy = [originString mutableCopy];\nNSLog(@&quot;%p, %p, %p&quot;, originString, originStringCopy, originStringMutableCopy);\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originString\n(__NSCFConstantString *) $0 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringCopy\n(__NSCFConstantString *) $1 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringMutableCopy\n(__NSCFString *) $2 = 0x0000608000262800 @&quot;origin&quot;\n</code></pre>\n<hr>\n<p>对<code>NSMutableString</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginString = [NSMutableString stringWithString:@&quot;mutableOrigin&quot;];\nNSString *mutableOriginStringCopy = [mutableOriginString copy];\nNSMutableString *mutableOriginStringMutableCopy = [mutableOriginString mutableCopy];\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p mutableOriginString\n(__NSCFString *) $0 = 0x000060800026aa40 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringCopy\n(__NSCFString *) $1 = 0x0000608000222340 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringMutableCopy\n(__NSCFString *) $2 = 0x000060800026a700 @&quot;mutableOrigin&quot;\n</code></pre>\n<p>这里要注意的是:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginStringCopy = [mutableOriginString copy];\n[mutableOriginStringCopy appendString:@&quot;123&quot;];\n</code></pre>\n<p>这样写是会crash的, 因为copy生成的是imutable对象, 不管声明是什么样的, 依旧是imutable的.</p>\n<p><strong>综上, 对于系统的非容器类对象:</strong></p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n</ul>\n<h3 id=\"系统的容器类对象\"><a href=\"#系统的容器类对象\" class=\"headerlink\" title=\"系统的容器类对象\"></a>系统的容器类对象</h3><p>容器类对象指的是<code>NSArray</code>, <code>NSDictionary</code>, <code>NSSet</code>等系统提供的结构体, 下面以<code>NSArray</code>为例.</p>\n<p>对<code>NSArray</code>进行copy操作:</p>\n<pre><code class=\"objective-c\">NSArray *originArray = [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayI *) $0 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x00006080002403c0 @&quot;3 elements&quot;\n</code></pre>\n<p>可以看出, copy是浅复制, mutableCopy是深复制. 需要注意的是,mutableCopy的对象是一个可变对象,  数组内元素全都是浅复制.</p>\n<hr>\n<p>对<code>NSMutableArray</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>打印内存地址如下:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayM *) $0 = 0x000060800005eae0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x000060800005e9f0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x000060800005e900 @&quot;3 elements&quot;\n</code></pre>\n<p>可以发现可以看出, copy是浅复制, mutableCopy是深复制. 数组内元素都是浅复制.</p>\n<p>需要注意的是, mutable对象copy的对象是imutable对象, 如果当做可变对象来用是会崩溃的.</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSMutableArray *originArrayCopy1 = [originArray copy];\n[originArrayCopy1 addObject:@&quot;d&quot;];//crash\n</code></pre>\n<p>综上, 对于容器类对象:</p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n<li><strong>元素对象是浅复制.</strong></li>\n</ul>\n<h3 id=\"系统类对象的完全深复制\"><a href=\"#系统类对象的完全深复制\" class=\"headerlink\" title=\"系统类对象的完全深复制\"></a>系统类对象的完全深复制</h3><p>对于容器类对象而言, 元素对象始终是浅复制, 要想深复制可通过如下方法:</p>\n<pre><code class=\"objective-c\">NSArray *array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],[NSString stringWithString:@&quot;b&quot;],@&quot;c&quot;,nil];\nNSArray *deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];\nNSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject: array]];\n</code></pre>\n<p>打印元素内存地址可以发现, trueDeepCopyArray的元素都是深复制, 而deepCopyArray由于第一个元素是可变对象, 所以是深复制, 其他的元素都是浅复制.</p>\n<p><strong>综上, 要想实现容器对象所有元素的深复制, 只能通过归档来实现.</strong></p>\n<blockquote>\n<p>If you need a true deep copy, such as when you have an array of arrays, you can archive and then unarchive the collection, provided the contents all conform to the <code>NSCoding</code> protocol</p>\n</blockquote>\n<pre><code class=\"objective-c\">@protocol NSCoding\n\n- (void)encodeWithCoder:(NSCoder *)aCoder;\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER\n\n@end\n</code></pre>\n<h3 id=\"自定义对象\"><a href=\"#自定义对象\" class=\"headerlink\" title=\"自定义对象\"></a>自定义对象</h3><p>对于自定义对象, 我们要实现<code>NSCopying</code>, <code>NSMutableCopying</code>协议, 这样我们就能调用copy和mutableCopy了.假设有一个<code>Person</code>类, 继承于<code>NSObject</code>.</p>\n<p><code>person.h</code></p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n@interface Person : NSobject\n\n@property (nonatomic, assign) NSInteger age;\n@end\n</code></pre>\n<p><code>person.m</code></p>\n<pre><code class=\"objective-c\">\n#import &quot;Person.h&quot;\n@interface Person()&lt;NSCopying&gt;\n@end\n\n@implementation Person\n\n- (id)copyWithZone:(NSZone *)zone {\n    Person *person = [[Person allocWithZone:zone] init];\n      person.age = self.age;\n    return person;\n}\n@end\n</code></pre>\n<p>这样当我们在外面调用的时候:</p>\n<pre><code class=\"objective-c\">Person *p = [[Person alloc] init];\np.age = 20;\n\nPerson *copyP = [p copy];\nNSLog(@&quot;p = %p copyP = %p&quot;, p, copyP);\nNSLog(@&quot;age = %ld&quot;, copyP.age);\n</code></pre>\n<p>通过打印地址:</p>\n<pre><code class=\"objective-c\">(lldb) p p\n(Person *) $0 = 0x000060800002a1e0\n(lldb) p copyP\n(Person *) $1 = 0x000060800002a2e0\n(lldb) p p.age\n(NSInteger) $2 = 20\n(lldb) p copyP.age\n(NSInteger) $4 = 20\n</code></pre>\n<p>我们可以发现, 自定义对象内部的属性都被浅拷贝, 自定义对象本身被深拷贝.</p>\n<p>需要注意的是, 如果我们的自定义对象不实现<code>NSCopying</code>协议而直接copy时, 是会crash的.</p>\n<h2 id=\"属性修饰之copy与strong\"><a href=\"#属性修饰之copy与strong\" class=\"headerlink\" title=\"属性修饰之copy与strong\"></a>属性修饰之copy与strong</h2><p>我们新建一个<code>Person</code>类, 添加几个属性来看一下copy和strong对属性使用的影响.</p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface Person : NSObject\n\n@property (nonatomic, strong) NSString *strongName;\n@property (nonatomic, copy) NSString *copyName;\n\n@end\n</code></pre>\n<p>在外面调用<code>Person</code>类, 代码如下:</p>\n<pre><code class=\"objective-c\">Person *person = [[Person alloc] init];\nNSMutableString *testString = [NSMutableString stringWithString:@&quot;test&quot;];\nperson.nameCopy = testString;\nperson.nameStrong = testString;\n[testString appendString:@&quot;copy&amp;&amp;strong&quot;];\n</code></pre>\n<p>打印<code>testString</code>改变前后属性</p>\n<pre><code class=\"objective-c\">//testString改变前\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $1 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $2 = 0x0000600000260540 @&quot;test&quot;\n//testString改变后\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $3 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $4 = 0x0000600000260540 @&quot;testcopy&amp;&amp;strong&quot;\n</code></pre>\n<p>由以上可以看出:</p>\n<p>对源头是<code>NSMutableString</code>的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的，它也会跟着改变, 相当于浅拷贝; 而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>\n<p>当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>\n<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>\n<p>综上可以发现, 如果property是<code>NSString</code>或者<code>NSArray</code>及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。</p>\n<p>参考文档:</p>\n<p>1.<a href=\"http://www.fanliugen.com/?p=278\" target=\"_blank\" rel=\"external\">copy与mutableCopy</a></p>\n<p>2.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3\" target=\"_blank\" rel=\"external\">Copying Collections</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e6a7cdcc705d\" target=\"_blank\" rel=\"external\">iOS浅谈: 深.浅拷贝与copy.strong</a></p>\n<p>4.<a href=\"http://www.cocoachina.com/ios/20150512/11805.html\" target=\"_blank\" rel=\"external\">NSString属性什么时候用copy，什么时候用strong?</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"内存分配","url":"http://hchong.net/2016/09/18/内存分配/","content":"<h1 id=\"iOS开发的内存分配\"><a href=\"#iOS开发的内存分配\" class=\"headerlink\" title=\"iOS开发的内存分配\"></a>iOS开发的内存分配</h1><p>计算机系统中, 应用程序的数据都保存在内存中, 不同类型的数据, 保存的区域不同.</p>\n<h2 id=\"RAM-ROM\"><a href=\"#RAM-ROM\" class=\"headerlink\" title=\"RAM ROM\"></a>RAM ROM</h2><blockquote>\n<p>RAM: 运行内存, 不能掉电存储.ROM: 存储型内存, 可以掉电存储, 例如内存卡, FLash.<br>    由于RAM类型不具备掉电存储的能力, 所以App程序一般存放在RMO中. RAM的访问速度和价格都高于ROM.</p>\n</blockquote>\n<h2 id=\"App程序启动\"><a href=\"#App程序启动\" class=\"headerlink\" title=\"App程序启动\"></a>App程序启动</h2><blockquote>\n<p>App程序启动, 系统会把开启的那个App程序从Flash或ROM里面拷贝到内存(RAM)中, 然后从内存里面执行代码.<br>    另外一个原因是CPU不能直接从内存卡里面读取指令(需要Flash驱动等等)</p>\n</blockquote>\n<h2 id=\"内存分区\"><a href=\"#内存分区\" class=\"headerlink\" title=\"内存分区\"></a>内存分区</h2><h3 id=\"栈区-stack\"><a href=\"#栈区-stack\" class=\"headerlink\" title=\"栈区(stack)\"></a>栈区(stack)</h3><p>栈区由编译器自动分配并且释放, 存放局部变量, 函数的参数值, 函数跳转地址, 现场保护等.栈是系统数据结构, 对应线程/进程是唯一的.</p>\n<p>栈空间分配分为静态分配和动态分配两种.</p>\n<ul>\n<li>静态分配是由便一起完成, 比如自动变量<code>auto</code>的分配. 动态分配由<code>alloca</code>函数完成.</li>\n<li>栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配.</li>\n</ul>\n<p>关于栈还需要注意:</p>\n<ul>\n<li>不需要我们管理栈区变量的内存</li>\n<li>栈区地址从高到低分配</li>\n<li>先进后出</li>\n</ul>\n<h3 id=\"堆区-heap\"><a href=\"#堆区-heap\" class=\"headerlink\" title=\"堆区(heap)\"></a>堆区(heap)</h3><p>堆区由我们分配(iOS下的<code>alloc</code>)和释放, 如果不释放, 在程序结束时, 可能会由系统回收(iOS的ARC下). 灵活方便, 数据适应面广, 但是因为顺序随意, 所以效率有一定降低.<br>关于堆还需要注意:</p>\n<ul>\n<li>堆区的内存分配使用<code>alloc</code>.</li>\n<li>需要程序猿管理.</li>\n<li>ARC下的内存管理由编译器自动添加<code>retain</code>, <code>release</code>, <code>autorelease</code>等关键字.</li>\n<li>堆区的地址由低到高分配.</li>\n<li>不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理).</li>\n<li>堆空间的分配总是动态的.</li>\n</ul>\n<h3 id=\"全局区-static\"><a href=\"#全局区-static\" class=\"headerlink\" title=\"全局区(static)\"></a>全局区(static)</h3><p>全局区也叫作静态区. 全局变量和静态变量在内存中是放在一起的, 初始化的全局变量和静态变量放在一块区域, 未初始化的全局变量和静态变量放在相邻的另一块区域.</p>\n<pre><code>int a;//未初始化的\nint b = 10;//初始化的\n</code></pre><h3 id=\"常量区\"><a href=\"#常量区\" class=\"headerlink\" title=\"常量区\"></a>常量区</h3><p>常量字符串就存放在这里, 程序结束后由系统自己释放.</p>\n<h3 id=\"代码区\"><a href=\"#代码区\" class=\"headerlink\" title=\"代码区\"></a>代码区</h3><p>代码区也叫作函数区, 存放函数的二进制代码, App的代码.</p>\n<h2 id=\"内存申请后的系统响应\"><a href=\"#内存申请后的系统响应\" class=\"headerlink\" title=\"内存申请后的系统响应\"></a>内存申请后的系统响应</h2><p>1.栈: 存储的函数在执行的时候都会向操作系统索要资源, 栈区就是函数运行时的内训, 栈区中的变量由编译器负责释放和分配, 内存随着函数的运行和结束而分配和释放, 由系统完成. 只要剩余的栈空间大于申请空间, 系统将会为程序提供内存, 否则将报异常提示栈溢出.<br>2.堆: 操作系统有一个记录空闲地址的链表, 当系统收到程序申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序. 由于找到的堆节点大小不一定正合适, 系统会将多余的那部分重新放入空闲链表.</p>\n<h2 id=\"内存大小的限制\"><a href=\"#内存大小的限制\" class=\"headerlink\" title=\"内存大小的限制\"></a>内存大小的限制</h2><p>1.栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.<br>2.堆: 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>如图所示: 代码区的地址最低, 栈区最高. 但是区与区之间的地址不连续.<br><img src=\"http://upload-images.jianshu.io/upload_images/1156719-1d0de5ca1edc35af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"内存地址示意图\"></p>\n<ul>\n<li>在iOS中, 堆区的内存是程序间共享, 堆区的内存分配是系统负责的.</li>\n<li>系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容).</li>\n<li>变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回.</li>\n<li>当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃.</li>\n<li>栈由系统自动分配, 速度快, 不会产生内存碎片, 先进后出.</li>\n<li>堆由<code>alloc</code>分配内存, 速度慢, 而且容易产生碎片, FIFO, 不过使用起来方便.</li>\n</ul>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://www.jianshu.com/p/f3c1b920e8eb\" target=\"_blank\" rel=\"external\">iOS程序中的内存分配</a><br>2.<a href=\"http://www.jianshu.com/p/7bbbe5d55440\" target=\"_blank\" rel=\"external\">深入浅出-iOS内存分配</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"属性的修饰符解析","url":"http://hchong.net/2016/09/16/属性的修饰符解析/","content":"<h1 id=\"属性的修饰符解析\"><a href=\"#属性的修饰符解析\" class=\"headerlink\" title=\"属性的修饰符解析\"></a>属性的修饰符解析</h1><h2 id=\"属性的修饰符\"><a href=\"#属性的修饰符\" class=\"headerlink\" title=\"属性的修饰符\"></a>属性的修饰符</h2><ol>\n<li>线程安全的: atomic, nonatomic </li>\n<li>访问权限的: readonly， readwrite </li>\n<li>内存管理（ARC）: assign，strong，weak，copy </li>\n<li>内存管理（MRC）:assign， retain，copy </li>\n<li>指定方法名称: setter= getter=</li>\n</ol>\n<hr>\n<p>默认的修饰符是:</p>\n<ul>\n<li>基本数据类型使用<code>atomic</code>, <code>readwrite</code>, <code>assign</code>.</li>\n<li>对于普通的Objective-C对象使用<code>atomic</code>, <code>readwrite</code>, <code>strong</code>.</li>\n</ul>\n<h2 id=\"weak-amp-assign\"><a href=\"#weak-amp-assign\" class=\"headerlink\" title=\"weak &amp; assign\"></a>weak &amp; assign</h2><p>assign修饰基本数据类型和结构体, weak修饰一个对象</p>\n<hr>\n<p>assign修饰的对象编译时会产生一个警告:Assigning retained object to unsafe_unretained variable; object will be released after assignment(Assign修饰的对象无法被保留). 并且在释放之后指针的地址还是存在的, 也就是说指针并没有被置为nil, 造成野指针. 对象分配一般分配在堆上的某块内存(详见<a href=\"http://hchong.net/2016/09/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/\">内存分配</a>), 如果在后续的内存分配中, 刚好分到了这块地址, 程序就会导致EXC_BAD_ACCESS(调用已释放的内存空间)崩溃掉.</p>\n<p>assign修饰的基本数据类型或者结构体因为技术数据类型和结构体一般分配在栈上, 栈的内存会由系统自己自动处理, 不会造成野指针.</p>\n<hr>\n<p>weak修饰的对象在释放之后, 指针会被置为nil, 所以一般弱引用指的就是用weak.</p>\n<p>weak主要使用在以下两个方面:</p>\n<ul>\n<li>在ARC下, 有可能出现循环引用的地方, 比如delegate<br><code>@property (nonatomic, weak) id XXXDelegate;</code></li>\n<li>自身已经被强引用过一次, 比如xib文件汇总的属性<br><code>@property (nonatomic, weak) IBOutlet UIButton *button;</code></li>\n</ul>\n<hr>\n<h2 id=\"copy关键字的使用\"><a href=\"#copy关键字的使用\" class=\"headerlink\" title=\"copy关键字的使用\"></a>copy关键字的使用</h2><p>copy和strong一样都会使引用计数加1, 但是strong是两个指针指向同一个内训地址, copy则会在内存里拷贝一份对象, 两个指针指向不同的内存地址.</p>\n<p>copy关键字主要有以下使用场景:</p>\n<ul>\n<li>不确定赋值过程中用的是可变还是不可变的变量. 例如NSString, NSArray, NSDictionary等等常使用关键字copy, 因为他们有对应的可变类型.<a href=\"http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/\">关于copy和strong的详解</a></li>\n<li>block也经常使用copy关键字. 用copy修饰block时要知道是在ARC还是MRC.<ul>\n<li>ARC下只要block访问了外部局部变量, block就会放到堆区里面, 使用strong或者copy都可以, 但是strong的性能可能会更好.</li>\n<li>MRC下, 如果block访问外部局部变量, block是在栈区的. 如果block访问了一个整个APP生命周期都存在的变量, 那他肯定在全局区. 只有使用copy属性才能把block放到堆区.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>参考内容:<br>1.<a href=\"http://www.jianshu.com/p/3e0f12e5faaa\" target=\"_blank\" rel=\"external\">@property 关键字的区别详解</a><br>2.<a href=\"http://bihongbo.com/2014/05/20/IOSassignandweak/\" target=\"_blank\" rel=\"external\">iOS开发中ARC下的assign和weak区别</a><br>3.<a href=\"http://www.jianshu.com/p/3aa1c650a967\" target=\"_blank\" rel=\"external\">整理一下OC中的那些属性修饰符</a><br>4.<a href=\"http://blog.csdn.net/qq_32744055/article/details/53443805\" target=\"_blank\" rel=\"external\">@property 后面可以有哪些修饰符</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Hello World","url":"http://hchong.net/2016/08/16/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"about","url":"http://hchong.net/about/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://hchong.net/link/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://hchong.net/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://hchong.net/project/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://hchong.net/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://hchong.net/search/index.html","content":"","categories":[],"tags":[]}]