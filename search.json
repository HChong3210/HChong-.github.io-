[{"title":"Swift实践指南","url":"http://hchong.net/2017/12/11/Swift实践指南/","content":"","categories":[],"tags":[]},{"title":"HTTP请求中的GET与POST","url":"http://hchong.net/2017/12/11/HTTP请求中的GET与POST/","content":"","categories":[],"tags":[]},{"title":"RunLoop用法与分析","url":"http://hchong.net/2017/12/11/RunLoop用法与分析/","content":"","categories":[],"tags":[]},{"title":"Runtime用法与分析","url":"http://hchong.net/2017/12/11/Runtime用法与分析/","content":"","categories":[],"tags":[]},{"title":"RN实践指南","url":"http://hchong.net/2017/12/01/RN实践指南/","content":"<h1 id=\"RN实践指南\"><a href=\"#RN实践指南\" class=\"headerlink\" title=\"RN实践指南\"></a>RN实践指南</h1><p>RN实践过程中, 新手上路</p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><h2 id=\"组件间通信\"><a href=\"#组件间通信\" class=\"headerlink\" title=\"组件间通信\"></a>组件间通信</h2><h2 id=\"状态绑定\"><a href=\"#状态绑定\" class=\"headerlink\" title=\"状态绑定\"></a>状态绑定</h2>","categories":["基础知识","RN"],"tags":["基础知识","RN"]},{"title":"iOS多线程","url":"http://hchong.net/2017/11/21/iOS多线程/","content":"<h1 id=\"iOS开发多线程\"><a href=\"#iOS开发多线程\" class=\"headerlink\" title=\"iOS开发多线程\"></a>iOS开发多线程</h1><p>首先我们来搞清楚几个概念和他们之间的联系和区别: </p>\n<h2 id=\"多线程开发常用概念\"><a href=\"#多线程开发常用概念\" class=\"headerlink\" title=\"多线程开发常用概念\"></a>多线程开发常用概念</h2><ol>\n<li><p>进程和线程</p>\n<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.<br>​<br>线程是进程的一个实体, 是CPU调度和分派(资源分配)的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数器, 一组寄存器和栈), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. </p>\n<p>一个线程可以创建和撤销另一个线程; 同一个进程中的多个线程之间可以并发执行. </p>\n<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式. 进程有独立的地址空间, 一个进程崩溃后, 在保护模式下不会对其它进程产生影响. 而线程只是一个进程中的不同执行路径. 线程有自己的堆栈和局部变量, 但线程之间没有单独的地址空间, 一个线程死掉就等于整个进程死掉, 所以多进程的程序要比多线程的程序健壮, 但在进程切换时, 耗费资源较大, 效率要差一些. 但对于一些要求同时进行并且又要共享某些变量的并发操作, 只能用线程, 不能用进程. </p>\n<ol>\n<li>简而言之, 一个程序至少有一个进程, 一个进程至少有一个线程.<ol>\n<li>线程的划分尺度小于进程, 使得多线程程序的并发性高. </li>\n<li>另外, 进程在执行过程中拥有独立的内存单元, 而多个线程共享内存, 从而极大地提高了程序的运行效率. </li>\n<li>线程在执行过程中与进程还是有区别的. 每个独立的线程有一个程序运行的入口, 顺序执行序列和程序的出口. 但是线程不能够独立执行, 必须依存在应用程序中, 由应用程序提供多个线程执行控制. </li>\n<li>从逻辑角度来看, 多线程的意义在于一个应用程序中, 有多个执行部分可以同时执行. 但操作系统并没有将多个线程看做多个独立的应用, 来实现进程的调度和管理以及资源分配. 这就是进程和线程的重要区别.</li>\n</ol>\n</li>\n</ol>\n<p>打个比方, 多进程就好比同时执行多个程序. 比如同时运行QQ, 音乐播放器, 以及浏览器. 多线程就是同一时刻执行多个线程, 用浏览器一边下载, 一边听歌, 一边看视频, 一边看网页. 浏览器这个进程下有多个线程, 这些线程共享系统分配给浏览器这个进程的资源, 所以各个线程之间可很方便的通信, 一个线程死了, 不会影响其他线程的运行. 如果浏览器这个进程死了, 那么他下面的所有线程就都用不了了. 我们可以通过浏览器打开QQ这里就是进程间通信, 由于不同的进程系统资源不同, 所以进程间的通信不是很容易实现. 并且切换进程会有性能问题.</p>\n</li>\n<li><p>并发和并行</p>\n<p> 并发指能够让多个任务在逻辑上交织执行的程序设计, 但并发事件之间不一定要同一时刻发生. 并行指的是程序运行时的状态是物理上同时执行, 是指同时发生的两个并发事件, 具有并发的含义, 而并发则不一定并行. </p>\n<p> 并发是一种现象, 面对这一现象, 我们首先创建多个线程. 真正加快程序运行速度的, 是并行技术. 也就是让多个CPU同时工作. 而多线程, 是为了让多个CPU同时工作成为可能. 并发设计让并发执行成为可能, 而并行是并发执行的一种模式.</p>\n<p> 并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头. 一个人同时吃三个馒头但是同一时间只能啃一个馒头, 三个人同时吃三个馒头, 三个馒头同一时间都会被啃.</p>\n<p> 下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况. 假设每个核心有两个线程, 那么每个CPU中两个线程会交替并发, 两个CPU之间的操作会并行运算. 就CPU1而言虽然实现了并发但是同一时间只有一个任务在进行, CPU只是快速的在任务之间切换, CPU1和CPU2整体来看是并行元算, 同一时间是有多个任务在进行. 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题, 其本身运行效率并没有提高. 多CPU的并行运算才真正解决了运行效率问题, 这也正是并发和并行的区别. </p>\n<p> <img src=\"http://img.souche.com/f2e/5d7717afde012bbfc557f26bc5eaffea.png\" alt=\"并发和并行\"></p>\n<p> 注意: 并行和串行是相对应的. 串行在物理层面上同一时刻只会有一个任务在进行.</p>\n</li>\n<li><p>同步和异步</p>\n<p> 同步在发出一个同步调用时, 在没有得到结果之前, 该调用就不返回. 多个任务情况下, 一个任务A执行结束, 才可以执行另一个任务B. 只存在一个线程. 异步在发出一个异步调用后, 调用者不会立刻得到结果, 该调用就返回了. 多个任务情况下, 一个任务A正在执行, 同时可以执行另一个任务B. 任务B不用等待任务A结束才执行. 存在多条线程. </p>\n</li>\n</ol>\n<h2 id=\"多线程实现方案\"><a href=\"#多线程实现方案\" class=\"headerlink\" title=\"多线程实现方案\"></a>多线程实现方案</h2><p>在iOS开发中常见的多线程方案一共有4套, 分别是<code>Pthreads</code>, <code>NSThread</code>, <code>GCD</code>, <code>NSOperation &amp; NSOperationQueue</code>. 前两种不怎么常用, 这里就简单的介绍一下, 着重介绍后两种. </p>\n<h3 id=\"Pthresds\"><a href=\"#Pthresds\" class=\"headerlink\" title=\"Pthresds\"></a>Pthresds</h3><p>POSIX线程(POSIX threads), 简称Pthreads, 是线程的POSIX标准. 该标准定义了创建和操纵线程的一整套API, 在类Unix操作系统(Unix、Linux、Mac OSX等)中, 都使用Pthreads作为操作系统的线程. 那也就意味着可以跨平台使用, 但是使用起来特别酸爽. 🙂</p>\n<pre><code>#import &lt;pthread.h&gt;\n\n- (void)pthreadsDoTask {\n    /*\n     pthread_t：线程指针\n     pthread_attr_t：线程属性\n     pthread_mutex_t：互斥对象\n     pthread_mutexattr_t：互斥属性对象\n     pthread_cond_t：条件变量\n     pthread_condattr_t：条件属性对象\n     pthread_key_t：线程数据键\n     pthread_rwlock_t：读写锁\n     //\n     pthread_create()：创建一个线程\n     pthread_exit()：终止当前线程\n     pthread_cancel()：中断另外一个线程的运行\n     pthread_join()：阻塞当前的线程, 直到另外一个线程运行结束\n     pthread_attr_init()：初始化线程的属性\n     pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）\n     pthread_attr_getdetachstate()：获取脱离状态的属性\n     pthread_attr_destroy()：删除线程的属性\n     pthread_kill()：向线程发送一个信号\n     pthread_equal(): 对两个线程的线程标识号进行比较\n     pthread_detach(): 分离线程\n     pthread_self(): 查询线程自身线程标识号\n     //\n     *创建线程\n     int pthread_create(pthread_t _Nullable * _Nonnull __restrict, //指向新建线程标识符的指针\n     const pthread_attr_t * _Nullable __restrict,  //设置线程属性. 默认值NULL. \n     void * _Nullable (* _Nonnull)(void * _Nullable),  //该线程运行函数的地址\n     void * _Nullable __restrict);  //运行函数所需的参数\n     *返回值：\n     *若线程创建成功, 则返回0\n     *若线程创建失败, 则返回出错编号\n     */\n\n    //\n    pthread_t thread = NULL;\n    NSString *params = @&quot;Hello World&quot;;\n    int result = pthread_create(&amp;thread, NULL, threadTask, (__bridge void *)(params));\n    result == 0 ? NSLog(@&quot;creat thread success&quot;) : NSLog(@&quot;creat thread failure&quot;);\n    //设置子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源\n    pthread_detach(thread);\n}\n\nvoid *threadTask(void *params) {\n    NSLog(@&quot;%@ - %@&quot;, [NSThread currentThread], (__bridge NSString *)(params));\n    return NULL;\n}\n</code></pre><p>看下这些API设计可以说是相当不友好, 并且需要手动管理线程的各个状态的转换和生命周期的管理.</p>\n<h3 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h3><p><code>NSThread</code>的API设计大致如下: </p>\n<pre><code>@interface NSThread : NSObject\n//当前线程\n@property (class, readonly, strong) NSThread *currentThread;\n//使用类方法创建线程执行任务\n+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;\n//判断当前是否为多线程\n+ (BOOL)isMultiThreaded;\n//指定线程的线程参数, 例如设置当前线程的断言处理器. \n@property (readonly, retain) NSMutableDictionary *threadDictionary;\n//当前线程暂停到某个时间\n+ (void)sleepUntilDate:(NSDate *)date;\n//当前线程暂停一段时间\n+ (void)sleepForTimeInterval:(NSTimeInterval)ti;\n//退出当前线程\n+ (void)exit;\n//当前线程优先级\n+ (double)threadPriority;\n//设置当前线程优先级\n+ (BOOL)setThreadPriority:(double)p;\n//指定线程对象优先级 0.0～1.0, 默认值为0.5\n@property double threadPriority NS_AVAILABLE(10_6, 4_0);\n//服务质量\n@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);\n//线程名称\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);\n//栈区大小\n@property NSUInteger stackSize NS_AVAILABLE(10_5, 2_0);\n//是否为主线程\n@property (class, readonly) BOOL isMainThread NS_AVAILABLE(10_5, 2_0);\n//获取主线程\n@property (class, readonly, strong) NSThread *mainThread NS_AVAILABLE(10_5, 2_0);\n//初始化\n- (instancetype)init NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;\n//实例方法初始化, 需要再调用start方法\n- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);\n- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));\n//线程状态, 正在执行\n@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);\n//线程状态, 正在完成\n@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);\n//线程状态, 已经取消\n@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);\n//取消, 仅仅改变线程状态, 并不能像exist一样真正的终止线程\n- (void)cancel NS_AVAILABLE(10_5, 2_0);\n//开始\n- (void)start NS_AVAILABLE(10_5, 2_0);\n//线程需要执行的代码, 一般写子类的时候会用到\n- (void)main NS_AVAILABLE(10_5, 2_0);\n@end\n\n还有一个NSObject的分类\n@interface NSObject (NSThreadPerformAdditions)\n//隐式的创建并启动线程, 并在指定的线程（主线程或子线程）上执行方法. \n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;\n- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);\n- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);\n- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);\n@end\n</code></pre><p>常见的用法有以下几种: </p>\n<pre><code>- (void) startThread {\n\n    //创建并且手动启动\n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n    [thread start];\n\n    //类方法创建并且自动启动\n    [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];\n\n    //通过NSObject的方法自动启动\n    [self performSelectorInBackground:@selector(run) withObject:nil];\n}    \n\n- (void)run {\n    NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n}\n</code></pre><h3 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h3><p>Grand Central Dispatch, 它是苹果为多核的并行运算提出的解决方案, 会自动合理地利用更多的CPU内核(比如双核、四核), 最重要的是它会自动管理线程的生命周期(创建线程、调度任务、销毁线程), 完全不需要我们管理, 我们只需要告诉干什么就行. 同时它使用的也是C语言, 不过由于使用了Block(Swift里叫做闭包), 使得使用起来更加方便, 而且灵活.</p>\n<p>了解GCD我们需要先了解两个概念, <strong><code>队列</code></strong>和<strong><code>任务</code></strong>.</p>\n<ol>\n<li><p>任务</p>\n<p> 要执行的操作或方法函数. 在GCD中指的就是block块, 在NSThread中指的是<code>performSelector:</code>中的方法. 加入任务时有两种形式: <code>同步任务(dispatch_sync)</code>和<code>异步任务(dispatch_async)</code>.</p>\n<ol>\n<li>同步任务: 不会开启新的线程, 会阻塞当前线程. 完成需要做的任务后才会返回, 进行下一任务. 创建方式为:<pre><code>  //把右边的参数(任务)提交给左边的参数(队列)进行执行\n  dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n</code></pre></li>\n<li><p>异步任务: 不会等待任务完成才返回, 会立即返回. 异步是多线程的代名词, 因为必定会开启新的线程, 线程的申请是由异步负责, 起到开分支的作用. 创建方式为:</p>\n<pre><code>  //把右边的参数(任务)提交给左边的参数(队列)进行执行\n  dispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n</code></pre></li>\n</ol>\n</li>\n<li><p>队列</p>\n<p> 存放任务的集合, 我们要做的就是将任务添加到队列然后执行, GCD会自动将队列中的任务按先进先出的方式取出. 队列主要有的有<code>串行队列(Serial Dispatch Queue)</code>, <code>并行队列(Concurrent Dispatch Queue)</code>, <code>全局队列(Global Queue)</code>和<code>主队列(Main Queue)</code>.</p>\n<ol>\n<li><p>串行队列: 任务依次执行, 同一时间队列中只有一个任务在执行, 每个任务只有在前一个任务执行完成后才能开始执行. 你不知道在一个Block(任务)执行结束到下一个Block(任务)开始执行之间的这段时间时间是多长, 这部分是由GCD控制. 创建方式为:</p>\n<pre><code>  //创建一个名为queue的串行队列\n  //第一个参数为队列名称\n  //第二个参数为队列类型, DISPATCH_QUEUE_SERIAL和NULL表示串行队列\n  dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.SerialQueue&quot;, DISPATCH_QUEUE_SERIAL);\n</code></pre></li>\n<li><p>并行队列: 任务并发执行, 唯一能保证的是, 这些任务会按照被添加的顺序开始执行. 但是任务可以以任何顺序完成, 你不知道在执行下一个任务是从什么时候开始, 或者说任意时刻有多个Block(任务)运行, 这个完全是取决于GCD. GCD默认已经提供了全局的并发队列, 供整个应用使用, 一般不需要手动创建创建方式为:</p>\n<pre><code>  //创建一个名为queue的并行队列\n  //第一个参数为队列名称\n  //第二个参数为队列类型, DISPATCH_QUEUE_CONCURRENT表示并行队列\n  dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.ConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);\n</code></pre></li>\n<li><p>全局队列: <strong>隶属于并行队列</strong>, 不要与 barrier 栅栏方法搭配使用, barrier 只有与自定义的并行队列一起使用, 才能让 barrier 达到我们所期望的栅栏功能. 与串行队列或者global队列 一起使用, barrier的表现会和dispatch_sync方法一样. 创建方式为:</p>\n<pre><code>  //获取系统全局队列, 并赋值给队列queue\n  //第一个参数表示优先级, 这里是新老优先级的对照Map\n*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED//高\n*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT//默认\n*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY//低\n*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND//后台\n\n//第二个参数是预留参数, 传0就好\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n</code></pre></li>\n<li><p>主队列: <strong>隶属于串行队列</strong>, 不能与sync同步方法搭配使用, 会造成死循环. 主队列是GCD自带的一种特殊的串行队列, 放在主队列中的任务, 都会放到主线程中执行. 创建方式为:</p>\n<pre><code>  //获取系统主队列, 并赋值给队列queue\n  dispatch_queue_t queue = dispatch_get_main_queue();\n</code></pre></li>\n</ol>\n</li>\n</ol>\n<p>不管是串行队列(SerialQueue)还是并行队列(ConcurrencyQueue), 都是FIFO队列. 也就意味着, 任务一定是一个一个地, 按照先进先出的顺序来执行.</p>\n<h3 id=\"NSOperation-amp-NSOperationQueue\"><a href=\"#NSOperation-amp-NSOperationQueue\" class=\"headerlink\" title=\"NSOperation &amp; NSOperationQueue\"></a>NSOperation &amp; NSOperationQueue</h3><p><code>NSOperation</code> 是苹果公司对<code>GCD</code>的封装, 完全面向对象, 所以使用起来更好理解. 大家可以看到 <code>NSOperation</code>和<code>NSOperationQueue</code>分别对应<code>GCD</code>的<strong>任务</strong>和<strong>队列</strong>. 所以他的操作步骤和<code>GCD</code>类似: 首先将要执行的任务封装到一个<code>NSOperation</code>对象中. 然后将此任务添加到一个<code>NSOperationQueue</code>对象中, 然后系统就会自动在执行任务.</p>\n<ol>\n<li><p><code>NSOperation</code>主要有一下这些属性和方法. </p>\n<pre><code>  ​```\n @interface NSOperation : NSObject {\n @private\n     id _private;\n     int32_t _private1;\n #if __LP64__\n     int32_t _private1b;\n #endif\n }\n\n - (void)start;//启动任务 默认在当前线程执行\n - (void)main;//自定义NSOperation，写一个子类，重写这个方法，在这个方法里面添加需要执行的操作。\n\n @property (readonly, getter=isCancelled) BOOL cancelled;//是否已经取消，只读\n - (void)cancel;//取消任务\n\n @property (readonly, getter=isExecuting) BOOL executing;//正在执行，只读\n @property (readonly, getter=isFinished) BOOL finished;//执行结束，只读\n @property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &#39;asynchronous&#39; below\n @property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);//是否并发，只读\n @property (readonly, getter=isReady) BOOL ready;//准备执行\n\n - (void)addDependency:(NSOperation *)op;//添加依赖\n - (void)removeDependency:(NSOperation *)op;//移除依赖\n\n @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;//所有依赖关系，只读\n\n typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n     NSOperationQueuePriorityVeryLow = -8L,\n     NSOperationQueuePriorityLow = -4L,\n     NSOperationQueuePriorityNormal = 0,\n     NSOperationQueuePriorityHigh = 4,\n     NSOperationQueuePriorityVeryHigh = 8\n };//系统提供的优先级关系枚举\n\n @property NSOperationQueuePriority queuePriority;//执行优先级\n\n @property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);//任务执行完成之后的回调\n\n - (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);//阻塞当前线程，等到某个operation执行完毕。\n\n @property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);//已废弃，用qualityOfService替代。\n\n @property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);//服务质量，一个高质量的服务就意味着更多的资源得以提供来更快的完成操作。\n\n @property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);//任务名称\n\n @end\n ​```\n</code></pre><p> 由于<code>NSOperation</code>是一个抽象基类, 不能直接使用, 在这里我么你一般使用<code>NSOperation</code>的两个子类<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>, 或者<code>NSOperation的自定义子类</code>:</p>\n<pre><code> 1. `NSInvocationOperation`基于应用的一个target对象和selector来创建operation object. 如果你已经有现有的方法来执行需要的任务, 就可以使用这个类. 使用方式大致如下: \n\n ```\n - (void)NSInvocationOperationRun {\n     NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];\n     [invocationOper start];\n }\n - (void)invocationOperSel {\n     NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);\n }\n ```\n</code></pre><p> 从打印结果可以看出, 该实现方式是同步顺序执行.</p>\n<pre><code> 2.  `NSBlockOperation`用来并发地执行一个或多个block对象. operation object使用**组**的语义来执行多个block对象，所有相关的 block 都执行完成之后, operation object才算完成. 使用方法如下\n\n      ```\n      //系统提供的API\n      @interface NSBlockOperation : NSOperation {\n      @private\n          id _private2;\n          void *_reserved2;\n      }\n\n     + (instancetype)blockOperationWithBlock:(void (^)(void))block;//在当前线程执行\n\n     - (void)addExecutionBlock:(void (^)(void))block;//新开线程执行\n     @property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;\n\n     @end\n      ```\n\n 使用`NSBlockOperation`类方法创建任务, 从打印结果可以看出来该任务是在主线程执行的\n\n     ```\n     - (void)NSBlockOperationRun {\n         NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n             NSLog(@&quot;NSBlockOperationRun_%@_%@&quot;, [NSOperationQueue currentQueue], [NSThread currentThread]);\n         }];\n         [blockOper start];\n     }\n     ```\n\n 使用`NBlockOperation`的实例方法创建任务, 从打印结果可以看出来, 第一个任务是在主线程执行, 其他任务均是新开的线程, 所有的任务是以异步并发的形式执行. \n\n     ```\n     - (void)NSBlockOperationRun {\n         NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n             NSLog(@&quot;NSBlockOperationRun_1_%@&quot;, [NSThread currentThread]);\n         }];\n         [blockOper addExecutionBlock:^{\n             NSLog(@&quot;NSBlockOperationRun_2_%@&quot;, [NSThread currentThread]);\n         }];\n         [blockOper addExecutionBlock:^{\n             NSLog(@&quot;NSBlockOperationRun_3_%@&quot;, [NSThread currentThread]);\n         }];\n         [blockOper addExecutionBlock:^{\n             NSLog(@&quot;NSBlockOperationRun_4_%@&quot;, [NSThread currentThread]);\n         }];\n         [blockOper start];\n     }\n     ```\n\n 3. `NSOperation的自定义子类`. \n\n     ```        \n     在子类中重写父类的`-(void)main`函数, 在里面实现主要逻辑\n     ```\n</code></pre><p>  <code>NSBlockOperation</code>, <code>NSBlockOperationRun</code>或者<code>NSOperation的自定义子类</code>创建的operation object都可以使用<code>NSOperation</code>的所有属性, 意味着他们具有以下主要特性: </p>\n<ol>\n<li>多个任务之间可以使用有依赖关系</li>\n<li>可以获得Operation object任务执行完成之后的回调</li>\n<li>支持应用使用 KVO 通知来监控 operation 的执行状态</li>\n<li>可以通过operation优先级, 从而影响相对的执行顺序</li>\n<li>可以终止正在执行的任务</li>\n</ol>\n</li>\n<li><p><code>NSOperationQueue</code></p>\n<p> 类似于GCD中的队列, 只需要吧任务加入到<code>NSOperationQueue</code>中, 就会自动运行, 由系统通过最大并发数来控制是并行还是串行, 官方提供的API如下:</p>\n<pre><code> static const NSInteger NSOperationQueueDefaultMaxConcurrentOperationCount = -1;\n\n NS_CLASS_AVAILABLE(10_5, 2_0)\n @interface NSOperationQueue : NSObject {\n @private\n     id _private;\n     void *_reserved;\n }\n\n - (void)addOperation:(NSOperation *)op;//向队列中添加任务\n - (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一组任务\n\n - (void)addOperationWithBlock:(void (^)(void))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一个block形式的任务\n\n @property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;//队列中所有任务的数组\n @property (readonly) NSUInteger operationCount API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//队列中所有任务数\n\n @property NSInteger maxConcurrentOperationCount;//最大并发数\n\n @property (getter=isSuspended) BOOL suspended;//暂停\n\n @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//名称\n\n @property NSQualityOfService qualityOfService API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));//服务质量, 系统会为权重高的服务分配更多的资源\n\n @property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));\n\n - (void)cancelAllOperations;//取消队列中所有的任务\n\n - (void)waitUntilAllOperationsAreFinished;//阻塞当前线程, 等到队列中的全部任务全部执行完毕\n\n @property (class, readonly, strong, nullable) NSOperationQueue *currentQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取当前队列\n @property (class, readonly, strong) NSOperationQueue *mainQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取主队列\n\n @end\n</code></pre><p> 使用方式如下:</p>\n<pre><code> //以三种方式为队列添加了三个任务, \n - (void)NSOperationQueueRun {\n     NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n     NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];\n     [queue addOperation:invocationOper];\n     NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n         NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]);\n     }];\n     [queue addOperation:blockOper];\n     [queue addOperationWithBlock:^{\n         NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]);\n     }];\n }\n\n - (void)invocationOperSel {\n     NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);\n }\n</code></pre><p> 一般情况下, <code>NSOperationQueue</code>会按照任务添加的顺序来执行任务, 但是我们可以通过使用优先级和依赖关系来改变执行顺序. 并发数大于任务数, 没有设置依赖关系, 并且在同一队列.</p>\n</li>\n</ol>\n<h2 id=\"常见的使用方式\"><a href=\"#常见的使用方式\" class=\"headerlink\" title=\"常见的使用方式\"></a>常见的使用方式</h2><h3 id=\"GCD向并行队列中添加异步任务\"><a href=\"#GCD向并行队列中添加异步任务\" class=\"headerlink\" title=\"GCD向并行队列中添加异步任务\"></a>GCD向并行队列中添加异步任务</h3><p>该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加异步任务. 任务会遵守FIFO原则来执行, 但是每个任务何时执行完我们却并不知道. 但是系统会新开线程来执行异步任务, 三个异步任务会分别在三个线程中执行, 各个任务的执行顺序无法确定.</p>\n<pre><code>- (void)test1 {\n    //获取系统提供的全局队列\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n        sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD向串行队列中添加异步任务\"><a href=\"#GCD向串行队列中添加异步任务\" class=\"headerlink\" title=\"GCD向串行队列中添加异步任务\"></a>GCD向串行队列中添加异步任务</h3><p>该过程一共分为两步, 第一步创建串行队列, 第二步向并行队列中添加异步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 但是由于我们是在串行队列中添加的任务, 不会新开线程, 所有的异步任务会按照顺序前一个执行完毕再执行后一个.</p>\n<pre><code> - (void)test2 {\n    //创建串行队列, 第一个参数为串行队列的名称, 第二个参数为队列的属性, NULL或者DISPATCH_QUEUE_SERIAL表示是串行队列\n    dispatch_queue_t queue = dispatch_queue_create(&quot;test2&quot;, NULL);\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n        sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD向并行队列添加同步任务\"><a href=\"#GCD向并行队列添加同步任务\" class=\"headerlink\" title=\"GCD向并行队列添加同步任务\"></a>GCD向并行队列添加同步任务</h3><p>该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加同步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 虽然是并行队列, 单由于添加的是同步任务, 不会新开线程, 全都在当前线程中执行, 所以三个任务会顺序执行, 并行队列失去了并行的能力. </p>\n<pre><code>//并行队列中添加同步任务\n- (void)test3 {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n    //向队列中添加异步任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n        sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD-向串行队列添加异步任务\"><a href=\"#GCD-向串行队列添加异步任务\" class=\"headerlink\" title=\"GCD 向串行队列添加异步任务\"></a>GCD 向串行队列添加异步任务</h3><p>该过程一共分为两步, 第一步创建自定义串行队列, 第二步向并行队列中添加异步任务. 虽然异步任务会新开线程, 但是由于是在串行队列中执行, 所以不新开线程, 所有任务前一个执行完毕再执行下一个.</p>\n<pre><code>- (void)test4 {\n    dispatch_queue_t queue = dispatch_queue_create(&quot;test4&quot;, NULL);\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);\n        sleep(5);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);\n    });\n\n    //向队列中添加异步任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD监听并行队列中多个异步任务是否已经完成-Dispatch-Group\"><a href=\"#GCD监听并行队列中多个异步任务是否已经完成-Dispatch-Group\" class=\"headerlink\" title=\"GCD监听并行队列中多个异步任务是否已经完成(Dispatch Group)\"></a>GCD监听并行队列中多个异步任务是否已经完成(Dispatch Group)</h3><p>分组模式 <code>dispatch_group_notify</code>. 可以异步执行多个耗时操作. 等耗时操作都执行完毕之后会回到主线程执行操作, 主要用于监听任务是否完成. 主要有两种用法: </p>\n<p>第一种用法是通过<code>dispatch_group_async</code>, 首先创建一个全局并行队列和一个group队列组, 再次创建异步group任务加入到前面创建的group队列中去. 当所有异步任务完成后, 会通过<code>dispatch_group_notify</code>回到主线程.</p>\n<pre><code>- (void)groupTest1 {\n    //获取全局队列\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    //创建一个队列组\n    dispatch_group_t group = dispatch_group_create();\n\n    dispatch_group_async(group, queue, ^{\n        NSLog(@&quot;--- 1 开始--- %@&quot;, [NSThread currentThread]);\n        //延时5秒 模仿堵塞子线程\n        [NSThread sleepForTimeInterval:5];\n        NSLog(@&quot;--- 1 --- 完成 %@&quot;, [NSThread currentThread]);\n    });\n\n    dispatch_group_async(group, queue, ^{\n        NSLog(@&quot;--- 2 开始--- %@&quot;, [NSThread currentThread]);\n        //延时5秒 模仿堵塞子线程\n        [NSThread sleepForTimeInterval:5];\n        NSLog(@&quot;--- 2 --- 完成 %@&quot;, [NSThread currentThread]);\n    });\n\n    //在这个队列组里面，会等group中的全部代码执行完毕再去执行其它的操作\n    dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        // 等前面的异步操作都执行完毕后，回到主线程...\n        NSLog(@&quot;全部完成&quot;);\n    });\n}\n</code></pre><p>第二种用法是通过信号量<code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code>. 创建一个并行线程和多个异步任务, 将异步任务添加到并行线程中区. 通过<code>dispatch_group_enter</code>来告知<code>group</code>一个异步任务开始,  未执行完毕任务数加1. 在异步线程任务执行完毕时, 通过<code>dispatch_group_leave</code>告知group, 一个任务结束, 未执行完毕任务数减1. 当未执行完毕任务数为0的时候, 这时group才认为组内任务都执行完毕了(这个和GCD的信号量的机制有些相似), 这时候才会回调<code>dispatch_group_notify</code>中的block. 此处需要注意, <code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的数量一定要一致. </p>\n<pre><code>- (void)groupTest2 {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_group_t group = dispatch_group_create();\n\n    dispatch_group_enter(group);\n    dispatch_async(queue, ^{\n        sleep(2); //这里线程睡眠1秒钟，模拟异步请求\n        NSLog(@&quot;%@ one finish&quot;, [NSThread currentThread]);\n        dispatch_group_leave(group);\n    });\n\n    dispatch_group_enter(group);\n    dispatch_async(queue, ^{\n        sleep(2); //这里线程睡眠1秒钟，模拟异步请求\n        NSLog(@&quot;%@ two finish&quot;, [NSThread currentThread]);\n        dispatch_group_leave(group);\n    });\n\n    dispatch_group_notify(group, queue, ^{\n        NSLog(@&quot;group finished&quot;);\n    });\n}\n</code></pre><h3 id=\"GCD延时操作-dispatch-after\"><a href=\"#GCD延时操作-dispatch-after\" class=\"headerlink\" title=\"GCD延时操作(dispatch_after)\"></a>GCD延时操作(dispatch_after)</h3><p>使用很简单, 两个核心的对象<code>dispatch_time_t</code>和<code>dispatch_after</code>. 大家都经常使用, 不用多说. 下面的代码和在3妙手用<code>dispatch_async</code>函数追加block到主线程的操作是相同的</p>\n<pre><code>- (void)afterTest {\n    double delayInSeconds = 2.0;\n    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));\n    //第一个参数代表时间, 第二各参数代表要在哪个线程执行接下来的任务, 第三个参数就是任务block\n    dispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n        NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><h3 id=\"GCD单例-dispatch-once\"><a href=\"#GCD单例-dispatch-once\" class=\"headerlink\" title=\"GCD单例(dispatch_once)\"></a>GCD单例(dispatch_once)</h3><p>这个更是不用多说, 直接贴上代码.</p>\n<pre><code>@interface Tool : NSObject\n+ (instancetype)sharedTool;\n@end\n\n@implementation Tool\nstatic id _instance;\n+ (instancetype)sharedTool {\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        _instance = [[Tool alloc] init];\n    });\n    return _instance;\n}\n@end\n</code></pre><h3 id=\"GCD-线程间的通讯\"><a href=\"#GCD-线程间的通讯\" class=\"headerlink\" title=\"GCD 线程间的通讯\"></a>GCD 线程间的通讯</h3><p>常用的方式就是在后台线程中执行长时间任务, 处理结束时, 主线程使用该处理结果. 代码如下: </p>\n<pre><code>- (void)threadTest {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_async(queue, ^{\n        //在这里执行耗时的操作\n        dispatch_async(dispatch_get_main_queue(), ^{\n            //在主线程使用上面操作的结果\n        });\n    });\n}\n</code></pre><h3 id=\"GCD重复执行同一个任务-dispatch-apply\"><a href=\"#GCD重复执行同一个任务-dispatch-apply\" class=\"headerlink\" title=\"GCD重复执行同一个任务(dispatch_apply)\"></a>GCD重复执行同一个任务(dispatch_apply)</h3><p><code>disaptch_apply</code>函数是<code>dispatch_sync</code>函数和<code>Dispatch Group</code>的关联API, 该函数按照指定的次数将指定的Block追加到指定的Dispatch Queue中, 并等待处理执行结束. </p>\n<pre><code>- (void)applyTest {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_apply(10, queue, ^(size_t index) {\n        //并行处理10次任务\n        NSLog(@&quot;%zu&quot;, index);\n    });\n}\n</code></pre><p>但是由于<code>dispatch_apply</code>函数与<code>dispatch_sync</code>函数相同, 会等待任务执行结束, 所以我们强烈推荐在<code>dispatch_async</code>函数中异步执行. </p>\n<pre><code>- (void)applyTest {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n    //在全局并行队列中异步执行\n    dispatch_async(queue, ^{\n        //等待函数中操作全部执行完毕\n        dispatch_apply(10, queue, ^(size_t index) {\n            //并行处理10次任务\n            sleep(2);\n            NSLog(@&quot;%zu&quot;, index);\n        });\n\n        //dispatch_apply中的处理全部结束, 在主线程异步执行\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSLog(@&quot;Done&quot;);\n        });\n    });\n}\n</code></pre><h3 id=\"GCD设置优先级-dispatch-set-target-queue\"><a href=\"#GCD设置优先级-dispatch-set-target-queue\" class=\"headerlink\" title=\"GCD设置优先级(dispatch_set_target_queue)\"></a>GCD设置优先级(dispatch_set_target_queue)</h3><p>将queue的优先级通过<code>dispatch_set_target_queue</code>变更的和queue1的优先级一致, 代码如下. </p>\n<pre><code>- (void)targetQueeuTest {\n    dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, NULL);\n    dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    //把第一个参数的执行优先级设置的和第二个参数的优先级一致.\n    dispatch_set_target_queue(queue, queue1);\n}\n</code></pre><h3 id=\"GCD栅栏-dispatch-barrier-async\"><a href=\"#GCD栅栏-dispatch-barrier-async\" class=\"headerlink\" title=\"GCD栅栏(dispatch_barrier_async)\"></a>GCD栅栏(dispatch_barrier_async)</h3><p>以下面的代码为例, 假设一个并行队列中添加了五个异步任务, 虽然遵循FIFO的原则, 这五个任务的执行必定是无序的. 当我们在第三个任务之后加入<code>dispatch_barrier_async</code>任务, 那么这五个任务就被分割成两部分, 前三次无序执行, 然后执行<code>dispatch_barrier_async</code>任务, 然后再无序执行后两次任务. 注意<strong>此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行</strong></p>\n<pre><code>- (void)barrierTest {\n\n    //此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行\n    dispatch_queue_t queue = dispatch_queue_create(&quot;barrierTest&quot;, DISPATCH_QUEUE_CONCURRENT);\n\n    dispatch_async(queue, ^{\n        NSLog(@&quot;1&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;2&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;3&quot;);\n    });\n    dispatch_barrier_async(queue, ^{\n        sleep(3);\n        NSLog(@&quot;插入执行&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;4&quot;);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;5&quot;);\n    });\n}\n</code></pre><h3 id=\"GCD信号量-dispatch-semaphore-t\"><a href=\"#GCD信号量-dispatch-semaphore-t\" class=\"headerlink\" title=\"GCD信号量(dispatch_semaphore_t)\"></a>GCD信号量(dispatch_semaphore_t)</h3><p>我们以这个使用场景为例, 来说明一下, 不考虑顺序 将所有的数据添加到空数组中去, 我们可能会这么实现:</p>\n<pre><code>- (void)dispatchSemaphoreDemo {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    NSMutableArray *array = [NSMutableArray array];\n    for (int i = 0; i &lt; 100000; i++) {\n        dispatch_async(queue, ^{\n            NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n            [array addObject:@(i)];\n        });\n    }\n}\n</code></pre><p>因为是并行队列, 异步任务, 所以会开大量的线程, 并且这些线程会保存在内存中,相当耗费资源, 最终运行的结果就是崩溃. 那么我们就需要通过信号量来控制任务的执行. <code>dispatch_semaphore_t</code>类似于单个队列的最大并发数控制机制, 提高并行效率的同时, 也可以防止太多线程的开辟对系统造成太大的负担. 改造后应该是这样的: </p>\n<pre><code>- (void)dispatchSemaphoreDemo {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    NSMutableArray *array = [NSMutableArray array];\n\n    //设置信号量初始值, 当信号量为0时, 所有任务等待, 信号量越大, 允许可并行执行的任务数量越多. 并发的线程由系统调配, 不一定一直是同样的两条, 但是最多只能同时存在两条.\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);\n    for (int i = 0; i &lt; 100; i++) {\n\n        //当信号量大于等于设定的初始值时就继续执行, 否则一直等待\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        dispatch_async(queue, ^{\n            //执行到这里就代表信号量大于等于设定的初始值, 所以在这里信号量要减1\n            NSLog(@&quot;%d+++++%@&quot;, i, [NSThread currentThread]);\n            [array addObject:@(i)];\n            //到这里的时候, 因为异步任务已经将要结束, 要将信号量加1. 如果前面有等待的线程, 最先等待的线程先执行\n            dispatch_semaphore_signal(semaphore);\n        });\n    }\n}\n</code></pre><h3 id=\"GCD定时器\"><a href=\"#GCD定时器\" class=\"headerlink\" title=\"GCD定时器\"></a>GCD定时器</h3><p>GCD实现定时器主要用到<code>dispatch_source_t</code>函数, 该函数实际有多种Type, <code>DISPATCH_SOURCE_TYPE_TIMER</code>是定时器相关的任务, 还有其他类型的处理事件类型. </p>\n<pre><code>- (void)timerDemo {\n    NSLog(@&quot;%@&quot;, [NSThread currentThread]);\n    //指定DISPATCH_SOURCE_TYPE_TIMER类型, 作成Dispatch Source\n\n    //在定时器经过指定时间, 把任务追加到main queue\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n\n    //定时器的相关设置, 将定时器设置为5s后, 不指定为重复, 允许延迟1s\n    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 1ull * NSEC_PER_SEC);\n\n    //指定定时器指定时间内执行的处理\n    dispatch_source_set_event_handler(timer, ^{\n        NSLog(@&quot;wake up&quot;);\n        dispatch_source_cancel(timer);\n    });\n\n    //取消定时器时的处理\n    dispatch_source_set_cancel_handler(timer, ^{\n        NSLog(@&quot;canceled&quot;);\n    });\n\n    //定时器启动\n    dispatch_resume(timer);\n}\n</code></pre><h3 id=\"NSOperation的优先级\"><a href=\"#NSOperation的优先级\" class=\"headerlink\" title=\"NSOperation的优先级\"></a>NSOperation的优先级</h3><p>NSOperationQueue中NSOperation对象的执行方式是按照FIFO的原则顺序执行, 但是如果我们设置了任务的优先级, 那么系统就会给优先级高的优先分配资源. </p>\n<p>优先级一共有这几种, 从高到低依次排列. </p>\n<pre><code>typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n    NSOperationQueuePriorityVeryLow = -8L,\n    NSOperationQueuePriorityLow = -4L,\n    NSOperationQueuePriorityNormal = 0,\n    NSOperationQueuePriorityHigh = 4,\n    NSOperationQueuePriorityVeryHigh = 8\n};\n</code></pre><p>示例代码如下, 三个任务被添加到队列中去, 这三个任务分别在三个线程, 互不干扰, 类似于GCD的异步并行模式, 如果我们设置<code>invocationOper.queuePriority = NSOperationQueuePriorityVeryLow</code>理论上, <code>invocationOper</code>任务会在最后执行, 但是我们发现并没有, 那是因为我们没有设置最大并发数的原因, 我猜测系统可能是做了某些限制, 虽然是新开了线程, 但是由于最大并发数小于等于1实际还是按照FIFO顺序执行, <strong>所以注意一定要设置最大并发数</strong>.</p>\n<pre><code>//把注释打开就可以看到想要的效果\n- (void)NSOperationQueueRun {\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    //queue.maxConcurrentOperationCount = 3;\n    NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];\n    //invocationOper.queuePriority = NSOperationQueuePriorityVeryLow;\n    [queue addOperation:invocationOper];\n    NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]);\n    }];\n    [queue addOperation:blockOper];\n    [queue addOperationWithBlock:^{\n        NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]);\n    }];\n}\n\n- (void)invocationOperSel {\n    NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);\n}\n</code></pre><h3 id=\"NSOperation的依赖关系\"><a href=\"#NSOperation的依赖关系\" class=\"headerlink\" title=\"NSOperation的依赖关系\"></a>NSOperation的依赖关系</h3><p>首先我们创建一个队列, 分别创建要执行的任务, <strong>在把要执行的任务添加到队列中去之前, 通过<code>addDependency</code>来建立任务间的依赖关系</strong>. 如果我们没有设置依赖的话, 如果设置的并发数大于1,  那么<code>blockOper_1</code>和<code>`blockOper_2</code>的执行顺序是随机的. 可是当我们执行<code>[blockOper_1 addDependency:blockOper_2]</code>时, 就给两个任务添加了依赖关系, <code>blockOper_1</code>永远只会在<code>blockOper_2</code>后执行. 即使我们给<code>blockOper_1</code>设置了最高的优先级, 因为<strong>依赖的优先级要高于<code>queuePriority</code></strong>. </p>\n<pre><code>- (void)NSOperationQueueRun2 {\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n//    queue.maxConcurrentOperationCount = 2;\n    NSBlockOperation *blockOper_1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@&quot;blockOper_1_%@_%@&quot;,@(1),[NSThread currentThread]);\n    }];\n\n    NSBlockOperation *blockOper_2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@&quot;blockOper_2_%@_%@&quot;,@(2),[NSThread currentThread]);\n    }];\n\n//    blockOper_1.queuePriority = NSOperationQueuePriorityVeryHigh;\n    [blockOper_1 addDependency:blockOper_2];\n    [queue addOperation:blockOper_1];\n    [queue addOperation:blockOper_2];\n}\n</code></pre><h2 id=\"常见使用案列分析\"><a href=\"#常见使用案列分析\" class=\"headerlink\" title=\"常见使用案列分析\"></a>常见使用案列分析</h2><h3 id=\"案例一\"><a href=\"#案例一\" class=\"headerlink\" title=\"案例一\"></a>案例一</h3><pre><code>- (void)case1 {\n    NSLog(@&quot;任务一 - %@&quot;, [NSThread currentThread]);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;同步任务 - %@&quot;,[NSThread currentThread]);\n    });\n    NSLog(@&quot;任务二 - %@&quot;, [NSThread currentThread]);\n}\n</code></pre><p>以上<code>- (void)case1</code>默认在当前线程(主线程)执行,  首先执行”任务一”. 然后<code>dispatch_sync</code>阻塞当前线程(主线程), 由于主队列是串行队列, 任务不能并发执行, 同时只能有一个任务在执行. 又因为<strong>“同步任务”后入列, 按照FIFO原则, 必须等到<code>- (void)case1</code>执行完毕才能执行</strong>, 但是<code>- (void)case1</code>中的”任务二”又在等着”同步任务”执行完毕才能执行, 这样就造成同一队列中的两个任务相互等待, 造成死锁. </p>\n<p><img src=\"http://img.souche.com/f2e/5b1729532683ad164c061958d5248a66.png\" alt=\"案例1\"></p>\n<p>有两种解决思路, 一是为当前队列扩容, 让它变成并行队列, 就不会造成阻塞. 第二种解决思路是把同步任务添加到一个新的自定义串行队列中去, 两个队列之间不存在阻塞就避免了死锁问题. </p>\n<h3 id=\"案例二\"><a href=\"#案例二\" class=\"headerlink\" title=\"案例二\"></a>案例二</h3><pre><code>- (void)case2 {\n    NSLog(@&quot;1&quot;);\n    //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行\n    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><p>打印顺序一定为1, 2, 3. 2新开队列, 不会造成死锁. <code>case2</code>和新开的block任务之间没有队列的约束, 但是由于是同步任务,阻塞线程, 所以block先执行, 执行完毕后再回到<code>case2</code>, 接着执行.</p>\n<p><img src=\"http://img.souche.com/f2e/27086c860f921209238d3f60c2f8722c.png\" alt=\"案例2\"></p>\n<h3 id=\"案例三\"><a href=\"#案例三\" class=\"headerlink\" title=\"案例三\"></a>案例三</h3><pre><code>- (void)case3 {\n    dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);\n    NSLog(@&quot;1&quot;); // 任务1\n    dispatch_async(queue, ^{\n        NSLog(@&quot;2&quot;); // 任务2\n        dispatch_sync(queue, ^{\n            NSLog(@&quot;3&quot;); // 任务3\n        });\n        NSLog(@&quot;4&quot;); // 任务4\n    });\n    NSLog(@&quot;5&quot;); // 任务5\n}\n</code></pre><p>控制台输出1, 5, 2. (5, 2的顺序不一定). 可以肯定, 使用的是自定义串行队列. 首先执行任务1, 接下来有一个异步任务, 新开辟线程(将任务2, 同步线程, 任务4加入新线程). 因为是异步线程, 主线程中的任务5不用等待, 所以 2 和 5 的输出顺序不定. 任务2执行完后, 遇到同步任务, 因为是在串行队列, 所以会阻塞当前线程, 任务3执行完后才能执行任务4. 但是任务4比任务3早加入队列, 根据FIFO原则, 任务3要等待任务4执行完后才能执行. 任务3和任务4相互等待造成死锁. </p>\n<p><img src=\"http://img.souche.com/f2e/9c13eaeac28f7fe7105af2feb878d5ef.png\" alt=\"案例三图片\"></p>\n<h3 id=\"案例四\"><a href=\"#案例四\" class=\"headerlink\" title=\"案例四\"></a>案例四</h3><pre><code>- (void)case4 {\n    NSLog(@&quot;1&quot;); // 任务1\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        NSLog(@&quot;2&quot;); // 任务2\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@&quot;3&quot;); // 任务3\n        });\n        NSLog(@&quot;4&quot;); // 任务4\n    });\n    NSLog(@&quot;5&quot;); // 任务5\n}\n</code></pre><p>打印结果是: 1, 5, 2, 3, 4.(2, 5的顺序不定). 首先在主线程中有三个任务, 分别是任务1, 并行队列的异步任务, 任务5. 并行队列的异步任务中又有三个任务, 分别是任务2, 异步任务, 任务4.  </p>\n<p>所以先打印1, 然后把异步任务加入全部并行队列, 由于是异步任务新开辟线程, 不阻塞主线程, 5不用等待. 所以2, 5顺序不定. 然后再分析并行队列中的异步任务, 任务2执行后遇到同步任务, 同步任务被加入到主线程(因为前面已经被加过3个任务, 所以该任务在任务5后面). 因为是同步, 阻塞主线程, 所以4一定在3后面. </p>\n<p><img src=\"http://img.souche.com/f2e/43a48f9de1c0bb336215543157ad875b.png\" alt=\"案例四\"></p>\n<h3 id=\"案例五\"><a href=\"#案例五\" class=\"headerlink\" title=\"案例五\"></a>案例五</h3><pre><code>- (void)case5 {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        NSLog(@&quot;1&quot;); // 任务1\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@&quot;2&quot;); // 任务2\n        });\n        NSLog(@&quot;3&quot;); // 任务3\n    });\n    NSLog(@&quot;4&quot;); // 任务4\n    while (1) {\n    }\n    NSLog(@&quot;5&quot;); // 任务5\n}\n</code></pre><p>打印结果是: 1, 4(顺序不定). 首先主线程中有四个任务, 分别是全局并行队列的异步任务, 任务4, 死循环, 任务5. 全局并行队列的异步任务中又有三个任务, 分别是任务1, 主线程的同步任务(任务2), 任务3. </p>\n<p>由于是异步任务, 不阻塞主线程, 所以全局并行队列的异步任务执行顺序和任务4不定, 全局并行队列的异步任务又是先执行任务1, 所以任务1和任务4的顺序不定. 当任务4执行完后, 进入死循环, 主线程被阻塞. 由于同步任务(任务2)是被加在主线程中, 但是此时主线程已被阻塞, 所以2不会被执行. 任务3又是在任务2后被加入队列, 任务2是同步任务, 所以任务3要等待任务2完成才执行. 所以任务2, 任务3都不会执行. 任务5在死循环后执行, 所以任务5永远不会被执行. 如果没有死循环, 任务2肯定在任务后后面, 任务3肯定在任务2后面. </p>\n<p><img src=\"http://img.souche.com/f2e/0d108cba7a737b62e2f5e1be402bc5d0.png\" alt=\"案例五\"></p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.cocoachina.com/ios/20150731/12819.html\" target=\"_blank\" rel=\"noopener\">关于iOS多线程, 你看我就够了</a></p>\n<p>2.<a href=\"https://bestswifter.com/multithreadconclusion/\" target=\"_blank\" rel=\"noopener\">iOS多线程编程总结</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/51fd1362249e\" target=\"_blank\" rel=\"noopener\">关于iOS多线程, 我说, 你听, 没准你就懂了</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/06a18323d9d2\" target=\"_blank\" rel=\"noopener\">深入理解 GCD</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/6a6722f12fe3\" target=\"_blank\" rel=\"noopener\">关于 iOS 多线程, 都在这里了</a></p>\n<p>6.<a href=\"http://blog.csdn.net/mxsgoden/article/details/8821936\" target=\"_blank\" rel=\"noopener\">进程与线程的区别</a></p>\n<p>7.<a href=\"https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/\" target=\"_blank\" rel=\"noopener\">并发和并行</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"JavaScript第二弹","url":"http://hchong.net/2017/08/22/JavaScript第二弹/","content":"<h1 id=\"JavaScript第二弹\"><a href=\"#JavaScript第二弹\" class=\"headerlink\" title=\"JavaScript第二弹\"></a>JavaScript第二弹</h1><p>第一弹主要是一些基本语法, 数据类型和变量. 这一弹来说一下字符串, 数组和对象. </p>\n<blockquote>\n<p>在 <code>JavaScript</code>中，对象的定义是拥有属性和方法的数据.<br>严格来讲, <code>JavaScript</code>中的所有事物都是对象：字符串, 数字, 数组, 日期，等等.</p>\n</blockquote>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>和OC的没什么太大的区别, 这里只说几点比较特殊的.</p>\n<ul>\n<li>可以使用反引号` <code>...</code> `来标记一串带符号的文本, 例如</li>\n</ul>\n<pre><code>alert(`你好, \n哈哈`);\n</code></pre><p>中间的所有符号都会被保留下来, </p>\n<ul>\n<li>还可以在在` <code>你好 + ${string}</code> `来拼接字符串, 其中<code>${String}</code>代表一个叫做<code>String</code>的变量</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>区别于OC的数组, <code>JavaScript</code>的<code>Array</code>可以包含任意的数据类型, 通过索引来访问每个元素.</p>\n<p>Array属性:</p>\n<blockquote>\n<p>constructor 返回对创建此对象的数组函数的引用.<br>length 设置或返回数组中元素的数目.<br>prototype 使您有能力向对象添加属性和方法.</p>\n</blockquote>\n<p>Array 对象方法:</p>\n<blockquote>\n<p>indexOf() 搜索一个指定的元素的位置.<br>concat() 连接两个或更多的数组，并返回结果.<br>join() 把数组的所有元素放入一个字符串.元素通过指定的分隔符进行分隔.<br>pop() 删除并返回数组的最后一个元素<br>push() 向数组的末尾添加一个或更多元素，并返回新的长度.<br>shift() 删除并返回数组的第一个元素.<br>unshift() 向数组的开头添加一个或更多元素，并返回新的长度.<br>reverse() 颠倒数组中元素的顺序.<br>slice() 从某个已有的数组返回选定的元素.<br>sort() 对数组的元素进行排序.<br>splice(loc, len, newElement, …) 删除元素，并向数组添加新元素.<br>toSource() 返回该对象的源代码.<br>toString() 把数组转换为字符串，并返回结果.<br>toLocaleString() 把数组转换为本地数组，并返回结果.<br>valueOf() 返回数组对象的原始值.</p>\n</blockquote>\n<p>在这里需要注意, 直接使用<code>arr.length</code>是会改变原<code>arr</code>的长度的, 没有被赋值的元素就会变为<code>undefined</code>, 直接通过索引赋值, 也会出现这个问题. 例如:</p>\n<pre><code>var arr1 = [1, 2, 3];\narr1.length; // 3\narr1.length = 6;\narr1; // arr1变为[1, 2, 3, undefined, undefined, undefined]\narr1.length = 2;\narr1; // arr1变为[1, 2]\n\nvar arr2 = [1, 2, 3];\narr2[5] = &#39;x&#39;;\narr2; // arr2变为[1, 2, 3, undefined, undefined, &#39;x&#39;]\n</code></pre><p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界.</p>\n","categories":["JavaScript"],"tags":["基础知识","JavaScript"]},{"title":"JavaScript第一弹","url":"http://hchong.net/2017/08/18/JavaScript第一弹/","content":"<h1 id=\"JavaScript第一弹\"><a href=\"#JavaScript第一弹\" class=\"headerlink\" title=\"JavaScript第一弹\"></a>JavaScript第一弹</h1><p>主要是一些JavaScript的一些基础知识, 和OC的一些区别</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>JavaScript可以嵌在网页的任意地方, 不过通常有两种写法:</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;script&gt;\n        JavaScript代码\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>或者把JavaScript代码放到一个单独的<code>.js</code>文件中, 然后在HTML中引用</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;script src=&quot;.js文件的路径&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  ...\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>把JavaScript代码放入一个单独的<code>.js</code>文件中更利于维护代码，并且多个页面可以各自引用同一份<code>.js</code>文件。</p>\n<p>可以在同一个页面中引入多个<code>.js</code>文件，还可以在页面中多次编写<code>&lt;script&gt; js代码... &lt;/script&gt;</code>，浏览器按照顺序依次执行。</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型, 这一点和OC是有区别的.</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串是以<code>单引号&#39;</code>或<code>双引号&quot;</code>括起来的任意文本, 这和OC的略有不同. 和OC的字符串初始化不同的是, JS只需用引号括起来就代表一个字符串了.</p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>JavaScript允许对任意数据类型做比较. 要特别注意相等运算符<code>==</code>。JavaScript在设计时，有两种比较运算符：</p>\n<ul>\n<li>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</li>\n<li>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</li>\n</ul>\n<p>由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用<code>===</code>比较。</p>\n<p>这个和<code>OC</code>类似, 如果使用<code>===</code>比较的是两个基本数据类型, 只要值相等就位<code>true</code>. 但是如果是数组, 字典, 对象等其他类型, 那比较的就是内存地址, 而不是元素.</p>\n<pre><code>var arr1 = [1,2,3];\nvar arr2 = [1,2,3];\nalert(arr1 === arr2)//false\n\nvar str1 = &#39;123&#39;;\nvar str2 = &#39;123&#39;;\nalert(str1 === str2);//true\n</code></pre><p>关于数组元素的比较, 如果是OC的话, 可以使用<code>-(BOOL)isEquleToArray:(NSArray *)array;</code>来比较数组中的元素, 然而JS没有这种方法, 常见的做法是先排序, 再转成String, 再比较String是否相等. 参考<a href=\"https://gist.github.com/smallnewer/6535788\" target=\"_blank\" rel=\"noopener\">equalArray.js</a></p>\n<p><code>NaN</code>这个值通过<code>===</code>来比较大小永远为<code>false</code>, 包括与自身比较. 唯一的判断方法就是通过<code>isNaN()</code>函数.</p>\n<h3 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h3><p><code>null</code>表示一个“空”的值类似于OC的<code>nil</code>，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”.</p>\n<p>还有一个和null类似的undefined，它表示“未定义”. JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义.</p>\n<ul>\n<li>大多数情况下，我们都应该用null.</li>\n<li>undefined仅仅在判断函数参数是否传递的情况下有用, 未使用值来声明的变量，其值实际上是 undefined.</li>\n</ul>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量和OC的变量是一样的, 但是命名规则有所不同. 变量名是大小写, 数字, <code>$</code>, 和<code>_</code>组合, 且不能用数字开头. </p>\n<p>和OC一样, 使用<code>=</code>对变量进行赋值, 由于JS是一门动态语言, 在初始化变量时可以不指定变量类型, 这与OC略有不同.</p>\n<p>仅仅声明但是没有赋值的变量, 其值实际上是<code>undefined</code>.</p>\n<pre><code>var carname;\nconsole.log(carname);\n</code></pre><hr>\n<p>1.<a href=\"http://www.bootcss.com/p/underscore/\" target=\"_blank\" rel=\"noopener\">Underscore - 一个JavaScript 工具库</a>.<br>2.<a href=\"https://halfrost.com/lost_in_javascript/\" target=\"_blank\" rel=\"noopener\">JavaScript 新手的踩坑日记</a>.</p>\n","categories":["JavaScript"],"tags":["基础知识","JavaScript"]},{"title":"UIView系列之---iOS的动态高度","url":"http://hchong.net/2017/07/24/UIView系列之---iOS的动态高度/","content":"<h1 id=\"UIView系列之—iOS的动态高度\"><a href=\"#UIView系列之—iOS的动态高度\" class=\"headerlink\" title=\"UIView系列之—iOS的动态高度\"></a>UIView系列之—iOS的动态高度</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<p>不论是UITableViewCell的高度也好, 或者是一个输入框也好, 都会用到动态布局. 实际上就是对一些显示文本内容的控件进行高度计算, 然后根据子视图的约束, 布局来得到父视图的高度并且改变他. </p>\n<h2 id=\"iOS布局机制大概分这么几种常见的方式\"><a href=\"#iOS布局机制大概分这么几种常见的方式\" class=\"headerlink\" title=\"iOS布局机制大概分这么几种常见的方式:\"></a>iOS布局机制大概分这么几种常见的方式:</h2><ul>\n<li><p>frame layout. frame layout最简单直接, 即通过设置view的frame属性值进而控制view的位置(相对于superview的位置)和大小. </p>\n</li>\n<li><p>autoresizing. autoresizing和frame layout一样, 从一开始存在, 它算是对frame layout的的补充,, 基于autoresizing机制, 能够让subview和superview维持一定的布局关系, 譬如让subview的大小适应superview的大小,, 随着后者的改变而改变. </p>\n<p>  站在代码接口的角度来看, autoresizing主要体现在几个属性上, 包括(但不限于):</p>\n<ul>\n<li><p><code>translatesAutoresizingMaskIntoConstraints</code>. 标识view是否愿意被autoresize;</p>\n</li>\n<li><p><code>autoresizingMask</code>. 是一个枚举值, 决定了当superview的size改变时, subview应该做出什么样的调整;</p>\n<p>autoresizing存在的不足是非常显著的, 通过autoresizingMask的可选枚举值可以看出: 基于autoresizing机制, 我们只能让view在superview的大小改变时做些调整; 而无法处理兄弟view之间的关系, 譬如处理与兄弟view的间隔; 更无法反向处理, 譬如让superview依据subview的大小进行调整. </p>\n</li>\n</ul>\n</li>\n<li><p>Auto layout. Auto Layout是随着iOS 6推出来的, 它是一种基于约束的布局系统, 可以根据你在元素(对象)上设置的约束自动调整元素(对象)的位置和大小对于某个view的布局方式. </p>\n<blockquote>\n<p>Auto Layout is a system that lets you lay out your app’s user interface by creating a mathematical description of the relationships between the elements. You define these relationships in terms of constraints either on individual elements, or between sets of elements. Using Auto Layout, you can create a dynamic and versatile interface that responds appropriately to changes in screen size, device orientation, and localization.</p>\n</blockquote>\n</li>\n</ul>\n<p>autoresizing和auto layout只能二选一, 简单来说, 若要对某个view采用auto layout布局, 则需要设置其<code>translatesAutoresizingMaskIntoConstraints</code>属性值为NO.</p>\n<h2 id=\"常见Auto-Layout场景下的运用\"><a href=\"#常见Auto-Layout场景下的运用\" class=\"headerlink\" title=\"常见Auto Layout场景下的运用\"></a>常见Auto Layout场景下的运用</h2><p>下面主要就几种常见场景下, Auto Layout的运用来说明一下用法. 在这里先说明一个概念 <em>Leaf-level views</em>, Leaf-level views指的是不包含任何subview的view, 譬如UILabel, UIButton等. 但是有些view不包含content, 譬如UIView, 这种view被认为「has no intrinsic size」, 它们的intrinsicContentSize返回的值是(-1, -1). </p>\n<h3 id=\"Leaf-level-views高度计算\"><a href=\"#Leaf-level-views高度计算\" class=\"headerlink\" title=\"Leaf-level views高度计算\"></a>Leaf-level views高度计算</h3><p>这类的view往往能够直接计算出content(譬如UILabel的text, UIButton的title, UIImageView的image)的大小. 以UILabel为例:</p>\n<p>假设我们已经设置了UILabel的x, y值约束, 没有设置与size有关的约束. 如果我们要根据UILabel的文本内容来计算最合适的size, 我们可以自定义一个Custom Label, 继承于UILabel, 在Custom Label中重写<code>- (CGSize)intrinsicContentSize</code>方法. 返回我们希望返回的size. 在需要使用UILabel的地方我们就可以通过使用Custom Label来实现搞得的正确计算. </p>\n<p>关于<code>intrinsicContentSize</code>方法的理解是, Auto Layout System在layout时, 不知道该为view分配多大的size, 因此回调view的<code>intrinsicContentSize</code>方法, 该方法会给auto layout system一个合适的size, system根据此size对view的大小进行设置; </p>\n<pre><code>@interface CustomLabel : UILabel\n\n@end\n\n@implementation CustomLabel\n\n- (CGSize)intrinsicContentSize {\n    CGSize size = [super intrinsicContentSize];\n    size.width  += 20;\n    size.height += 20;\n    return size;\n}\n\n@end\n</code></pre><p>以上如果是单行label的话, 实现起来没问题. 但是如果label一行显示不下需要换行的话, 那事情就没这么简单了. 但是怎么计算多行label的高度呢? 有以下几种方法: </p>\n<p>下面几种方法都需要我们首先设置<code>preferredMaxLayoutWidth</code>, 也就是UILabel的Width最大值, label会根据这个最大值来换行. 再设置<code>numberOfLines = 0</code>, 来实现换行. ==注意:== <code>preferredMaxLayoutWidth</code>适用于没有指定UILabel的Width的情况, 如果设置了Width的约束, 又设置了<code>preferredMaxLayoutWidth</code>. 那么计算size会以<code>preferredMaxLayoutWidth</code>为准, 显示则以Width的约束为准.</p>\n<ol>\n<li><p><code>boundingRectWithSize:options:attributes:context:</code></p>\n<p> <code>boundingRectWithSize:options:attributes:context:</code>是NSString的方法. 理解起来也非常简单, 根据一些绘制字符的选项和字符属性(字体, 字号, 字体颜色)等信息返回一个可以容纳字符串内容的CGRect. 它同样也需要一个CGSize来确定绘制区域.<br> size: 通常你可以传一个任意的Size, 它会返回一个它认为最合适的CGSize给你. 不过如果要想把视图的内容显示完全(纵向), 最好是将视图的实际宽度和最大高度<code>CGFLOAT_MAX</code>作为参数传递. 这样返回的才是完全显示内容的Size.<br> options: 默认情况下这个方法不会绘制多行, 如果要绘制多行字符, 那么options参数必须为: <code>NSStringDrawingUsesLineFragmentOrigin</code>.<br> attributes: 字符属性信息也非常重要. 如果要显示UILabel的全部内容, 必须传递这个参数. 以确保绘制的字体大小和UILabel的字体大小一致, </p>\n<p> 最后一个关键点是，这个方法返回的CGRect中Size的width和height都是小数，所以必须使用ceil函数才能确保结果的准确性。</p>\n</li>\n<li><p><span id=\"sizeThatFits\">sizeThatFits:</span></p>\n<blockquote>\n<p>Asks the view to calculate and return the size that best fits the specified size.</p>\n<p>Return Value<br>A new size that fits the receiver’s subviews.</p>\n<p>Discussion<br>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.</p>\n</blockquote>\n<p> sizeThatFits: 方法意味着「根据文本计算最适合的size」, 但是并不改变调用者的size. 它需要传入一个CGSize参数这个参数和<code>boundingRectWithSize:options:attributes:context:</code>中size的作用和意义是一样的. </p>\n</li>\n<li><p><span id=\"sizeToFit\">sizeToFit:</span></p>\n<blockquote>\n<p>calls sizeThatFits: with current view bounds and changes bounds size. </p>\n</blockquote>\n<p> <code>sizeToFit</code>内部会调用<code>sizeThatFits:</code>方法, 然后改变调用者的size. sizeToFit的伪代码大致如下：</p>\n<pre><code>// calls sizeThatFits\nCGSize size = [self sizeThatFits:self.bounds.size];\n// change bounds size\nCGRect bounds = self.bounds;\nbounds.size.width = size.width;\nbounds.size.height = size.width;\nself.bounds = bounds;\n</code></pre></li>\n<li><p><span id=\"systemLayoutSizeFittingSize\">systemLayoutSizeFittingSize</span> </p>\n<p> <code>systemLayoutSizeFittingSize</code>, 它也是UIView的方法, 是AutoLayout诞生后的产物. 所以使用它的前提是需要展示内容的控件(这里指的就是UILabel)必须约束完美. 不然就不会起作用。而且必须要设置UILabel的<code>preferredMaxLayoutWidth</code>属性.<br> 这个属性非常重要, 它影响着layout. 如果设置了<code>preferredMaxLayoutWidth</code>, 当内容超过约束区域, 就会自动换行并且更新约束. 在良好约束的前提下, <code>systemLayoutSizeFittingSize</code>同样接受一个CGSize, 不同的是这次不用计算了, 直接使用系统提供的Fitting Size即可:</p>\n<pre><code>const CGSize UILayoutFittingCompressedSize; //在保证适当尺寸的前提下尽量压缩CGSize的大小\nconst CGSize UILayoutFittingExpandedSize; //在保证适当尺寸的前提下尽量扩充CGSize的大小\n</code></pre><p> 所以为了刚好将UILabel的内容显示完全，应该使用UILayoutFittingCompressedSize。代码如下：</p>\n<p> ```</p>\n</li>\n</ol>\n<ul>\n<li><p>(void)layoutSubviews {<br>  [super layoutSubviews];<br>  self.label.preferredMaxLayoutWidth = CGRectGetWidth(self.label.bounds);<br>  CGSize size = [self.label systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];<br>  self.labelConstraintHeight.constant = size.height + (2 * MARGIN);<br>}<br>  ```</p>\n<p>  需要注意的是: 约束的上下左右一定要写好, 但是不能约束UILabel的高度. 否则可能会导致返回的CGRect不准确. <code>numberOfLines = 0</code> 让Label可以显示多行内容. 设置<code>preferredMaxLayoutWidth</code>属性, 使UILabel能自适应多行内容. <code>UILayoutFittingCompressedSize</code> 使用这个参数会返回符合条件最合适的Size. 最后也要加上边距, 主要是因为这里我们在内部计算UILabel的Size, 而如果在外部对View调用<code>systemLayoutSizeFittingSize</code>方法, 就会得到整个View视图的Size. </p>\n</li>\n</ul>\n<p><code>sizeThatFits:</code>和<code>boundingRectWithSize:options:attributes:context:</code>这两个API也可以在传统布局(基于Frame)的情况下使用. </p>\n<h3 id=\"非Leaf-level-views高度计算\"><a href=\"#非Leaf-level-views高度计算\" class=\"headerlink\" title=\"非Leaf-level views高度计算\"></a>非Leaf-level views高度计算</h3><p>以UITextView显示文本为例, 让其能够自适应文本, 即根据文本自动调整其大小; 由于<code>intrinsicContentSize</code>的特性, 当其内部含有subView时返回值是(-1, -1), 无法向auto layout system传递我们想要传达的值, 我们可以使用<a href=\"#sizeThatFits\">sizeThatFits</a>或者<a href=\"#sizeToFit\">sizeToFit</a>来计算或者改变UITextView的大小. </p>\n<p>==这里需要注意的是:== 当调用<code>sizeThatFits:</code>的size=(width, height)，当width/height的值为0时，width/height就被认为是无穷大, size就不能被正常的显示. 所以区别于UILabel, 我们的约束一定要设置好Width和height, 否则使用<code>sizeToFit</code>也不能正确计算出. </p>\n<h3 id=\"Leaf-level-views和非Leaf-level-views混合使用下高度计算\"><a href=\"#Leaf-level-views和非Leaf-level-views混合使用下高度计算\" class=\"headerlink\" title=\"Leaf-level views和非Leaf-level views混合使用下高度计算\"></a>Leaf-level views和非Leaf-level views混合使用下高度计算</h3><p>这里我们需要计算的是根据subView来确定superView的frame, 大致分为一下几种情况: </p>\n<ol>\n<li><p>多个纯Leaf-level views的组合使用</p>\n<p> 这个计算起来比较简单, 我们以一个UIView里面添加两个UILabel为例. 我们只需要从上到下, 把subViews的子约束撑满superView. 需要注意, 如果UILabel需要换行, 那么高度约束就不能写, 并且要设置<code>numberOfLines = 0</code>. 虽然我们什么也没做, 但是子控件会通过<code>intrinsicContentSize</code>方法将最合适的size告诉superView. 但是对于superView, 因为它本身是UIVIew, 他的<code>intrinsicContentSize</code>返回是(-1, -1), 那么它是怎么得出正确的结果呢. auto layout system在处理某个view的size时，<span id=\"size\">参考值</span>包括:</p>\n<ul>\n<li>自身的<code>intrinsicContentSize</code>方法返回值;</li>\n<li>subviews的<code>intrinsicContentSize</code>方法返回值;</li>\n<li><p>自身和subviews的constraints;</p>\n<p>系统会将superView的size和subViews的约束以及<code>intrinsicContentSize</code>返回的正确size相加, 然后比较两个值的大小, 然后取最大的一个.<br><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fjvnn0tr2lj30ok0ru0st.jpg\" alt=\"约束\"></p>\n<p>size1, size2, size3, 分别是label1, label2, superView的<code>intrinsicContentSize</code>方法返回的size.<br>width = max{91 + size1.width + 91 + size2.width, size3.width}<br>height = max{60 + size1.height + 36 + size2.height + 58, size3.height}</p>\n</li>\n</ul>\n</li>\n<li><p>多个纯非Leaf-level views的组合使用</p>\n<p> 仍旧以UITextView为例, 如果没有设定UItextView的height属性的话, 由于非Leaf-level views的<code>intrinsicContentSize</code>返回值值为(-1, -1). 设置某个View的size有三个<a href=\"#size\">参考值</a>, 在<code>intrinsicContentSize</code>方法返回值和constraints中取最大值为0, 导致height=0不能正常显示. 解决方案参考<a href=\"#next\">下一个</a>;</p>\n</li>\n<li><p><span id=\"next\">Leaf-level views和非Leaf-level views混合使用</span></p>\n<p> 因为有UItextView这种非Leaf-level views的存在, 会导致superView的size不能得到正常值. 解决方案有两种:</p>\n<ol>\n<li><p>设置非Leaf-level views的height, width约束, 因为<code>intrinsicContentSize</code>方法不能正常的返回size, 但是如果我们设置了width和height约束, constraints就不为0, 那么就可以正常显示了. </p>\n</li>\n<li><p>使用<code>systemLayoutSizeFittingSize:</code>, 具体使用方式可以参考<a href=\"#systemLayoutSizeFittingSize\">systemLayoutSizeFittingSize:</a>.</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Cell的动态高度计算\"><a href=\"#Cell的动态高度计算\" class=\"headerlink\" title=\"Cell的动态高度计算\"></a>Cell的动态高度计算</h3><p>对于使用auto layout机制布局的view, auto layout system会在布局过程中综合各种约束的考虑为之设置一个size, 在布局完成后, 该size的值即为view.frame.size的值; 这包含的另外一层意思, 即在布局完成前, 我们是不能通过view.frame.size准确获取view的size的. 但有时候, 我们需要在auto layout system对view完成布局前就知道它的size, <code>systemLayoutSizeFittingSize:</code>方法正是能够满足这种要求的API. <code>systemLayoutSizeFittingSize:</code>方法会根据其constraints返回一个合适的size值. </p>\n<p>在这里看一下比较知名的cell高度计算库<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\" target=\"_blank\" rel=\"noopener\">UITableView-FDTemplateLayoutCell</a>的核心高度计算方法, 大体上和我们所使用的方法差不多. Auto layout mode using <code>-systemLayoutSizeFittingSize:</code>, Frame layout mode using <code>-sizeThatFits:</code>. </p>\n<pre><code>- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell {\n    CGFloat contentViewWidth = CGRectGetWidth(self.frame);\n\n    // If a cell has accessory view or system accessory type, its content view&#39;s width is smaller\n    // than cell&#39;s by some fixed values.\n    if (cell.accessoryView) {\n        contentViewWidth -= 16 + CGRectGetWidth(cell.accessoryView.frame);\n    } else {\n        static const CGFloat systemAccessoryWidths[] = {\n            [UITableViewCellAccessoryNone] = 0,\n            [UITableViewCellAccessoryDisclosureIndicator] = 34,\n            [UITableViewCellAccessoryDetailDisclosureButton] = 68,\n            [UITableViewCellAccessoryCheckmark] = 40,\n            [UITableViewCellAccessoryDetailButton] = 48\n        };\n        contentViewWidth -= systemAccessoryWidths[cell.accessoryType];\n    }\n\n    // If not using auto layout, you have to override &quot;-sizeThatFits:&quot; to provide a fitting size by yourself.\n    // This is the same height calculation passes used in iOS8 self-sizing cell&#39;s implementation.\n    //\n    // 1. Try &quot;- systemLayoutSizeFittingSize:&quot; first. (skip this step if &#39;fd_enforceFrameLayout&#39; set to YES.)\n    // 2. Warning once if step 1 still returns 0 when using AutoLayout\n    // 3. Try &quot;- sizeThatFits:&quot; if step 1 returns 0\n    // 4. Use a valid height or default row height (44) if not exist one\n\n    CGFloat fittingHeight = 0;\n\n    if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) {\n        // Add a hard width constraint to make dynamic content views (like labels) expand vertically instead\n        // of growing horizontally, in a flow-layout manner.\n        NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth];\n        [cell.contentView addConstraint:widthFenceConstraint];\n\n        // Auto layout engine does its math\n        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;\n        [cell.contentView removeConstraint:widthFenceConstraint];\n\n        [self fd_debugLog:[NSString stringWithFormat:@&quot;calculate using system fitting size (AutoLayout) - %@&quot;, @(fittingHeight)]];\n    }\n\n    if (fittingHeight == 0) {\n#if DEBUG\n        // Warn if using AutoLayout but get zero height.\n        if (cell.contentView.constraints.count &gt; 0) {\n            if (!objc_getAssociatedObject(self, _cmd)) {\n                NSLog(@&quot;[FDTemplateLayoutCell] Warning once only: Cannot get a proper cell height (now 0) from &#39;- systemFittingSize:&#39;(AutoLayout). You should check how constraints are built in cell, making it into &#39;self-sizing&#39; cell.&quot;);\n                objc_setAssociatedObject(self, _cmd, @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n            }\n        }\n#endif\n        // Try &#39;- sizeThatFits:&#39; for frame layout.\n        // Note: fitting height should not include separator view.\n        fittingHeight = [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height;\n\n        [self fd_debugLog:[NSString stringWithFormat:@&quot;calculate using sizeThatFits - %@&quot;, @(fittingHeight)]];\n    }\n\n    // Still zero height after all above.\n    if (fittingHeight == 0) {\n        // Use default row height.\n        fittingHeight = 44;\n    }\n\n    // Add 1px extra space for separator line if needed, simulating default UITableViewCell.\n    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) {\n        fittingHeight += 1.0 / [UIScreen mainScreen].scale;\n    }\n\n    return fittingHeight;\n}\n</code></pre><p><a href=\"http://www.cocoachina.com/industry/20140604/8668.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>也有一些常见cell布局的高度计算方法, 可以参考下.</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://zhangbuhuai.com/beginning-auto-layout-part-1/\" target=\"_blank\" rel=\"noopener\">深入理解Auto Layout</a>.</p>\n<p>2.<a href=\"http://www.cocoachina.com/industry/20140604/8668.html\" target=\"_blank\" rel=\"noopener\">动态计算UITableViewCell高度</a></p>\n<p>3.<a href=\"http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/\" target=\"_blank\" rel=\"noopener\">优化UITableViewCell高度计算的那些事</a></p>\n<p>4.<a href=\"http://sylenthwave.github.io/2016/01/02/iOS%E5%8A%A8%E6%80%81%E5%8F%98%E9%AB%98%E6%80%BB%E7%BB%93/\" target=\"_blank\" rel=\"noopener\">iOS动态变高总结</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---如何写一个自定义View","url":"http://hchong.net/2017/07/15/UIView系列之---如何写一个自定义View/","content":"<h1 id=\"UIView系列之—如何写一个自定义View\"><a href=\"#UIView系列之—如何写一个自定义View\" class=\"headerlink\" title=\"UIView系列之—如何写一个自定义View\"></a>UIView系列之—如何写一个自定义View</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<p>这一篇和前面的实际是一个系列, 但是有不太一样, 也稍微偏架构和规范一些. 说一下在实际编程中的写法. </p>\n<h2 id=\"通用的自定义类的function归纳\"><a href=\"#通用的自定义类的function归纳\" class=\"headerlink\" title=\"通用的自定义类的function归纳\"></a>通用的自定义类的function归纳</h2><p>一个自定义类中的代码首先是有序的, 不管是<code>UIVIewControl</code>, <code>UIVIew</code>, 或者<code>NSObject</code>, 都应该把具有相同作用的function归纳为一个类, 我一般按照下面这样来分割代码, 这样看上去会比较有条理: </p>\n<pre><code>#pragma mark - LifeCycle\n这里面是一些类的生命周期的方法, 以及overWrite的父类的方法\n#pragma mark - UIConfig\n这里面是和当前类的UI相关的设置信息\n#pragma mark - HttpRequest\n当前类的网络请求部分\n#pragma mark - XXXDelegate\n当前类响应的代理事件\n#pragma mark - Action\n当前类的EventResponse事件\n#pragma mark - Private\n当前类中所用到的一些工具function, 不过一般不建议写在这里面, 我们应该按照模块新建一个专门的工具类来管理这些function\n#pragma mark - Getter, Setter\n当前类中用到的所有属性的Getter和Setter, 强烈推荐这么些, 这样可以把当前类的子控件的初始化放到Getter中去, 维护了代码的整洁度.\n</code></pre><p>除此之外, 上面这个顺序一般是按照使用者对这个类中所有function的关心程度来排序的, 例如对Lifecycle和UIConfig的关心程度就比Getter和Setter的程度高. 如果这个类还是特别长的话, 那就建议把代码在拆分为各个独立功能的category, 或者把尽量多的Private方法拆分为独立的工具类, 这样不管是对当前类的代码量, 或者后面可能会使用到这些PrivateFunction的人来说都是比较合理的做法. </p>\n<h2 id=\"组合代替继承\"><a href=\"#组合代替继承\" class=\"headerlink\" title=\"组合代替继承\"></a>组合代替继承</h2><p>除此之外, 对于复杂类来说我们要尽量<em>使用组合来代替继承</em>. 例如当前有一个类实现了A功能, 业务发展我们要使用A+B功能, 我们可能会想到写一个A的子类A’, 在里面再加上B功能, 完美解决. 那么后面我们要再使用A+B+C功能, 那么我们可能会写一个A’的子类A’’, 在里面实现C的功能, 又完美实现. 那如果突然有一天, 产品经理突然说要实现A+C功能呢, 傻眼了, 一大坨代码怎么拆分. 所以正确的做法应该是, 我们新建三个类, 分别独立实现A, B, C的功能, 业务方要用哪个就自由组合, 假设后面再来了D, E, F我们也不怕, 我们只用像插件一样, 用到哪个组合哪个就好. </p>\n<h2 id=\"UIView的写法\"><a href=\"#UIView的写法\" class=\"headerlink\" title=\"UIView的写法\"></a>UIView的写法</h2><p>UIView作为直接展示给用户看的层面, 是最重要的部分. 我强烈推荐使用纯代码布局, 使用Frame或者Autolayout都可以. 使用Frame的话, 推荐使用<a href=\"https://github.com/casatwy/HandyAutoLayout\" target=\"_blank\" rel=\"noopener\">这个项目</a>. 如果使用AutoLayout的话, <code>masonry</code>则是很不错的选择. </p>\n<p>objc构建一个对象使用的是两段式, 首先分配内存<code>alloc</code>然后<code>init</code>, 这样的好处就是将内存操作和初始化操作解耦合, 让我们能够在初始化的时候对对象做一些必要的操作. 这是个很好的思路, 我们在做很多事情的时候都可以使用这种两段式的思路. 比如布局一个UIView, 我们可以分成两部, <a href=\"#alloc\">初始化必要的子view和变量</a>, <a href=\"#init\">然后在合适的时机进行布局</a>. 一般来说我们的自定义类继承自UIView, 首先在initWithFrame:方法中将需要的子控件加入view中. 注意, 这里只是加入到view中, 并没有设置各个子控件的尺寸.</p>\n<h3 id=\"初始化必要的子view和变量\"><a href=\"#初始化必要的子view和变量\" class=\"headerlink\" title=\"初始化必要的子view和变量\"></a><span id=\"alloc\">初始化必要的子view和变量</span></h3><p>所以第一步应该是: <code>- (id)initWithFrame:(CGRect)aRect</code>, 那我们为什么不适用<code>- (id)init</code>来完成初始化呢? 如果是这种情况, 那么在init方法中frame是不确定的, 此时如果在initWithFrame:方法中设置尺寸, 那么各个子控件的尺寸都会是0, 因为这个view的frame还没有设置.所以我们应该保证view的frame设置完才会设置它的子控件的尺寸. </p>\n<p>还有就是这个函数是无论你用什么初始化函数都会被调用的一个, 比如你用<code>[UIView new]</code>或者<code>[[UIView alloc] init]</code>都会调用initWithFrame这个函数(有些UIView的子类有特殊情况，比如UITableViewCell), 所以你要是对一个view的变量有初始化的操作尽量往initWithFrame里面放还是非常合适的.  并且这样也能够保证, 以后在使用的时候所有的变量都被正确的初始化过. 而我们一般会在initWithFrame中做些什么呢.</p>\n<ul>\n<li>添加子View</li>\n<li>初始化属性变量</li>\n<li>其他一些共用操作</li>\n</ul>\n<h3 id=\"在合适的时机进行布局\"><a href=\"#在合适的时机进行布局\" class=\"headerlink\" title=\"在合适的时机进行布局\"></a><span id=\"init\">在合适的时机进行布局</span></h3><p>初始化函数中有一个名称withFrame, 大家可能就会以为这个函数使用布局用的. 然而在代码逻辑比较清晰的工程中，几乎很少看到在这个函数中进行界面布局的工作, 因为UIKit给你提供了一个专门的函数<code>layoutSubViews</code>来干这个事情. 而且, 在这个函数中做的界面布局的工作, 是一次性编码, 界面布局没有任何复用性, 如果父View的大小变了之后, 这个View还是傻傻的保持原来的模样. 同时也会造成, 初始化函数臃肿, 导致维护上的困难. 所以在<code>layoutSubViews</code>中对子视图进行布局才是最合理的地方. </p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>一个控件有2种创建方式: </p>\n<ul>\n<li>通过代码创建</li>\n</ul>\n<p>初始化时一定会调用<code>initWithFrame:</code>方法. </p>\n<ul>\n<li>通过xib\\storyboard创建</li>\n</ul>\n<p>初始化时不会调用<code>initWithFrame:</code>方法, 只会调用<code>initWithCoder:</code>方法, 初始化完毕后会调用<code>awakeFromNib</code>方法注意要在在awakeFromNib中初始化子控件</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈</a></p>\n<p>2.<a href=\"https://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1124.html\" target=\"_blank\" rel=\"noopener\">视图类, 如何布局</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---UIView的常见layout方法","url":"http://hchong.net/2017/07/10/UIView系列之---UIView的常见layout方法/","content":"<h2 id=\"UIView系列之—UIView的常见layout方法\"><a href=\"#UIView系列之—UIView的常见layout方法\" class=\"headerlink\" title=\"UIView系列之—UIView的常见layout方法\"></a>UIView系列之—UIView的常见layout方法</h2><ul>\n<li><p><code>init</code> &amp; <code>initWithFrame</code></p>\n<p>  <code>init</code> 和 <code>initWithFrame</code>方法, 实际上都会调用<code>initWithFrame</code>方法来完成初始化, 不同的是在<code>init</code>方法内部获取到的<code>self.frame</code>是<code>CGRectZero</code>, 在<code>initWithFrame</code>中获取到的<code>self.frame</code>就是初始化时, 传入的<code>frame</code>的大小. 不过一般不建议在初始化方法中设置子控件的<code>frame</code>, 因为这时<code>self.frame</code>时机还不是固定的.</p>\n</li>\n<li><p>layoutSubviews</p>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Lays out subviews.<br>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>\n<p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p>\n<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>\n</blockquote>\n<p>翻译成人话大概就是: <code>layoutSubviews</code>方法用来布局子视图. 在<code>layoutSubviews</code>方法内部直接给需要改变布局的子视图赋值新frame来改变其<code>frame</code>. 该方法主要应用在封装的自定义<code>view</code>中, 我们通过重写这个方法完成自定义<code>view</code>中子视图的布局. 但是我们不能直接调用他来更新子视图的<code>frame</code>. 只能通过<a href=\"#layoutIfNeeded\">layoutIfNeeded</a>或者<a href=\"#setNeedsLayout\">setNeedsLayout</a>来调用, 或者等待系统触发. 系统触发<code>layoutSubviews</code>的<a href=\"#layoutSubviews\">条件</a>.</p>\n<ul>\n<li><span id=\"setNeedsLayout\">setNeedsLayout</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.</p>\n<p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.</p>\n</blockquote>\n<p>翻译成人话大概就是: 如果一个layer的sublayer布局发生了改变需要更新布局, 我们通过调用<code>setNeedsLayout</code>方法来标记这个layer. 或者当layer的bounds发生变化或者layer上进行了add或者remove sublayer操作, 系统会自动调用<code>setNeedsLayout</code>方法. 这些被标记需要更新布局的layer会在下一个视图绘制周期(iOS屏幕刷新频率为60HZ, 因此下一个视图绘制周期是1/60s后)触发layoutSubviews完成子视图布局更新.</p>\n<p>如果你想要更新一个视图的子视图布局, 那么可以在主线程中调用这个方法来标记当前视图为需要更新子视图布局的视图. 可以使用这个方法给多个不同的view标记需要更新子视图布局, 然后在下一个视图绘制周期中这些view的subviews就会被一块更新布局, 这样做是可以很大地提高性能和效率的. </p>\n<ul>\n<li><span id=\"layoutIfNeeded\">layoutIfNeeded</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Lays out the subviews immediately.<br>Use this method to force the layout of subviews before drawing. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root.</p>\n</blockquote>\n<p>翻译成人话大概就是: 在下一次绘图周期开始之前使用此方法强制进行子视图的布局更新. 此方法会将receiver作为根视图, 然后从根视图开始遍历根视图的subview链, 判断super layer是否被标记需要更新布局, 直到找到一个super layer没有标记更新布局为止, 然后系统会向所有这些被标记需要更新布局的layer发送<code>layoutSublayers</code>消息. <code>layoutSublayers</code>是<code>setNeedsLayout</code>的一个辅助方法, 调用该方法就意味着不会等到下个绘制周期, 而是立马触发<code>layoutSubviews</code>方法, 完成子视图的布局. </p>\n<p>但是需要注意只有当系统检测到某个view被<code>setNeedsLayout</code>标记之后才会立即触发<code>layoutSubviews</code>, 如果没有检测到<code>setNeedsLayout</code>标记就不会触发<code>layoutSubviews</code>, 所以如果想要立即刷新某个视图的子视图布局, 需要先让该视图调用<code>setNeedsLayout</code>方法标记一下, 然后再调用<code>layoutIfNeeded</code>. 另外所有的视图在第一次显示之前都是默认有<code>setNeedsLayout</code>标记的, 所以视图第一次显示的时候就可以直接调用<code>layoutIfNeeded</code>. 但是当第一次显示完成后, 如果还想要调用<code>layoutIfNeeded</code>就必须先使用<code>setNeedsLayout</code>标记一下. </p>\n<ul>\n<li>setNeedsDisplay</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Marks the receiver’s entire bounds rectangle as needing to be redrawn.<br>You can use this method or the <code>setNeedsDisplayInRect:</code> to notify the system that your view’s contents need to be redrawn. This method makes a note of the request and returns immediately. The view is not actually redrawn until the next drawing cycle, at which point all invalidated views are updated.</p>\n<p>其他说明:<br>You should only be calling setNeedsDisplay if you override drawRect in a subclass of UIView which is basically a custom view drawing something on the screen, like lines, images, or shapes like a rectangle.</p>\n</blockquote>\n<p>如果我们在自定义的UIView中, 重写了<code>drawRect:</code>方法在屏幕上绘制一些东西, 那就需要在合适的地方调用<code>setNeedsDisplay</code>来标记当前视图, 系统会在下一个绘制周期时触发<code>drawRect:</code>方法. <a href=\"#drawRect\">系统触发drawRect:的条件</a>.</p>\n<p>也可以使用<code>setNeedsDisplayInRect:</code>方法来标记视图的某个区域需要重新绘制.</p>\n<ul>\n<li>drawRect</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Draws the receiver’s image within the passed-in rectangle</p>\n<p>The default implementation of this method does nothing. Subclasses that use technologies such as Core Graphics and UIKit to draw their view’s content should override this method and implement their drawing code there. You do not need to override this method if your view sets its content in other ways. For example, you do not need to override this method if your view just displays a background color or if your view sets its content directly using the underlying layer object.</p>\n<p>This method is called when a view is first displayed or when an event occurs that invalidates a visible part of the view. You should never call this method directly yourself. To invalidate part of your view, and thus cause that portion to be redrawn, call the <code>setNeedsDisplay</code> or <code>setNeedsDisplayInRect:</code> method instead.</p>\n</blockquote>\n<p>drawRect使用:</p>\n<p>该方法默认没有做任何操作, 如果视图中包含我们用<code>UIKit</code>或者<code>Core Graphics</code>绘制的内容, 我们需要重写该方法. 当视图第一次出现, 或者是改变约束条件让视图的全部或者一部分在屏幕上发生变化时, 系统都会调用<code>UIView</code>类的<code>drawRect</code>方法. 然后我们在此方法中能过获取到当前图形上下文, 实现我们的绘制内容, 最后系统会在合适的时机自动调用此方法. </p>\n<p><code>drawRect</code>一般调用是在<code>UIView</code>的<code>layoutSubviews</code>方法执行后. 但是, 在我们的视图全部初始化后,如果视图又发生了改变, 此时视图就需要重绘, 但是系统不会再帮我们自动调用<code>drewRect</code>方法. 这个时候就需要我们手动调用<code>UIView</code>类的 <code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect</code>方法. 这两个方法是用来告诉系统, 我们的视图有了更新需要去重绘. 相当于是给系统做了标记, 在系统 runloop 的下一个周期自动调用<code>drawRect</code>方法.</p>\n<p>使用中要注意的地方:</p>\n<ol>\n<li><p>不要直接调用 drawRect 方法,如果强行调用此方法也是无效果的.苹果要求我们调用 UIView 类的 setNeedsDisplay 方法,则程序会自动调用 drawRect 方法进行重绘.</p>\n</li>\n<li><p>因为在绘制时要拿到图形上下文,如果在 UIView 初始化时没有设置 rect 大小, drawRect 方法不会被调用.</p>\n</li>\n<li><p>调用 sizeThatFits 后, 控件 frame 改变, UIView 的 layoutSubviews 被调用, 然后再调用 drawRect 方法. 所以可以先调用 sizeToFit 计算出size. 然后系统自动调用 drawRect 方法.</p>\n</li>\n<li><p>通过设置 contentMode 属性值为 UIViewContentModeRedraw.那么将在每次设置或更改 bounds 的时候自动调用 drawRect.</p>\n</li>\n<li><p>若要实时画图, 如果使用 gestureRecognizer 来刷新屏幕, 需要判断并转化 point 的坐标; 使用 touchbegan 等方法, 只需调用 setNeedsDisplay 实时刷新屏幕.</p>\n</li>\n</ol>\n<p>这里有一篇<a href=\"http://bihongbo.com/2016/01/03/memoryGhostdrawRect/\" target=\"_blank\" rel=\"noopener\">使用drawRect:实现绘制画板功能的内存优化</a>的文章.</p>\n<ul>\n<li>sizeToFit</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622630-sizetofit?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Resizes and moves the receiver view so it just encloses its subviews.</p>\n<p>Call this method when you want to resize the current view so that it uses the most appropriate amount of space. Specific UIKit views resize themselves according to their own internal needs. In some cases, if a view does not have a superview, it may size itself to the screen bounds. Thus, if you want a given view to size itself to its parent view, you should add it to the parent view before calling this method.<br>You should not override this method. If you want to change the default sizing information for your view, override the sizeThatFits: instead. That method performs any needed calculations and returns them to this method, which then makes the change.</p>\n</blockquote>\n<p>当我们想要resize当前View以便获取他合适的大小时, 我们需要调用该方法. 尤其是<code>UIKit</code>的<code>View</code>视图是根据内部需要进行尺寸调整时. 在某些情况下, 如果当前View没有父视图, 他会根据屏幕的bounds来resize自身大小. 如果你想让一个View根据父视图来调整大小, 必须将该View添加到父视图中.</p>\n<p>一般情况下, 我们不需要重写该方法, 如果你想改变当前View的default size, 我们通过重写<a href=\"#sizeThatFits\">sizeThatFits:</a>来实现. 在<code>sizeThatFits:</code>方法中进行必要的计算, 返回结果, 然后改变他的大小.</p>\n<ul>\n<li><span id=\"sizeThatFits\">sizeThatFits</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Asks the view to calculate and return the size that best fits the specified size.</p>\n<p>Parameters<br>size<br>The size for which the view should calculate its best-fitting size.</p>\n<p>Return Value<br>A new size that fits the receiver’s subviews.</p>\n<p>Discussion<br>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.<br>This method does not resize the receiver.</p>\n</blockquote>\n<p>该方法要求View计算并返回最适合指定大小的大小. 传入的参数就是View需要最合适的大小, 返回值是根据传入的大小, 计算得到的一个最适合receiver子视图的尺寸. </p>\n<p>该方法默认返回视图的现有大小, 子类能够通过重写该方法获得一个基于该子类所有子视图的期望布局的自定义大小. 调用<code>sizeThatFits:</code>并不改变view的size, 它只是让view根据已有content和给定size计算出最合适的view.size. </p>\n<h2 id=\"sizeToFit-vs-sizeThatFits\"><a href=\"#sizeToFit-vs-sizeThatFits\" class=\"headerlink\" title=\"sizeToFit vs sizeThatFits:\"></a>sizeToFit vs sizeThatFits:</h2><ol>\n<li>sizeToFit会自动调用sizeThatFits方法；</li>\n<li>sizeToFit不应该在子类中被重写, 应该重写sizeThatFits</li>\n<li>sizeThatFits传入的参数是receiver当前的size, 返回一个适合subviews的size</li>\n<li>sizeToFit可以被手动直接调用, </li>\n<li>sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己</li>\n<li>调用 sizeToFit() 会去自动调用 sizeThatFits(_ size: CGSize) 方法。</li>\n<li>sizeThatFits 不会改变 receiver 的 size, 调用 sizeToFit() 会改变 receiver 的 size. 此处的receiver一般是方法的调用者. </li>\n</ol>\n<h2 id=\"系统触发layoutSubviews的条件\"><a href=\"#系统触发layoutSubviews的条件\" class=\"headerlink\" title=\"系统触发layoutSubviews的条件\"></a><span id=\"layoutSubviews\">系统触发layoutSubviews的条件</span></h2><ol>\n<li>父视图使用<code>init</code>方法完成初始化时不会触发<code>layoutSubviews</code>. </li>\n<li>父视图用<code>initWithFrame</code>完成初始化并且当frame参数为<code>CGRectZero</code>时不会触发<code>layoutSubviews</code>. 当frame参数不为<code>CGRectZero</code>时则会触发<code>layoutSubviews</code>.</li>\n<li>父视图<code>setFrame</code>的时候会触发<code>layoutSubviews</code>, 当然frame前后值得发生变化.</li>\n<li>父视图<code>addSubview</code>添加子视图时会触发其内部的<code>layoutSubviews</code>.</li>\n<li>子视图从父视图上<code>removeFromSuperView</code>的时候会触发其内部的<code>layoutSubviews</code>. </li>\n<li>滚动ScrollView的时候会触发<code>layoutSubviews</code>. </li>\n<li>旋转屏幕的时候会触发<code>layoutSubviews</code>. </li>\n</ol>\n<h2 id=\"系统出发drawRect-的条件\"><a href=\"#系统出发drawRect-的条件\" class=\"headerlink\" title=\"系统出发drawRect:的条件\"></a><span id=\"drawRect\">系统出发drawRect:的条件</span></h2><ol>\n<li>如果在<code>UIView</code>初始化时没有设置rect大小, 将直接导致<code>drawRect</code>不被自动调用. <code>drawRect</code>调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的. 所以不用担心一进入到控制器中, 这些View的drawRect就开始画了. 这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).</li>\n<li>该方法在调用<code>sizeToFit</code>后被调用, 所以可以先调用<code>sizeToFit</code>计算出size, 然后系统自动调用drawRect:方法. </li>\n<li>通过设置<code>contentMode</code>属性值为<code>UIViewContentModeRedraw</code>. 那么将在每次设置或更改frame的时候自动调用<code>drawRect:</code>.</li>\n<li>直接调用<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>触发<code>drawRect:</code>. 但是有个前提条件是rect不能为<code>CGRectZero</code>.<br>以上1, 2推荐; 而3, 4不提倡. </li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/087529c83747\" target=\"_blank\" rel=\"noopener\">Core Animation 之 CALayer</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/3282c93c1a61\" target=\"_blank\" rel=\"noopener\">UIView几个layout方法的理解</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/b3bb9b08e3da\" target=\"_blank\" rel=\"noopener\">UIView布局深入理解</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/eb2c4bb4e3f1\" target=\"_blank\" rel=\"noopener\">UIViewLayout的几个方法</a></p>\n<p>5.<a href=\"http://zhangbuhuai.com/beginning-auto-layout-part-1/\" target=\"_blank\" rel=\"noopener\">深入理解Auto Layout 第一弹</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---UIView和CALayer","url":"http://hchong.net/2017/07/07/UIView系列之---UIView和CALayer/","content":"<h1 id=\"UIView系列之—UIView和CALayer\"><a href=\"#UIView系列之—UIView和CALayer\" class=\"headerlink\" title=\"UIView系列之—UIView和CALayer\"></a>UIView系列之—UIView和CALayer</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<h2 id=\"UIView和CALayer\"><a href=\"#UIView和CALayer\" class=\"headerlink\" title=\"UIView和CALayer\"></a>UIView和CALayer</h2><ol>\n<li><p><code>UIView</code>继承自<code>UIResponder</code>, 可以相应触摸事件. 而<code>CALayer</code>继承自<code>NSObject</code>, 不能响应触摸.</p>\n</li>\n<li><p><code>UIView</code>主要是对显示内容的管理, 而<code>CALayer</code>则主要侧重显示内容的绘制. 访问<code>UIVIew</code>的与绘图和跟坐标有关的属性, 例如<code>frame</code>, <code>bounds</code>等, 实际上内部都是在访问它所包含的CALayer的相关属性. <code>UIView</code>的<code>frame</code>实际是<code>layer</code>的<code>frame</code>, <code>center</code>, <code>bounds</code>实际也是只是内部<code>layer</code>相对应属性的<code>get</code>和<code>set</code>方法, 当你改变一个<code>view</code>的<code>frame</code>的时候, 你其实改变的是内部<code>layer</code>的<code>frame</code>. CALayer的frame由<code>anchorPoint</code>, <code>position</code>, <code>bounds</code>, <code>transform</code>共同决定. <code>UIView</code>的创建, 实际上是一系列<code>UILayer</code>创建的过程.</p>\n</li>\n<li><p><code>UIView</code>有个重要属性<code>layer</code>. 可以返回它的主<code>CALayer</code>实例. 所有从UIView继承来的对象都继承了这个属性. 这意味着你可以在所有的<code>UIVIew</code>子类上增加动画, 旋转, 缩放等<code>CALayer</code>支持的操作. <code>UIView</code>的<code>layerClass</code>方法, 可以返回主<code>layer</code>所使用的类, <code>UIView</code>的子类可以通过重载这个方法, 来让<code>UIView</code>使用不同的CALayer来显示. 代码示例：</p>\n<pre><code> - (class)layerClass {\n     return ([CAEAGLLayer class]);\n }\n</code></pre></li>\n<li><p><code>UIView</code>的主<code>CALayer</code>是类似于<code>subviews</code>的树形结构, 我们可以通过给主<code>layer</code>添加子<code>layer</code>来完成特殊的绘制效果.</p>\n<p> 在<code>view</code>上添加一个黑色透明<code>layer</code>层的示例代码:</p>\n<pre><code> grayCover = [[CALayer alloc] init];\n grayCover.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];\n [self.layer addSubLayer:grayCover];\n</code></pre></li>\n<li><p><code>UIView</code>的内部, 有三个<code>layer tree</code>: 1.逻辑树, 这里是代码可以操纵的. 2.动画树, 是一个中间层, 系统就在这一层上通过逻辑树来更改属性, 进行各种渲染操作. 3.显示树, 其内容就是当前正被显示在屏幕上得内容. </p>\n</li>\n<li><p><code>UIView</code>实际上是<code>CALayer</code>的<code>CALayerDelegate</code>, 通过实现一系列的代理方法来显示<code>CALayer</code>绘制的内容.</p>\n</li>\n<li><p>在做 iOS 动画的时候, 修改非<code>RootLayer</code>的属性(譬如位置, 背景色等)会默认产生隐式动画, 而修改<code>UIView</code>则不会.</p>\n</li>\n<li><p><code>layer</code>可以设置圆角显示(cornerRadius), 也可以设置阴影(shadowColor). 但是如果<code>layer</code>树中某个<code>layer</code>设置了圆角, 树种所有<code>layer</code>的阴影效果都将不显示了. 因此若是要有圆角又要阴影, 变通方法只能做两个重叠的<code>UIView</code>, 一个的<code>layer</code>显示圆角, 一个<code>layer</code>显示阴影.</p>\n</li>\n<li><p><code>UIView</code> 是<code>UIKit</code>框架下的(只能iOS使用). <code>CALayer</code> 是<code>QuartzCore</code>的(iOS 和macOS通用).</p>\n</li>\n<li><p><code>QuartzCore</code>的渲染能力. 使二维图像可以被自由操纵, 就好像是三维的. 图像可以在一个三维坐标系中以任意角度被旋转, 缩放和倾斜. <code>CATransform3D</code>的一套方法提供了一些魔术般的变换效果. </p>\n</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">详解CALayer 和 UIView的区别和联系</a></p>\n<p>2.<a href=\"http://blog.csdn.net/weiwangchao_/article/details/7771538\" target=\"_blank\" rel=\"noopener\">UIView和CALayer的区别</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"Block用法与原理分析","url":"http://hchong.net/2017/07/04/Block用法与原理分析/","content":"<h1 id=\"Block用法及分析\"><a href=\"#Block用法及分析\" class=\"headerlink\" title=\"Block用法及分析\"></a>Block用法及分析</h1><hr>\n<p>参考资料: </p>\n<p>1.<a href=\"https://halfrost.com/ios_block/\" target=\"_blank\" rel=\"noopener\">深入研究 Block 捕获外部变量和 __block 实现原理</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/51d04b7639f1\" target=\"_blank\" rel=\"noopener\">Block技巧与底层解析</a></p>\n<p>3.<a href=\"https://halfrost.com/ios_block_retain_circle/\" target=\"_blank\" rel=\"noopener\">深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</a></p>\n","categories":["基础知识"],"tags":["Block","基础知识"]},{"title":"自己动手制作Xcode插件","url":"http://hchong.net/2017/06/25/自己动手制作Xcode插件/","content":"<h1 id=\"自己动手制作Xcode插件\"><a href=\"#自己动手制作Xcode插件\" class=\"headerlink\" title=\"自己动手制作Xcode插件\"></a>自己动手制作Xcode插件</h1><p>Xcode8以后, 以前的插件都不能用了. 网上虽然也有方法来解决这个问题, 但是稍显复杂, 这里我们采用曲线救国的方式, 使用Apple官方推荐的方式<em>Xcode Source Editor Extension</em>来自己制作插件. Extension的方式开发的插件, 可以独立上架AppStore, 并且是独立于Xcode工程独立运行的. 但是没有UI交互, 不能在后台运行并且只能在开发者调用的时候直接修改代码.</p>\n<p>在平常的开发过程中, 有些操作是经常遇到的. 下面我们以<em>根据属性自动生成Getter方法</em>和<em>根据选中内容导入头文件</em>两种经常碰到的场景来制作Xcode插件.</p>\n<h2 id=\"新建插件制作工程\"><a href=\"#新建插件制作工程\" class=\"headerlink\" title=\"新建插件制作工程\"></a>新建插件制作工程</h2><ol>\n<li><p>打开Xcode, <code>command + shift + N</code> 选择macOS -&gt; Cocoa Application, 点击Next新建一个工程. 此处我新建的工程名为<em>AutoImportPlugin</em>.</p>\n</li>\n<li><p>在Xcode工具栏中选择Editor -&gt; Add Target -&gt; MacOS -&gt; Xcode Source Editor Extension来新建一个Extension来编写插件的主要代码. 新建的Target名称不能与工程的名字一样. 接下来会有一个弹窗, 提示你是否<em>Activate xxx Scheme</em>, 选择<em>Activate</em>即可, 这一步骤会帮你创建一个和你新建Target对应的Scheme. 完成后你的页面应该是这个样子的.</p>\n</li>\n</ol>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fgyotdiqdbj312w0q03zl.jpg\" alt=\"主工程页面\"></p>\n<h2 id=\"工程环境和参数介绍\"><a href=\"#工程环境和参数介绍\" class=\"headerlink\" title=\"工程环境和参数介绍\"></a>工程环境和参数介绍</h2><p>这里我们会主要用到AutoImport文件夹下面的两个类<code>SourceEditorExtension</code> 和 <code>SourceEditorCommand</code>. </p>\n<p><code>SourceEditorExtension.m</code>中我们可以看到两个方法:</p>\n<ul>\n<li><code>-(void)extensionDidFinishLaunching{}</code>, 注释内容为<code>If your extension needs to do any work at launch, implement this optional method.</code>   指的是指刚刚加载好插件但还未点击插件按钮时，可以执行某些准备工作.</li>\n<li><code>- (NSArray &lt;NSDictionary &lt;XCSourceEditorCommandDefinitionKey, id&gt; *&gt; *)commandDefinitions{}</code>. 返回字典类型的数组, 可以为每个插件重写名字、标识符和自定义类名等信息，和<code>Info.plist</code>文件中对应的<code>XCSourceEditorCommandName</code>、<code>XCSourceEditorCommandIdentifier</code>和<code>XCSourceEditorCommandClassName</code>等信息一致.</li>\n</ul>\n<p><code>SourceEditorCommand.m</code>中只有一个方法:</p>\n<pre><code>- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler\n{\n    // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.\n\n    completionHandler(nil);\n}\n</code></pre><p>关于插件的核心逻辑代码, 就是在这个方法里面实现. <code>XCSourceEditorCommandInvocation</code>类包含了所有的信息.可以通过他的各种属性来拿到原工程中的各种数据, 主要用到的有:</p>\n<ul>\n<li><code>invocation.buffer.lines</code>是一个数组, 包含了使用插件的工程的页面的每一行代码, 艺术组的形式存在. </li>\n<li><code>invocation.buffer.selections</code>是一个数组, 数组的内容是<code>XCSourceTextRange</code>. <code>XCSourceTextRange</code>包含了两个结构体, 用于标记原工程中选中部分的代码的位置信息.<h2 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h2></li>\n</ul>\n<p>此处以自动导入头文件的插件为例. 主要思路是遍历类的所有行, 拿到选中的内容, 判断是否被import过, 没有的话, 在合适位置插入<code>#import</code>;</p>\n<pre><code>- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler\n{\n    XCSourceTextRange *range = [invocation.buffer.selections firstObject];\n\n    NSString *selectedLines = [invocation.buffer.lines objectAtIndex:range.start.line];\n    NSString *selection = [selectedLines substringWithRange:NSMakeRange(range.start.column, range.end.column - range.start.column)];\n\n    for (NSInteger i = 0; i &lt; invocation.buffer.lines.count - 1; i++) {\n        NSString *importString = [invocation.buffer.lines objectAtIndex:i];\n        if ([importString containsString:@&quot;@interface&quot;]) {\n            self.startLineNumber = i;\n            break;\n        }\n    }\n\n    BOOL isImported = NO;\n    for (NSInteger i = 0; i &lt;= self.startLineNumber ; i++) {\n        NSString *importString = [invocation.buffer.lines objectAtIndex:i];\n        if ([importString containsString:[NSString stringWithFormat:@&quot;%@.h&quot;, selection]]) {\n            isImported = YES;\n            break;\n        }\n    }\n    if (isImported == NO) {\n        [invocation.buffer.lines insertObject:[NSString stringWithFormat:@&quot;#import \\&quot;%@.h\\&quot;&quot;, selection] atIndex:self.startLineNumber - 1];\n    }\n    completionHandler(nil);\n}\n</code></pre><h2 id=\"插件使用\"><a href=\"#插件使用\" class=\"headerlink\" title=\"插件使用\"></a>插件使用</h2><h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>我们在插件工程中选中AutoImport的Scheme(新建的那个), <code>command + R</code>运行,这时会出现一个弹窗, 让你选择要运行的工程. 选中要运行的工程后, 正常打开. 在Editor的最下面可以看到我们运行的插件工程, 点击就可以运行插件了. 打断点和调试什么的和正常的Xcode项目一样.</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fgz0hh71w6j30ht0ccdgm.jpg\" alt=\"插件运行调试\"></p>\n<p>需要注意的是, 我们在插件工程中两个Target的Singing一定要保持一致, 并且不能为空. 否则在Xcode中看不到插件.</p>\n<h3 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h3><p>以上我们已经可以在自己电脑上调试和使用Xcode插件了, 那么怎么才能在其他电脑上也使用我们开发的插件呢?</p>\n<ol>\n<li><p>我们可以在插件工程中, 找到Products文件夹下生成的的.app文件</p>\n</li>\n<li><p>右键点击此文件 -&gt; “在Finder中显示” -&gt; 将这个.app文件拷贝到你或者小伙伴电脑上的”应用程序”里</p>\n</li>\n<li><p>在“应用程序”中双击.app文件运行。然后，打开“系统偏好设置” -&gt; “扩展” -&gt; “Xcode Source Editor” -&gt; 确认插件名字前已打钩 -&gt; 此时Xcode中菜单栏Editor下的插件虽然显示，但是为灰色，无法点按，所以要 -&gt; 重启Xcode -&gt; 大功告成！</p>\n</li>\n<li><p>添加快捷键: Xcode -&gt; “Preferences” -&gt; “Key Bindings” -&gt; 搜索插件名字 -&gt; 添加对应的快捷键.</p>\n</li>\n</ol>\n<hr>\n<p>下载地址: <a href=\"https://github.com/HChong3210/AutoGetterPlugin\" target=\"_blank\" rel=\"noopener\">AutoPlugin</a></p>\n<hr>\n<p>参考文章:<br>1.<a href=\"http://www.jianshu.com/p/9c9d0fcc62cc\" target=\"_blank\" rel=\"noopener\">详解一步步实现Xcode 8 插件——Source Editor Extensions</a></p>\n<p>2.<a href=\"http://www.code4app.com/blog-822721-394.html\" target=\"_blank\" rel=\"noopener\">使用 Xcode Source Editor Extension开发Xcode 8 插件</a></p>\n","categories":["插件"],"tags":["基础知识","Xcode"]},{"title":"车","url":"http://hchong.net/2017/06/20/车/","content":"<h1 id=\"十万左右落地\"><a href=\"#十万左右落地\" class=\"headerlink\" title=\"十万左右落地\"></a>十万左右落地</h1><p>数据来自汽车之家, 车主成交价是各地车主成交的真实价格, 和去4S店咨询的价格差不多</p>\n<table><br>   <tr><br>      <td>车系</td><br>      <td>车型</td><br>      <td>车型详情</td><br>      <td>车主成交价</td><br>   </tr><br>   <tr><br>      <td>别克-英朗</td><br>      <td>2017款 15N 自动精英型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28698/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28698/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28698#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28698#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>雪佛兰-科沃兹</td><br>      <td>2016款 1.5L 自动欣悦版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/27573/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/27573/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-27573#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-27573#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>现代-悦动</td><br>      <td>2017款 1.6L 自动悦值版GLS</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29502/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29502/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29502#pvareaid=103597\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29502#pvareaid=103597</a></td><br>   </tr><br>   <tr><br>      <td>东风-标致</td><br>      <td>2017款 1.6L 自动豪华版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29620/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29620/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29620#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29620#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>大众-朗逸</td><br>      <td>2017款 1.6L 自动风尚版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29362/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29362/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29362#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29362#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>大众-捷达</td><br>      <td>2017款 1.5L 自动舒适型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28451/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28451/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28451#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28451#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>东风雪铁龙-爱丽舍</td><br>      <td>2017款 1.6L 自动舒适型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29341/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29341/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/s-98#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/s-98#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪GS</td><br>      <td>2016款 运动版 1.3T 自动领尚型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/26402/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/26402/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-26402#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-26402#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪GL</td><br>      <td>2017款 1.3T 自动尊贵型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/26596/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/26596/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-26596#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-26596#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪</td><br>      <td>2017款 三厢百万款 1.5L CVT向上版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28104/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28104/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28104#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28104#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪</td><br>      <td>2017款 两厢RS百万款 1.5L CVT向上版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28133/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28133/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28133#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28133#pvareaid=103596</a></td><br>   </tr><br></table>\n\n\n","categories":[],"tags":["生活"]},{"title":"基于OpenCV的人脸识别","url":"http://hchong.net/2017/06/16/基于OpenCV的人脸识别/","content":"","categories":[],"tags":[]},{"title":"Python爬虫入门","url":"http://hchong.net/2017/06/14/Python爬虫入门/","content":"<h1 id=\"HCModule\"><a href=\"#HCModule\" class=\"headerlink\" title=\"HCModule\"></a>HCModule</h1><p><a href=\"https://travis-ci.org/HChong3210/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.shields.io/travis/HChong3210/HCModule.svg?style=flat\" alt=\"CI Status\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/v/HCModule.svg?style=flat\" alt=\"Version\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/l/HCModule.svg?style=flat\" alt=\"License\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/p/HCModule.svg?style=flat\" alt=\"Platform\"></a></p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>To run the example project, clone the repo, and run <code>pod install</code> from the Example directory first.</p>\n<h2 id=\"Requirements\"><a href=\"#Requirements\" class=\"headerlink\" title=\"Requirements\"></a>Requirements</h2><h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>HCModule is available through <a href=\"http://cocoapods.org\" target=\"_blank\" rel=\"noopener\">CocoaPods</a>. To install<br>it, simply add the following line to your Podfile:</p>\n<pre><code class=\"ruby\">pod &#39;HCModule&#39;\n</code></pre>\n<h2 id=\"Author\"><a href=\"#Author\" class=\"headerlink\" title=\"Author\"></a>Author</h2><p>HChong3210, hchong7557@gmail.com</p>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p>HCModule is available under the MIT license. See the LICENSE file for more info.</p>\n","categories":["爬虫","Python"],"tags":["爬虫","Python"]},{"title":"Cocoapods实践","url":"http://hchong.net/2017/05/24/Cocoapods实践/","content":"<h1 id=\"Cocoapods实践\"><a href=\"#Cocoapods实践\" class=\"headerlink\" title=\"Cocoapods实践\"></a>Cocoapods实践</h1><p>Cocoapods是一个基于Ruby的包管理工具, 类似的还有Carthage. Cocoapods的安装在这里不在详述, 请自行百度, 在这里着重讲一下如何使用Cocoapods制作私有包, 以及Cocoapods的实现原理. </p>\n<h2 id=\"Cocoapods的实现原理\"><a href=\"#Cocoapods的实现原理\" class=\"headerlink\" title=\"Cocoapods的实现原理\"></a>Cocoapods的实现原理</h2><p>cocoapods安装成功后, 我们怎么来使用它呢. 这里就要用到cocoapods的核心文件之一<code>Podfile</code>. Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度自定义，你可以根据个人喜好对其做出定制。<a href=\"https://guides.cocoapods.org/syntax/Podfile.html\" target=\"_blank\" rel=\"noopener\">查看更多官方介绍</a>. </p>\n<h3 id=\"Podfile\"><a href=\"#Podfile\" class=\"headerlink\" title=\"Podfile\"></a>Podfile</h3><p>下面是一个🌰, 我们来挨个分析下他们背后都代表着什么.</p>\n<pre><code class=\"Ruby\">source &#39;http://source.git&#39;\nplatform :ios, &#39;8.0&#39;\n\ntarget &#39;Demo&#39; do\n    pod &#39;AFNetworking&#39;\n    pod &#39;SDWebImage&#39;\n    pod &#39;Masonry&#39;\nend\n</code></pre>\n<p><code>source</code>: Specifies the location of specs. spec的地址.</p>\n<p><code>platform</code>: Specifies the platform for which a static library should be built. 指定构建静态库的平台.</p>\n<p><code>target</code>: Defines a CocoaPods target and scopes dependencies defined within the given block. A target should correspond to an Xcode target. By default the target includes the dependencies defined outside of the block, unless instructed not to inherit them. 定义了CocoaPods在指定target的依赖, 此处的Target应该与Xcode目标相对应。默认情况下，除非表明不继承它们, 否则Target包括在块外部定义的依赖项.</p>\n<p><code>pod</code>: A dependency requirement is defined by the name of the Pod and optionally a list of version requirements. 一个依赖项需求是由Pod的名称和可选的版本需求列表所定义的.</p>\n<p>当你写完<code>Podfile</code>之后, 就需要执行Pod的命令<code>pod install</code>, 来按照<code>Podfile</code>中的配置来配置我么你的工程</p>\n<h3 id=\"pod-install\"><a href=\"#pod-install\" class=\"headerlink\" title=\"pod install\"></a>pod install</h3><p>当运行 <code>pod install</code> 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 <code>--verbose</code>来查看详细内容。现在运行这个命令 <code>pod install --verbose</code>，可以看到类似如下的内容:</p>\n<pre><code>  Preparing\n\nAnalyzing dependencies\n\nInspecting targets to integrate\n  Using `ARCHS` setting to build architectures of target `Pods-XXX`: (``)\n\nResolving dependencies of `Podfile`\n\nComparing resolved specification to the sandbox manifest\n  A AFNetworking\n  A Masonry\n  A SDWebImage\n\nDownloading dependencies\n\n-&gt; Installing AFNetworking (3.1.0)\n &gt; Git download\n &gt; Git download\n     $ /usr/bin/git clone https://github.com/AFNetworking/AFNetworking.git\n     /var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8\n     --template= --single-branch --depth 1 --branch 3.1.0\n     Cloning into &#39;/var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8&#39;...\n     Note: checking out &#39;88f13053b1d1f20bf657f5c36459b87a5d317ad7&#39;.\n\n     You are in &#39;detached HEAD&#39; state. You can look around, make experimental\n     changes and commit them, and you can discard any commits you make in this\n     state without impacting any branches by performing another checkout.\n\n     If you want to create a new branch to retain commits you create, you may\n     do so (now or later) by using -b with the checkout command again. Example:\n\n       git checkout -b &lt;new-branch-name&gt;\n\n     $ /usr/bin/git -C\n     /var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8\n     submodule update --init --recursive\n  &gt; Copying AFNetworking from\n  `/Users/hc/Library/Caches/CocoaPods/Pods/Release/AFNetworking/3.1.0-5e0e1` to\n  `Pods/AFNetworking`\n\n-&gt; Installing Masonry (1.0.2)\n  &gt; Copying Masonry from\n  `/Users/hc/Library/Caches/CocoaPods/Pods/Release/Masonry/1.0.2-7c429` to\n  `Pods/Masonry`\n\n-&gt; Installing SDWebImage (4.1.0)\n  &gt; Copying SDWebImage from\n  `/Users/hc/Library/Caches/CocoaPods/Pods/Release/SDWebImage/4.1.0-0e435` to\n  `Pods/SDWebImage`\n  - Running pre install hooks\n\nGenerating Pods project\n  - Creating Pods project\n  - Adding source files to Pods project\n  - Adding frameworks to Pods project\n  - Adding libraries to Pods project\n  - Adding resources to Pods project\n  - Linking headers\n  - Installing targets\n    - Installing target `AFNetworking` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/AFNetworking/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/AFNetworking/AFNetworking.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/AFNetworking/AFNetworking-umbrella.h`\n    - Installing target `Masonry` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/Masonry/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/Masonry/Masonry.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/Masonry/Masonry-umbrella.h`\n    - Installing target `SDWebImage` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/SDWebImage/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/SDWebImage/SDWebImage.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/SDWebImage/SDWebImage-umbrella.h`\n    - Installing target `Pods-CarMall` iOS 8.0\n      - Generating Info.plist file at `Pods/Target Support\n      Files/Pods-CarMall/Info.plist`\n      - Generating module map file at `Pods/Target Support\n      Files/Pods-CarMall/Pods-CarMall.modulemap`\n      - Generating umbrella header at `Pods/Target Support\n      Files/Pods-CarMall/Pods-CarMall-umbrella.h`\n  - Running post install hooks\n  - Writing Xcode project file to `Pods/Pods.xcodeproj`\n    - Generating deterministic UUIDs\n  - Writing Lockfile in `Podfile.lock`\n  - Writing Manifest in `Pods/Manifest.lock`\n\nIntegrating client project\n\n[!] Please close any current Xcode sessions and use `CarMall.xcworkspace` for this project from now on.\n\nIntegrating target `Pods-CarMall` (`CarMall.xcodeproj` project)\n  - Running post install hooks\n    - cocoapods-stats from\n    `/Users/hc/.rvm/gems/ruby-2.4.1/gems/cocoapods-stats-1.0.0/lib/cocoapods_plugin.rb`\n\nSending stats\n      - AFNetworking, 3.1.0\n      - Masonry, 1.0.2\n      - SDWebImage, 4.1.0\n\n-&gt; Pod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed.\n</code></pre><p>先看我们工程的变化, 可以发现工程里面多了三个文件, 一个<code>XXX.xcworkspace</code>文件, 一个<code>Podfile.lock</code>文件, 还有一个<code>Pods</code>文件夹. 我们在通过终端输出的命令来分析, 为什么会生成这几个文件, 以及他们的作用.</p>\n<ol>\n<li>Analyzing dependencies. 弄清楚声明了哪些第三方库.在加载 <code>podspecs</code> 过程中，<code>CocoaPods</code> 就建立了包括版本信息在内的所有的第三方库的列表。<code>Podspecs</code> 被存储在本地路径 <code>~/.cocoapods</code> 中.</li>\n<li>Inspecting targets to integrate. 检查目标集成.</li>\n<li>Resolving dependencies of <code>Podfile</code> 和 Comparing resolved specification to the sandbox manifest. 分析<code>Podfile</code>文件的依赖和将已经解析的Pod与缓存过的Pod进行比对, 是添加还是删除, 还是更新.</li>\n<li>Downloading dependencies. 根据第三部的分析结果来下载依赖到<code>Pods</code>文件夹下面.</li>\n<li>Generating Pods project. 生成Pods的工程. 这一步还包含了许多其他的步骤.<ul>\n<li>Creating Pods project</li>\n<li>Adding source files to Pods project</li>\n<li>Adding frameworks to Pods project</li>\n<li>Adding libraries to Pods project</li>\n<li>Adding resources to Pods project</li>\n<li>Linking headers</li>\n<li>Installing targets</li>\n<li>Running post install hooks</li>\n<li>Writing Xcode project file to <code>Pods/Pods.xcodeproj</code> 如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 Pods.xcodeproj 进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中.</li>\n<li>Writing Lockfile in <code>Podfile.lock</code>. 记录各个Pod的版本号和之家你的依赖关系.</li>\n<li>Writing Manifest in <code>Pods/Manifest.lock</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"pod-install-vs-pod-update\"><a href=\"#pod-install-vs-pod-update\" class=\"headerlink\" title=\"pod install vs pod update\"></a>pod install vs pod update</h3><p>引用官方的文档<a href=\"https://guides.cocoapods.org/using/pod-install-vs-update.html\" target=\"_blank\" rel=\"noopener\">https://guides.cocoapods.org/using/pod-install-vs-update.html</a>来说明一下二者的区别, 以及使用场景.</p>\n<p>You will only use pod update when you want to update the version of a specific pod (or all the pods).</p>\n<ul>\n<li><code>pod install</code>主要用在第一次安装pods时, 如果后面你新增, 修改, 删除你的<code>Podfile</code>文件时也可以使用该命令. 每次执行<code>pod install</code>命令会把每一个安装的pod的版本写进<code>Podfile.lock</code>文件中, 来记录和lock这些已经安装Pod的版本. 当执行<code>Pod install</code>. 如果是新增Pod, 那么会搜索与Podfile中描述的匹配的版本; 如果已经存在, 他会下载<code>Podfile.lock</code>文件中明确的版本, 但不会去检查有没有可用的最新版本.</li>\n<li><code>pod update</code>会不关注<code>Podfile.lock</code>中的版本而直接更新到符合<code>Podfile</code>中定义的最新版本.</li>\n</ul>\n<h2 id=\"使用CocoaPods创建私有Pod\"><a href=\"#使用CocoaPods创建私有Pod\" class=\"headerlink\" title=\"使用CocoaPods创建私有Pod\"></a>使用CocoaPods创建私有Pod</h2><p>上面我们已经介绍过如何使用CocoaPods了, 下面要讲解的就是如何创建Pod来供别人使用. 在创建私有Pod之前我们需要两个git地址:</p>\n<ul>\n<li>用来保存Spec Repo的内容的Git地址</li>\n<li>用来保存具体Pod内容的Git地址</li>\n</ul>\n<h3 id=\"创建一个Spec-Repo\"><a href=\"#创建一个Spec-Repo\" class=\"headerlink\" title=\"创建一个Spec Repo\"></a>创建一个Spec Repo</h3><p>在这一步, 我们主要创建第一个Git地址, 并且关联到本地.</p>\n<p><code>Spec Repo</code>是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端. 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的:</p>\n<pre><code>.\n├── Specs\n    └── [SPEC_NAME]\n        └── [VERSION]\n            └── [SPEC_NAME].podspec\n</code></pre><p>如果你要创建私有Pod, 那么你的<code>Spec Repo</code>的远端地址就必须是私有的. 反之如果你要创建一个公有的Pod, 那么就可以使用GitHub来托管你的代码. 当你创建好远端的仓库之后, 执行<code>pod repo add [Spec Repo的仓库名] [Spec Repo的git地址]</code>来把远端的仓库clone到本地. 注意, 这里<code>[Spec Repo的仓库名]</code>不一定是远端Git仓库的名字, 而是clone到本地后, 本地文件加的名字, 但是这个名字会在后面提交<code>PodSpec</code>文件时用到.</p>\n<h3 id=\"创建Pod工程文件\"><a href=\"#创建Pod工程文件\" class=\"headerlink\" title=\"创建Pod工程文件\"></a>创建Pod工程文件</h3><p>我们在你需要创建Pod的目录下使用<code>pod lib create [Pod名称]</code>来创建对应的Pod模板.  实际上该命令行隐藏了默认参数, 参数补全后应该是<code>pod lib create ProjectName --template-url=https://github.com/CocoaPods/pod-template.git</code>. </p>\n<p>接下来会问你四个问题:</p>\n<ol>\n<li>What language do you want to use?? [ Swift / ObjC ]. 使用什么语言</li>\n<li>Would you like to include a demo application with your library?. 是否需要一个例子工程, 一般选择YES</li>\n<li>Which testing frameworks will you use? [ Specta / Kiwi / None ]. 选择一个测试框架</li>\n<li>Would you like to do view based testing? [ Yes / No ]. 是否基于View测试</li>\n<li>What is your class prefix?. 类的前缀</li>\n</ol>\n<p>根据自己的实际需要来选择后, 就会自动执行<code>Pod install</code>命令来创建项目并且生成依赖. 这是这个Pod的没目录结构应该是这样的:</p>\n<pre><code>  MyLib\n  ├── .travis.yml\n  ├── _Pods.xcproject\n  ├── Example\n  │   ├── MyLib\n  │   ├── MyLib.xcodeproj\n  │   ├── MyLib.xcworkspace\n  │   ├── Podfile\n  │   ├── Podfile.lock\n  │   ├── Pods\n  │   └── Tests\n  ├── LICENSE\n  ├── MyLib.podspec\n  ├── Pod\n  │   ├── Assets\n  │   └── Classes\n  │     └── RemoveMe.[swift/m]\n  └── README.md\n</code></pre><p>接下来, 我们需要创建第二个Git地址, 用来保存Pod的实现代码. 我们进入到Pod文件夹的根目录下, 使用如下代码来关联Pod到远端仓库:</p>\n<pre><code>$ git add .\n$ git commit -s -m &quot;Initial Commit of Library&quot;\n$ git remote add origin [Pod的远端地址]           #添加远端仓库\n$ git push origin master     #提交到远端仓库\n</code></pre><h3 id=\"编辑Pod文件\"><a href=\"#编辑Pod文件\" class=\"headerlink\" title=\"编辑Pod文件\"></a>编辑Pod文件</h3><p>Pod文件就是这个Pod要实现功能的具体逻辑, 在主工程根目录下面有一个和Pod同名的文件夹, 里面有两个子文件夹. 一个是<code>Assets</code>, 一个是<code>Classes</code>.</p>\n<ul>\n<li>Assets文件主要用来存放资源文件, 例如图片资源和XIB文件.</li>\n<li>Classes则存放主要的功能代码, 类.</li>\n</ul>\n<p>在这里需要注意两个地方:</p>\n<ol>\n<li>当我们要使用<code>Pod</code>中的资源时, 以图片为例, 我们通过<code>[UIImage imageWithName:@&quot;xxx.png&quot;]</code>是取不到Pod中的图片的, 因为<code>imageWithName:</code>方法默认是从<code>mainBundle</code>中来取的, 而Pod不属于<code>mainBundle</code>的范畴, 我们需要先根据<code>class</code>来拿到当前类所在的<code>bundle</code>, 再取该<code>Bundle</code>中的资源.</li>\n<li>每次在Pod文件夹中添加新的文件或者资源时, 都需要在根目录的Example目录下执行<code>pod update</code>命令来重新建立索引.</li>\n</ol>\n<h3 id=\"编辑Podspec文件\"><a href=\"#编辑Podspec文件\" class=\"headerlink\" title=\"编辑Podspec文件\"></a>编辑Podspec文件</h3><p>关于<code>Podspec</code>文件<a href=\"http://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"noopener\">官方</a>是这样描述的:</p>\n<blockquote>\n<p>A specification describes a version of Pod library. It includes details about where the source should be fetched from, what files to use, the build settings to apply, and other general metadata such as its name, version, and description.</p>\n</blockquote>\n<p><code>pod lib create XXX</code>创建出来的Pod, 初始时的<code>Podspec</code>文件包含了各种信息, 详细的说明我们可以看<a href=\"http://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>, 这里贴上最基础的用法代码:</p>\n<pre><code>Pod::Spec.new do |s|\n  s.name             = &#39;HCPods&#39;\n  #Pod的版本\n  s.version          = &#39;0.1.0&#39;\n  s.summary          = &#39;你在搜索时会呈现&#39;\n\n  s.description      = &lt;&lt;-DESC\n    这里是关于你Pod功能的描述\n                       DESC\n\n  s.homepage         = &#39;https://github.com/HChong3210/HCPods&#39;\n  s.license          = { :type =&gt; &#39;MIT&#39;, :file =&gt; &#39;LICENSE&#39; }\n  s.author           = { &#39;HChong3210&#39; =&gt; &#39;hchong7557@gmail.com&#39; }\n  #Pod的远端仓库地址\n  s.source           = { :git =&gt; &#39;https://github.com/HChong3210/HCPods.git&#39;, :tag =&gt; s.version.to_s }\n\n    #Pod支持的最低版本\n  s.ios.deployment_target = &#39;8.0&#39;\n    #Pod源文件的位置\n  s.source_files = &#39;HCPods/Classes/**/*&#39;\n  #Pod中资源文件的位置\n  s.resource_bundles = {\n    &#39;DFCForms&#39; =&gt; [&#39;HCPods/Assets/*.{png,xib,plist}&#39;]\n  }\n  #对外公开的类\n  s.public_header_files = &#39;DFCForms/Classes/**/*.h&#39;\n\n  #Pod中用到的第三方库\n  s.frameworks = &#39;UIKit&#39;\n  s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39;\n  s.dependency &#39;SDWebImage&#39;\n\nend\n</code></pre><h3 id=\"提交Pod文件\"><a href=\"#提交Pod文件\" class=\"headerlink\" title=\"提交Pod文件\"></a>提交Pod文件</h3><p>Pod文件编辑好后, 我们要把代码提交到远端服务器, 我们就使用正常的方式来提交代码, 并且给代码打上Tag, <em> 注意, 这里的Tag必须和<code>Podspec</code>文件中的Pod版本号一致 </em>, 因为Podspec会根据Tag从远端来找相应的代码, 否则会出现版本和代码不匹配的现象.</p>\n<p>如果不使用Sourcetree这样的GUI工具, 可以参考下面的Git代码:</p>\n<pre><code># 在根目录下\ngit status\ngit add .\ngit tag -m &#39;备注&#39; 版本号\ngit commit -s -m &#39;备注&#39; \ngit push origin master —tags\n</code></pre><h3 id=\"提交Podspec文件\"><a href=\"#提交Podspec文件\" class=\"headerlink\" title=\"提交Podspec文件\"></a>提交Podspec文件</h3><p>提交完Pod文件后, 我们只用把<code>Podspec</code>文件也提交上去, 这样就可以在Cocoapods中简历起来索引, 找到自己的Pod了. </p>\n<p>在提交之前我们可以在根目录下使用<code>pod lib lint</code>命令来验证是否编译通过. 也可以直接提交<code>pod repo push [你clone到本地的Spec Repo的仓库名] [Pod名称].podspec      --use-libraries --allow-warnings --sources=&#39;[Podspec远端地址],https://github.com/CocoaPods/Specs&#39; --verbose</code></p>\n<h3 id=\"subspec的使用\"><a href=\"#subspec的使用\" class=\"headerlink\" title=\"subspec的使用\"></a>subspec的使用</h3><p>有时一个Pod太大了, 而我们又用不到全部的内容, 这时我们就可以使用subspec来解决这个问题. 我们可以在Pod文件夹中, 使用文件夹来分割各个子Pod, 然后在<code>Podspec</code>文件中这样设置:</p>\n<pre><code>  s.subspec &#39;[子Pod名称]&#39; do |pod1|\n      pod1.source_files = &#39;SCCQRCode/Classes/[子文件夹名]/**/*&#39;\n  end\n\n  s.subspec &#39;[子Pod名称]&#39; do |pod2|\n            pod2.source_files = &#39;SCCQRCode/Classes/[子文件夹名]/**/*&#39;\n  end\n</code></pre><p>我们也可以在各个子Pod中分别设置他们的资源路径, 对外暴露的header路径, 以及dependency.</p>\n<p>我们在外面引用该Pod的时候就可以使用<code>pod [Pod/子Pod]</code>的方式来只引用一个子Pod. </p>\n<h2 id=\"cocoapods的相关知识\"><a href=\"#cocoapods的相关知识\" class=\"headerlink\" title=\"cocoapods的相关知识\"></a>cocoapods的相关知识</h2><p>这里是CocoaPods的其他相关知识, 做一个备忘.</p>\n<h3 id=\"Pod的版本说明\"><a href=\"#Pod的版本说明\" class=\"headerlink\" title=\"Pod的版本说明\"></a>Pod的版本说明</h3><p>CocoaPods 使用<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener\">语义版本控制 - Semantic Versioning</a>命名约定来解决对版本的依赖. 常见的版本说明符号有以下这些.</p>\n<ul>\n<li>= 0.1 Version 0.1.</li>\n<li>0.1 Any version higher than 0.1.</li>\n<li><blockquote>\n<p>= 0.1 Version 0.1 and any higher version.</p>\n</blockquote>\n</li>\n<li>&lt; 0.1 Any version lower than 0.1.</li>\n<li>&lt;= 0.1 Version 0.1 and any lower version.</li>\n<li>~&gt; 0.1.2 Version 0.1.2 and the versions up to 0.2, not including 0.2. </li>\n</ul>\n<h3 id=\"常见Pod依赖的几种写法\"><a href=\"#常见Pod依赖的几种写法\" class=\"headerlink\" title=\"常见Pod依赖的几种写法\"></a>常见Pod依赖的几种写法</h3><ul>\n<li>pod ‘AFNetworking’, :configurations =&gt; [‘Debug’, ‘Beta’]</li>\n<li>pod ‘QueryKit/Attribute’</li>\n<li>pod ‘QueryKit’, :subspecs =&gt; [‘Attribute’, ‘QuerySet’]</li>\n<li>pod ‘AFNetworking’, :path =&gt; ‘~/Documents/AFNetworking’</li>\n<li>pod ‘AFNetworking’, :git =&gt; ‘<a href=\"https://github.com/gowalla/AFNetworking.git\" target=\"_blank\" rel=\"noopener\">https://github.com/gowalla/AFNetworking.git</a>‘</li>\n<li>pod ‘JSONKit’, :podspec =&gt; ‘<a href=\"https://example.com/JSONKit.podspec\" target=\"_blank\" rel=\"noopener\">https://example.com/JSONKit.podspec</a>‘</li>\n</ul>\n<hr>\n<p>参考文章:<br>1.<a href=\"https://swiftcafe.io/2015/10/25/swift-daily-carthage-package/\" target=\"_blank\" rel=\"noopener\">Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验</a>.</p>\n<p>2.<a href=\"https://bestswifter.com/cocoapods/\" target=\"_blank\" rel=\"noopener\">细聊Cocoapods与Xcode工程配置</a>.</p>\n<p>3.<a href=\"http://guides.cocoapods.org/making/using-pod-lib-create.html\" target=\"_blank\" rel=\"noopener\">Cocoapods官方文档</a>.</p>\n<p>4.<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"noopener\">使用Cocoapods创建私有podspec</a></p>\n<p>5.<a href=\"http://draveness.me/cocoapods.html\" target=\"_blank\" rel=\"noopener\">CocoaPods 都做了什么？</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/d6a592d6fced\" target=\"_blank\" rel=\"noopener\">使用私有Cocoapods仓库中引用.a库</a></p>\n<p>7.<a href=\"https://objccn.io/issue-6-4/\" target=\"_blank\" rel=\"noopener\">深入理解CocoaPods</a></p>\n<p>8.<a href=\"https://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"noopener\">podspec官方文档</a></p>\n<p>9.<a href=\"https://guides.cocoapods.org/syntax/Podfile.html\" target=\"_blank\" rel=\"noopener\">Podfile官方文档</a></p>\n","categories":["基础知识","模块化"],"tags":["基础知识","模块化"]},{"title":"iOS的组件化实践","url":"http://hchong.net/2017/05/23/iOS的模块化实践/","content":"<h1 id=\"iOS的组件化实践\"><a href=\"#iOS的组件化实践\" class=\"headerlink\" title=\"iOS的组件化实践\"></a>iOS的组件化实践</h1><p>随着工程的变大, 业务的复杂, 开发人员的增多, 如何提高成员间的开发效率和最大程度的复用代码, 成为了亟待解决的问题. 除了更加清晰的结构目录外, 模块化, 应该是一种比较优雅解决方案. 关于组件化我们要达成的一个目标就是<em>重用高度抽象化的代码单元</em>.</p>\n<p>参考文章系列基本上可以代表业界目前对组件化的一些思考, 建议按照顺序阅读. 下面是我结合我司项目中的一些实际应用, 谈一下我对组件化的理解.</p>\n<p>我司的组件化之路, 大致可以分为几个阶段, 下面我就项目的变化历程来分析我司的组件化之路.</p>\n<h2 id=\"大杂烩\"><a href=\"#大杂烩\" class=\"headerlink\" title=\"大杂烩\"></a>大杂烩</h2><p>最开始, 我们的项目所有代码都在工程里面, 每个具体的业务使用独立的文件夹进行分割, 看似十分整洁, 但是也有很多不便之处. 各个模块之间耦合性很强, 责任人不明确. 这个时候可以说完全没有组件化的概念, 十分混乱. </p>\n<p>组件化的引入, 源于和另外一个项目的代码复用. 当时在做一个营销相关的业务, 由于效果十分好, 所以决定在另外一个项目中也接入这块业务. 然而, 并没有想象的那么简单. 由于跨项目, 后台完全不同, 牵涉到网络库调用, 公共组件的使用, 要想把这个业务单独拆分出去, 就必须把这个业务用到的网络库, 公共组件库也拆分出去, 难度非常之大. 这时候, 就想到了使用Cocoapods来管理一些工具类和公共组件, 于是就有了第二阶段.</p>\n<h2 id=\"非业务代码组件化\"><a href=\"#非业务代码组件化\" class=\"headerlink\" title=\"非业务代码组件化\"></a>非业务代码组件化</h2><p>在这一阶段, 我们充分使用Cocoapods的模块化功能, 将一些通用的类, 工具类, 封装成私有的Pod(<a href=\"http://hchong.net/2017/05/24/Cocoapods%E5%AE%9E%E8%B7%B5/\">参考这里</a>). 这样一来, 就把基础代码从项目中抽离出来, 其他的项目要想使用, 只需依赖我们的私有Pod就可以了. 那么上面想要拆分公共业务组件的想法就可以实现了.</p>\n<p>然而, 随着业务的打通. 不同的项目之间需要调用的共同组件越来越多, 组件与组件之间如何进行交互, 组件与项目之间又如何进行交互, 这些问题又出来了. 于是, 又有了现在的完全组件化方案.</p>\n<h2 id=\"完全组件化\"><a href=\"#完全组件化\" class=\"headerlink\" title=\"完全组件化\"></a>完全组件化</h2><p>称之为完全组件化方案, 是因为我司目前采用的就是这样的解决方案, 并且暂时也找不到更加好的解决方案. 完全组件化方案, 实际还是在<em>非业务代码组件化</em>的基础上, 通过引入<a href=\"http://hchong.net/2017/05/23/iOS%E7%9A%84%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AE%9E%E8%B7%B5/\">路由协议</a>来实现的.</p>\n<p>通过路由协议, 相当于我们通过一个中间层来转发我们组件与组件之间的通信, 这样就实现了组件之间的解耦, 而组件内部又是完整的业务逻辑, 属于高内聚, 低耦合.</p>\n<p>至此, 就完成了我们的组件化之路, 解除组件之间相互引用的代码硬依赖, 规范了组件之间的通信接口, 各个组件本身就相当于一个黑盒, 可以独立开发.</p>\n<h2 id=\"其他组件化方案\"><a href=\"#其他组件化方案\" class=\"headerlink\" title=\"其他组件化方案\"></a>其他组件化方案</h2><p>可以将需要封装的代码打包成静态库, 静态库中把需要暴露出来的头文件选择性的暴露出来, 不过这样各个模块之间的耦合性还是比较高的.</p>\n<hr>\n<p>参考文章:<br>1.<a href=\"http://limboy.me/tech/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"noopener\">蘑菇街App的组件化之路</a>.</p>\n<p>2.<a href=\"https://casatwy.com/iOS-Modulization.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈 组件化方案</a>.</p>\n<p>3.<a href=\"http://limboy.me/tech/2016/03/14/mgj-components-continued.html\" target=\"_blank\" rel=\"noopener\">蘑菇街App的组件化之路.续</a>.</p>\n<p>4.<a href=\"http://blog.cnbang.net/tech/3080/\" target=\"_blank\" rel=\"noopener\">iOS组件化方案探讨</a>.</p>\n","categories":["模块化"],"tags":["模块化","cocoapods"]},{"title":"iOS的路由协议实践","url":"http://hchong.net/2017/05/23/iOS的路由协议实践/","content":"<h1 id=\"iOS的路由协议实践\"><a href=\"#iOS的路由协议实践\" class=\"headerlink\" title=\"iOS的路由协议实践\"></a>iOS的路由协议实践</h1><p>路由协议, 是组件化的核心所在. 组件化, 实际就会把代码拆分为一个一个的模块, 无论采用Pod的方式,  文件夹分割的方式, 还是静态库的方式, 实质都是把代码分为一个个的模块. 如何在模块之间和应用之间通信, 就是路由协议需要考虑的问题.</p>\n<p>关于路由协议, 冰霜的<a href=\"https://halfrost.com/ios_router/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>写的实在是太详细了, 看得是男默女泪, 简直是业界良心. 简单说来, 路由协议跳转主要解决这几类问题:</p>\n<ol>\n<li>外部跳转到App内部一个很深层次的一个界面.</li>\n<li>App之间的相互跳转.</li>\n<li>解除App组件之间和App页面之间的耦合性.</li>\n<li>统一iOS和Android两端的页面跳转逻辑, 统一三端的请求资源的方式.</li>\n<li>iOS和Android两边只要共用一套动态下发配置文件来配置App的跳转逻辑.</li>\n<li>在App任何界面都可以调用任意一个界面或者任意一个组件.</li>\n</ol>\n<h2 id=\"应用间路由跳转\"><a href=\"#应用间路由跳转\" class=\"headerlink\" title=\"应用间路由跳转\"></a>应用间路由跳转</h2><p>应用间路由跳转主要有以下几种常见的使用场景: </p>\n<ol>\n<li>使用第三方用户登录，跳转到需授权的App或跳转到分享app的对应页面.</li>\n<li>应用程序推广, 跳转到另一个应用程序(本机已经安装).</li>\n<li>跳转到iTunes并显示应用程序下载页面(本机没有安装).</li>\n<li>第三方支付, 跳转到第三方支付App, 如支付宝支付, 微信支付.</li>\n<li>使用系统内置程序, 如跳转到打电话, 发短信, 发邮件, Safari等.</li>\n</ol>\n<p>应用间的跳转主要有两种方式: URL Scheme和Universal Links. 这两种实现方式并不冲突, 可以共存.</p>\n<h3 id=\"URL-Scheme方式跳转\"><a href=\"#URL-Scheme方式跳转\" class=\"headerlink\" title=\"URL Scheme方式跳转\"></a>URL Scheme方式跳转</h3><p>以A-&gt;B为例, 来说明下如何跳转.<br>首先我们需要分别在两个App的info.plist里面添加对应的URL types - URL Schemes, 如图所示:</p>\n<p><img src=\"http://img.souche.com/f2e/2b762dfb368b3b50621cd5c39b51a86e.png\" alt=\"添加URL types\"></p>\n<p>A的URL Schemes是APPA, B的URL Schemes是APPB. 由于iOS9引入了白名单的概念,<br>如果使用 canOpenURL:方法, 该方法所涉及到的 URL Schemes 必须在”Info.plist”中将它们列为白名单, 否则<code>canOpenURL</code>返回<code>NO</code>, 不能正常跳转. 所以要在A中添加B的URL Schemes, B中添加A的Schemes. key叫做<code>LSApplicationQueriesSchemes</code>, 键值内容是上一步对应应用程序的URL Schemes. </p>\n<pre><code>\n- jumpToAppB:(id)sender {\n   // 1.获取应用程序App-B的URL Scheme\n   NSURL *appBUrl = [NSURL URLWithString:@&quot;zacharyB1://&quot;];\n   // 2.判断手机中是否安装了对应程序\n   if ([[UIApplication sharedApplication] canOpenURL:appBUrl]) {\n       // 3. 打开应用程序App-B\n       //[[UIApplication sharedApplication] openURL:appBUrl];//iOS 9之后被废弃\n       [[UIApplication sharedApplication] openURL:appBUrl options:@{UIApplicationOpenURLOptionUniversalLinksOnly : @YES} completionHandler:^(BOOL success) {\n\n        }];\n   } else {\n       NSLog(@&quot;没有安装&quot;);\n   }\n}\n</code></pre><p>options目前可传入参数Key在UIApplication头文件只有一个:UIApplicationOpenURLOptionUniversalLinksOnly, 其对应的Value为布尔值, 默认为False. 如该Key对应的Value为True, 那么打开所传入的Universal Link时, 只允许通过这个Link所代表的iOS应用跳转的方式打开这个链接, 否则就会返回success为false, 也就是说只有安装了Link所对应的App的情况下才能打开这个Universal Link, 而不是通过启动Safari方式打开这个Link的代表的网站. </p>\n<p>至此, 就可以正常跳转了, 如果我们不希望某个APP通过URL Scheme的方式打开我们的应用, 我们可以在<code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code>方法中判断指定的Scheme然后返回<code>NO</code>, 如下所示, 只有<code>com.tencent.weixin</code>的Scheme才能打开我们的APP. </p>\n<pre><code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {\n    NSLog(@&quot;sourceApplication: %@&quot;, sourceApplication);\n    NSLog(@&quot;URL scheme:%@&quot;, [url scheme]);\n    NSLog(@&quot;URL query: %@&quot;, [url query]);\n\n    if ([sourceApplication isEqualToString:@&quot;com.tencent.weixin&quot;]){\n        // 允许打开\n        return YES;\n    }else{\n        return NO;\n    }\n}\n</code></pre><h3 id=\"Universal-Links方式跳转\"><a href=\"#Universal-Links方式跳转\" class=\"headerlink\" title=\"Universal Links方式跳转\"></a>Universal Links方式跳转</h3><p>使用这个功能可以使我们的App通过HTTP链接来启动App, 通用链接就是HTTP协议的普通URL, 通过在服务器上配置一些文件, 配合应用. 实现客户点击网页链接之后直接打开应用. 客户在微信\\QQ中点击链接时不再需要点击右上’在Safari浏览器打开’才能打开软件, 实现客户操作的无缝跳转, 让客户体验更加连贯, 更顺畅. </p>\n<ol>\n<li><p>如果安装过App, 不管在微信里面http链接还是在Safari浏览器, 还是其他第三方浏览器, 都可以打开App. </p>\n</li>\n<li><p>如果没有安装过App, 就会打开网页. </p>\n</li>\n</ol>\n<p>具体设置需要3步: </p>\n<ol>\n<li><p>App需要开启Associated Domains服务, 并设置Domains, 注意必须要applinks：开头. 这里需要在APP使用的证书中设置这个选项, 否则在APP设置中看不到Associated Domains服务. </p>\n</li>\n<li><p>域名必须要支持HTTPS. </p>\n</li>\n<li><p>上传内容是Json格式的文件, 文件名为apple-app-site-association到自己域名的根目录下, 或者.well-known目录下. iOS自动会去读取这个文件. 具体的文件内容请查看<a href=\"https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>. </p>\n</li>\n</ol>\n<p><a href=\"http://www.jianshu.com/p/c83164c2aec2\" target=\"_blank\" rel=\"noopener\">参考文章一</a></p>\n<p><a href=\"http://www.jianshu.com/p/1970fd59de12\" target=\"_blank\" rel=\"noopener\">参考文章二</a></p>\n<h2 id=\"应用内路由协议设计思路\"><a href=\"#应用内路由协议设计思路\" class=\"headerlink\" title=\"应用内路由协议设计思路\"></a>应用内路由协议设计思路</h2><p><em>页面间跳转</em> 和 <em>组件间调用</em>, 是应用内路由协议要解决的两大问题, 举个例子来说明一下:</p>\n<ul>\n<li><em>页面跳转</em>, 如果以传统的Push来说, 我们怎么才能从任一界面push到另外任一界面, 各个界面之间的跳转必然要相互<code>Import</code>, 这些怎么解决.</li>\n<li><em>组件见调用</em>, 随着业务的模块化拆分, 各个模块之间有业务调用怎么办, 本身独立的模块, 为了相互调用必然又增加接口供外部调用, 本身相对独立的业务模块, 瞬间又变得相互耦合了.</li>\n</ul>\n<p>而路由协议正是为了解决这一类问题, 现在比较流行的路由协议有如下几种:</p>\n<ul>\n<li><a href=\"https://github.com/joeldev/JLRoutes\" target=\"_blank\" rel=\"noopener\">JLRouts</a></li>\n<li><a href=\"https://github.com/clayallsopp/routable-ios\" target=\"_blank\" rel=\"noopener\">Routable</a></li>\n<li><a href=\"https://github.com/lightory/HHRouter\" target=\"_blank\" rel=\"noopener\">HHRouter</a></li>\n<li><a href=\"https://github.com/meili/MGJRouter\" target=\"_blank\" rel=\"noopener\">MGJRouter</a></li>\n<li><a href=\"https://github.com/casatwy/CTMediator\" target=\"_blank\" rel=\"noopener\">CTMediator</a></li>\n</ul>\n<p><img src=\"https://ob6mci30g.qnssl.com/Blog/ArticleImage/40_15.png\" alt=\"URL资源\"></p>\n<p>通过上面应用间的跳转, 我们可以发现iOS 系统里面使用的是URL Scheme方式. 对于一个资源的访问，苹果也是用URL的方式来访问的, 那么我们就可以想办法通过URL来统一三端的跳转. 一段标准的URL的格式, 每一部分都代表不同的含义. 我们可以按照规则来解析接受到的URL, 从而获得有用的信息. 下面说一下我的解决方案. </p>\n<p>大致的解决思路如下:</p>\n<ol>\n<li><p>在APP开始加载时设置Module的<code>Scheme</code>, 并且初始化Module的核心类<code>HCModuleCore</code>.</p>\n<p> <code>Scheme</code>是用来标记当前APP, 每个APP的<code>Scheme</code>不尽相同, 他和应用间跳转时设置的<code>Scheme</code>是一个东西. <code>HCModuleCore</code>是个单例, 它存在于整个APP的生命周期中. </p>\n</li>\n<li><p>有一个<code>HCModuleProtocol</code>协议, 里面有几个必须要实现的方法.</p>\n<p> 如果某个类想要通过协议被跳转就必须实现该协议, 并且实现协议中的<code>@required</code>方法. <code>@optional</code>方法根据实际需要选择实现.</p>\n<pre><code> HCModuleProtocol.h\n\n @required\n /**\n 该方法返回当前类的标签, 该标签是当前类的唯一标识, 不可重复\n @return 字符串类型\n */\n + (NSString *)moduleName;\n\n @optional\n /**\n 如果是通过push方式打开, 就实现该方法, 返回当前类的self\n\n @param params 传入的参数\n @param callback 传入的block回调\n @return 实现跳转协议类的self\n */\n - (id)open:(NSDictionary *)params callback:(void(^)(NSDictionary *))callback;\n\n /**\n如果是通过present方式打开, 就实现该方法, 返回当前类的self\n\n @param params 传入的参数\n @param callback 传入的block回调\n @return 实现跳转协议类的self\n */\n - (id)open_present:(NSDictionary *)params callback:(void(^)(NSDictionary *))callback;\n</code></pre></li>\n<li><p><code>HCModuleCore</code>是个单例, 在初始化的时候, 通过runtime提供的方法把遵守``的类名缓存起来, 缓存信息存储在单例中, 存在于整个APP的生命周期中.</p>\n<pre><code> HCModuleCore.m\n\n + (instancetype)moduleCore {\n     static HCModuleCore *moduleCore;\n     static dispatch_once_t onceToken;\n     dispatch_once(&amp;onceToken, ^{\n         moduleCore = [[HCModuleCore alloc] init];\n     });\n     return moduleCore;\n }\n\n - (instancetype)init {\n     self = [super init];\n     if (self) {\n         [self cacheModuleProrocolClasses];\n     }\n     return self;\n }\n\n /**\n 把遵守HCModuleProtocol的类缓存起来\n */\n - (void)cacheModuleProrocolClasses {\n     if (_cache.count != 0) {\n         return;\n     }\n     NSMutableDictionary *tmpCache = [NSMutableDictionary dictionary];\n     Class *classes;\n     unsigned int outCount;\n     classes = objc_copyClassList(&amp;outCount);//获取全部类\n     for (int i = 0; i &lt; outCount; i++) {\n         Class class = classes[i];\n\n         //实现了HCModuleProtocol的类\n         if (class_conformsToProtocol(class, @protocol(HCModuleProtocol))) {\n             NSString *moduleName = [class moduleName];\n             //重复检查\n             NSCAssert([tmpCache objectForKey:moduleName] == nil, @&quot;in class %@, module %@ has defined, please check!&quot;, NSStringFromClass(class), moduleName);\n             [tmpCache setObject:NSStringFromClass(class) forKey:moduleName];\n         }\n     }\n     free(classes);\n     self.cache = [tmpCache copy];\n}\n</code></pre></li>\n<li><p>主要是通过传入的moduleName或者URl来获取到被打开页面的唯一标识, 再通过唯一标识从单例中缓存的遵守跳转协议的类中去找. 如果找到的话, <code>performSelector:withObject:withObject:</code>方法的返回值是响应的方法的返回值, 通过该函数获取到被跳转的类的实例. </p>\n<pre><code> HCModuleCore.m\n\n //根据moduleName返回对应注册的类\n - (id)moduleName:(NSString *)moduleName openWithParams:(NSDictionary *)params callback:(void(^)(NSDictionary *moduleInfo))callback {\n     NSCAssert(moduleName != nil, @&quot;moduleName can not be nil!&quot;);\n     id module = [self moduleName:moduleName performSelectorName:@&quot;open:callback:&quot; withParams:params callback:callback];\n     if (module == nil) {\n         module = [self moduleName:moduleName performSelectorName:@&quot;open_present:callback:&quot; withParams:params callback:callback];\n     }\n     return module;\n }\n\n //获取缓存起来的响应相应协议方法的类\n - (id)moduleName:(NSString *)moduleName performSelectorName:(NSString *)selectorName withParams:(NSDictionary *)params callback:(void(^)(NSDictionary *moduleInfo))callback {\n     NSCAssert(moduleName != nil &amp;&amp; selectorName != nil, @&quot;moduleName and selectorName can not be nil!&quot;);\n     id module;\n     NSString *clsName = self.cache[moduleName];\n     if (clsName.length) {\n         Class class = NSClassFromString(clsName);//根据缓存的类名字创建类\n         SEL selec = NSSelectorFromString(selectorName);\n         if (class) {\n             id target = [[class alloc] init];//初始化一个类的对象\n             if ([target respondsToSelector:selec]) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;\n                 //performSelector:withObject:withObject:的返回值是响应的方法的返回值\n                 module = [target performSelector:selec withObject:params withObject:callback];\n#pragma clang diagnostic pop\n             }\n         }\n     }\n     return module;\n }\n</code></pre></li>\n<li><p>然后有两个category, 分别是<code>UINavigationController+HCModuleCore</code>和<code>UIViewController+HCModuleCore</code>. 分别对应push和present的情况. 因为上面已经拿到了要跳转到的页面的实例, 这里就可以通过push或者present的方法跳转过去.   </p>\n</li>\n</ol>\n<hr>\n<p>参考文章:<br>1.<a href=\"https://halfrost.com/ios_router/\" target=\"_blank\" rel=\"noopener\">iOS 组件化 —— 路由设计思路分析</a></p>\n<p>2.<a href=\"http://awhisper.github.io/2016/06/12/%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%80%9D%E8%80%83/\" target=\"_blank\" rel=\"noopener\">路由跳转的思考</a></p>\n<p>3.<a href=\"http://wereadteam.github.io/2016/03/19/iOS-Component/\" target=\"_blank\" rel=\"noopener\">iOS组件化方案探讨</a></p>\n<p>4.<a href=\"https://casatwy.com/iOS-Modulization.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈-组件化方案</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/bb3f42fdbc31\" target=\"_blank\" rel=\"noopener\">iOS10跳转系统设置的正确姿势</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/32ca4bcda3d1\" target=\"_blank\" rel=\"noopener\">关于 iOS 系统功能的 URL 汇总列表</a></p>\n<p>7.<a href=\"http://www.jianshu.com/p/b5e8ef8c76a3\" target=\"_blank\" rel=\"noopener\">iOS应用间相互跳转</a></p>\n<p>8.<a href=\"http://www.jianshu.com/p/c83164c2aec2\" target=\"_blank\" rel=\"noopener\">从微信直接跳转到我们的APP</a></p>\n<p>9.<a href=\"http://www.jianshu.com/p/1970fd59de12\" target=\"_blank\" rel=\"noopener\">iOS Universal Links(通用链接)的使用</a></p>\n","categories":["模块化"],"tags":["模块化","路由"]},{"title":"Xcode自动化打包脚本","url":"http://hchong.net/2017/05/17/Xcode自动化打包脚本/","content":"<h1 id=\"Xcode自动化打包脚本\"><a href=\"#Xcode自动化打包脚本\" class=\"headerlink\" title=\"Xcode自动化打包脚本\"></a>Xcode自动化打包脚本</h1><p>自动化打包脚本是配合<a href=\"http://hchong.net/2017/03/12/%E5%A4%9ATarget%E5%AE%9E%E7%8E%B0/\">多渠道包和多环境包的自动化实现</a>使用的, 实际上脚本语言都可以做到, 我这里选用了Shell和Python两种实现方式. 对比下来发现, Python更好懂一点, 但是Shell更加简洁.</p>\n<h2 id=\"打包的基本思路\"><a href=\"#打包的基本思路\" class=\"headerlink\" title=\"打包的基本思路\"></a>打包的基本思路</h2><p>这里说一下打包脚本的基本实现思路:</p>\n<ol>\n<li>需要传入的参数有Scheme(用来指定打哪个环境的包), 如果使用Fir来作为内测分发工具的话, 还需要传入Fir的Token.</li>\n<li>在脚本内需要指定工程的路径, 工程名, Archive包的路径, IPA包的路径.</li>\n<li>通过Xcodebuild命令行生成Archive包.</li>\n<li>根据生成的Archive包导出IPA包.</li>\n<li>上传IPA包到Fir.</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>Xcode8.3后, 需要一个打包参数配置的plist文件, 生成Archive包时会用到.</li>\n<li>shell脚本需要给权限<code>chomd 777 xx.sh</code>.</li>\n<li>Archive导出为IPA有时会报错<code>Code=14 &quot;No applicable devices found.&quot;</code>, 这个多少是Ruby的路径没有指定导致, 找了一大圈有两个解决方案:<ol>\n<li>通过<code>sudo gem install CFPropertyList</code>, <code>rvm list</code>, <code>rvm use system</code>来解决, Python或者Shell都可以使用这种方式.</li>\n<li>Shell下还有另外的解决方案, 在shell脚本前加入如下代码, 指定路径.<pre><code>[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot;\nrvm use system\nxcodebuild &quot;$@&quot;\n</code></pre></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Xcode8-3后的plist文件\"><a href=\"#Xcode8-3后的plist文件\" class=\"headerlink\" title=\"Xcode8.3后的plist文件\"></a>Xcode8.3后的plist文件</h2><p>使用<code>xcodebuild -help</code> 可以查看Xcodebuild相关介绍</p>\n<pre><code>Available keys for -exportOptionsPlist:\n\n    compileBitcode : Bool\n\n        For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.\n\n    embedOnDemandResourcesAssetPacksInBundle : Bool\n\n        For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.\n\n    iCloudContainerEnvironment\n\n        For non-App Store exports, if the app is using CloudKit, this configures the &quot;com.apple.developer.icloud-container-environment&quot; entitlement. Available options: Development and Production. Defaults to Development.\n\n    manifest : Dictionary\n\n        For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.\n\n    method : String\n\n        Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.\n\n    onDemandResourcesAssetPacksBaseURL : String\n\n        For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn&#39;t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.\n\n    teamID : String\n\n        The Developer Portal team to use for this export. Defaults to the team used to build the archive.\n\n    thinning : String\n\n        For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. &quot;iPhone7,1&quot;). Defaults to &lt;none&gt;.\n\n    uploadBitcode : Bool\n\n        For App Store exports, should the package include bitcode? Defaults to YES.\n\n    uploadSymbols : Bool\n\n        For App Store exports, should the package include symbols? Defaults to YES.\n</code></pre><p>我们在工程中新建一个plist文件, 可以看出, 大部分是有默认值的, 所以我们不用每个选项都填, 只写一些必填的就可以. </p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;\n&lt;plist version=&quot;1.0&quot;&gt;\n    &lt;dict&gt;\n        &lt;key&gt;method&lt;/key&gt;\n        &lt;string&gt;enterprise&lt;/string&gt;\n        &lt;key&gt;uploadSymbols&lt;/key&gt;\n        &lt;true/&gt;\n        &lt;key&gt;uploadBitcode&lt;/key&gt;\n        &lt;false/&gt;\n    &lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre><hr>\n<p><a href=\"https://github.com/HChong3210/buildScript.git\" target=\"_blank\" rel=\"noopener\">附件下载</a></p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"https://diaojunxian.github.io/2016/10/21/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%B8%83/\" target=\"_blank\" rel=\"noopener\">自动化测试-持续集成(7)</a></p>\n<p>2.<a href=\"http://stackoverflow.com/questions/33041109/xcodebuild-no-applicable-devices-found-when-exporting-archive\" target=\"_blank\" rel=\"noopener\">xcodebuild: “No applicable devices found.” when exporting archive</a></p>\n<p>3.<a href=\"\"></a></p>\n","categories":["自动化打包"],"tags":["自动化打包","Target","解决方案"]},{"title":"Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系","url":"http://hchong.net/2017/05/16/Settings关系/","content":"<h1 id=\"Xcode中的Workspace-Scheme-Project-Target和Build-Settings的关系\"><a href=\"#Xcode中的Workspace-Scheme-Project-Target和Build-Settings的关系\" class=\"headerlink\" title=\"Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系\"></a>Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系</h1><h2 id=\"Xcode-Workspace\"><a href=\"#Xcode-Workspace\" class=\"headerlink\" title=\"Xcode Workspace\"></a>Xcode Workspace</h2><p>官方文档如下: </p>\n<blockquote>\n<p>A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets.</p>\n</blockquote>\n<p>workspace是Xcode的一种文件，用来管理工程和里面的文件，一个workspace可以包含若干个工程，甚至可以添加任何你想添加的文件。workspace提供了工程和工程里面的target之间隐式和显式依赖关系，用来管理和组织工程里面的所有文件.</p>\n<p> 一个workspace可以管理多个Project, <code>pod install</code>的过程就是生成了一个workspace和一个全是Pod组件的Project, 然后我们通过生成的workspace来管理新生成的Project和原本的Project.</p>\n<h2 id=\"Xcode-Project\"><a href=\"#Xcode-Project\" class=\"headerlink\" title=\"Xcode Project\"></a>Xcode Project</h2><p>官方文档如下:</p>\n<blockquote>\n<p>An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings).</p>\n</blockquote>\n<p>project就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。</p>\n<p>Xcode中的 project里面包含了所有的源文件，资源文件和构建一个或者多个product的信息。project利用他们去编译我们所需的product，也帮我们组织它们之间的关系。一个project可以包含一个或者多个target。project定义了一些基本的编译设置，每个target都继承了project的默认设置，每个target可以通过重新设置target的编译选项来定义自己的特殊编译选项。</p>\n<p>project包含了以下信息：</p>\n<ul>\n<li>源文件<ul>\n<li>代码的头文件和实现文件</li>\n<li>静态库，动态库，</li>\n<li>资源文件(如文本，xml，plist等)</li>\n<li>图片资源</li>\n<li>界面资源文件(xib， storyboard等)</li>\n</ul>\n</li>\n<li>在文件结构的导航中，采用group去组织文件(实际开发中，尽量使用实体文件夹)</li>\n<li>project的编译级别配置文件如(debug， release)</li>\n<li>target</li>\n<li>运行环境如：debug，test</li>\n</ul>\n<p>project可以单独存在，或者存在于一个workspace中.<br>​    </p>\n<h2 id=\"Xcode-Target\"><a href=\"#Xcode-Target\" class=\"headerlink\" title=\"Xcode Target\"></a>Xcode Target</h2><p>官方文档如下:</p>\n<blockquote>\n<p>A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.</p>\n</blockquote>\n<p>target 定义了生成的唯一 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product.</p>\n<p>这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode 的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;Build Phases)中进行查看和编辑。target 中的 build setting 参数继承自 project 的 build settings, 但是你可以在 target 中修改任意 settings 来重写 project settings，这样，最终生效的 settings 参数以在 target 中设置的为准. Project 可包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效.</p>\n<p>target 和其生成的 product 可与另一个 target 有关，如果一个 target 的 build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个 target .如果这些 target 在同一个 workspace 中，那么 Xcode 能够发现这种依赖关系，从而使其以我们期望的顺序生成 products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets 之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。</p>\n<p>指定 targets 之间的依赖关系的地方在 Project Editor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置.</p>\n<h2 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h2><p>官方文档如下:</p>\n<blockquote>\n<p>An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.</p>\n</blockquote>\n<p>一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。指定了编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等。可以通过scheme editor来编辑scheme.</p>\n<blockquote>\n<p>You can have as many schemes as you want, but only one can be active at a time. You can specify whether a scheme should be stored in a project—in which case it’s available in every workspace that includes that project, or in the workspace—in which case it’s available only in that workspace. When you select an active scheme, you also select a run destination (that is, the architecture of the hardware for which the products are built).</p>\n</blockquote>\n<p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>\n<h2 id=\"Build-Settings\"><a href=\"#Build-Settings\" class=\"headerlink\" title=\"Build Settings\"></a>Build Settings</h2><p>官方文档如下:</p>\n<blockquote>\n<p>A build setting is a variable that contains information about how a particular aspect of a product’s build process should be performed. For example, the information in a build setting can specify which options Xcode passes to the compiler.</p>\n</blockquote>\n<p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>\n<p>build setting 中包含了 product 生成过程中所需的参数信息。你可以在 project-level 和 target-level 层指定 build settings。project-level 的 build settings 适用于 project 中的所有targets，但是当 target-level 的 build settings 重写了 project-level 的 build settings，以 target-level 中的 build settings 中的值为准</p>\n<p>一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 build configarations, 分别用于生成 debug 和 release 模式下的 product。</p>\n<p>除了创建工程时生成的默认 build settings，你也可以自定义 project-level 或者 target-level 的 build settings.</p>\n<p>关于继承关系，<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html#BuildSettingInheritance\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a> 这里也有详细的说明，强烈建议阅读。</p>\n<p>动态环境配置就是使用自定义的 build settings 来实现的.</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/\" target=\"_blank\" rel=\"noopener\">Xcode使用xcconfig文件配置环境</a>.<br>​<br>2.<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html\" target=\"_blank\" rel=\"noopener\">Apple官方文档</a>.</p>\n<p>3.<a href=\"https://xiuchundao.me/post/xcode-scheme-and-build-configuration\" target=\"_blank\" rel=\"noopener\">Xcode中的Scheme和Build Configuration</a>.</p>\n<p>4.<a href=\"http://www.jianshu.com/p/1f312abafeff\" target=\"_blank\" rel=\"noopener\">Xcode workSpace 多个project联编</a></p>\n<p>5.<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html#BuildSettingInheritance\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a></p>\n","categories":["基础知识"],"tags":["基础知识","Target"]},{"title":"通讯录数据的读取和性能优化","url":"http://hchong.net/2017/04/23/通讯录数据的读取和性能优化/","content":"<h1 id=\"通讯录数据的读取和性能优化\"><a href=\"#通讯录数据的读取和性能优化\" class=\"headerlink\" title=\"通讯录数据的读取和性能优化\"></a>通讯录数据的读取和性能优化</h1><p>前段时间再做一个关于通讯录相关的项目, 记录一下通讯录相关的基础和读取优化的部分. 在本篇文章中, 我主要侧重读取通讯录数据方面, 至于调用原生的界面在这里则不做阐述. 关于通讯录的API, 在iOS9之后做了较大的调整, 使用<code>Contacts Framework</code>替代<code>AddressBookFramework</code>. 下面我将就iOS9和iOS8两种API进行分析.</p>\n<h2 id=\"通讯录的授权\"><a href=\"#通讯录的授权\" class=\"headerlink\" title=\"通讯录的授权\"></a>通讯录的授权</h2><p>既然要读取通讯录, 那么通讯录授权状态的查询, 要放在在前面, 这里也区分iOS9和iOS8系统.</p>\n<h3 id=\"iOS8查询通讯录授权状态\"><a href=\"#iOS8查询通讯录授权状态\" class=\"headerlink\" title=\"iOS8查询通讯录授权状态\"></a>iOS8查询通讯录授权状态</h3><pre><code>+ (void)checkAddressBookAuthorization:(void (^)(bool isAuthorized))block {\n    ABAddressBookRef addressBookRef =  ABAddressBookCreateWithOptions(NULL, NULL);\n    switch (ABAddressBookGetAuthorizationStatus()) {\n        case kABAuthorizationStatusNotDetermined: {\n            NSLog(@&quot;未询问用户是否授权&quot;);\n            ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) {\n                if (granted) {\n                    NSLog(@&quot;授权可以读取&quot;);\n                    block(YES);\n                } else {\n                    NSLog(@&quot;授权不能读取&quot;);\n                    block(NO);\n                }\n            });\n        } break;\n        case kABAuthorizationStatusAuthorized: {\n            NSLog(@&quot;同意授权通讯录&quot;);\n            block(YES);\n        } break;\n        case kABAuthorizationStatusDenied: {\n            block(NO);\n            NSLog(@&quot;未授权，用户拒绝造成的&quot;);\n        } break;\n        case kABAuthorizationStatusRestricted: {\n            block(NO);\n            NSLog(@&quot;未授权，例如家长控制&quot;);\n        } break;\n        default: {\n        } break;\n    }\n}\n</code></pre><h3 id=\"iOS9查询通讯录授权状态\"><a href=\"#iOS9查询通讯录授权状态\" class=\"headerlink\" title=\"iOS9查询通讯录授权状态\"></a>iOS9查询通讯录授权状态</h3><pre><code>- (void)addressBookEmpowerCheck {\n    CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts];\n    switch (status) {\n        case CNAuthorizationStatusNotDetermined: {\n            [[[CNContactStore alloc]init] requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n                NSLog(@&quot;还没问&quot;);\n                if (granted) {\n                    NSLog(@&quot;点击了同意&quot;);\n                } else {\n                    NSLog(@&quot;点击了拒绝&quot;);\n                }\n            }];\n        }\n        break;\n        case CNAuthorizationStatusRestricted: {\n            NSLog(@&quot;未授权, 例如家长控制&quot;);\n        }\n        break;\n        case CNAuthorizationStatusDenied: {\n            NSLog(@&quot;未授权, 用户拒绝所致&quot;);\n        }\n        break;\n        case CNAuthorizationStatusAuthorized: {\n            NSLog(@&quot;已经授权&quot;);\n        }\n        break;\n        default: {\n        }\n        break;\n    }\n}\n</code></pre><p>注意: 如果是iOS10的系统需要在<code>Info.plist</code>配置<code>NSContactsUsageDescription</code></p>\n<pre><code>&lt;key&gt;NSContactsUsageDescription&lt;/key&gt;\n&lt;string&gt;请求访问通讯录&lt;/string&gt;\n</code></pre><h2 id=\"通讯录数据写入和删除\"><a href=\"#通讯录数据写入和删除\" class=\"headerlink\" title=\"通讯录数据写入和删除\"></a>通讯录数据写入和删除</h2><p>当通讯录数据少时, 数据的读取耗时较少, 为了更好地测试大量数据下的性能问题, 我们先写入大量的数据来进行测试. </p>\n<h3 id=\"iOS8写入联系人\"><a href=\"#iOS8写入联系人\" class=\"headerlink\" title=\"iOS8写入联系人\"></a>iOS8写入联系人</h3><pre><code>- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone {\n    if((name.length &lt; 1)||(phone.length &lt; 1)){\n        NSLog(@&quot;输入属性不能为空&quot;);\n        return;\n    }\n    CFErrorRef error = NULL;\n\n    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, &amp;error);\n    ABRecordRef newRecord = ABPersonCreate();\n    ABRecordSetValue(newRecord, kABPersonFirstNameProperty, (__bridge CFTypeRef)name, &amp;error);\n\n    ABMutableMultiValueRef multi = ABMultiValueCreateMutable(kABMultiStringPropertyType);\n    ABMultiValueAddValueAndLabel(multi, (__bridge CFTypeRef)name, kABPersonPhoneMobileLabel, NULL);\n\n    ABRecordSetValue(newRecord, kABPersonPhoneProperty, multi, &amp;error);\n    CFRelease(multi);\n\n    ABAddressBookAddRecord(addressBook, newRecord, &amp;error);\n    CFRelease(newRecord);\n    CFRelease(addressBook);\n}\n</code></pre><p>需要注意的是, 在本例中, 只填写了<code>FirstName</code>和<code>phone</code>, 实际还有许多其他属性可供选择, 具体参照<code>ABAddressBookRef</code>和<code>ABRecordRef</code>需要调用<code>CFRelease</code>来释放内存.</p>\n<h3 id=\"iOS9写入联系人\"><a href=\"#iOS9写入联系人\" class=\"headerlink\" title=\"iOS9写入联系人\"></a>iOS9写入联系人</h3><pre><code>- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone {\n    // 创建对象\n    CNMutableContact * contact = [[CNMutableContact alloc]init];\n    contact.givenName = name?:@&quot;defaultname&quot;;\n    CNLabeledValue *phoneNumber = [CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberMobile value:[CNPhoneNumber phoneNumberWithStringValue:phone?:@&quot;10086&quot;]];\n    contact.phoneNumbers = @[phoneNumber];\n\n    // 把对象加到请求中\n    CNSaveRequest * saveRequest = [[CNSaveRequest alloc]init];\n    [saveRequest addContact:contact toContainerWithIdentifier:nil];\n\n    // 执行请求\n    CNContactStore * store = [[CNContactStore alloc]init];\n    [store executeSaveRequest:saveRequest error:nil];\n}\n</code></pre><p>更稳健一点的写法, 是可以把请求放在通讯录授权判断的block中</p>\n<pre><code>    CNContactStore *store = [[CNContactStore alloc] init];\n    [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!granted) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                //失败原因\n            });\n            return;\n        }\n        //do something\n    }];\n</code></pre><p>使用下面这种方式</p>\n<pre><code> - (void)addContactWithName:(NSString *)name {\n\n    CNContactStore *store = [[CNContactStore alloc] init];\n    [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {\n        if (!granted) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                //失败原因\n            });\n            return;\n        }\n\n        CNMutableContact *contact = [[CNMutableContact alloc] init];\n        contact.familyName = @&quot;Doe&quot;;\n        contact.givenName = @&quot;John&quot;;\n\n        CNLabeledValue *homePhone = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:[CNPhoneNumber phoneNumberWithStringValue:@&quot;312-555-1212&quot;]];\n        contact.phoneNumbers = @[homePhone];\n\n        CNSaveRequest *request = [[CNSaveRequest alloc] init];\n        [request addContact:contact toContainerWithIdentifier:nil];\n\n        // save it\n        NSError *saveError;\n        if (![store executeSaveRequest:request error:&amp;saveError]) {\n            NSLog(@&quot;error = %@&quot;, saveError);\n        }\n    }];\n}\n</code></pre><h3 id=\"iOS8删除联系人\"><a href=\"#iOS8删除联系人\" class=\"headerlink\" title=\"iOS8删除联系人\"></a>iOS8删除联系人</h3><pre><code>- (void)removeItemWithName:(NSString *)name phone:(NSString *)phone {\n    ABAddressBookRef addressbook = ABAddressBookCreate();\n    CFStringRef nameRef = (__bridge CFStringRef) name;\n    CFArrayRef  allSearchRecords = ABAddressBookCopyPeopleWithName(addressbook, nameRef);\n    if (allSearchRecords != NULL)\n    {\n        CFIndex count = CFArrayGetCount(allSearchRecords);\n        for (int i = 0; i &lt; count; ++i)\n        {\n            ABRecordRef contact = CFArrayGetValueAtIndex(allSearchRecords, i);\n            ABAddressBookRemoveRecord(addressbook, contact, nil);\n        }\n    }\n    ABAddressBookSave(addressbook, nil);\n    CFRelease(addressbook);\n}\n</code></pre><h3 id=\"iOS9删除联系人\"><a href=\"#iOS9删除联系人\" class=\"headerlink\" title=\"iOS9删除联系人\"></a>iOS9删除联系人</h3><pre><code>- (void)removeContactWithName:(NSString *)name {\n    CNContactStore *store = [[CNContactStore alloc] init];\n    NSPredicate *predicate = [CNContact predicateForContactsMatchingName:name];\n    NSArray *contacts = [store unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey, CNContactFamilyNameKey] error:nil];\n\n    for (CNMutableContact *contact in contacts) {\n        CNSaveRequest *request = [[CNSaveRequest alloc] init];\n        [request deleteContact:contact];\n        // save it\n        NSError *saveError;\n        if (![store executeSaveRequest:request error:&amp;saveError]) {\n            NSLog(@&quot;error = %@&quot;, saveError);\n        }\n    }\n}\n</code></pre><h2 id=\"通讯录数据读取\"><a href=\"#通讯录数据读取\" class=\"headerlink\" title=\"通讯录数据读取\"></a>通讯录数据读取</h2><p>通过上面的一通操作, 我们已经可以创建和删除通讯录了, 那么我们就通过批量写入通讯录数据, 来进行通讯录数据的读取, 并且按照姓名和首字母分组排序. 相应的, 此处我们也区分<code>iOS8</code>和<code>iOS9</code>下面两个不同的框架.</p>\n<h3 id=\"iOS8读取联系人\"><a href=\"#iOS8读取联系人\" class=\"headerlink\" title=\"iOS8读取联系人\"></a>iOS8读取联系人</h3><pre><code>+ (NSArray *)getAllContact {\n    NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];\n\n    CFErrorRef *error = NULL;\n    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, error);\n\n    CFIndex numberOfPeople = ABAddressBookGetPersonCount(addressBook);\n    CFArrayRef people = ABAddressBookCopyArrayOfAllPeople(addressBook);\n    if (numberOfPeople == 0) {\n        CFRelease(people);\n        CFRelease(addressBook);\n        return @[];\n    }\n    for ( int i = 0; i &lt; numberOfPeople; i++){\n        AddressBookContact *contact = [[AddressBookContact alloc] init];\n\n        ABRecordRef person = CFArrayGetValueAtIndex(people, i);\n\n        //姓名\n        NSString *firstName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonFirstNameProperty));\n        NSString *lastName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonLastNameProperty));\n        NSString *name = [NSString stringWithFormat:@&quot;%@%@&quot;, lastName, firstName;\n        contact.name = name;\n\n        //第一次添加该条记录的时间戳\n        NSDate *createDate = (NSDate *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonCreationDateProperty));\n        NSTimeInterval timeIn = [createDate timeIntervalSince1970];\n        NSInteger createTime = round(timeIn);\n        contact.createTime = [NSString stringWithFormat:@&quot;%010ld&quot;, (long)createTime];\n\n        //读取电话多值\n        ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty);\n        NSArray *arr = (NSArray *)CFBridgingRelease(ABMultiValueCopyArrayOfAllValues(phone));\n        contact.phone = [AddressBookData filterPhoneFormate:[arr lastObject]];\n\n        if (contact.phone.length &gt; 0) {\n            [array addObject:contact];\n        }\n    }\n    CFRelease(people);\n    CFRelease(addressBook);\n    return array;\n}\n\n//剔除手机号中的特殊字符\n+ (NSString *)filterPhoneFormate:(NSString *)phoneNumber {\n    NSCharacterSet *notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];\n    NSString *resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@&quot;&quot;];\n    return resultString;\n}\n</code></pre><h3 id=\"iOS9读取联系人\"><a href=\"#iOS9读取联系人\" class=\"headerlink\" title=\"iOS9读取联系人\"></a>iOS9读取联系人</h3><pre><code>    // 创建通信录对象\n    CNContactStore *contactStore = [[CNContactStore alloc] init];\n\n    // 创建获取通信录的请求对象\n    // 拿到所有打算获取的属性对应的key\n    NSArray *keys = @[CNContactGivenNameKey, CNContactFamilyNameKey, CNContactPhoneNumbersKey];\n\n    // 创建CNContactFetchRequest对象\n    CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:keys];\n\n    // 遍历所有的联系人\n    [contactStore enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) {\n        // 获取联系人的姓名\n        NSString *lastname = contact.familyName;\n        NSString *firstname = contact.givenName;\n        NSLog(@&quot;%@ %@&quot;, lastname, firstname);\n\n        // 获取联系人的电话号码\n        NSArray *phoneNums = contact.phoneNumbers;\n        for (CNLabeledValue *labeledValue in phoneNums) {\n            // 获取电话号码的KEY\n            NSString *phoneLabel = labeledValue.label;\n\n            // 获取电话号码\n            CNPhoneNumber *phoneNumer = labeledValue.value;\n            NSString *phoneValue = phoneNumer.stringValue;\n\n            NSLog(@&quot;%@ %@&quot;, phoneLabel, phoneValue);\n            AddressBookContact *contact = [[AddressBookContact alloc] init];\n            contact.name = [NSString stringWithFormat:@&quot;%@%@&quot;,lastname,firstname];\n            person.phone = phoneValue;\n            [_addressBookArray addObject:contact];\n        }\n    }];\n</code></pre><p>我们通过上面的方法拿到的数据是一个元素是我们自定义数据模型<code>AddressBookContact</code>的数组, 所有的数据都在这一个数组里面, 没有分组, 相同首字母的联系人按照创建时间来排序.显然这样的数据是不能满足我们业务需求的. 常见的是按照首字母来分组, 下面我们就以iOS8为例来对数据进行分组排序和展示, 类似于系统通讯录列表.</p>\n<h3 id=\"通讯录分组\"><a href=\"#通讯录分组\" class=\"headerlink\" title=\"通讯录分组\"></a>通讯录分组</h3><pre><code>//返回包含分组信息和分组后通讯录数据的字典\n+ (NSDictionary *)dealDataWithArray:(NSArray *)array {\n    if (array.count == 0) {\n        return nil;\n    }\n    NSMutableArray *titleArray = [NSMutableArray arrayWithCapacity:0];\n    NSMutableArray *data = [NSMutableArray arrayWithCapacity:0];\n    NSMutableArray * tmpArray = [[NSMutableArray alloc]init];\n    for (NSInteger i =0; i &lt;27; i++) {\n        //给临时数组创建27个数组作为元素，用来存放A-Z和#开头的联系人\n        NSMutableArray * array = [[NSMutableArray alloc]init];\n        [tmpArray addObject:array];\n    }\n\n    for (AddressBookContact * model in array) {\n        //AddressMode是联系人的数据模型\n        //转化为首拼音并取首字母\n        NSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\n        if (nickName.length == 0) {\n            //如果不是，就放到最后一个代表#的数组\n            NSMutableArray * array =[tmpArray lastObject];\n            [array addObject:model];\n        } else {\n            int firstWord = [nickName characterAtIndex:0];\n            //把字典放到对应的数组中去\n\n            if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n                //如果首字母是A-Z，直接放到对应数组\n                NSMutableArray * array = tmpArray[firstWord - 65];\n                [array addObject:model];\n\n            } else {\n                //如果不是，就放到最后一个代表#的数组\n                NSMutableArray * array =[tmpArray lastObject];\n                [array addObject:model];\n            }\n        }\n    }\n\n    //此时数据已按首字母排序并分组\n    //遍历数组，删掉空数组\n    for (NSMutableArray * mutArr in tmpArray) {\n        //如果数组不为空就添加到数据源当中\n        if (mutArr.count != 0) {\n            [data addObject:mutArr];\n            AddressBookContact * model = mutArr[0];\n            NSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\n            if (nickName.length != 0) {\n                int firstWord = [nickName characterAtIndex:0];\n                //取出其中的首字母放入到标题数组，暂时不考虑非A-Z的情况\n                if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n                    [titleArray addObject:nickName];\n                }\n            }\n        }\n    }\n\n    //判断是否需要加#\n    if (titleArray.count != data.count) {\n        [titleArray addObject:@&quot;#&quot;];\n    }\n\n    NSDictionary *dic = @{@&quot;source&quot;: [AddressBookDataManager sortedArray:data],\n                          @&quot;title&quot;: titleArray};\n    return dic;\n}\n\n+ (NSArray *)sortedArray:(NSArray *)data {\n    NSMutableArray *sortedArray = [NSMutableArray array];\n    for (NSInteger index = 0; index &lt; data.count; index++) {\n        NSMutableArray *personArrayForSection = data[index];\n        NSArray *temp = [personArrayForSection sortedArrayUsingComparator:^NSComparisonResult(AddressBookContact * contact1, AddressBookContact * contact2) {\n            return [contact1.name compare:contact2.name];\n        }];\n        sortedArray[index] = temp;\n    }\n    return sortedArray;\n}\n\n\n#pragma mark - Tool\n+ (BOOL)objectIsNull:(id)obj{\n    return ([obj isKindOfClass:[NSNull class]] || obj == nil) ? YES : NO;\n}\n\n+ (NSString*)strNoNull:(id)str{\n    if ([AddressBookDataManager objectIsNull:str]) {\n        str = @&quot;&quot;;\n    }\n    return str;\n}\n\n//汉字转拼音并取得关键字\n+ (NSString *)returnFirstWordWithString:(NSString *)str {\n    NSMutableString * mutStr = [NSMutableString stringWithString:str];\n\n    //将mutStr中的汉字转化为带音标的拼音（如果是汉字就转换，如果不是则保持原样）\n    CFStringTransform((__bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformMandarinLatin, NO);\n    //将带有音标的拼音转换成不带音标的拼音（这一步是从上一步的基础上来的，所以这两句话一句也不能少）\n    CFStringTransform((__bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformStripCombiningMarks, NO);\n    if (mutStr.length &gt; 0) {\n        //全部转换为大写    取出首字母并返回\n        NSString * res = [[mutStr uppercaseString] substringToIndex:1];\n        return res;\n    } else {\n        return @&quot;&quot;;\n    }\n}\n\n//剔除手机号中的特殊字符\n+ (NSString *)filterPhoneFormate:(NSString *)phoneNumber {\n    NSCharacterSet *notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];\n    NSString *resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@&quot;&quot;];\n    return resultString;\n}\n</code></pre><p><img src=\"http://ohjcp7fjy.bkt.clouddn.com/IMG_0277.PNG\" alt=\"数据截图\"><br>至此, 我们可以得到符合业务需求的通讯录页面, 已经按照姓名首字母分组, 并且实现了快速索引. 我的通讯录测试数据有2700+条数据, 每次通讯录打开都要耗时特别久, 为了更好的用户体验, 这时就会想到要优化一下代码了.</p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p>说道性能优化, 首先就要进行性能分析, 知道我们需要优化的地方在哪里. Xcode提供了一个强大的分析工具Instruments, 具体一些常见的分析可以参考<a href=\"http://hchong.net/2017/04/13/Xcode%E7%A5%9E%E5%99%A8-Instruments%E5%A4%A7%E6%B3%95/\">这里</a>.<br>我们主要使用Instruments的Time ProFiler来分析一下, 究竟耗时的代码在哪里, 并且做一下优化.<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1ffevnuzt0zj30pg0e2wfj.jpg\" alt=\"耗时操作\"><br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1ffevnwtfovj317m0q440f.jpg\" alt=\"耗时操作的具体代码\"><br>通过分析可以发现, 目前的瓶颈主要出现在汉字转拼音取首字母的方法上, 可以发现我们使用的是<code>CFStringTransform</code>类, 我们先对这个进行一些优化</p>\n<pre><code>//汉字首字母\n+ (NSString *)returnFirstWordWithString:(NSString *)str {\n    NSMutableString *mutableString = [NSMutableString stringWithString:str];\n    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);\n    mutableString = (NSMutableString *)[mutableString stringByFoldingWithOptions:NSDiacriticInsensitiveSearch locale:[NSLocale currentLocale]];\n    NSString *string = [mutableString stringByReplacingOccurrencesOfString:@&quot;&#39;&quot; withString:@&quot;&quot;];\n    return [[string uppercaseString] substringToIndex:1];\n}\n</code></pre><p>再使用Instruments分析发现, 并没有什么太大的效果. 分析一下发现, 发现我们取首字母主要有两个用途.一个是把全部通讯录按照首字母的方式进行分组, 另一个用途就是为了在列表页生成索引数组. </p>\n<h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><p>一番查找发现, 系统针对这种情况已经有API可供我们调用了(贴心的Apple).下面就要介绍本次优化的关键类<code>UILocalizedIndexedCollation</code>.</p>\n<blockquote>\n<p>返回传入object对象指定selector在[UILocalizedIndexedCollation currentCollation]中的匹配的索引<br>// Returns the index of the section that will contain the object.<br>// selector must not take any arguments and return an NSString.</p>\n<pre><code>- (NSInteger)sectionForObject:(id)object collationStringSelector:(SEL)selector;\n</code></pre><p>返回传入object对象指定selector在[UILocalizedIndexedCollation currentCollation]中的匹配的索引<br>// Returns the index of the section that will contain the object.<br>// selector must not take any arguments and return an NSString.</p>\n<pre><code>- (NSInteger)sectionForObject:(id)object collationStringSelector:(SEL)selector;\n-\n</code></pre></blockquote>\n<pre><code>+ (NSDictionary *)dealDataWithArray:(NSArray *)array {\n\n    // 1.初始化一个索引，根据不同国家语言，会初始化出不同的索引，中文的是“A~Z,#”\n    UILocalizedIndexedCollation *collation = [UILocalizedIndexedCollation currentCollation];\n    // 2.获取索引的数量，并初始化对应数量的空数组，用于存放筛选数据\n    NSInteger sectionTitlesCount = [[collation sectionTitles] count];\n    NSMutableArray *sectionArrays = [NSMutableArray arrayWithCapacity:sectionTitlesCount];\n    for (int i = 0; i &lt; sectionTitlesCount; i++) {\n        NSMutableArray *sectionArray = [NSMutableArray arrayWithCapacity:1];\n        [sectionArrays addObject:sectionArray];\n    }\n    // 3.排序的方法\n    SEL sorter = ABPersonGetSortOrdering() == kABPersonSortByFirstName ? NSSelectorFromString(@&quot;name&quot;) : NSSelectorFromString(@&quot;name&quot;);\n    // 4.分组\n    for (AddressBookContact *contact in array) {\n        //获取name属性的值所在的位置，比如&quot;小白鼠&quot;，首字母是X，在A~Z中排第23（第一位是0），sectionNumber就为23\n        NSInteger sectionNumber = [collation sectionForObject:contact collationStringSelector:sorter];\n        //把name为“小白鼠”的contact加入newSectionsArray中的第23个数组中去\n        NSMutableArray *sectionNames = sectionArrays[sectionNumber];\n        [sectionNames addObject:contact];\n    }\n    //5.排序\n    for (NSInteger i = 0; i &lt; sectionTitlesCount; i++) {\n        NSMutableArray *personArrayForSection = sectionArrays[i];\n        NSArray *sortedPersonArrayForSection = [collation sortedArrayFromArray:personArrayForSection collationStringSelector:@selector(name)];\n        sectionArrays[i] = sortedPersonArrayForSection;\n    }\n\n    NSArray *titleArray = [[[UILocalizedIndexedCollation currentCollation] sectionTitles] copy];\n    NSDictionary *dic = @{@&quot;source&quot;: sectionArrays,\n                          @&quot;title&quot;: titleArray};\n    return dic;\n    }\n</code></pre><p>分析一下上面的代码, 我们使用<code>UILocalizedIndexedCollation</code>提供的方法, 按照A-Z来快读数据进行分组, 并且排序. 索引数组也直接使用<code>UILocalizedIndexedCollation</code>自带的方法.这样就避免了大量的循环遍历和取姓名拼音首字母造成的开销.</p>\n<p>相应的, 列表展示页面的title和索引也要做调整</p>\n<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{\n    if ([self.dataArray[section] count] == 0 || self.dataArray.count == 0) {\n        return 0.01;\n    }\n    return 22;\n}\n\n// 按照索引个数配置tableview区数\n- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {\n    if ([self.dataArray[section] count] == 0 || self.dataArray.count == 0) {\n        return @&quot;&quot;;\n    }\n    return [[UILocalizedIndexedCollation currentCollation] sectionTitles][section];\n}\n\n// 配置索引内容，就是通讯录中右侧的那一列“A~Z、#”\n- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView {\n    return [[UILocalizedIndexedCollation currentCollation] sectionIndexTitles];\n}\n\n// 索引点击响应\n- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index {\n    return [[UILocalizedIndexedCollation currentCollation] sectionForSectionIndexTitleAtIndex:index];\n}\n</code></pre><p>至此优化结束, 再通过Time Profiler来分析下发现时间已经从5.8s到2.6s, 优化效果还是很明显的. 2.6s中数组排序大概耗时1.7s, 我们使用的已经是系统推荐的排序方法, 除非采用复杂度更低的排序算法, 这里已经没办法再优化了.</p>\n<p>这里有三种不同实现的排序方法, 测试了下, 优化效果都不明显</p>\n<pre><code>+ (NSArray *)sortedArray:(NSArray *)data {\n    //        NSMutableArray *sortedArray = [NSMutableArray array];\n    //        //对每个section中的数组按照name属性排序\n    //        for (NSInteger index = 0; index &lt; data.count; index++) {\n    //            NSMutableArray *personArrayForSection = data[index];\n    //            NSSortDescriptor *nameDesc    = [NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot;\n    //                                                                          ascending:YES];\n    //            NSArray *descriptorArray = @[nameDesc];//此处可以按照多个排序规则, 顺序比较, 比较的顺序就是数组里面元素的顺序\n    //\n    //            NSArray *temp = [personArrayForSection sortedArrayUsingDescriptors: descriptorArray];\n    //            sortedArray[index] = temp;\n    //        }\n\n\n    NSMutableArray *sortedArray = [NSMutableArray array];\n    for (NSInteger index = 0; index &lt; data.count; index++) {\n        NSMutableArray *personArrayForSection = data[index];\n        NSArray *temp = [personArrayForSection sortedArrayUsingComparator:^NSComparisonResult(AddressBookContact * contact1, AddressBookContact * contact2) {\n            return [contact1.name compare:contact2.name];\n        }];\n        sortedArray[index] = temp;\n    }\n\n\n\n    //    UILocalizedIndexedCollation *collation = [UILocalizedIndexedCollation currentCollation];\n    //    NSMutableArray *sortedArray = [NSMutableArray array];\n    //    //对每个section中的数组按照name属性排序\n    //    for (NSInteger index = 0; index &lt; data.count; index++) {\n    //        NSMutableArray *personArrayForSection = data[index];\n    //        NSArray *sortedPersonArrayForSection = [collation sortedArrayFromArray:personArrayForSection collationStringSelector:@selector(name)];\n    //        sortedArray[index] = sortedPersonArrayForSection;\n    //    }\n    return sortedArray;\n}\n</code></pre><h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><p>至于第二种优化方案, 我们需要借助本地化存储SQL来实现. 当然如果没有本地化存储的需求, 则方案一就够用了.</p>\n<p>因为主要耗时的操作在分组和排序上, 我么你可以利用SQL的快速查找和排序来实现.在3000条左右数据时和方案一的效果差不多, 此处就不再贴代码了, 只提供一下思路.</p>\n<h2 id=\"监听通讯录数据变化\"><a href=\"#监听通讯录数据变化\" class=\"headerlink\" title=\"监听通讯录数据变化\"></a>监听通讯录数据变化</h2><p>此处仍然区分iOS8和iOS9的API, 但是需要注意监听规则:<br>1.当App活跃（前台+后台包活期间）的时候, 当通讯录修改的时候, 会收到通知.<br>2.当App不活跃的时候(挂起的时候), App收不到通知; 而是, 当App到前台的时候收到延迟的通知.<br>3.当App被杀掉进程后, App收不到通知; 当再次进入App时依然没有通知.</p>\n<h3 id=\"ios8监听通讯录变化\"><a href=\"#ios8监听通讯录变化\" class=\"headerlink\" title=\"ios8监听通讯录变化\"></a>ios8监听通讯录变化</h3><pre><code>@property (nonatomic, assign) ABAddressBookRef addresBook;\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        _addresBook = ABAddressBookCreateWithOptions(NULL, NULL);\n        ABAddressBookRegisterExternalChangeCallback(_addresBook, addressBookChanged, nil);\n    }\n    return self;\n}\n\n//监听通讯录变化\nvoid addressBookChanged(ABAddressBookRef addressBook, CFDictionaryRef info, void *context) {\n    NSLog(@&quot;通讯录变化啦....&quot;);\n    //    VC1 *myVC = (__bridge VC1 *)context;\n    //    [myVC getPersonOutOfAddressBook];\n}\n\n- (void)dealloc {\n    NSLog(@&quot;%@-------------------dealloc&quot;, self);\n    ABAddressBookUnregisterExternalChangeCallback(_addresBook, addressBookChanged, nil);\n}\n</code></pre><h3 id=\"ios9监听通讯录变化\"><a href=\"#ios9监听通讯录变化\" class=\"headerlink\" title=\"ios9监听通讯录变化\"></a>ios9监听通讯录变化</h3><pre><code>- (instancetype)init {\n    self = [super init];\n    if (self) {\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(addressBookDidChange:) name:CNContactStoreDidChangeNotification object:nil];\n\n    }\n    return self;\n}\n\n\n- (void)dealloc {\n    NSLog(@&quot;%@-------------------dealloc&quot;, self);\n    [[NSNotificationCenter defaultCenter] removeObserver:self name:CNContactStoreDidChangeNotification object:nil];\n}\n\n- (void)addressBookDidChange:(NSNotification*)notification{\n    NSLog(@&quot;通讯录变化啦....&quot;);\n}\n</code></pre><p>参考文档:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/47189c71543b\" target=\"_blank\" rel=\"noopener\">iOS9下全新的通讯录框架</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/94e8444f1ad6\" target=\"_blank\" rel=\"noopener\">iOS学习笔记29-系统服务(二)通讯录</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/6acad14cf3c9\" target=\"_blank\" rel=\"noopener\">iOS通讯录开发</a></p>\n<p>4.<a href=\"https://developer.apple.com/reference/contacts/cncontact\" target=\"_blank\" rel=\"noopener\">CNContact官方文档</a></p>\n<p>5.<a href=\"https://developer.apple.com/reference/addressbook\" target=\"_blank\" rel=\"noopener\">AddressBook官方文档</a></p>\n<p>6.<a href=\"http://www.bijishequ.com/detail/320846?p=\" target=\"_blank\" rel=\"noopener\">UILocalizedIndexedCollation——本地化索引排序</a></p>\n<p>7.<a href=\"http://www.olinone.com/?p=131\" target=\"_blank\" rel=\"noopener\">iOS开发中如何快速的实现汉字转拼音</a></p>\n<p>8.<a href=\"http://www.jianshu.com/p/d0a752bcda3f\" target=\"_blank\" rel=\"noopener\">iOS通讯录数据变化监听</a></p>\n","categories":["基础知识","性能优化"],"tags":["通讯录"]},{"title":"Xcode神器-Instruments大法","url":"http://hchong.net/2017/04/13/Xcode神器-Instruments大法/","content":"<h1 id=\"Xcode调试神器-Instruments大法\"><a href=\"#Xcode调试神器-Instruments大法\" class=\"headerlink\" title=\"Xcode调试神器-Instruments大法\"></a>Xcode调试神器-Instruments大法</h1><p>用户体验, 是每个App开发很重要的点, 是每个程序猿都应该时刻被想到的点. 好的用户体验就必然要有好的性能. Xcode给我们提供了强大的性能分析工具Instruments.</p>\n<p>打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1ffevnub9j1j316s0q2wfd.jpg\" alt=\"Instruments首界面\"><br>这里我们主要介绍三个常用的工具Core Animation(检测帧率), Leaks(内存泄漏), Time Profiler(检查耗时操作)</p>\n<h2 id=\"Core-Animation\"><a href=\"#Core-Animation\" class=\"headerlink\" title=\"Core Animation\"></a>Core Animation</h2><p>Core Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿.<br><img src=\"http://ww1.sinaimg.cn/large/006tNbRwgy1ffffmifexvj310w0nxwfn.jpg\" alt=\"帧率\"><br>在屏幕的下方有一个Debug Options按钮, 点击展开菜单中可以选择一些更加具体的UI性能的检测,<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffffp2z37cj30xk0i474v.jpg\" alt=\"选项\"><br>我们可以使用这些选项，来监测更加具体的图形性能, 具体参考如下:</p>\n<ul>\n<li><code>Color Blended Layers</code>，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。</li>\n<li><code>Color Hits Green and Misses Red</code>，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。</li>\n<li><code>Color Copied Images</code>，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。</li>\n<li><code>Color Non-Standard Surface Formats</code>, 不标准的表面颜色格式.</li>\n<li><code>Color Immediately</code>，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</li>\n<li><code>Color Misaligned Images</code>，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。</li>\n<li><code>Color Offscreen-Rendered Yellow</code>，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。</li>\n<li><code>Color Compositing Fast Path Blue</code>，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。</li>\n<li><code>Flash Updated Regions</code>，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。</li>\n</ul>\n<p>使用时要注意Xcode和手机系统的版本号匹配, 否则会出现设备off line 无法被选中的情况.</p>\n<h2 id=\"Leaks\"><a href=\"#Leaks\" class=\"headerlink\" title=\"Leaks\"></a>Leaks</h2><p>关于内存方面的监控, 有<code>Leaks</code>用来检测内存泄漏, <code>Zombies</code>用来检测僵尸对象. 关于内存泄漏常见的几种情况, <a href=\"http://www.jianshu.com/p/d465831aebbf\" target=\"_blank\" rel=\"noopener\">这里</a>讲的特别清晰和全面.</p>\n<h2 id=\"Time-Profiler\"><a href=\"#Time-Profiler\" class=\"headerlink\" title=\"Time Profiler\"></a>Time Profiler</h2><p>这个主要是用来统计各个方法消耗的时间.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1fffhjy18vij31kw0zi44c.jpg\" alt=\"Time Profiler\"><br>如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的.</p>\n<p>在下方的call Tree中有一些选项菜单, 选择不同的菜单, 可以查看不同的状态, 具体如下:</p>\n<ul>\n<li><code>Separate byt Thread</code>（建议选择）：通过线程分类来查看那些纯种占用CPU最多。</li>\n<li><code>Invert Call Tree</code>（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。</li>\n<li><code>Hide Missing Symbols</code>（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。</li>\n<li><code>Hide System Libraries</code>（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。</li>\n<li><code>Flatten Recursion</code>（一般不选）：选上它会将调用栈里递归函数作为一个入口。</li>\n<li><code>Top Functions</code>（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><p>在调试过程中也遇到一些问题, 记录下来.</p>\n<h3 id=\"设备灰色不可选\"><a href=\"#设备灰色不可选\" class=\"headerlink\" title=\"设备灰色不可选\"></a>设备灰色不可选</h3><p>解决方案：重启<br>我最终的解决步骤：<br>1.拔掉iPhone的USB线，重启iPhone<br>2.关闭Xcode和Instruments<br>3.重新连接iPhone到Mac上<br>4.重启Xcode并启动Profile<br>5.成功</p>\n<p>参考这个<a href=\"http://stackoverflow.com/questions/32878283/unable-to-profile-app-on-device-with-ios-9-0-1-using-xcode-7-7-0-1-or-7-1-beta\" target=\"_blank\" rel=\"noopener\">帖子</a>.</p>\n<h3 id=\"Time-Profiler无法定位到代码\"><a href=\"#Time-Profiler无法定位到代码\" class=\"headerlink\" title=\"Time Profiler无法定位到代码\"></a>Time Profiler无法定位到代码</h3><p>Time Profliter 都是地址符号，往深里也一直是地址符号，根本没法判断是哪些代码的执行时间, 无法定位代码</p>\n<p>解决方法:</p>\n<ol>\n<li>Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File</li>\n<li>Profile要在debug模式下运行, BuildConfiguration要选择debug.</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://blog.leancloud.cn/2835/\" target=\"_blank\" rel=\"noopener\">iOS 性能优化：Instruments 工具的救命三招</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/439e158b44de\" target=\"_blank\" rel=\"noopener\">Instruments性能优化-Core Animation</a></p>\n<p>3.<a href=\"http://www.samirchen.com/use-instruments/\" target=\"_blank\" rel=\"noopener\">使用 Instruments 做 iOS 程序性能调试</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/d465831aebbf\" target=\"_blank\" rel=\"noopener\">关于内存泄漏，还有哪些是你不知道的？</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/c0aa12d91f05\" target=\"_blank\" rel=\"noopener\">使用Instruments定位iOS应用的Memory Leaks</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/21d29be26479\" target=\"_blank\" rel=\"noopener\">instrument Time Profiler总结</a></p>\n<p>7.<a href=\"http://stackoverflow.com/questions/32878283/unable-to-profile-app-on-device-with-ios-9-0-1-using-xcode-7-7-0-1-or-7-1-beta\" target=\"_blank\" rel=\"noopener\">Unable to profile app on device with iOS 9.0.1 using Xcode 7, 7.0.1 or 7.1 beta</a></p>\n","categories":["基础知识"],"tags":["基础知识","调试"]},{"title":"iOS逆向-下载历史版本","url":"http://hchong.net/2017/04/06/iOS逆向-下载历史版本/","content":"<h1 id=\"iOS逆向-下载历史版本\"><a href=\"#iOS逆向-下载历史版本\" class=\"headerlink\" title=\"iOS逆向-下载历史版本\"></a>iOS逆向-下载历史版本</h1><p>目前App Store默认只能下载最新版, 而我们的目的是要能够下载到App Store中的历史版, 那就要借助一些其他工具来实现.<br>原理如下:</p>\n<blockquote>\n<p>通过Charles来获取下载链接, 通过分析来得到每个版本在连接中所对应的字段, 再通过Charles来截取和替换下载链接中的参数, 来达到下载特定版本App的目的.</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装Charles.</li>\n<li>为了Charles能够抓取HTTPS类型的链接, 需要安装Charles的证书, 参考这里<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.</li>\n</ol>\n</blockquote>\n<h2 id=\"开始抓包\"><a href=\"#开始抓包\" class=\"headerlink\" title=\"开始抓包\"></a>开始抓包</h2><p>安装了Charles之后, 我们就可以获取App的下载链接了, 并且从中分析出我们需要的参数.</p>\n<h3 id=\"获取APP的下载链接和版本号对应的参数\"><a href=\"#获取APP的下载链接和版本号对应的参数\" class=\"headerlink\" title=\"获取APP的下载链接和版本号对应的参数\"></a>获取APP的下载链接和版本号对应的参数</h3><p>下面我们以iOS上一款比较好用的看书软件<em>追书神器</em>为例来说明.</p>\n<ol>\n<li>首先打开ITunes来下载软件, 点击下载, 通过Charles来确定下载软件的链接.<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4m4udoqj30zo0iwdhx.jpg\" alt=\"点击下载\"></li>\n<li>在Charles中观察发现, ITunes使用的是HTTPS链接, 无法直接查看request内容.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4n5nyodj30f707e74h.jpg\" alt=\"无法直接查看HTTPS\"></li>\n<li>我们通过添加SSL Proxying来查看request内容, 并且通过给链接加断点来详细分析请求的参数.</li>\n</ol>\n<p><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4nt57ykj30b60jr74v.jpg\" alt=\"添加SSL Proxy\"><br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4ogb7edj30bg0lkab0.jpg\" alt=\"添加断点\"></p>\n<h3 id=\"推断控制版本的关键字段\"><a href=\"#推断控制版本的关键字段\" class=\"headerlink\" title=\"推断控制版本的关键字段\"></a>推断控制版本的关键字段</h3><p>观察response, 推断<code>softwareVersionExternalIdentifiers</code>展示的是全部的APP对应的版本, <code>softwareVersionExternalIdentifier</code>是用来标记当前版本.<em>追书神器</em>目前的版本标记是<code>820420814</code><br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4pltv74j310w0qjq5r.jpg\" alt=\"字段分析\"><br>通过在request中搜索<code>820420814</code>发现,<code>appExtVrsId</code>是来标记要下载哪个版本.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4p2c1jqj30be08wwew.jpg\" alt=\"推断关键字\"></p>\n<h3 id=\"修改Request参数下载历史版本\"><a href=\"#修改Request参数下载历史版本\" class=\"headerlink\" title=\"修改Request参数下载历史版本\"></a>修改Request参数下载历史版本</h3><p>我们在<code>softwareVersionExternalIdentifiers</code>中任选一个版本号, 此处我以<code>819147298</code>为例</p>\n<ol>\n<li>删除刚才下载好的软件, 重新下载.</li>\n<li>因为我们在下载链接中加的有断点, 再次下载时Charles会停在断点的位置</li>\n<li>点击<code>Edit Request</code>来编辑<code>appExtVrsId</code>字段<br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4qg1avyj30yf0o60v0.jpg\" alt=\"Edit Request\"></li>\n<li>执行断点, 继续下载.</li>\n<li>在ITunes中看到更新的标志说明下载成功<br><img src=\"https://ww1.sinaimg.cn/large/006tNbRwgy1fel4komzx2j30p00c8t9i.jpg\" alt=\"下载成功\"></li>\n</ol>\n<h2 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h2><p>通过ITunes来安装下载好的软件到手机.</p>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.<br>2.<a href=\"http://www.jianshu.com/p/edfed1b1822c\" target=\"_blank\" rel=\"noopener\">iOS秘籍-下载历史版本App超详细教程</a>.</p>\n","categories":["iOS逆向"],"tags":["Charles","iOS逆向"]},{"title":"使用Jenkins实现持续集成","url":"http://hchong.net/2017/03/23/Jenkins自动化打包/","content":"<h1 id=\"使用Jenkins实现持续集成\"><a href=\"#使用Jenkins实现持续集成\" class=\"headerlink\" title=\"使用Jenkins实现持续集成\"></a>使用Jenkins实现持续集成</h1><p>什么是持续集成, 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>\n<p>常见的持续集成的工具有<a href=\"http://jenkins-ci.org/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>  <a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis</a>  <a href=\"http://hudson-ci.org/\" target=\"_blank\" rel=\"noopener\">Hudson</a>  <a href=\"https://circleci.com/\" target=\"_blank\" rel=\"noopener\">Circle</a>. 然而好多我并没有实践过, 😂. <a href=\"http://www.infoq.com/cn/articles/ios-code-server-jenkins-travis-fastlane\" target=\"_blank\" rel=\"noopener\">这里</a>有一篇文章, 对比讲解了主流iOS持续化集成方案, 包括了Xcode Server.</p>\n<p>Code review, 单元测试, 打包与分发, 这些构成了一个APP开发生命周期. 所以一个完整持续化集成应该包含以上的而全部信息, 这里我们主要讲解一下打包与分发的持续化集成方案. 关于我们为什么选择Jenkins, 而不使用其他的持续化方案, <a href=\"http://www.infoq.com/cn/articles/ios-code-server-jenkins-travis-fastlane\" target=\"_blank\" rel=\"noopener\">这篇文章</a>已经讲解的很清楚了. 下面就跟随我一步步的搭建Jenkins, 实现一个简单但强大的持续化集成方案. 本文均以Jenkins2.35为例.</p>\n<h2 id=\"安装Jenkins\"><a href=\"#安装Jenkins\" class=\"headerlink\" title=\"安装Jenkins\"></a>安装Jenkins</h2><p>首先, 我们要安装Jenkins. 安装Jenkins一般有两种方式. </p>\n<p>第一种我们可以从<a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">官网</a>上下载最新的pkg安装包。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vhnmh9bj30h80c7dgr.jpg\" alt=\"安装步骤1\"></p>\n<p>一路点击继续, 直到安装成功为止.</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vikplwxj30hb0c5q35.jpg\" alt=\"安装完成\"></p>\n<p>第二种方式也可以下载<code>brew install jenkins</code>, 切换到切换到 <code>cd /usr/local/Cellar/jenkins/版本号/libexec/jenkins.war</code>,  然后运行Java -jar jenkins.war，进行安装.<br>注意: 如果brew无效要先安装homebrew, <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>\n<p>安装完成后, 重启电脑, 你会发现多了一个Jenkins的用户, 但是他的登录密码我们并不知道. 我们应该打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>, 此时可以看到Jenkins的初始界面. </p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vod9epvj30yg0jet93.jpg\" alt=\"Jenkins初始界面\"><br>注意, 由于Jenkins是由Java开发的, 所以Jenkins的运行必须是在Java环境下, 如果你打开界面为空白的话, 那就说明你需要安装Java环境了.</p>\n<p>按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录, 由于非Jenkins用户没有查看权限, 所以需要我们右键 -&gt; 显示简介, 给这个文件夹赋予读写权限. 按照提示找到<em>initialAdminPassword</em>文件, 复制出密码，就可以填到网页上去重置密码了.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fh5vsrxh73j30yg0je0t5.jpg\" alt=\"重置密码\"></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fh5vt9bk89j30yg0jemxk.jpg\" alt=\"开始安装\"></p>\n<p>然后一路安装下去, 输入用户名，密码，邮件这些，就算安装完成了。</p>\n<h2 id=\"Jenkins插件配置-amp-系统设置\"><a href=\"#Jenkins插件配置-amp-系统设置\" class=\"headerlink\" title=\"Jenkins插件配置&amp;系统设置\"></a>Jenkins插件配置&amp;系统设置</h2><p>打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>页面, 我们需要安装一些辅助插件, 选择<em>系统管理</em> -&gt; <em>管理插件</em>. 下面我列一下我安装到的一些常用的插件: </p>\n<ul>\n<li><p>GitLab Plugin, Gitlab Hook Plugin. 用于连接到GitLab, 如果你的源码在Gitlab上托管, 这连个插件必须要安装.</p>\n</li>\n<li><p>Xcode integration. 这个看名字就知道必须安装了.</p>\n</li>\n<li><p>Environment Injector Plugin. 自定义全局变量的插件, 必须安装.</p>\n</li>\n<li><p>Keychains and Provisioning Profiles Management. 用于管理钥匙串和描述文件, 必须安装.</p>\n</li>\n<li><p>build timeout plugin. 如果构建超时, 自动停止Jenkins当前的构建, 可选.</p>\n</li>\n<li><p>Email Extension Plugin. 用于发邮件, 可选.</p>\n<h2 id=\"Jenkins打包配置准备工作\"><a href=\"#Jenkins打包配置准备工作\" class=\"headerlink\" title=\"Jenkins打包配置准备工作\"></a>Jenkins打包配置准备工作</h2></li>\n</ul>\n<p>首先, 我们需要明确在这一步我们的目的: 把指定代码的指定分支打包为签名过的IPA包, 并且生成一个可供下载的链接. 那么明确了我们的目的, 接下来就一步一步的来实现它. 打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>页面, 接下来我们开始新建一个打包项目. 点击左侧工具栏<em>新建</em>, 选择<em>构建一个自由风格的软件项目</em>, 注意这里最好使用英文, 不要出现中文和特殊字符.</p>\n<p>进入项目配置页面, 接下来我将从<em>General</em>, <em>源码管理</em>, <em>构建触发器</em>, <em>构建环境</em>, <em>构建</em>, 和<em>构建后操作</em>几个方面来配置打包项目.</p>\n<p>在项目配置之前, 我们需要先配置一些其他全局的变量, 这些变量在项目的配置中会使用到.</p>\n<h3 id=\"gitlab代码地址配置\"><a href=\"#gitlab代码地址配置\" class=\"headerlink\" title=\"gitlab代码地址配置\"></a>gitlab代码地址配置</h3><p>Jenkins系统管理 -&gt; 系统设置 -&gt; Gitlab选项, 因为我们的代码托管在gitlab上面, 所以在这里需要配置相关信息. 点击<em>增加</em>. 填写相关信息.<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fh93xkbelyj31ei0qk75f.jpg\" alt=\"gitlab地址配置\"></p>\n<p>注: 这里会报一个<em>API Token for Gitlab access required</em>的错误, 可以暂时忽略, 是因为gitlab一般都是私有的仓库, Jenkins没有连接的权限导致的.</p>\n<h3 id=\"添加与gitlab连接的证书\"><a href=\"#添加与gitlab连接的证书\" class=\"headerlink\" title=\"添加与gitlab连接的证书\"></a>添加与gitlab连接的证书</h3><p>Jenkins -&gt; Credentials -&gt; Add Credentials, <a href=\"http://localhost:8080/credentials/store/system/domain/_/newCredentials\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/credentials/store/system/domain/_/newCredentials</a>增加一个新的证书, 用来连接gitlab. </p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fh94ryjjgvj31kw0qngml.jpg\" alt=\"连接gitlab的证书\"></p>\n<p><em>kind</em> , <em>Scope</em> 和 <em>Private Key</em> 就按照如图所示选择好. <em>UserName</em> 表示这个证书的名字, <em>ID</em> 自动生成, 用来标记这个证书. <em>Description</em>是关于这个证书的描述. <em>key</em> 那里填写SSH的Private Key, <em>Passphrase</em> 那里填写生成SSH时填写的密码.  <a href=\"https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5\" target=\"_blank\" rel=\"noopener\">关于SSH的申请</a>.</p>\n<p>注意: 这里记得要在你的gitlab的Profile Settings -&gt; SSH Keys中添加上一步生成的Public Key, </p>\n<h3 id=\"添加钥匙串和描述文件\"><a href=\"#添加钥匙串和描述文件\" class=\"headerlink\" title=\"添加钥匙串和描述文件\"></a>添加钥匙串和描述文件</h3><p>在Jenkins -&gt; 系统管理 -&gt; KeyChain and Provisioning Profiles Management 中添加 keychains 和 Provisioning Profile文件.<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fha7tvmt2uj30yg08ljrq.jpg\" alt=\"添加钥匙串和描述文件\"></p>\n<p>分别上传keychains 和 Provisioning Profile.</p>\n<ul>\n<li><p>keychains的路径在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。</p>\n</li>\n<li><p>Provisioning Profiles文件在~/Library/MobileDevice/Provisioning Profiles 目录下, 这里面可能会有许多描述文件, 找到我们需要的, 上传并且拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下.</p>\n</li>\n</ul>\n<p>注: 如果 Jenkins 下保存 keychain 和 Provision profile 的目录不存在可以手动创建. 我们可以邮件查看要打包工程*.xcodeproj的包内容, 查看project.pbxproj文件, 通过搜索找到描述文件的ID, 再在~/Library/MobileDevice/Provisioning Profiles文件夹中根据ID来找到具体的描述文件.</p>\n<h3 id=\"Xcode-Builder\"><a href=\"#Xcode-Builder\" class=\"headerlink\" title=\"Xcode Builder\"></a>Xcode Builder</h3><p>在Jenkins -&gt; 系统设置 -&gt; Xcode Builder -&gt; 新增, 如下图所示.<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fha9gi02fyj30nu0fz74v.jpg\" alt=\"Xcode Builder\"></p>\n<p>Keychain Name是要打包的证书的名字, 在钥匙串中找到该证书, 点击右键 显示简介, 复制过来就好.</p>\n<p>Keychain password是开机密码.</p>\n<h2 id=\"Jenkins打包配置\"><a href=\"#Jenkins打包配置\" class=\"headerlink\" title=\"Jenkins打包配置\"></a>Jenkins打包配置</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fha9o70e7wj31kw0t4758.jpg\" alt=\"Jenkins打包工程的配置\"></p>\n<h3 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h3><p>配置一些通用的选项. 项目名称和项目描述如其字面意思一样. <code>GitLab connection</code>是源码的地址, 在外面配置好的选项, 在这里可选.</p>\n<ul>\n<li><p>节流构建，通过设置时间段内允许并发的次数来实现构建的控制</p>\n</li>\n<li><p>丢弃旧的构建, 按需选择.</p>\n</li>\n<li><p>参数化构建过程, 在Jenkins开始打包之前, 填写需要你传入的参数.</p>\n</li>\n<li><p>关闭构建, 在必要的时候并发构建. 可选</p>\n</li>\n</ul>\n<h2 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h2><p>根据自己的实际需求, 不管是SVN或者Git. 因为我使用的是Git, 在一开始安装了Git管理的插件, 所以这里选择Git.<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fhab3vad6rj30tm0f3q3d.jpg\" alt=\"\"></p>\n<ol>\n<li><p>这里的 <em>Credentials</em> 如果使用的是SSH模式, 那上面的 <em>Repository URL</em>就要使用SSH类型的地址. 如果是账号密码模式, 那上面的源码就要使用HTTP形式的地址. 两者必须保持一致.</p>\n</li>\n<li><p>指定代码, 我们可以拉取指定git地址的代码. 因为分支是个变量, 它不像git地址那样一成不变, 所以最好是外部传入, 那就用到了全局环境变量. </p>\n</li>\n</ol>\n<h2 id=\"构建触发器\"><a href=\"#构建触发器\" class=\"headerlink\" title=\"构建触发器\"></a>构建触发器</h2><p>构建触发器是设置自动化构建的地方, 如果想设置自动化构建, 例如监测到git有更新就打包, 或者每隔固定时间就打一次包.</p>\n<ul>\n<li><p>Poll SCM (poll source code management) 轮询源码管理. 需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次</p>\n</li>\n<li><p>Build periodically (定时build) 一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的.</p>\n</li>\n</ul>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fhfrpjn2twj31kw0cegma.jpg\" alt=\"构建触发器\"></p>\n<h2 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h2><p>构建环境, 主要是对构建时一些环境变量的配置.<br><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fhgvjboomwj31a60eujrv.jpg\" alt=\"构建环境\"></p>\n<p>在该模块中 主要设置 xcode build 打包时需要的 keychains 和 Provision Profiles 配置文件。<br>如果不配置 就会使用 xcode 自动的配置，来去系统中查找相应的配置，不过有一点需要注意,就是钥匙串中，登陆钥匙串中的证书 要复制到 系统钥匙串中，因为jenkins 访问的是系统中的钥匙串 这样在第一次打包的时候，会提示 是否授权访问钥匙串，点击始终允许就可以了。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fhjnx3dnwvj31gg0jo755.jpg\" alt=\"Keychains and Code Signing Identities\"><br><em>Keychains and Code Signing Identities</em> 中的选项, 因为在前面已经选择过了 <em> Keychain </em> 和 <em>Code Signing Identity</em>在前面已经填写过, 此处只用根据当前工程来选择正确的选项.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fhjo37irdyj31g20hojs1.jpg\" alt=\"Mobile Provisioning Profiles\"></p>\n<p><em>Mobile Provisioning Profiles</em>由于前面已经填写过描述文件, 此处只需要选择与当前打包工程相匹配的描述文件.</p>\n<h2 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h2><p>在这里才进入了自动化集成的关键步骤, 前面的都是一些准备工作. 我们选择<em>增加构建步骤</em>, 按照自己的实际需求, 选择打包脚本的类型. 因为Jenkins自带Shell脚本集成, 所以此处我选择<em>Execute shell</em>, 使用shell脚本来进行构建.</p>\n<pre><code>export PATH\n#######执行脚本命令#######\nrm -rf Users/Shared/Jenkins/Library/ipa/JenkinsTest/JenkinsTest.ipa\nsecurity unlock-keychain  -p &quot;HChong&quot; ~/Library/Keychains/login.keychain\nsh /Users/Shared/Jenkins/Library/BuildScript/build.sh JenkinsTest 4c86cf7c8b4d00013c59b30b0c8d5e77\nfir p /Users/Shared/Jenkins/Library/ipa/JenkinsTest/JenkinsTest.ipa -T 4c86cf7c8b4d00013c59b30b0c8d5e77\n</code></pre><p>shell脚本的具体内容如下</p>\n<pre><code>#!/bin/bash\n\n#=================项目路径配置===============\nPROJECT_PATH=&#39;/Users/Shared/Jenkins/Home/workspace/iOSPackage&#39;\nWORKSPACE_NAME=&#39;JenkinsTest.xcworkspace&#39;\nArchive_PATH=&#39;/Users/Shared/Jenkins/Library/archive&#39;\nIPA_PATH=&#39;/Users/Shared/Jenkins/Library/ipa&#39;\nPLIST_PATH=&#39;/Users/Shared/Jenkins/Home/workspace/iOSPackage/exportArchive.plist&#39;\n\n\n#===================================脚本开始=================================================\n#使用帮助\nif [ $# == 0 ];then\necho &quot;===========================如何使用=============================&quot;\necho &quot; eg: ./build [scheme] [token] &#39;版本描述中间不要留空格&#39;, 不传token默认用当前已经登录的fir token&quot;\necho &quot; scheme list:&quot;\necho &quot; JenkinsTest&quot;\necho &quot; token list:&quot;\necho &quot;================================================================&quot;\nexit\nfi\n\n#update code from gitlab\ncd $PROJECT_PATH\n#git pull\n\n#update pod\n#pod install --repo-update\n#pod update\n\n#删除旧的编译目录\nAPP_BUILD_LOCATION=${PROJECT_PATH}/Build/\nrm -rf ${APP_BUILD_LOCATION}\n#创建dfc目录\n\n#key auth\nsecurity unlock-keychain &quot;-p&quot; &quot;钥匙串密码&quot; &quot;/Users/hc/Library/Keychains/login.keychain&quot;\n\n#创建ARCHIVE目录\nmkdir -p IPA_PATH\n#Archive_NAME = $1.xcarchive\n\n#开始打包\ncd ${PROJECT_PATH}\npwd\n\nXCCONFIG_PATH=${PROJECT_PATH}/dfc_v2/appconfig\n\n#xcodebuild -workspace ${WORKSPACE_NAME} -scheme Enterprise -xcconfig ${XCCONFIG_PATH}/$1.xcconfig -archivePath ${Archive_PATH}/$1.xcarchive archive\nxcodebuild -workspace ${WORKSPACE_NAME} -scheme $1 -config $1 -archivePath ${Archive_PATH}/$1.xcarchive archive\necho &quot;--------------------------------------------&quot;${Archive_PATH}/$1.xcarchive\n\n#创建ipa\nIPA_LOCATION=${IPA_PATH}/$1\n\n#删除旧的ipa\nrm -rf IPA_LOCATION\nmkdir -p ${IPA_PATH}/$1\nxcodebuild -exportArchive -exportOptionsPlist ${PLIST_PATH} -archivePath ${Archive_PATH}/$1.xcarchive -exportPath ${IPA_LOCATION}\n\n\nIPA_FILE_LOCATION=${IPA_PATH}/$1/$1.ipa\n\n#检查ipa是否创建成功\nif [ -f $IPA_FILE_LOCATION ]; then\necho &quot;ipa已经创建:&quot;${IPA_FILE_LOCATION}\nelse\necho &quot;打包失败&quot;\nexit 0\nfi\n</code></pre><h2 id=\"构建后的操作\"><a href=\"#构建后的操作\" class=\"headerlink\" title=\"构建后的操作\"></a>构建后的操作</h2><p>顾名思义, 就是构建之后进行的操作. 在这里我们可以选择<em>Execute a set of scripts</em>, 通过脚本来实现构建后的操作. 常见的是将构建的结果, 上传到内测平台或者内部下载地址. 但是如果构建操作的脚本中包含有这一项, 这一个步骤也就可以忽略掉了.</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><h3 id=\"找不到Fir命令\"><a href=\"#找不到Fir命令\" class=\"headerlink\" title=\"找不到Fir命令\"></a>找不到Fir命令</h3><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fhjsalg3fej31b80cewfp.jpg\" alt=\"找不到Fir命令\"><br>出现如图所示的Error, 一般是由于没有安装fit-cli命令导致, 通过安装<code>gem install fir-cli -V --no-ri --no-rdoc</code>来解决. 如果提示安装成功, 但是还是报错的话, 那就在安装命令前加上<code>sudo</code>, 覆盖安装即可.</p>\n<h3 id=\"fir-cli-jenkins-fir-command-not-found\"><a href=\"#fir-cli-jenkins-fir-command-not-found\" class=\"headerlink\" title=\"fir-cli jenkins fir:command not found\"></a>fir-cli jenkins fir:command not found</h3><p>这个错误是由于没有导入fir-cli安装目录导致的, 可以先在终端输入<code>echo $PATH</code>, 然后把输出结果复制下来, 在Jenkins -&gt; 系统管理 -&gt; 添加全局变量. 然后在工程构建步骤, 先引入全局变量<code>export ${PATH}</code>. 如果没有设置全局变量的话, 也可以直接使用<code>export PATH=</code>echo $PATH 的输出结果``</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fhk9pyt7nsj31dg0cmwen.jpg\" alt=\"添加Path全局变量\"></p>\n<h3 id=\"证书配置文件没有找到\"><a href=\"#证书配置文件没有找到\" class=\"headerlink\" title=\"证书配置文件没有找到\"></a>证书配置文件没有找到</h3><p>No iOS profile matching ‘xxxxxx/xxxxxxx’ found:Xcode couldn’t find a profile<br>matching ‘xxxxxx/xxxxxxx’.<br>Install the profile (by dragging and dropping it onto Xcode’s dock item)<br>or select a different one in the General tab of the target editor.<br>Code signing is required for product type ‘Application’ in SDK ‘iOS 10.3’ </p>\n<p>是因为Archive时没有找到profile导致的. 解决办法是, 把系统的<code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code>整个Provisioning Profiles文件夹复制到<code>/Users/Shared/Jenkins/Library/MobileDevice</code>目录下, 并且在Jenkins -&gt; Keychains and Provisioning Profiles Management 的Provisioning Profiles Directory Path中, 设置好profile的存放目录.</p>\n<h3 id=\"Command-usr-bin-codesign-failed-with-exit-code-1\"><a href=\"#Command-usr-bin-codesign-failed-with-exit-code-1\" class=\"headerlink\" title=\"Command/usr/bin/codesign failed with exit code 1\"></a>Command/usr/bin/codesign failed with exit code 1</h3><h2 id=\"这个是由于没有给钥匙串开锁权限导致-编译之前添加-security-unlock-keychain-p-quot-你的密码-quot-quot-path-to-keychain-login-keychain-quot-解决\"><a href=\"#这个是由于没有给钥匙串开锁权限导致-编译之前添加-security-unlock-keychain-p-quot-你的密码-quot-quot-path-to-keychain-login-keychain-quot-解决\" class=\"headerlink\" title=\"这个是由于没有给钥匙串开锁权限导致, 编译之前添加 security unlock-keychain -p &quot;你的密码&quot; &quot;path to keychain/login.keychain&quot;解决.\"></a>这个是由于没有给钥匙串开锁权限导致, 编译之前添加 <code>security unlock-keychain -p &quot;你的密码&quot; &quot;path to keychain/login.keychain&quot;</code>解决.</h2><h2 id=\"待解决\"><a href=\"#待解决\" class=\"headerlink\" title=\"待解决\"></a>待解决</h2><p>使用Tomcat, 把Jenkins发布出去, 这个是下一步要解决的问题.<br>参考文章:</p>\n<p>1.<a href=\"https://runningyoung.github.io/2016/04/01/2016-04-05-jenkins2/\" target=\"_blank\" rel=\"noopener\">iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 2)</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/c69deb29720d\" target=\"_blank\" rel=\"noopener\">一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e19c8327b167\" target=\"_blank\" rel=\"noopener\">Jenkins/git/KeyChains &amp; Provisioning, 记录CI中的一些坑</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/e19c8327b167\" target=\"_blank\" rel=\"noopener\">使用 Jenkins 持续集成 iOS 项目时碰到的一些问题</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/41ecb06ae95f\" target=\"_blank\" rel=\"noopener\">手把手教你利用Jenkins持续集成iOS项目</a></p>\n","categories":["自动化打包","持续集成"],"tags":["自动化打包","Jenkins","持续集成"]},{"title":"多渠道包和多环境包的自动化实现","url":"http://hchong.net/2017/03/12/多Target实现/","content":"<h1 id=\"多渠道包和多环境包的自动化实现\"><a href=\"#多渠道包和多环境包的自动化实现\" class=\"headerlink\" title=\"多渠道包和多环境包的自动化实现\"></a>多渠道包和多环境包的自动化实现</h1><p>在App的开发过程中, 肯定会有很多后台环境的区分. 例如开发时, 我们用的是开发环境. 测试时使用的是测试环境. 在预发布之前肯定要有个缓冲的环境, 也就是预发布环境. 最后还有一个线上的环境, 也称为生产环境. 那么这么多环境, 问题就来了, 该怎么在各个环境之间无缝切换呢?  </p>\n<p>首先我们会想到在代码中建一个单独的类, 把用到的所有服务按照环境列一个遍, 每次需要运行什么环境就按照什么环境从类里面去取相关环境代码. 于是有了方案一.</p>\n<h2 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h2><p>方案一的伪代码, 大概是这个样子的:</p>\n<pre><code class=\"objective-c\">+ (void)getHttpHostWithStatus:(NSInteger)status {\n    switch (status) {\n        case 0: {\n            Host1 = @&quot;开发环境&quot;;\n            Host2 = @&quot;开发环境&quot;;\n        }\n            break;\n        case 1: {\n            Host1 = @&quot;测试环境&quot;;\n            Host2 = @&quot;测试环境&quot;;\n        }\n            break;\n        case 2: {\n            Host1 = @&quot;预发布环境&quot;;\n            Host2 = @&quot;预发布环境&quot;;\n        }\n            break;\n        case 3: {\n            Host1 = @&quot;线上环境&quot;;\n            Host2 = @&quot;线上环境&quot;;\n        }\n            break;\n        default:\n            break;\n    }\n}\n</code></pre>\n<p>在App每次启动时调用这个方法, 来获取各个Host的地址, 完美解决. </p>\n<p>测试每次想要个新的包来测试, 都会有如下对话, “帮我打个包吧”, “你要什么环境的”, “预发环境”, “好的”. 于是 ,我们一同操作, 传入预发的status, 调用动态取Host的方法, 然后Product-&gt;Archive, 等个十几二十分钟, 打包完毕, 生成一个IPA文件, 自己拿ITunes安装. 嗯, 虽然辛苦点, 但是目前看来, 一切都很完美嘛, 打包的时候还能喝个茶.</p>\n<p>然而, 随着我司测试流程的规范化, 逐渐推进使用<a href=\"\">Jenkins持续集成</a>来打包, 那么问题就来了. 你让测试也装个Xcode, 每次切换一下环境, 手动Archive吗, 呵呵. 于是我们有了方案二.</p>\n<h2 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h2><p>我们先来理一下方案二主要解决的问题: <em>测试要能够在不改代码的前提下使用Jenkins打不同环境的包</em>. 听起来有点复杂呢, 我们来逐个分析下.</p>\n<ol>\n<li>使用Jenkins来打包, 那就是跑脚本嘛, xcodebuild已经寂寞难耐.</li>\n<li>既然搞Jenkins了, 不能再用IPA自己安装的方式了, Low, 蒲公英和Fir简直不要太方便.</li>\n<li>既然要用脚本来打包了, 那不能每次跑脚本之前, 先改一下代码吧, 于是想到我们应该有一个参数来在工程中区分不同的环境, </li>\n</ol>\n<p>以上就是我们方案二要解决的主要问题, 下面我们来逐个分析和解决.</p>\n<h3 id=\"打包脚本\"><a href=\"#打包脚本\" class=\"headerlink\" title=\"打包脚本\"></a>打包脚本</h3><p>关于打包的脚本, 版本很多, 有Python流, 有Shell流, 可以<a href=\"\">参考这里</a>. 但说到底, 无非用的是xcodebuild来实现的, 在终端中输入<code>xcodebuild -help</code>可以查看xcodebuild的相关操作<a href=\"http://www.jianshu.com/p/4f4d16326152\" target=\"_blank\" rel=\"noopener\">这篇文章</a>将的也比较全面, 可以参考下.</p>\n<p>在这里, 我们主要用到的命令有两个.</p>\n<pre><code class=\"objective-c\">//编译\nxcodebuild -workspace &lt;workspacename&gt; -scheme &lt;schemeName&gt; [-destination &lt;destinationspecifier&gt;]... [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...\n\n//生成IPA\nxcodebuild -exportArchive -archivePath &lt;xcarchivepath&gt; -exportPath &lt;destinationpath&gt; -exportOptionsPlist &lt;plistpath&gt;\n</code></pre>\n<p>到这一步, 我们的打包脚本仅仅完成了第一步, 生成了IPA文件. </p>\n<h3 id=\"内测分发平台\"><a href=\"#内测分发平台\" class=\"headerlink\" title=\"内测分发平台\"></a>内测分发平台</h3><p>生成IPA之后, 我们要提供一个可供下载安装的链接. 此处我们使用的是<a href=\"https://fir.im/\" target=\"_blank\" rel=\"noopener\">Fir</a>, 它提供的也有<a href=\"https://github.com/FIRHQ/fir-cli/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">命令行操作</a>, 可以直接上传IPA文件, 生成可供下载的二维码.👍</p>\n<p>当然有条件的公司也可以自己搭建一个下载地址, 制作一个管理后台, 用来管理自己的内测.</p>\n<h3 id=\"APP配置多个环境变量\"><a href=\"#APP配置多个环境变量\" class=\"headerlink\" title=\"APP配置多个环境变量\"></a>APP配置多个环境变量</h3><p>接下来这个, 才是本次解决方案的重点, 明确了我们的目的, 就是配置多环境变量, 那么我们就开始吧. 关于多环境变量的配置, 冰霜大神的<a href=\"http://www.jianshu.com/p/83b6e781eb51\" target=\"_blank\" rel=\"noopener\">这篇文章</a>讲解的比较详细. 但是我们采用的方案和他的又略有区别, 一开始我们使用的是多Target的方式, 后来感觉不够轻量化, 并且每个Target的Seeting也基本你没有大的不同, 于是就采用了多Scheme的方式来解决.</p>\n<p>具体步骤如下:<br>1.新建Scheme. 注意这里一定要把Scheme的名字和编译方式区分开，选择了一个Scheme，只是相当于选择了一个环境，并不是代表这Debug还是Release, 此处以<code>PrePublish</code>为例.<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8ovbi6rj318o0aq0t6.jpg\" alt=\"新建Scheme\"></p>\n<p>2.新建xcconfig文件, 名字与Scheme对应. 在新建时, 一定要在Target那里勾选上(默认是非勾选状态).<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8qe5nx2j313k13umy6.jpg\" alt=\"新建xcconfig\"></p>\n<p>3.Project -&gt; Info -&gt; Configurations 新建Configurations文件. 注意, 如果有使用Pod的话, 此处需要立马执行<code>pod install</code>, 生成对应的Pod的xcconfig文件<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8s76f92j318u0h2aap.jpg\" alt=\"新建Configurations\"></p>\n<p>4.修改Configurations文件, 使之与对应的Scheme相关联.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1ffl8vld5eyj31c00g4mxp.jpg\" alt=\"修改Configurations\"></p>\n<p>5.Edit Scheme<br><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgy1ffl92zbnlhj31ds0s0q3p.jpg\" alt=\"Edit Scheme\"></p>\n<p>6.编辑PrePublish.xcconfig文件, 设置自定义字段. 具体如下:</p>\n<pre><code>#include &quot;Pods/Target Support Files/Pods-MultipleChannel/Pods-MultipleChannel.prepublish.xcconfig&quot;\n\nHOST1 = @&quot;HOST1/PrePublish&quot;\n\nHOST2 = @&quot;HOST2/PrePublish&quot;\n\nGCC_PREPROCESSOR_DEFINITIONS = $(inherited) HOST2=&#39;$(HOST2)&#39; HOST1=&#39;$(HOST1)&#39;\n</code></pre><p>注意, 此处必须要引入<code>pod install</code>生成的对应的Pod的xcconfig, 否则会报错.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1ffl9102hzij30ji0aoglq.jpg\" alt=\"报错\"><br>7.Manage Schemes</p>\n<p>因为一般是多人合作开发, 所以此处的Scheme需要设置为Share状态<br><img src=\"http://ww1.sinaimg.cn/large/006tNbRwgy1ffl969kivwj316o0o0jrt.jpg\" alt=\"\"></p>\n<p>至此, 已经可以在工程中使用我们在xcconfig中自定义的字段了. 因为我们使用了<code>GCC_PREPROCESSOR_DEFINITIONS</code>, 他会在编译时生成一个宏定义, 所以我们可以直接使用宏定义</p>\n<pre><code>NSLog(@&quot;----------%@&quot;, HOST1);\nNSLog(@&quot;----------%@&quot;, HOST2);\n</code></pre><p>注: 此外, 还有另外一种使用方式. 我们可以每个Scheme新建一个plist(也可使用Info.plist)文件与之对应, 在plist文件中新增<code>key-value</code>来与xcconfig中的自定义字段对应.</p>\n<p>使用方法如下:</p>\n<p>1.在plist中新增与xcconfig中自定义字段对应的<code>key-value</code><br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl9dzmseoj310y0nqjsm.jpg\" alt=\"plist文件新增\"></p>\n<p>2.使用方式如下:</p>\n<pre><code>    NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];\n    NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithContentsOfFile:bundlePath];\n    NSLog(@&quot;----------%@&quot;, [dict objectForKey:@&quot;HOST1&quot;]);\n    NSLog(@&quot;----------%@&quot;, [dict objectForKey:@&quot;HOST2&quot;]);\n</code></pre><p>至此, 我们已经实现不同Scheme下, 参数的动态化配置的两种方案, 下面我们分析下原理:</p>\n<p>首先, 我们先来区分一下Xcode Workspace、Xcode Scheme、Xcode Project、Xcode Target、Build Settings 这5者的关系, 由于篇幅较长, <a href=\"http://hchong.net/2017/05/16/Settings%E5%85%B3%E7%B3%BB/\">另开一文</a>.<br>这5者的关系在苹果官方文档上其实都已经说明的很清楚了。详情见文档<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html\" target=\"_blank\" rel=\"noopener\">Xcode Concepts</a>。 </p>\n<p>总结起来, 一个Workspace可以包含多个Project,一个Project可以包含多个Target，Scheme包含了所有的Target集合，这个集合指定了，编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等.</p>\n<p>xcconfig文件是一个用来保存Build Settings键值对的纯文本文件, 这些键值对会覆盖Build Settings中的值. xcconifg支持可以根据不同的Configuration选项配置不同的文件. 不同的xcconfig可以指定不同的Build Settings里的属性值.</p>\n<h2 id=\"方案三\"><a href=\"#方案三\" class=\"headerlink\" title=\"方案三\"></a>方案三</h2><p>我们的初衷是用这个来动态配置App的环境. 既然已经可以通过xcconfig和Scheme来配合修改Build Seetings的值, 那么就会有一些更加高级的玩法. 例如我们可以在<code>Images.xcassets</code>中新建新的icon和launch Image的分类, 通过<code>ASSETCATALOG_COMPILER_APPICON_NAME</code>和<code>ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME</code>中的设置, 以及<code>Display Name</code>,<code>Bundle Identifier</code>, <code>Provisioning Profile</code>等一些配置(此处Build Settings中的值可以直接<code>command + C</code>来copy)来管理大量的相似APP.</p>\n<p>Info.plist中的值, 需要在Value中使用${Value}来动态配置, 参考域名的配置.</p>\n<p>xcconfig还能动态配置Build Settings里面的很多参数。这其实类似于cocopods的做法。但是有一个大神的做法很优雅。值得大家感兴趣的人去学习学习。iOS大神Justin Spahr-Summers的开源库提供了一个类权威的<a href=\"https://github.com/jspahrsummers/xcconfigs\" target=\"_blank\" rel=\"noopener\">模板</a>.</p>\n<p>那么伴随着业务的发展, 就有有问题了. 如果我想管理大量相似的APP, 每次发布新版本, 我就要打N多个新包. 每次跑脚本, 数量多了时间也很长, 那这就不是一杯茶的功夫了, 甚至要一两个小时. 并且我还要管理N多个Scheme, 这些Scheme明明只有很少的差别, 真的好烦啊. 有没有更加优雅的解决方案呢, 来看下方案四.</p>\n<h2 id=\"方案四\"><a href=\"#方案四\" class=\"headerlink\" title=\"方案四\"></a>方案四</h2><p>首先, 还是先来明确下我们这个方案要解决的问题:</p>\n<ol>\n<li>Scheme太多, 每个渠道一个Scheme, 管理起来费劲.</li>\n<li>新版本发布时, 各个渠道的包, 跑脚本跑到手软.</li>\n</ol>\n<hr>\n<p>附件下载地址:</p>\n<p>1.<a href=\"\">打包脚本</a>    </p>\n<p>2.<a href=\"https://github.com/HChong3210/MultipleChannel\" target=\"_blank\" rel=\"noopener\">Demo</a>    </p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/4f4d16326152\" target=\"_blank\" rel=\"noopener\">xcodebuild命令说明</a></p>\n<p>2.<a href=\"https://fir.im/\" target=\"_blank\" rel=\"noopener\">Fir.im</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/83b6e781eb51\" target=\"_blank\" rel=\"noopener\">手把手教你给一个iOS app配置多个环境变量</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/9a6f3019d81f\" target=\"_blank\" rel=\"noopener\">Xcode 配置文件 xcconfig</a></p>\n<p>5.<a href=\"http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/\" target=\"_blank\" rel=\"noopener\">Xcode使用xcconfig文件配置环境</a></p>\n<p>6.<a href=\"http://blog.csdn.net/vbirdbest/article/details/53454014\" target=\"_blank\" rel=\"noopener\">iOS Xcode使用xcconfig配置环境参数(Debug&amp;Release)</a></p>\n<p>7.<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a></p>\n","categories":["自动化打包"],"tags":["自动化打包","Target"]},{"title":"Charles抓包Https请求","url":"http://hchong.net/2017/02/28/Charles抓包Https请求/","content":"<h1 id=\"Charles抓包HTTPS请求\"><a href=\"#Charles抓包HTTPS请求\" class=\"headerlink\" title=\"Charles抓包HTTPS请求\"></a>Charles抓包HTTPS请求</h1><p>有时我们会对手机里面的App进行一些分析, 产看App的请求包, 这时我们就需要祭出神器<a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">Charles</a>了.<br>下面跟着我来教你从零开始抓取App的请求包.</p>\n<h2 id=\"安装Charles\"><a href=\"#安装Charles\" class=\"headerlink\" title=\"安装Charles\"></a>安装Charles</h2><p>这个纯属占坑(废话).</p>\n<h2 id=\"抓取HTTP请求\"><a href=\"#抓取HTTP请求\" class=\"headerlink\" title=\"抓取HTTP请求\"></a>抓取HTTP请求</h2><p>我们先拿一个简单的HTTP请求来练一下手.</p>\n<h3 id=\"查看本地IP地址和Charles端口号\"><a href=\"#查看本地IP地址和Charles端口号\" class=\"headerlink\" title=\"查看本地IP地址和Charles端口号\"></a>查看本地IP地址和Charles端口号</h3><p>查看IP地址的方法比较多, 这里只介绍两种比较常用的:</p>\n<ol>\n<li>可以在网络偏好设置-&gt;高级-&gt;TCP/IP下查看对应网络的IP.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd5z8oku1vj311a0lwgpb.jpg\" alt=\"网络偏好设置中查看\"></li>\n<li>option+左键单击屏幕上方的WiFi标志也可以查看.<br> <img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65kx0mjhj308c0eft9q.jpg\" alt=\"option+左键查看\"></li>\n</ol>\n<h3 id=\"查看Charles的端口号\"><a href=\"#查看Charles的端口号\" class=\"headerlink\" title=\"查看Charles的端口号\"></a>查看Charles的端口号</h3><p>打开Charles-&gt;Proxy-&gt;Proxy Settings查看端口号, 默认一般是<code>8888</code>. 注意不要随意修改端口号, 以避免被占用.</p>\n<h3 id=\"在iPhone中设置\"><a href=\"#在iPhone中设置\" class=\"headerlink\" title=\"在iPhone中设置\"></a>在iPhone中设置</h3><p>打开手机, 连上WiFi, 注意此处的WiFi最好和Mac连接的WiFi是同一个, 避免出现不在一个网段的情况.<br>打开设置-&gt;无线局域网-&gt;点击对应WiFi后的更多.<br><img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd65mobyrjj30b40jrq3k.jpg\" alt=\"WiFi列表\"><br>点击手动, 设置HTTP代理地址(与Mac的IP地址一致)和端口号(与Charles中代理的端口号一致)<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65mo3y0aj30b40jrmxm.jpg\" alt=\"设置HTTP代理地址和端口号\"></p>\n<p>至此, 就可以轻松的抓取App中的HTTP请求啦.</p>\n<h2 id=\"抓取HTTPS请求\"><a href=\"#抓取HTTPS请求\" class=\"headerlink\" title=\"抓取HTTPS请求\"></a>抓取HTTPS请求</h2><p>HTTPS的请求抓取, 略微复杂, 他的原理大致是这样的.</p>\n<blockquote>\n<p>Charles能进行https协议抓包分析，是使用了中间人代理的方法（man-in-the-middle，也常作为一个黑客攻击手段）。Charles代替你的app接受server的证书，然后使用这个证书通过SSL和server通信；同时，Charles会动态的生成一个对应的证书（用Charles的CA证书签名），然后使用这个证书和你的app通信，这样就完成了一个中间人代理，从而可以把app和server的https包给抓到和解码出来。</p>\n</blockquote>\n<p>从里面我们可以看到一些关键字: <code>证书</code>, <code>代理</code>, 等. 那么我们就通过这些手段来抓取HTTPS的请求.</p>\n<h3 id=\"设置代理地址和端口号\"><a href=\"#设置代理地址和端口号\" class=\"headerlink\" title=\"设置代理地址和端口号\"></a>设置代理地址和端口号</h3><p>这一步骤, 和抓取HTTP的方法一样, 这里不再赘述, 需要设置端口号和IP地址.</p>\n<h3 id=\"Mac安装证书\"><a href=\"#Mac安装证书\" class=\"headerlink\" title=\"Mac安装证书\"></a>Mac安装证书</h3><p>安装Charles的证书到Mac, 信任该证书, 以便Charles能够通过该证书进行通信. 具体步骤如下: </p>\n<ol>\n<li>打开Charles, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd607vw0k6j30pk094gmj.jpg\" alt=\"安装根证书\"></li>\n<li>信任该证书<br><img src=\"http://upload-images.jianshu.io/upload_images/1552510-461959c476a2d9d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书不被信任时\"></li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1552510-8c43e95be0a35b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"信任Charles证书\"></p>\n<h3 id=\"iPhone安装证书\"><a href=\"#iPhone安装证书\" class=\"headerlink\" title=\"iPhone安装证书\"></a>iPhone安装证书</h3><p>安装Charles证书到手机, 信任该证书, 以便Charles能够截获网络请求. 具体步骤如下:</p>\n<ol>\n<li>在Charles中, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser, 来查看当前IP地址下, 手机下载证书的网址.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd60jpjcgvj30nx094my0.jpg\" alt=\"步骤一:选择生成手机下载证书的网址\"></li>\n<li>在手机中用Safari打开网址(如图所示的网址)<br> <img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd60l2cz81j30nz06t3yl.jpg\" alt=\"步骤二:输入生成的网址\"></li>\n<li>打开网址后自动跳转到证书安装界面, 安装并信任该证书.<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd65rnpokjj30b40jrgly.jpg\" alt=\"步骤三:安装并信任该证书\"></li>\n<li>打开Charles选择Proxy-&gt;SSL Proxying Settings-&gt;SSL Proxying(因为Charles默认是不会抓取任何域名下的HTTPS, 所以需要我们添加域名到Location下)勾选Enable SSL Proxying, 单击Add, 添加域名和端口(用*来表示所有).<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd60zndgejj30gj0cb0st.jpg\" alt=\"步骤四:设置抓取的域名和端口\"></li>\n</ol>\n<p>至此, 我们再打开手机App就会发现, 之前<code>Unknown</code>的HTTPS接口, 就都可以正常现实啦.</p>\n<p>参考资料:<br>1.<a href=\"http://www.jianshu.com/p/a0215dd2047f\" target=\"_blank\" rel=\"noopener\">HTTP/HTTPS抓包工具Charles</a><br>2.<a href=\"http://www.jianshu.com/p/a83b19a36a8b\" target=\"_blank\" rel=\"noopener\">使用Charles进行https抓包</a><br>3.<a href=\"http://blog.devtang.com/2015/11/14/charles-introduction/\" target=\"_blank\" rel=\"noopener\">Charles 从入门到精通</a></p>\n","categories":["iOS逆向"],"tags":["逆向","安全","Charles"]},{"title":"统计打点的AOP实现","url":"http://hchong.net/2017/02/13/统计打点的AOP实现/","content":"<h1 id=\"统计打点的AOP实现\"><a href=\"#统计打点的AOP实现\" class=\"headerlink\" title=\"统计打点的AOP实现\"></a>统计打点的AOP实现</h1><p>每一个App, 必然会有大量的分析数据来统计用户行为. 而这些统计对应在客户端就是, 统计打点, 又称埋点.<br>关于埋点的本质, 我理解的就是用户出发一个行为后, 调用一个特定的接口. 服务端拿到我们的请求后, 根据客户端传的参数也就是事件ID来区分是什么操作(注意, 这里的事件ID是具有唯一性的, 不同的ID对应用户不同的操作). 有时也可能会需要其他的信息, 比如操作人的ID等. 服务端拿到这些信息之后, 再整理筛选, 通过视图, 报表的形式展现出来.<br>因为埋点是和业务紧密相连的, 所以一般我们的埋点代码(就是调用特定网络接口的代码)分散在整个项目的各个地方. 当业务越来越复杂, 工程越来越大时, 我们的埋点代码就会变得很难维护, 埋点事件分散在各个地方, 很难有个清晰的逻辑. 并且把埋点事件和业务代码高度耦合在一起, 也不是一个明智的选择.<br>这个时候, 就会想到, 要是能用AOP的方式来解决埋点的实现, 把埋点事件和业务代码解耦开来, 那我们维护起来就会方便好多.</p>\n<blockquote>\n<p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP与OOP是面向不同领域的两种设计思想。<br>OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。<br>AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。<br>AOP可以用在日志记录，性能统计，安全控制，事务处理，异常处理等等，本篇文章主要讲的是埋点也就是日志记录</p>\n</blockquote>\n<p>在Objective-C中使用AOP主要指的是使用Objective-C的Runtime特性, 给指定的方法添加自定义代码. 有很多方式来实现AOP, MethodSwizzling只是其中之一.而又有一些第三方库, 将Runtime进行了很好地封装, 让我们不用了解Runtime的知识, 就能很好地使用AOP.<br>我们主要使用的是<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a>这个第三方库, 关于Aspects的内部实现, 可以参考这篇博文<a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"noopener\">iOS 如何实现Aspect Oriented Programming</a>.<br>由以上的解释, 可以基本了解, 我们主要是通过Aspect来Hook对应事件的方法, 传递事件唯一的ID给服务端来标记此事件响应过一次.所以, 我们的代码大致应该是这样.<br>首先有一个类用来记录埋点事件ID和需要Hook的类和方法, 并且将他们一一对应.</p>\n<p>根据记录埋点事件的复杂程度, 我们大致可以将埋点分为简单埋点和复杂埋点两种:</p>\n<ol>\n<li>简单埋点: 只用记录某个操作事件响应次数</li>\n<li>复杂埋点:<ul>\n<li>需要传除了事件ID外的参数</li>\n<li>需要根据服务端返回的数据来响应不同的事件</li>\n<li>埋点事件ID放在服务端返回的字段中</li>\n</ul>\n</li>\n</ol>\n<p>我们新建两个类, 一个用来记录Hook的类<code>HYZTrackList</code>, Hook的方法和与之对应的事件ID. 另外一个类<code>HYZTrackManager</code>, 用来实现埋点事件的具体操作方法.</p>\n<h2 id=\"简单埋点的实现\"><a href=\"#简单埋点的实现\" class=\"headerlink\" title=\"简单埋点的实现\"></a>简单埋点的实现</h2><p>我们在<code>HYZTrackList</code>中实现<code>trackList</code>方法, 返回一个数组. 数组的元素是一个个的字典, 用对记录每一个事件的相关信息.</p>\n<pre><code>+ (NSArray *)trackList {\n    NSArray *trackList = @[\n  //=======================================简单埋点==========================================\n                           //HYZViewController1简单埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;simpleTrack:para2:&quot;,\n                             kEventType:HYZViewController1SimpleButtonClick,\n                             kIsLightEvent:@(YES)},\n                           //HYZViewController1复杂埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;blockButtonAction:&quot;,\n                             kEventType:HYZViewController1BlockButtonClick,\n                             kIsLightEvent:@(YES)},\n                           //HYZViewController1block埋点点击事件\n                           @{kClassName:@&quot;HYZViewController1&quot;,\n                             kHookFunction:@&quot;complexButtonAction:&quot;,\n                             kEventType:HYZViewController1ComplexButtonClick,\n                             kIsLightEvent:@(YES)},\n\n//=======================================复杂埋点==========================================\n                           @{kClassName:@&quot;HYZViewController3&quot;,\n                             kHookFunction:@&quot;trackWithTag:&quot;,\n                             kHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,\n                             kIsLightEvent:@(NO)}];\n    return trackList;\n}\n</code></pre><p>如上所示, 我们是要记录<code>HYZViewController1</code>类里面的<code>simpleTrack:para2:</code>方法的点击事件, 事件ID是<code>HYZViewController1SimpleButtonClick</code>.<br>我们在<code>APPDelegate</code>的<code>application:didFinishLaunchingWithOptions:</code>方法中, 来hook所有的在<code>trackList</code>中记录的方法.<br>在``中, 实现如下相关代码.</p>\n<pre><code>+ (void)setup {\n    //实现和替换hook的block方法\n    NSMutableDictionary *blockDict = [[NSMutableDictionary alloc] init];\n    [HYZTrackManager weightEventEntry:blockDict];\n\n    [[HYZTrackList trackList] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        BOOL isLightEvent = [obj[kIsLightEvent] boolValue];\n        NSString *className = obj[kClassName];\n        NSString *functionName = obj[kHookFunction];\n        NSString *eventName = obj[kEventType];\n        Class class = NSClassFromString(className);\n        SEL selector = NSSelectorFromString(functionName);\n        if (isLightEvent == YES) {\n            if (!functionName) {\n                return;\n            }\n            [HYZTrackManager lightTrackTarget:class selector:selector functionName:functionName trackId:eventName];\n        } else {\n            NSString *blockName = obj[kHandlerBlock];\n            id handleBlock = [blockDict objectForKey:blockName];\n            if (!handleBlock) {\n                return;\n            }\n            [HYZTrackManager complexTrackTarget:class selector:selector usingBlock:handleBlock];\n        }\n    }];\n}\n</code></pre><p>针对简单埋点, 我们直接使用</p>\n<pre><code>//简单埋点虽然可以拿到对应方法的参数, 但是如果需要把该参数传到埋点请求的网络事件中的话, 必须使用复杂埋点来处理\n+ (void)lightTrackTarget:(Class)target selector:(SEL)selector functionName:(NSString *)functionName trackId:(NSString *)trackId {\n    NSError *error;\n    NSInteger functionParamCount = [[functionName componentsSeparatedByString:@&quot;:&quot;] count] - 1;\n    switch (functionParamCount) {\n        case 0: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo){\n                [HYZTrackManager trackRequestWithTrackId:trackId, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 1: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 2: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 3: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, nil];\n            }error:&amp;error];\n        }\n            break;\n        case 4: {\n            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3, id p4){\n                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, p4, nil];\n            }error:&amp;error];\n        }\n            break;\n        default:\n            break;\n    }\n}\n</code></pre><p>简单埋点虽然也可以拿到Hook的方法的参数, 但是由于通用性, 所以不能用来传递可变的参数.</p>\n<p>真正的埋点请求是这样的</p>\n<pre><code>+ (void)trackRequestWithTrackId:(NSString *)trackId, ... NS_REQUIRES_NIL_TERMINATION{\n    // 定义一个指向个数可变的参数列表指针；\n    va_list args;\n    // 用于存放取出的参数\n    NSString *arg;\n    // 初始化变量刚定义的va_list变量，这个宏的第二个参数是第一个可变参数的前一个参数，是一个固定的参数\n    va_start(args, trackId);\n    // 遍历全部参数 va_arg返回可变的参数(a_arg的第二个参数是你要返回的参数的类型)\n    while ((arg = va_arg(args, NSString *))) {\n        NSLog(@&quot;%@&quot;, arg);\n    }\n    // 清空参数列表，并置参数指针args无效\n    va_end(args);\n    NSLog(@&quot;此处用来实现埋点事件记录%@的网络请求&quot;, trackId);\n}\n</code></pre><p>至此, 实现了简单埋点的方法Hook.</p>\n<h2 id=\"复杂埋点\"><a href=\"#复杂埋点\" class=\"headerlink\" title=\"复杂埋点\"></a>复杂埋点</h2><p>复杂埋点, 因为要传参数进来, 所以我们利用<code>+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;</code>可以传block参数来实现.<br>首先, 我们在<code>HYZTrackList</code>中把类名, 方法名和需要定义的Block关联起来,如下所示.</p>\n<pre><code>{kClassName:@&quot;HYZViewController3&quot;,\nkHookFunction:@&quot;trackWithTag:&quot;,\nkHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,\nkIsLightEvent:@(NO)}\n</code></pre><p>在<code>APPDelegate</code>中初始化时, 需要在<code>HYZTrackManager</code>中实现Block的定义, </p>\n<pre><code>//hook的block在这里定义和实现\n+ (void)weightEventEntry:(NSMutableDictionary*)blockDict{\n    [HYZTrackManager trackButtonAction:blockDict];\n}\n\n//block的内部实现\n+ (void)trackButtonAction:(NSMutableDictionary *)blockDict {\n    void(^HYZViewController3TrackHandleBlock)(id, NSInteger tag) = ^(id &lt;AspectInfo&gt;aspectInfo, NSInteger tag) {\n        switch (tag) {\n                case 1: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 2: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 3: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n                case 4: {\n                    [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n                }\n                break;\n            default:\n                break;\n        }\n    };\n    [blockDict setObject:[HYZViewController3TrackHandleBlock copy] forKey:@&quot;HYZViewController3TrackHandleBlock&quot;];\n}\n</code></pre><p>然后Hook原方法;</p>\n<pre><code>//复杂的埋点,\n+ (void)complexTrackTarget:(Class)target selector:(SEL)selector usingBlock:(id)block {\n    NSError *error;\n    [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:block error:&amp;error];\n}\n</code></pre><p><a href=\"https://github.com/HChong3210/AOPTrack\" target=\"_blank\" rel=\"noopener\">Demo</a><br>参考资料: </p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"noopener\">iOS 如何实现Aspect Oriented Programming</a></li>\n<li><a href=\"http://www.vienta.me/2016/09/21/AOP%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%80%E7%BB%9F%E8%AE%A1%E5%9F%8B%E7%82%B9/\" target=\"_blank\" rel=\"noopener\">AOP在iOS中的实践——统计埋点</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20160421/15912.html\" target=\"_blank\" rel=\"noopener\">可复用且高度解耦的iOS用户统计实现</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150120/10959.html\" target=\"_blank\" rel=\"noopener\">Method Swizzling和AOP(面向切面编程)实践</a></li>\n</ol>\n","categories":["统计打点"],"tags":["解决方案","AOP","统计打点"]},{"title":"设计模式-工厂模式","url":"http://hchong.net/2017/02/08/设计模式-工厂模式/","content":"<h1 id=\"设计模式-工厂模式\"><a href=\"#设计模式-工厂模式\" class=\"headerlink\" title=\"设计模式-工厂模式\"></a>设计模式-工厂模式</h1><p>下面有一个case, 要编写一个简单的计算器程序, 用来实现加减乘除的运算操作, 并且展示出来.我们就拿这个最简单的例子来一步一步见识一下”工厂模式”的魅力.</p>\n<h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>版本一:我们首先想到的最简单的模式就是我们先从业务上来拆分, 把计算器程序分成两部分<em>计算</em>和<em>展示</em>两个类来写代码.OC作为一门面向对象的语言, 在这里我们已经可以清楚地意识到我们已经使用了<em>封装</em>这面向对象语言的一大特性.但是随着业务的发展, 我们发现可能会增加其他的业务(例如增加其他的运算操作),这是我们每次都要修改<em>计算</em>这个类, 慢慢的代码就会越来越多, 不利于维护.而且在新加逻辑的过程中有可能会修改到老的代码, 维护成本很高.这是我们就会想到其他两个特性<em>继承</em>和<em>多态</em>.于是, 就有了版本二.</p>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>这时我们发现,把所有的运算写到一个类中是有些不妥当的, 那么要怎么来修改呢.我们自然地想到, 每一种运算可以单独度的封装为一个类, 只用于实现固定的计算.于是我们可以得到<em>加</em>,<em>减</em>,<em>乘</em>,<em>除</em>四个类, 每个类都三个属性, 分别是<em>操作数</em>和<em>结果</em>.哪里怪怪的呢, 有没有一丝”坏代码”的味道呢.通过提炼我们发现四个类都有相同的三个属性,那么我们可以这样做新建一个<code>Operation</code>操作类, 包含三个<code>Public</code>属性</p>\n<pre><code>@interface Operation : NSObject\n\n@property (nonatomic, assign) CGFloat numberA;\n@property (nonatomic, assign) CGFloat numberB;\n@property (nonatomic, assign) CGFloat numberResult;\n\n- (CGFloat)getResult;\n@end\n</code></pre><p>这样的话, 只需要每一个单独的计算类继承于<code>Operation</code>类, 就会自带父类的三个属性, 只用在他们内部实现自己独有的计算方法, 返回计算结果就可以了.到这里, 我们会发现代码变得更加有意思了.<br>但是我们又发现了一个新的问题, 那就是我们该何时初始化哪个类呢, 毕竟我们现在有了四个计算子类.我们只好计算结果的地方写<code>Switch</code>条件来判断到底要初始化那一个子类.</p>\n<p>可是仍然感觉哪里还是怪怪的.我们不是还有<em>多态</em>这种特性没有使用的嘛.仔细一想, 于是又有了版本三.</p>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><blockquote>\n<p>多态:多态表示不同的对象可以执行相同的操作, 但要通过他们自己的实现代码来执行.<br>这是我们需要增加一个工厂类<code>OperationFactory</code>, 用来判断要初始化哪一个子类.</p>\n</blockquote>\n<p><code>OperationFactory.h</code>代码如下:</p>\n<pre><code>@class Operation;\n@interface OperationFactory : NSObject\n\n+ (Operation *)createOperationWithOperate:(NSString *)operate;\n@end\n</code></pre><p><code>OperationFactory.m</code>代码如下:</p>\n<pre><code>@implementation OperationFactory\n\n//传入计算符号, 初始化不同的子类\n+ (Operation *)createOperationWithOperate:(NSString *)operate {\n    if ([operate isEqualToString:@&quot;+&quot;]) {\n        OperationAdd *add = [[OperationAdd alloc] init];\n        return add;\n    }\n\n    if ([operate isEqualToString:@&quot;-&quot;]) {\n        OperationSubtraction *subtraction = [[OperationSubtraction alloc] init];\n        return subtraction;\n    }\n\n    ...\n    return nil;\n}\n\n@end\n</code></pre><p>此时展示的地方, 代码就变得很简单了:</p>\n<pre><code>@interface ViewController ()\n\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    Operation *operation = [OperationFactory createOperationWithOperate:@&quot;-&quot;];//子类以父类的身份出现\n    operation.numberA = 3;\n    operation.numberB = 5;\n    CGFloat result = [operation getResult];//子类在工作时以自己的方式实现\n    NSLog(@&quot;%f&quot;, result);\n    NSLog(@&quot;%f&quot;, operation.numberResult);\n}\n@end\n</code></pre><p>如上我们可以发现, 整个工厂模式的关键就在于<code>OperationFactory</code>这个工厂类的实现.我们在调用的时候不用关心我们要实现哪一个类, <code>CGFloat result = [operation getResult];</code>, 只用调用父类的方法就可以, 而内部则是子类自己的实现.<br>这里面还有几点要注意:</p>\n<blockquote>\n<ol>\n<li>子类以父类的身份出现</li>\n<li>子类在工作时以自己的方式实现</li>\n<li>子类独有的方法和属性不可以使用</li>\n</ol>\n</blockquote>\n<p>在这里解释一下就是, 我们在展示的时候初始化的实际上是父类<code>Operation</code>.但是在获取计算结果时, 我们使用的是子类的计算方法<code>CGFloat result = [operation getResult];</code>, 因为我们在子类里面复写了父类的方法, 所以实际上走的还是子类各自自己的方法.</p>\n","categories":["设计模式"],"tags":["架构","设计模式"]},{"title":"常见的代码\"坏味道\"","url":"http://hchong.net/2016/12/28/常见的代码坏味道/","content":"<h1 id=\"常见的代码”坏味道”\"><a href=\"#常见的代码”坏味道”\" class=\"headerlink\" title=\"常见的代码”坏味道”\"></a><strong>常见的代码”坏味道”</strong></h1><p>正所谓优雅的代码是相似的, 不优雅的代码却各有各的丑. 最近在拜读&lt;重构- 改善既有代码的设计&gt;一书, 虽然书中大量示例是用Java编写的, 但是也给了我很多启发.<br>见贤思齐, 耗时把感想记录下来, 督促自己的成长. </p>\n<h2 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a><strong>重复代码</strong></h2><p>坏味道行列中 ,最常见的就是Duplicated Code. 如果你在一个以上的地点看到相同的程序结构, 那么可以肯定: 把他们合而为一, 会使得代码变得更好.</p>\n<ol>\n<li><p>最单纯的Duplicated Code就是”同一个类的两个函数有相同的表达式”, 解决办法就是:</p>\n<ul>\n<li>采用Extract Method(提炼函数)提炼出重复的代码, 然后这两个地方都调用提炼出来的那一段代码.</li>\n</ul>\n</li>\n<li><p>两个互为兄弟的子类内包含相同的表达式, 解决办法就是:</p>\n<ul>\n<li>对两个类都是用Extract Method(提炼函数), 再对提炼出来的代码使用Pull Up Method(函数上移)</li>\n<li>如果代码只是类似而不完全相同, 那就要先使用Extract Method(提炼函数)将相似和差异的代码分隔开, 构造成一个单独的函数, 然后再<em>塑造模板函数</em></li>\n</ul>\n</li>\n<li><p>如果两个毫不相关的类出现Duplicated Code, 应该把重复代码提炼到一个独立类中, 然后再另一个类中使用这个新类</p>\n</li>\n</ol>\n<blockquote>\n<p>函数上移(Pull Up Method): 若干个身处子类中的函数, 他们又可以通过某种形式的参数调整成为相同的函数. 这时候, 最简单的方法就是首先分别调整这些函数的参数, 然后再将他们概括到父类中去. 特殊情况: 当子类的函数覆写了父类的函数, 但却仍然做相同的工作.</p>\n<p>塑造模板函数(Form Template Method): 两个函数以相同顺序执行大致相近的操作, 但是各操作不完全相同. 这种情况下我们可以将执行操作的序列移至父类, 并借助多态保证各操仍得以保持差异性.</p>\n</blockquote>\n<h2 id=\"过长函数-Long-Method\"><a href=\"#过长函数-Long-Method\" class=\"headerlink\" title=\"过长函数(Long Method)\"></a><strong>过长函数(Long Method)</strong></h2><p>程序愈长愈难理解.<br>我们应该积极地分解函数, 只要你感觉需要在一个地方加注释, 我们就要把需要说明的东西写进一个独立函数, 并以其用途(而非实现手法)命名. 哪怕替换后的函数调用动作比函数自身还长, 只要函数名称能够解释其用途, 我们就应该毫不犹豫地那么做, 关键不在于函数的长度, 而在于”做什么”和”如何做”之间的语义距离.</p>\n<ol>\n<li>大多数场合, 把函数变小, 只需使用Extract Method(提炼函数). 找到函数中适合集中在一起的部分, 将他们提炼出来一个新函数.</li>\n<li>如果函数中有大量的参数和临时变量, 他们会对你的函数提炼形成阻碍. 如果</li>\n</ol>\n<h2 id=\"过大的类-Large-Class\"><a href=\"#过大的类-Large-Class\" class=\"headerlink\" title=\"过大的类(Large Class)\"></a><strong>过大的类(Large Class)</strong></h2><h2 id=\"过长参数列-Long-Parameter-List\"><a href=\"#过长参数列-Long-Parameter-List\" class=\"headerlink\" title=\"过长参数列(Long Parameter List)\"></a><strong>过长参数列(Long Parameter List)</strong></h2><h2 id=\"发散式变化-Divergent-Change\"><a href=\"#发散式变化-Divergent-Change\" class=\"headerlink\" title=\"发散式变化(Divergent Change)\"></a><strong>发散式变化(Divergent Change)</strong></h2><h2 id=\"霰弹式修改-Shotgun-Surgery\"><a href=\"#霰弹式修改-Shotgun-Surgery\" class=\"headerlink\" title=\"霰弹式修改(Shotgun Surgery)\"></a><strong>霰弹式修改(Shotgun Surgery)</strong></h2><h2 id=\"依恋情结-Feature-Envy\"><a href=\"#依恋情结-Feature-Envy\" class=\"headerlink\" title=\"依恋情结(Feature Envy)\"></a><strong>依恋情结(Feature Envy)</strong></h2><h2 id=\"数据泥团-Data-Clumps\"><a href=\"#数据泥团-Data-Clumps\" class=\"headerlink\" title=\"数据泥团(Data Clumps)\"></a><strong>数据泥团(Data Clumps)</strong></h2><h2 id=\"基本类型偏执-Primitive-Obsession\"><a href=\"#基本类型偏执-Primitive-Obsession\" class=\"headerlink\" title=\"基本类型偏执(Primitive Obsession)\"></a><strong>基本类型偏执(Primitive Obsession)</strong></h2><h2 id=\"Switch-惊悚现身-Switch-Statements\"><a href=\"#Switch-惊悚现身-Switch-Statements\" class=\"headerlink\" title=\"Switch 惊悚现身(Switch Statements)\"></a><strong>Switch 惊悚现身(Switch Statements)</strong></h2><h2 id=\"平行继承体系-Parallel-Inheritance-Hierarchies\"><a href=\"#平行继承体系-Parallel-Inheritance-Hierarchies\" class=\"headerlink\" title=\"平行继承体系(Parallel Inheritance Hierarchies)\"></a><strong>平行继承体系(Parallel Inheritance Hierarchies)</strong></h2><h2 id=\"冗赘类-Lazy-Class\"><a href=\"#冗赘类-Lazy-Class\" class=\"headerlink\" title=\"冗赘类(Lazy Class)\"></a><strong>冗赘类(Lazy Class)</strong></h2><h2 id=\"夸夸其谈未来性-Speculative-Generatlity\"><a href=\"#夸夸其谈未来性-Speculative-Generatlity\" class=\"headerlink\" title=\"夸夸其谈未来性(Speculative Generatlity)\"></a><strong>夸夸其谈未来性(Speculative Generatlity)</strong></h2><h2 id=\"令人迷惑的暂时字段-Temporary-Field\"><a href=\"#令人迷惑的暂时字段-Temporary-Field\" class=\"headerlink\" title=\"令人迷惑的暂时字段(Temporary Field)\"></a><strong>令人迷惑的暂时字段(Temporary Field)</strong></h2><h2 id=\"过度耦合的消息链-Message-Chains\"><a href=\"#过度耦合的消息链-Message-Chains\" class=\"headerlink\" title=\"过度耦合的消息链(Message Chains)\"></a><strong>过度耦合的消息链(Message Chains)</strong></h2><h2 id=\"中间人-Middle-Man\"><a href=\"#中间人-Middle-Man\" class=\"headerlink\" title=\"中间人(Middle Man)\"></a><strong>中间人(Middle Man)</strong></h2><h2 id=\"狎昵关系-Inappropriate-Intimacy\"><a href=\"#狎昵关系-Inappropriate-Intimacy\" class=\"headerlink\" title=\"狎昵关系(Inappropriate Intimacy)\"></a><strong>狎昵关系(Inappropriate Intimacy)</strong></h2><h2 id=\"异曲同工的类-AlertNative-Classes-with-Different-Interfaces\"><a href=\"#异曲同工的类-AlertNative-Classes-with-Different-Interfaces\" class=\"headerlink\" title=\"异曲同工的类(AlertNative Classes with Different Interfaces)\"></a><strong>异曲同工的类(AlertNative Classes with Different Interfaces)</strong></h2><h2 id=\"不完美的库类-Incomplete-Library-Class\"><a href=\"#不完美的库类-Incomplete-Library-Class\" class=\"headerlink\" title=\"不完美的库类(Incomplete Library Class)\"></a><strong>不完美的库类(Incomplete Library Class)</strong></h2><h2 id=\"纯稚的数据类-Data-Class\"><a href=\"#纯稚的数据类-Data-Class\" class=\"headerlink\" title=\"纯稚的数据类(Data Class)\"></a><strong>纯稚的数据类(Data Class)</strong></h2><h2 id=\"被拒绝的遗赠-Refused-Bequest\"><a href=\"#被拒绝的遗赠-Refused-Bequest\" class=\"headerlink\" title=\"被拒绝的遗赠(Refused Bequest)\"></a><strong>被拒绝的遗赠(Refused Bequest)</strong></h2><h2 id=\"过多的注释-COmments\"><a href=\"#过多的注释-COmments\" class=\"headerlink\" title=\"过多的注释(COmments)\"></a><strong>过多的注释(COmments)</strong></h2>","categories":["架构"],"tags":["重构","架构"]},{"title":"代码重构与拆分","url":"http://hchong.net/2016/12/26/代码重构与拆分/","content":"<h1 id=\"代码的重构与拆分\"><a href=\"#代码的重构与拆分\" class=\"headerlink\" title=\"代码的重构与拆分\"></a><strong>代码的重构与拆分</strong></h1><p>最近项目中有一块代码, 几经人手, 流落到我这里. 代码的业务逻辑十分复杂, 而且随着业务的扩张, 被不同的人加入而不同风格的代码, 最初的架构已经不适合现有业务的发展了, 维护起来也是相当的困难. 于是, 我就走上了重构和拆分之路.</p>\n<p>实际上来讲, 重构和拆分是两个不同的概念, 但是又都是相辅相成, 下面我简单讲一下我的理解.</p>\n<blockquote>\n<p>重构: 对软件内部结构的一种调整, 目的是在不改变软件可观察行为的前提下, 提高其可理解性, 降低其修改成本.</p>\n</blockquote>\n<ul>\n<li>拆分: 整体项目的架构, 降低代码的耦合性, 使得团队中的成员协作使用起来更加容易.</li>\n</ul>\n<p>不管重构还是拆分, 都是为了让代码能够跟上业务发展的水平, 不至于变得一团乱麻, 让团队之间的协作开发更加有效.</p>\n","categories":["架构"],"tags":["重构","拆分"]},{"title":"hexo常见问题","url":"http://hchong.net/2016/12/21/hexo常见问题/","content":"<h1 id=\"hexo常见问题\"><a href=\"#hexo常见问题\" class=\"headerlink\" title=\"hexo常见问题\"></a><strong>hexo常见问题</strong></h1><p>在使用hexo的过程中遇到了一些问题, 在这里列出来, 做一个记录.</p>\n<h2 id=\"hexo的常见发布流程\"><a href=\"#hexo的常见发布流程\" class=\"headerlink\" title=\"hexo的常见发布流程\"></a><strong>hexo的常见发布流程</strong></h2><ul>\n<li>hexo新建一篇文章使用<code>hexo new type name</code>, <code>type</code>有三种, 最常使用的是<code>post</code>, <code>name</code>是新建文档的名字.</li>\n<li><p>hexo新建完成, 编辑之后发布会经常使用到下面几个命令:</p>\n<ul>\n<li><code>hexo clean</code>清除之前缓存的一些信息, 例如主题之类的, 不是每次都必须执行.</li>\n<li><code>hexo g</code>相当于编译.</li>\n<li><code>hexo s</code>发布到本地服务器, 把<em>.md</em>文件生成讲台html用于展示, 也可做调试用.</li>\n<li><code>hexo d</code>推本地的文件到服务器, 这里指的是github上面, 如果绑定的有域名, 就直接发布到Internet. 每次推送前, 要确保<code>hexo g</code>和<code>hexo s</code>没有问题, 否则可造成Internet上面无法正常显示.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"hexo目录结构分析\"><a href=\"#hexo目录结构分析\" class=\"headerlink\" title=\"hexo目录结构分析\"></a><strong>hexo目录结构分析</strong></h2><h3 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a><strong>根目录</strong></h3><ul>\n<li>_config.yml: 位于本地博客的根目录下, 在这里面对整个博客的内容进行一些设置.</li>\n<li>source文件夹: 里面存储一些博客使用的文件资源, 例如<em>category(分类)</em>, <em>tag(标签)</em>, <em>link(链接)</em>, <em>about(关于)</em>, <em>project(工程)</em>, <em>search(搜索)</em>, *_posts(使用post格式新建的文章.md文件存储在这里).需要说明一下的是, 这些文件夹的名称和数量不固定, 要看你使用的主题里面的模块大概有几个 ,我使用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"noopener\">fexo</a>.还有一些坑, 后面再详述.</li>\n<li>public文件夹: 里面存储的是之前发布过得一些归档数据, 如果要删除之前的测试数据的话, 记得清理里面响应的内容.</li>\n<li>scaffolds文件夹: 存储.md文档的类型.</li>\n<li>themes文件夹: 里面是你下载的主题内容, 如果有多个主题, 就会有多个文件夹, 但只能同时使用一种样式的主题.这个后面会着重分析一下.</li>\n</ul>\n<h3 id=\"themes文件夹\"><a href=\"#themes文件夹\" class=\"headerlink\" title=\"themes文件夹\"></a><strong>themes文件夹</strong></h3><p>这里面主要会进行一些主题相关的设置.</p>\n<ul>\n<li>_config.yml: 位于主题目录下, 在这里面对当前只用主题的内容进行一些配置, 不同主题的配置可能不太一样, 我是用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"noopener\">fexo</a></li>\n</ul>\n<ul>\n<li>source文件夹: 该文件夹下面是该主题相关的一些资源, 例如一些静态的图片之类的.</li>\n<li>layout文件夹: 该文件夹下面是静态页面显示的相关配置. 代码高亮的设置也是在该文件夹下面. 其他的例如静态页面的展示, 可以修改相关的js文件.</li>\n</ul>\n<h2 id=\"修改代码高亮\"><a href=\"#修改代码高亮\" class=\"headerlink\" title=\"修改代码高亮\"></a><strong>修改代码高亮</strong></h2><p>代码高亮的展示, 不同的主题有不同的使用方式, 但是代码高亮的theme可以参考这里, 我使用的是<a href=\"https://highlightjs.org/static/demo/\" target=\"_blank\" rel=\"noopener\">HighLight</a>, 它提供了多种Theme, 基本上能满足各种需求.</p>\n<p>修改步骤如下:</p>\n<p>1.修改博客根目录下的<em>_config.yml</em>文件, 关闭hexo自带的代码高亮.</p>\n<pre><code class=\"js\">highlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n</code></pre>\n<p>2.<code>cd 博客根目录/themes/fexo/layout/_partial</code>打开<em>head.ejs</em>文件, 最好是在<code>&lt;head&gt;&lt;/head&gt;</code>之间开头处插入代码</p>\n<pre><code class=\"html5\">  &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css&quot;&gt;\n  &lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>也可以使用下面的写法:</p>\n<pre><code class=\"h5\">&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/styles/default.css&quot;&gt;\n&lt;script src=&quot;/path/to/highlight.pack.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;\n</code></pre>\n<p>二者的区别在于, 第一种写法使用的是CDN创建的<a href=\"http://www.bootcdn.cn/?\" target=\"_blank\" rel=\"noopener\">在线文档地址</a>, 该地址还保存了其他一些常见的文档, 非常强大.而第二种写法则是把文件下载到本地, 从本地读取代码高亮的配置.</p>\n<hr>\n<p>修改过程中, 我参考了以下两篇博文, 还趟过不少坑, 贴上博文的地址:</p>\n<ol>\n<li><a href=\"http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-highlight/\" target=\"_blank\" rel=\"noopener\">地址一</a></li>\n<li><a href=\"http://jumpbyte.cn/2016/07/02/use-and-install-prettify/\" target=\"_blank\" rel=\"noopener\">地址二</a></li>\n</ol>\n","categories":["hexo"],"tags":["hexo","个人博客"]},{"title":"属性修饰符之copy和strong","url":"http://hchong.net/2016/09/21/属性修饰符之copy和strong/","content":"<h1 id=\"属性修饰符之copy和strong\"><a href=\"#属性修饰符之copy和strong\" class=\"headerlink\" title=\"属性修饰符之copy和strong\"></a>属性修饰符之copy和strong</h1><p>在了解属性修饰符的copy和strong的区分之前, 我们先来了解下浅拷贝和深拷贝的区别.</p>\n<h2 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h2><p>浅复制并不是拷贝对象本身, 仅仅是拷贝指向对象的指针; 深复制是直接拷贝整个对象内存到另一块内存中. 简单地说:</p>\n<ul>\n<li><strong>浅复制就是指针拷贝,  不会产生新的对象，指向的是同一个对象; </strong></li>\n<li><strong>深复制就是内容拷贝，会产生新的对象, 不同的对象, 内容相同.</strong></li>\n</ul>\n<p><img src=\"http://7s1ssm.com1.z0.glb.clouddn.com/image_note50592_1.png\" alt=\"浅复制和深复制\"></p>\n<h2 id=\"copy和mutableCopy\"><a href=\"#copy和mutableCopy\" class=\"headerlink\" title=\"copy和mutableCopy\"></a>copy和mutableCopy</h2><p><code>copy</code>就是复制了一个imutable对象, <code>mutableCopy</code>就是复制了一个mutable对象.</p>\n<p>一个<code>NSObject</code>对象要想使用这两个函数, 必须实现<code>NSCopying</code>协议和<code>NSMutableCopying</code>协议, 并且分别实现<code>- (id)copyWithZone:(nullable NSZone *)zone;</code>和<code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code>方法.但是常见的<code>NSString</code>, <code>NSArray</code>, <code>NADictionary</code>等常用的系统提供的结构体都已经实现. </p>\n<h3 id=\"系统的非容器类对象\"><a href=\"#系统的非容器类对象\" class=\"headerlink\" title=\"系统的非容器类对象\"></a>系统的非容器类对象</h3><p>这里指的是<code>NSString</code>, <code>NSNumber</code>等等一类的对象.下面以<code>NSString</code>为例.</p>\n<p>对<code>NSString</code>进行copy和mutableCop操作:</p>\n<pre><code class=\"objective-c\">NSString *originString = @&quot;origin&quot;;\nNSString *originStringCopy = [originString copy];\nNSMutableString *originStringMutableCopy = [originString mutableCopy];\nNSLog(@&quot;%p, %p, %p&quot;, originString, originStringCopy, originStringMutableCopy);\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originString\n(__NSCFConstantString *) $0 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringCopy\n(__NSCFConstantString *) $1 = 0x0000000108dd8190 @&quot;origin&quot;\n(lldb) p originStringMutableCopy\n(__NSCFString *) $2 = 0x0000608000262800 @&quot;origin&quot;\n</code></pre>\n<hr>\n<p>对<code>NSMutableString</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginString = [NSMutableString stringWithString:@&quot;mutableOrigin&quot;];\nNSString *mutableOriginStringCopy = [mutableOriginString copy];\nNSMutableString *mutableOriginStringMutableCopy = [mutableOriginString mutableCopy];\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p mutableOriginString\n(__NSCFString *) $0 = 0x000060800026aa40 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringCopy\n(__NSCFString *) $1 = 0x0000608000222340 @&quot;mutableOrigin&quot;\n(lldb) p mutableOriginStringMutableCopy\n(__NSCFString *) $2 = 0x000060800026a700 @&quot;mutableOrigin&quot;\n</code></pre>\n<p>这里要注意的是:</p>\n<pre><code class=\"objective-c\">NSMutableString *mutableOriginStringCopy = [mutableOriginString copy];\n[mutableOriginStringCopy appendString:@&quot;123&quot;];\n</code></pre>\n<p>这样写是会crash的, 因为copy生成的是imutable对象, 不管声明是什么样的, 依旧是imutable的.</p>\n<p><strong>综上, 对于系统的非容器类对象:</strong></p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n</ul>\n<h3 id=\"系统的容器类对象\"><a href=\"#系统的容器类对象\" class=\"headerlink\" title=\"系统的容器类对象\"></a>系统的容器类对象</h3><p>容器类对象指的是<code>NSArray</code>, <code>NSDictionary</code>, <code>NSSet</code>等系统提供的结构体, 下面以<code>NSArray</code>为例.</p>\n<p>对<code>NSArray</code>进行copy操作:</p>\n<pre><code class=\"objective-c\">NSArray *originArray = [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>内存地址分别是:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayI *) $0 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x00006080002405a0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x00006080002403c0 @&quot;3 elements&quot;\n</code></pre>\n<p>可以看出, copy是浅复制, mutableCopy是深复制. 需要注意的是,mutableCopy的对象是一个可变对象,  数组内元素全都是浅复制.</p>\n<hr>\n<p>对<code>NSMutableArray</code>进行copy和mutableCopy操作:</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSArray *originArrayCopy = [originArray copy];\nNSMutableArray *originArrayMutableCopy = [originArray mutableCopy];\nfor (NSInteger i = 0; i &lt; originArray.count; i++) {\n    NSLog(@&quot;originArray--%p&quot;, originArray[i]);\n    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);\n    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);\n}\n</code></pre>\n<p>打印内存地址如下:</p>\n<pre><code class=\"objective-c\">(lldb) p originArray\n(__NSArrayM *) $0 = 0x000060800005eae0 @&quot;3 elements&quot;\n(lldb) p originArrayCopy\n(__NSArrayI *) $1 = 0x000060800005e9f0 @&quot;3 elements&quot;\n(lldb) p originArrayMutableCopy\n(__NSArrayM *) $2 = 0x000060800005e900 @&quot;3 elements&quot;\n</code></pre>\n<p>可以发现可以看出, copy是浅复制, mutableCopy是深复制. 数组内元素都是浅复制.</p>\n<p>需要注意的是, mutable对象copy的对象是imutable对象, 如果当做可变对象来用是会崩溃的.</p>\n<pre><code class=\"objective-c\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];\nNSMutableArray *originArrayCopy1 = [originArray copy];\n[originArrayCopy1 addObject:@&quot;d&quot;];//crash\n</code></pre>\n<p>综上, 对于容器类对象:</p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n<li><strong>元素对象是浅复制.</strong></li>\n</ul>\n<h3 id=\"系统类对象的完全深复制\"><a href=\"#系统类对象的完全深复制\" class=\"headerlink\" title=\"系统类对象的完全深复制\"></a>系统类对象的完全深复制</h3><p>对于容器类对象而言, 元素对象始终是浅复制, 要想深复制可通过如下方法:</p>\n<pre><code class=\"objective-c\">NSArray *array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],[NSString stringWithString:@&quot;b&quot;],@&quot;c&quot;,nil];\nNSArray *deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];\nNSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject: array]];\n</code></pre>\n<p>打印元素内存地址可以发现, trueDeepCopyArray的元素都是深复制, 而deepCopyArray由于第一个元素是可变对象, 所以是深复制, 其他的元素都是浅复制.</p>\n<p><strong>综上, 要想实现容器对象所有元素的深复制, 只能通过归档来实现.</strong></p>\n<blockquote>\n<p>If you need a true deep copy, such as when you have an array of arrays, you can archive and then unarchive the collection, provided the contents all conform to the <code>NSCoding</code> protocol</p>\n</blockquote>\n<pre><code class=\"objective-c\">@protocol NSCoding\n\n- (void)encodeWithCoder:(NSCoder *)aCoder;\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER\n\n@end\n</code></pre>\n<h3 id=\"自定义对象\"><a href=\"#自定义对象\" class=\"headerlink\" title=\"自定义对象\"></a>自定义对象</h3><p>对于自定义对象, 我们要实现<code>NSCopying</code>, <code>NSMutableCopying</code>协议, 这样我们就能调用copy和mutableCopy了.假设有一个<code>Person</code>类, 继承于<code>NSObject</code>.</p>\n<p><code>person.h</code></p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n@interface Person : NSobject\n\n@property (nonatomic, assign) NSInteger age;\n@end\n</code></pre>\n<p><code>person.m</code></p>\n<pre><code class=\"objective-c\">\n#import &quot;Person.h&quot;\n@interface Person()&lt;NSCopying&gt;\n@end\n\n@implementation Person\n\n- (id)copyWithZone:(NSZone *)zone {\n    Person *person = [[Person allocWithZone:zone] init];\n      person.age = self.age;\n    return person;\n}\n@end\n</code></pre>\n<p>这样当我们在外面调用的时候:</p>\n<pre><code class=\"objective-c\">Person *p = [[Person alloc] init];\np.age = 20;\n\nPerson *copyP = [p copy];\nNSLog(@&quot;p = %p copyP = %p&quot;, p, copyP);\nNSLog(@&quot;age = %ld&quot;, copyP.age);\n</code></pre>\n<p>通过打印地址:</p>\n<pre><code class=\"objective-c\">(lldb) p p\n(Person *) $0 = 0x000060800002a1e0\n(lldb) p copyP\n(Person *) $1 = 0x000060800002a2e0\n(lldb) p p.age\n(NSInteger) $2 = 20\n(lldb) p copyP.age\n(NSInteger) $4 = 20\n</code></pre>\n<p>我们可以发现, 自定义对象内部的属性都被浅拷贝, 自定义对象本身被深拷贝.</p>\n<p>需要注意的是, 如果我们的自定义对象不实现<code>NSCopying</code>协议而直接copy时, 是会crash的.</p>\n<h2 id=\"属性修饰之copy与strong\"><a href=\"#属性修饰之copy与strong\" class=\"headerlink\" title=\"属性修饰之copy与strong\"></a>属性修饰之copy与strong</h2><p>我们新建一个<code>Person</code>类, 添加几个属性来看一下copy和strong对属性使用的影响.</p>\n<pre><code class=\"objective-c\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface Person : NSObject\n\n@property (nonatomic, strong) NSString *strongName;\n@property (nonatomic, copy) NSString *copyName;\n\n@end\n</code></pre>\n<p>在外面调用<code>Person</code>类, 代码如下:</p>\n<pre><code class=\"objective-c\">Person *person = [[Person alloc] init];\nNSMutableString *testString = [NSMutableString stringWithString:@&quot;test&quot;];\nperson.nameCopy = testString;\nperson.nameStrong = testString;\n[testString appendString:@&quot;copy&amp;&amp;strong&quot;];\n</code></pre>\n<p>打印<code>testString</code>改变前后属性</p>\n<pre><code class=\"objective-c\">//testString改变前\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $1 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $2 = 0x0000600000260540 @&quot;test&quot;\n//testString改变后\n(lldb) p person.nameCopy\n(NSTaggedPointerString *) $3 = 0xa000000747365744 @&quot;test&quot;\n(lldb) p person.nameStrong\n(__NSCFString *) $4 = 0x0000600000260540 @&quot;testcopy&amp;&amp;strong&quot;\n</code></pre>\n<p>由以上可以看出:</p>\n<p>对源头是<code>NSMutableString</code>的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的，它也会跟着改变, 相当于浅拷贝; 而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>\n<p>当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>\n<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>\n<p>综上可以发现, 如果property是<code>NSString</code>或者<code>NSArray</code>及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。</p>\n<p>参考文档:</p>\n<p>1.<a href=\"http://www.fanliugen.com/?p=278\" target=\"_blank\" rel=\"noopener\">copy与mutableCopy</a></p>\n<p>2.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3\" target=\"_blank\" rel=\"noopener\">Copying Collections</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e6a7cdcc705d\" target=\"_blank\" rel=\"noopener\">iOS浅谈: 深.浅拷贝与copy.strong</a></p>\n<p>4.<a href=\"http://www.cocoachina.com/ios/20150512/11805.html\" target=\"_blank\" rel=\"noopener\">NSString属性什么时候用copy，什么时候用strong?</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"内存分配","url":"http://hchong.net/2016/09/18/内存分配/","content":"<h1 id=\"iOS开发的内存分配\"><a href=\"#iOS开发的内存分配\" class=\"headerlink\" title=\"iOS开发的内存分配\"></a>iOS开发的内存分配</h1><p>计算机系统中, 应用程序的数据都保存在内存中, 不同类型的数据, 保存的区域不同.</p>\n<h2 id=\"RAM-ROM\"><a href=\"#RAM-ROM\" class=\"headerlink\" title=\"RAM ROM\"></a>RAM ROM</h2><blockquote>\n<p>RAM: 运行内存, 不能掉电存储.ROM: 存储型内存, 可以掉电存储, 例如内存卡, FLash.<br>    由于RAM类型不具备掉电存储的能力, 所以App程序一般存放在RMO中. RAM的访问速度和价格都高于ROM.</p>\n</blockquote>\n<h2 id=\"App程序启动\"><a href=\"#App程序启动\" class=\"headerlink\" title=\"App程序启动\"></a>App程序启动</h2><blockquote>\n<p>App程序启动, 系统会把开启的那个App程序从Flash或ROM里面拷贝到内存(RAM)中, 然后从内存里面执行代码.<br>    另外一个原因是CPU不能直接从内存卡里面读取指令(需要Flash驱动等等)</p>\n</blockquote>\n<h2 id=\"内存分区\"><a href=\"#内存分区\" class=\"headerlink\" title=\"内存分区\"></a>内存分区</h2><h3 id=\"栈区-stack\"><a href=\"#栈区-stack\" class=\"headerlink\" title=\"栈区(stack)\"></a>栈区(stack)</h3><p>栈区由编译器自动分配并且释放, 存放局部变量, 函数的参数值, 函数跳转地址, 现场保护等.栈是系统数据结构, 对应线程/进程是唯一的.</p>\n<p>栈空间分配分为静态分配和动态分配两种.</p>\n<ul>\n<li>静态分配是由便一起完成, 比如自动变量<code>auto</code>的分配. 动态分配由<code>alloca</code>函数完成.</li>\n<li>栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配.</li>\n</ul>\n<p>关于栈还需要注意:</p>\n<ul>\n<li>不需要我们管理栈区变量的内存</li>\n<li>栈区地址从高到低分配</li>\n<li>先进后出</li>\n</ul>\n<h3 id=\"堆区-heap\"><a href=\"#堆区-heap\" class=\"headerlink\" title=\"堆区(heap)\"></a>堆区(heap)</h3><p>堆区由我们分配(iOS下的<code>alloc</code>)和释放, 如果不释放, 在程序结束时, 可能会由系统回收(iOS的ARC下). 灵活方便, 数据适应面广, 但是因为顺序随意, 所以效率有一定降低.<br>关于堆还需要注意:</p>\n<ul>\n<li>堆区的内存分配使用<code>alloc</code>.</li>\n<li>需要程序猿管理.</li>\n<li>ARC下的内存管理由编译器自动添加<code>retain</code>, <code>release</code>, <code>autorelease</code>等关键字.</li>\n<li>堆区的地址由低到高分配.</li>\n<li>不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理).</li>\n<li>堆空间的分配总是动态的.</li>\n</ul>\n<h3 id=\"全局区-static\"><a href=\"#全局区-static\" class=\"headerlink\" title=\"全局区(static)\"></a>全局区(static)</h3><p>全局区也叫作静态区. 全局变量和静态变量在内存中是放在一起的, 初始化的全局变量和静态变量放在一块区域, 未初始化的全局变量和静态变量放在相邻的另一块区域.</p>\n<pre><code>int a;//未初始化的\nint b = 10;//初始化的\n</code></pre><h3 id=\"常量区\"><a href=\"#常量区\" class=\"headerlink\" title=\"常量区\"></a>常量区</h3><p>常量字符串就存放在这里, 程序结束后由系统自己释放.</p>\n<h3 id=\"代码区\"><a href=\"#代码区\" class=\"headerlink\" title=\"代码区\"></a>代码区</h3><p>代码区也叫作函数区, 存放函数的二进制代码, App的代码.</p>\n<h2 id=\"内存申请后的系统响应\"><a href=\"#内存申请后的系统响应\" class=\"headerlink\" title=\"内存申请后的系统响应\"></a>内存申请后的系统响应</h2><p>1.栈: 存储的函数在执行的时候都会向操作系统索要资源, 栈区就是函数运行时的内训, 栈区中的变量由编译器负责释放和分配, 内存随着函数的运行和结束而分配和释放, 由系统完成. 只要剩余的栈空间大于申请空间, 系统将会为程序提供内存, 否则将报异常提示栈溢出.<br>2.堆: 操作系统有一个记录空闲地址的链表, 当系统收到程序申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序. 由于找到的堆节点大小不一定正合适, 系统会将多余的那部分重新放入空闲链表.</p>\n<h2 id=\"内存大小的限制\"><a href=\"#内存大小的限制\" class=\"headerlink\" title=\"内存大小的限制\"></a>内存大小的限制</h2><p>1.栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.<br>2.堆: 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>如图所示: 代码区的地址最低, 栈区最高. 但是区与区之间的地址不连续.<br><img src=\"http://upload-images.jianshu.io/upload_images/1156719-1d0de5ca1edc35af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"内存地址示意图\"></p>\n<ul>\n<li>在iOS中, 堆区的内存是程序间共享, 堆区的内存分配是系统负责的.</li>\n<li>系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容).</li>\n<li>变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回.</li>\n<li>当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃.</li>\n<li>栈由系统自动分配, 速度快, 不会产生内存碎片, 先进后出.</li>\n<li>堆由<code>alloc</code>分配内存, 速度慢, 而且容易产生碎片, FIFO, 不过使用起来方便.</li>\n</ul>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://www.jianshu.com/p/f3c1b920e8eb\" target=\"_blank\" rel=\"noopener\">iOS程序中的内存分配</a><br>2.<a href=\"http://www.jianshu.com/p/7bbbe5d55440\" target=\"_blank\" rel=\"noopener\">深入浅出-iOS内存分配</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"属性的修饰符解析","url":"http://hchong.net/2016/09/16/属性的修饰符解析/","content":"<h1 id=\"属性的修饰符解析\"><a href=\"#属性的修饰符解析\" class=\"headerlink\" title=\"属性的修饰符解析\"></a>属性的修饰符解析</h1><h2 id=\"属性的修饰符\"><a href=\"#属性的修饰符\" class=\"headerlink\" title=\"属性的修饰符\"></a>属性的修饰符</h2><ol>\n<li>线程安全的: atomic, nonatomic </li>\n<li>访问权限的: readonly， readwrite </li>\n<li>内存管理（ARC）: assign，strong，weak，copy </li>\n<li>内存管理（MRC）:assign， retain，copy </li>\n<li>指定方法名称: setter= getter=</li>\n</ol>\n<hr>\n<p>默认的修饰符是:</p>\n<ul>\n<li>基本数据类型使用<code>atomic</code>, <code>readwrite</code>, <code>assign</code>.</li>\n<li>对于普通的Objective-C对象使用<code>atomic</code>, <code>readwrite</code>, <code>strong</code>.</li>\n</ul>\n<h2 id=\"weak-amp-assign\"><a href=\"#weak-amp-assign\" class=\"headerlink\" title=\"weak &amp; assign\"></a>weak &amp; assign</h2><p>assign修饰基本数据类型和结构体, weak修饰一个对象</p>\n<hr>\n<p>assign修饰的对象编译时会产生一个警告:Assigning retained object to unsafe_unretained variable; object will be released after assignment(Assign修饰的对象无法被保留). 并且在释放之后指针的地址还是存在的, 也就是说指针并没有被置为nil, 造成野指针. 对象分配一般分配在堆上的某块内存(详见<a href=\"http://hchong.net/2016/09/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/\">内存分配</a>), 如果在后续的内存分配中, 刚好分到了这块地址, 程序就会导致EXC_BAD_ACCESS(调用已释放的内存空间)崩溃掉.</p>\n<p>assign修饰的基本数据类型或者结构体因为技术数据类型和结构体一般分配在栈上, 栈的内存会由系统自己自动处理, 不会造成野指针.</p>\n<hr>\n<p>weak修饰的对象在释放之后, 指针会被置为nil, 所以一般弱引用指的就是用weak.</p>\n<p>weak主要使用在以下两个方面:</p>\n<ul>\n<li>在ARC下, 有可能出现循环引用的地方, 比如delegate<br><code>@property (nonatomic, weak) id XXXDelegate;</code></li>\n<li>自身已经被强引用过一次, 比如xib文件汇总的属性<br><code>@property (nonatomic, weak) IBOutlet UIButton *button;</code></li>\n</ul>\n<hr>\n<h2 id=\"copy关键字的使用\"><a href=\"#copy关键字的使用\" class=\"headerlink\" title=\"copy关键字的使用\"></a>copy关键字的使用</h2><p>copy和strong一样都会使引用计数加1, 但是strong是两个指针指向同一个内训地址, copy则会在内存里拷贝一份对象, 两个指针指向不同的内存地址.</p>\n<p>copy关键字主要有以下使用场景:</p>\n<ul>\n<li>不确定赋值过程中用的是可变还是不可变的变量. 例如NSString, NSArray, NSDictionary等等常使用关键字copy, 因为他们有对应的可变类型.<a href=\"http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/\">关于copy和strong的详解</a></li>\n<li>block也经常使用copy关键字. 用copy修饰block时要知道是在ARC还是MRC.<ul>\n<li>ARC下只要block访问了外部局部变量, block就会放到堆区里面, 使用strong或者copy都可以, 但是strong的性能可能会更好.</li>\n<li>MRC下, 如果block访问外部局部变量, block是在栈区的. 如果block访问了一个整个APP生命周期都存在的变量, 那他肯定在全局区. 只有使用copy属性才能把block放到堆区.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>参考内容:<br>1.<a href=\"http://www.jianshu.com/p/3e0f12e5faaa\" target=\"_blank\" rel=\"noopener\">@property 关键字的区别详解</a><br>2.<a href=\"http://bihongbo.com/2014/05/20/IOSassignandweak/\" target=\"_blank\" rel=\"noopener\">iOS开发中ARC下的assign和weak区别</a><br>3.<a href=\"http://www.jianshu.com/p/3aa1c650a967\" target=\"_blank\" rel=\"noopener\">整理一下OC中的那些属性修饰符</a><br>4.<a href=\"http://blog.csdn.net/qq_32744055/article/details/53443805\" target=\"_blank\" rel=\"noopener\">@property 后面可以有哪些修饰符</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Hello World","url":"http://hchong.net/2016/08/16/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"Wiki","url":"http://hchong.net/Wiki/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://hchong.net/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://hchong.net/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://hchong.net/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://hchong.net/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://hchong.net/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://hchong.net/tag/index.html","content":"","categories":[],"tags":[]}]