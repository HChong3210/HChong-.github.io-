[{"title":"React Native源码解析","url":"http://hchong.net/2018/04/17/React Native源码解析/","content":"<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><p>前端大致的开发流程就是:</p>\n<ul>\n<li>用 HTML 创建 DOM, 构建整个网页的布局, 结构</li>\n<li>用 CSS 控制 DOM 的样式, 比如字体, 字号, 颜色, 居中等</li>\n<li>用 JavaScript 接受用户事件, 动态的操控 DOM</li>\n</ul>\n<p>在React中, 我们使用JSX语法, 它是一种 JavaScript 语法拓展. JSX 允许我们写 HTML 标签或 React 标签, 它们终将被转换成原生的 JavaScript 并创建 DOM. 我们也可以在里面写CSS.</p>\n<p>React 独创了 Virtual DOM 机制. Virtual DOM 是一个存在于内存中的 JavaScript 对象, 它与 DOM 是一一对应的关系, 也就是说只要有 Virtual DOM, 我们就能渲染出 DOM. 当界面发生变化时, 得益于高效的 DOM Diff 算法, 我们能够知道 Virtual DOM 的变化, 从而高效的改动 DOM, 避免了重新绘制 DOM.</p>\n<p>React Native我们可以理解为Native 版本的 React. 即使使用了 React Native, 我们依然需要 UIKit 等框架, 调用的是 Objective-C 代码. JavaScript 只是辅助, 它只是提供了配置信息和逻辑的处理结果. 它只是以 JavaScript 的形式告诉 Objective-C 该执行什么代码. </p>\n<h1 id=\"React-Native启动流程\"><a href=\"#React-Native启动流程\" class=\"headerlink\" title=\"React Native启动流程\"></a>React Native启动流程</h1><p><img src=\"http://img.souche.com/f2e/bfb53a0a04e1c7a9ca7c99d9440e0972.png\" alt=\"RN整体结构\"></p>\n<p>RN的整体结构如图所示, RCTRootView 是RN的根视图, 它内部持有了 RCTBridge. RCTBridge 内部持有了 RCTBatchBridge 对象, 这个对象里面有着大部分的业务逻辑和核心代码.</p>\n<p>RCTBatchBridge 对象会持有一个 RCTDisplayLink对象, 这个对象主要用于一些Timer, Navigator的Module需要按着屏幕渲染频率回调JS用的. </p>\n<p>RCTModuleXXX 表示所有的RN的Module组件都是 RCTModuleData, 无论是RN的核心系统组件还是扩展的UI组件, API组件. </p>\n<p>RCTJSExecutor 是一个特殊的 RCTModuleData. 他是系统组件的核心, 负责单独开一个线程, 执行JS代码, 处理JS回调, 是bridge的核心通道.</p>\n<p>RCTEventDispatcher 也是一个特殊的 RCTModuleData. 各个业务模块通过它主动调起JS, 他封装了eventDispatcher得API来方便业务Module使用.</p>\n<h1 id=\"React-Native源码加载\"><a href=\"#React-Native源码加载\" class=\"headerlink\" title=\"React Native源码加载\"></a>React Native源码加载</h1><p><img src=\"http://img.souche.com/f2e/f0aa996dd91edbb43c65963064be0fae.png\" alt=\"源码加载顺序\"><br>RCTRootView的初始化中<code>-initWithBundleURL:XXX</code>中初始化了一个</p>\n<h1 id=\"React-Native页面渲染\"><a href=\"#React-Native页面渲染\" class=\"headerlink\" title=\"React Native页面渲染\"></a>React Native页面渲染</h1><h1 id=\"React-Native事件处理\"><a href=\"#React-Native事件处理\" class=\"headerlink\" title=\"React Native事件处理\"></a>React Native事件处理</h1><h1 id=\"React-Native通信机制\"><a href=\"#React-Native通信机制\" class=\"headerlink\" title=\"React Native通信机制\"></a>React Native通信机制</h1><p>React Native用iOS自带的JavaScriptCore作为JS的解析引擎, 并没有用到JavaScript提供的一些可以让JS与OC互调的特性, </p>\n","categories":["RN"],"tags":["RN"]},{"title":"iOS开发中的字符串匹配算法","url":"http://hchong.net/2018/04/12/iOS开发中的字符串匹配算法/","content":"<p>字符串匹配是计算机的基本任务之一, 例如有一个字符串”BBC ABCDAB ABCDABCDABDE”, 我想知道, 里面是否包含另一个字符串”ABCDABD”.</p>\n<h1 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h1>","categories":["算法"],"tags":["算法"]},{"title":"iOS开发总结系列-排序算法","url":"http://hchong.net/2018/04/09/iOS开发总结系列-排序算法/","content":"<p>这里主要是iOS开发中常见的排序算法. </p>\n<h1 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h1><p>原理: 从数列中挑出一个元素, 成为”基准”, 重新排序数列, 所有元素比基准值小的摆放在基准前面, 所有元素比基准值大的摆在基准的后面(相同的数可以放在任一边), 在这个分区退出之后, 该基准就处于数列的中间位置, 递归的把小于基准值元素的子数列和大于基准值元素的子数列排序.</p>\n<p>这种排序方法是基于二分的思想来实现的, 简单的说就是将一个大的问题通过不断的一分为二化简为较小的问题来解决. 通过二分化简了问题的规模来提高解决问题的效率. 因此我们将发现快速排序的平均时间复杂度是O(nlogn), 最差时间复杂度是O(n^2).</p>\n<ol>\n<li>定义两个哨兵i(数组的第一个位置), j(数组的最后一个位置), 一个基准数(数组的第一个元素). </li>\n<li>从j开始, 向i比较, 直到遇到一个数小于基准数. </li>\n<li>从i开始, 向j比较, 直到遇到一个数大于基准数.</li>\n<li>交换i, j两个位置的值.</li>\n<li>交换后, i, j继续按照之前的方式比较, 直到i与j相遇.</li>\n<li>我们交换基准数和哨兵位置上的数.</li>\n<li>接下来我们以这个哨兵位置为临界, 将原数组分为左右两部分, 再递归的调用上面的比对过程. </li>\n<li>此时原数组的左边部分的哨兵i实际就是原i, 哨兵j实际就是i-1.</li>\n<li>此时原数组的右边部分的哨兵i实际就是原i+1, 哨兵j实际就是原j.</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)quickSortArray:(NSMutableArray *)array formLeft:(NSInteger)left right:(NSInteger)right &#123;</div><div class=\"line\">    if (left &gt;= right) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSInteger i = left;</div><div class=\"line\">    NSInteger j = right;</div><div class=\"line\">    //记录比较基准数</div><div class=\"line\">    NSInteger key = [array[i] integerValue];</div><div class=\"line\">    </div><div class=\"line\">    while (i &lt; j) &#123;</div><div class=\"line\">        //从右基准数开始向左递减, 直到一个数小于基准数(先从右边开始遍历是为了保持基准数不变)</div><div class=\"line\">        while (i &lt; j &amp;&amp; [array[j] integerValue] &gt;= key) &#123;</div><div class=\"line\">            j--;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //从左基准位置开始向右递增, 直到遇到一个数大于基准数</div><div class=\"line\">        while (i &lt; j &amp;&amp; [array[i] integerValue] &lt;= key) &#123;</div><div class=\"line\">            i++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //交换两个数在数组中的位置</div><div class=\"line\">        if (i &lt; j) &#123;</div><div class=\"line\">            array[i] = @([array[i] integerValue] + [array[j] integerValue]);</div><div class=\"line\">            array[j] = @([array[i] integerValue] - [array[j] integerValue]);</div><div class=\"line\">            array[i] = @([array[i] integerValue] - [array[j] integerValue]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //此时, 两个基准数相等, 将基准数归位</div><div class=\"line\">    array[left] = array[i];</div><div class=\"line\">    array[i] = @(key);</div><div class=\"line\">    </div><div class=\"line\">    //递归处理基准数左边</div><div class=\"line\">    [self quickSortArray:array formLeft:left right:i - 1];</div><div class=\"line\">    //递归处理基准数右边</div><div class=\"line\">    [self quickSortArray:array formLeft:i + 1 right:right];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h1><p>归并排序是建立在归并操作上的一种有效的排序算法, 该算法是采用分治法(Divide and Conquer)的一个非常典型的应用. 他的时间复杂度是O(nlogn).</p>\n<p>它的原理是假设初始序列含有n个记录, 则可以看成是n个有序的子序列, 每个子序列的长度为1, 然后两两归并, 得到n/2个长度为2或者1的有序子序列; 再两两归并, 如此反复, 直到得到一个长度为n的有序序列为止, 这种排序方法称为归并排序.<br><img src=\"https://img-blog.csdn.net/20160908095240209\" alt=\"归并排序\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)mergeSortArray:(NSMutableArray *)array &#123;</div><div class=\"line\">  //创建一个副本数组</div><div class=\"line\">  NSMutableArray * auxiliaryArray = [[NSMutableArray alloc]initWithCapacity:array.count];</div><div class=\"line\"></div><div class=\"line\">  //对数组进行第一次二分，初始范围为0到array.count-1</div><div class=\"line\">  [self mergeSort:array auxiliary:auxiliaryArray low:0 high:array.count-1];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mergeSort:(NSMutableArray *)array auxiliary:(NSMutableArray *)auxiliaryArray low:(int)low high:(int)high &#123;</div><div class=\"line\">  //递归跳出判断</div><div class=\"line\">  if (low&gt;=high) &#123;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //对分组进行二分</div><div class=\"line\">  int middle = (high - low)/2 + low;</div><div class=\"line\"></div><div class=\"line\">  //对左侧的分组进行递归二分 low为第一个元素索引，middle为最后一个元素索引</div><div class=\"line\">  [self mergeSort:array auxiliary:auxiliaryArray low:low high:middle];</div><div class=\"line\"></div><div class=\"line\">  //对右侧的分组进行递归二分 middle+1为第一个元素的索引，high为最后一个元素的索引</div><div class=\"line\">  [self mergeSort:array auxiliary:auxiliaryArray low:middle + 1 high:high];</div><div class=\"line\"></div><div class=\"line\">  //对每个有序数组进行回归合并</div><div class=\"line\">  [self merge:array auxiliary:auxiliaryArray low:low middel:middle high:high];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)merge:(NSMutableArray *)array auxiliary:(NSMutableArray *)auxiliaryArray low:(int)low middel:(int)middle high:(int)high &#123;</div><div class=\"line\">  //将数组元素复制到副本</div><div class=\"line\">  for (int i=low; i&lt;=high; i++) &#123;</div><div class=\"line\">    auxiliaryArray[i] = array[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  //左侧数组标记</div><div class=\"line\">  int leftIndex = low;</div><div class=\"line\">  //右侧数组标记</div><div class=\"line\">  int rightIndex = middle + 1;</div><div class=\"line\"></div><div class=\"line\">  //比较完成后比较小的元素要放的位置标记</div><div class=\"line\">  int currentIndex = low;</div><div class=\"line\"></div><div class=\"line\">  while (leftIndex &lt;= middle &amp;&amp; rightIndex &lt;= high) &#123;</div><div class=\"line\">    //此处是使用NSNumber进行的比较，你也可以转成NSInteger再比较</div><div class=\"line\">    if ([auxiliaryArray[leftIndex] compare:auxiliaryArray[rightIndex]]!=NSOrderedDescending) &#123;</div><div class=\"line\">        //左侧标记的元素小于等于右侧标记的元素</div><div class=\"line\">        array[currentIndex] = auxiliaryArray[leftIndex];</div><div class=\"line\">        currentIndex++;</div><div class=\"line\">        leftIndex++;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        //右侧标记的元素小于左侧标记的元素</div><div class=\"line\">        array[currentIndex] = auxiliaryArray[rightIndex];</div><div class=\"line\">        currentIndex++;</div><div class=\"line\">        rightIndex++;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //如果完成后左侧数组有剩余</div><div class=\"line\">  if (leftIndex &lt;= middle) &#123;</div><div class=\"line\">     for (int i = 0; i&lt;=middle - leftIndex; i++) &#123;</div><div class=\"line\">        array[currentIndex +i] = auxiliaryArray[leftIndex +i ];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/8fce5bfb0013\" target=\"_blank\" rel=\"noopener\">归并排序</a></p>\n","categories":["算法"],"tags":["算法"]},{"title":"iOS事件传递与响应","url":"http://hchong.net/2018/04/08/iOS事件传递流程/","content":"<p>iOS中的事件分为3大类型: 触屏事件(手势), 传感器事件(摇一摇, 陀螺仪), 远程控制事件(耳机的线控, 外接手柄). 按照时间顺序, 事件的生命周期概括如下: </p>\n<ol>\n<li>事件的产生和传递</li>\n<li>找出最合适的View后事件的处理</li>\n</ol>\n<p>下面以触摸事件为例.</p>\n<h1 id=\"事件的产生和传递\"><a href=\"#事件的产生和传递\" class=\"headerlink\" title=\"事件的产生和传递\"></a>事件的产生和传递</h1><h2 id=\"事件的产生\"><a href=\"#事件的产生\" class=\"headerlink\" title=\"事件的产生\"></a>事件的产生</h2><p>发生触摸事件后, 系统会将该事件加入到一个由UIApplication管理的事件队列中. 因为队列的特点是FIFO, 先进先出, 先产生的事件先处理.</p>\n<p>UIApplication会从事件队列中取出最前面的事件, 并将事件分发下去以便处理, 通常先发送事件给应用程序的主窗口(Keywindow).</p>\n<p>主窗口(keywindow)会在视图层析结构找到一个最合适的视图来处理触摸事件, 找到合适的视图控件后就会调用视图控件的touches方法来做具体的事件处理.</p>\n<h2 id=\"事件的传递与寻找最合适的View\"><a href=\"#事件的传递与寻找最合适的View\" class=\"headerlink\" title=\"事件的传递与寻找最合适的View\"></a>事件的传递与寻找最合适的View</h2><p>触摸事件的传递是从父控件到子控件, 也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view. <em>如果父控件不能接受触摸事件, 那么子控件就不可能接收到触摸事件.</em></p>\n<ol>\n<li>主窗口接收到应用程序传递过来的事件后, 首先判断自己能否接手触摸事件. 如果能, 那么在判断触摸点在不在窗口自己身上.</li>\n<li>如果触摸点在自己身上, 那么窗口会倒序遍历子控件来寻找最合适的View(倒序先遍历最新添加的View, 效率更高).</li>\n<li>遍历到每一个子控件, 会重复上面的两个步骤. (传递事件给子控件, 判断子控件能否接受事件, 触摸点是否在子控件上)</li>\n<li>循环遍历子控件, 直到找到最合适的View. 如果没有符合条件的子控件, 那么就认为自己最合适处理.</li>\n</ol>\n<p>如果UIView的<code>userInteractionEnabled = NO</code>, 或者<code>hidden = YES</code>, 或者透明度&lt;0.01则不能接受触摸事件. 注意父控件的hidden属性和透明度alpha属性都会影响他的子控件.</p>\n<h2 id=\"时间传递与寻找最合适View的底层实现\"><a href=\"#时间传递与寻找最合适View的底层实现\" class=\"headerlink\" title=\"时间传递与寻找最合适View的底层实现\"></a>时间传递与寻找最合适View的底层实现</h2><p>寻找最合适的View用到了两个重要方法: <code>hitTest:withEvent:</code> 和 <code>pointInside:withEvent:</code>.</p>\n<h3 id=\"hitTest-withEvent\"><a href=\"#hitTest-withEvent\" class=\"headerlink\" title=\"hitTest:withEvent:\"></a>hitTest:withEvent:</h3><p>只要事件一传递给一个控件, 这个控件就会调用他自己的<code>hitTest:withEvent:</code>方法. 他的作用就是寻找并返回最合适的view(能够响应事件的那个最合适的view). <em>不管这个控件能不能处理事件, 也不管触摸点在不在这个控件上, 事件都会先传递给这个控件, 随后再调用 <code>hitTest:withEvent:</code>方法.</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">底层具体实现如下: </div><div class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    // 1.判断当前控件能否接收事件</div><div class=\"line\">    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</div><div class=\"line\">    // 2. 判断点在不在当前控件</div><div class=\"line\">    if ([self pointInside:point withEvent:event] == NO) return nil;</div><div class=\"line\">    // 3.从后往前遍历自己的子控件</div><div class=\"line\">    NSInteger count = self.subviews.count;</div><div class=\"line\">    for (NSInteger i = count - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        UIView *childView = self.subviews[i];</div><div class=\"line\">        // 把当前控件上的坐标系转换成子控件上的坐标系</div><div class=\"line\">        CGPoint childP = [self convertPoint:point toView:childView];</div><div class=\"line\">        UIView *fitView = [childView hitTest:childP withEvent:event];</div><div class=\"line\">        if (fitView) &#123; // 寻找到最合适的view</div><div class=\"line\">            return fitView;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 循环结束,表示没有比自己更合适的view</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事件传递给窗口或者控件后, 就调用<code>hitTest:withEvent:</code>寻找最合适的View. 所以是先传递事件, 再根据事件在自己身上找到最合适的View. 不管子控件是不是最合适的View, 系统都会先把事件传递给子控件, 经过子控件的<code>hitTest:withEvent:</code>验证后才知道有没有最合适的View. 所以如果确定最终父控件是最合适的view, 那么该父控件的子控件的hitTest:withEvent:方法也是会被调用的.</p>\n<p>一般我们在父控件的hitTest:withEvent:中返回子控件作为最合适的view. 例如: 当遍历子控件时, 如果触摸点不在子控件A自己身上而是在子控件B身上, 还要要求返回子控件A作为最合适的view, 采用返回自己的方法可能会导致还没有来得及遍历A自己, 就有可能已经遍历了点真正所在的view, 也就是B. 这就导致了返回的不是自己而是触摸点真正所在的view, 所以还是建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view.</p>\n<h3 id=\"pointInside-withEvent\"><a href=\"#pointInside-withEvent\" class=\"headerlink\" title=\"pointInside:withEvent:\"></a>pointInside:withEvent:</h3><p>pointInside:withEvent:方法判断点在不在当前view上(方法调用者的坐标系上)如果返回YES, 代表点在方法调用者的坐标系上; 返回NO代表点不在方法调用者的坐标系上, 那么方法调用者也就不能处理事件.</p>\n<h1 id=\"事件的响应\"><a href=\"#事件的响应\" class=\"headerlink\" title=\"事件的响应\"></a>事件的响应</h1><p>如果找到合适的View之后就会调用该view的touches方法要进行响应处理具体的事件, 找不到就不会调用. </p>\n<p>响应者链条其实就是很多响应者对象(继承自UIResponder的对象)一起组合起来的链条称之为响应者链条. 响应者链的事件传递过程如下:</p>\n<ol>\n<li>如果当前view是控制器的view, 那么控制器就是上一个响应者, 事件就传递给控制器; 如果当前view不是控制器的view, 那么父视图就是当前view的上一个响应者, 事件就传递给它的父视图.</li>\n<li>在视图层级结构的最顶级视图, 如果也不能处理接收到的事件或者消息, 则将其事件或消息传递给window对象进行处理.</li>\n<li>如果window对象也不处理, 则将其事件或消息传递给UIApplication对象.</li>\n<li>如果UIApplication也不能处理该事件或者消息则将其丢弃.</li>\n</ol>\n<h1 id=\"事件处理的完整流程\"><a href=\"#事件处理的完整流程\" class=\"headerlink\" title=\"事件处理的完整流程\"></a>事件处理的完整流程</h1><ol>\n<li>触摸屏产生触摸事件后, 触摸事件会被添加到由UIApplication管理的事件队列中去.</li>\n<li>UIApplication会从事件队列中取出最前面的事件, 把事件传递给应用程序的主窗口(keywindow).</li>\n<li>主窗口会在视图层级结构中找到一个最合适的View来处理触摸事件.</li>\n<li>最合适的View会调用自己的touches方法处理事件.</li>\n<li>把事件沿着响应者链向上抛.</li>\n</ol>\n<p>事件的传递是从上到下(父控件到子控件), 事件的响应是从下到上(顺着响应者链条向上传递: 子控件到父控件).</p>\n<h1 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h1><h2 id=\"一个事件多个对象处理\"><a href=\"#一个事件多个对象处理\" class=\"headerlink\" title=\"一个事件多个对象处理\"></a>一个事件多个对象处理</h2><p>事件的响应是顺着响应者链条向上传递的, 即从子控件传递给父控件, touch方法默认不处理事件, 而是把事件顺着响应者链条传递给上一个响应者. 这样我们就可以依托这个原理, 让一个事件多个控件响应.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class=\"line\">  NSLog(@&quot;-- dosomething&quot;);</div><div class=\"line\">  [super touchesBegan:touches withEvent:event];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"扩大view的点击区域\"><a href=\"#扩大view的点击区域\" class=\"headerlink\" title=\"扩大view的点击区域\"></a>扩大view的点击区域</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">底层具体实现如下: </div><div class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</div><div class=\"line\">    CGRect touchRect = CGRectInset(self.bounds, -10, -10);</div><div class=\"line\">    if (CGRectContainsPoint(touchRect, point)) &#123;</div><div class=\"line\">        NSInteger count = self.subviews.count;</div><div class=\"line\">        for (NSInteger i = count - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">            UIView *childView = self.subviews[i];</div><div class=\"line\">            CGPoint childP = [self convertPoint:point toView:childView];</div><div class=\"line\">            UIView *fitView = [childView hitTest:childP withEvent:event];</div><div class=\"line\">            if (fitView) &#123;</div><div class=\"line\">                return fitView;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return self;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://blog.flight.dev.qunar.com/2016/10/28/ios-event-mechanism-summary/\" target=\"_blank\" rel=\"noopener\">iOS事件传递及响应</a></p>\n<p>2.<a href=\"https://zhoon.github.io/ios/2015/04/12/ios-event.html\" target=\"_blank\" rel=\"noopener\">深入浅出iOS事件机制</a></p>\n<p>3.<a href=\"https://www.jianshu.com/p/2e074db792ba\" target=\"_blank\" rel=\"noopener\">史上最详细的iOS之事件的传递</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发的崩溃日志分析与异常类型","url":"http://hchong.net/2018/04/05/iOS开发的崩溃日志分析与异常类型/","content":"<h1 id=\"崩溃分析\"><a href=\"#崩溃分析\" class=\"headerlink\" title=\"崩溃分析\"></a>崩溃分析</h1><h2 id=\"崩溃日志\"><a href=\"#崩溃日志\" class=\"headerlink\" title=\"崩溃日志\"></a>崩溃日志</h2><h3 id=\"如何得到crash-report\"><a href=\"#如何得到crash-report\" class=\"headerlink\" title=\"如何得到crash report\"></a>如何得到crash report</h3><ol>\n<li>当一个iOS应用程序崩溃时, 系统会创建一份crash日志保存在设备上. 这份crash日志记录着应用程序崩溃时的信息, 通常包含着每个执行线程的栈调用信息(低内存闪退日志例外). 如果设备就在身边, 可以连接设备, 打开Xcode - Window - Organizer, 在左侧面板中选择Device Logs(可以选择具体设备的Device Logs或者Library下所有设备的Device Logs), 然后根据时间排序查看设备上的crash日志. 这是开发, 测试阶段最经常采用的方式.</li>\n<li>如果应用程序已经提交到App Store发布, 用户已经安装使用了, 那么开发者可以通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志. 不过这并不是100%有效的, 因为这需要用户设备同意上传相关信息.</li>\n<li>线上app的崩溃日志会被app store收集并符号化分组. 类似的崩溃报告的集合被称为崩溃点, (如果用户选择了与苹果共享诊断数据, 这些崩溃日志才会被收集并被符号化). 打开Xcode - Window - Organizer, 在点击相应应用后, 会显示此应用的崩溃集合. 可以看到每一个集合中都会有很多个设备, 如果右键进去查看的话, 会看到很多文件. 右键显示包内容, 会看到最终的详细日志, 当选中了一个崩溃集合后, 如果选择在项目中打开, 会在项目代码中找到具体出问题的代码. 选中Open in Project的话, 会直接在工程中打开.</li>\n<li>如果用户反馈应用曾亏, 也可以通过让用户设备与iTunes同步, 设备与电脑上的iTunes Store同步后, 会将崩溃日志保存在电脑上(路径：Mac OS X:~/Library/Logs/CrashReporter/MobileDevice/)到上述位置把崩溃日志下载下来, 然后通过电子邮件发送给你.</li>\n<li>通过第三方工具来获取崩溃信息.</li>\n</ol>\n<h3 id=\"如何得到-dSYM\"><a href=\"#如何得到-dSYM\" class=\"headerlink\" title=\"如何得到.dSYM\"></a>如何得到.dSYM</h3><p>我们在Archive的时候会生成.xcarchive文件, 显示包内容就能够在里面找到.dSYM文件和.app文件. .dSYM文件位于 /Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives 目录下, 在目录中包含了一个16进制的保存函数地址映射信息的中转文件, 所有Debug文件的symbols都在这个文件中(包含文件名, 函数名, 行号等), 也称之为调试符号信息文件.</p>\n<p>当我们软件 release 模式打包或上线后, 不会像我们在 Xcode 中那样直观的看到用崩溃的错误, 这个时候我们就需要分析 crash report 文件了, iOS 设备中会有日志文件保存我们每个应用出错的函数内存地址, 通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件, 这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名. 大前提是我们需要有软件版本对应的 dSYM 文件, 这也是为什么我们很有必要保存每个发布版本的 Archives 文件了.</p>\n<p>每一个 xx.app 和 xx.app.dSYM 文件都有对应的 UUID, crash 文件也有自己的 UUID, 只要这三个文件的 UUID 一致, 我们就可以通过他们解析出正确的错误函数信息了.</p>\n<ol>\n<li>通过<code>dwarfdump --uuid xx.app/xx (xx代表你的项目名)</code>查看xx.app文件的UUID</li>\n<li>通过<code>dwarfdump --uuid xx.app.dSYM</code>查看xx.dSYM的UUID</li>\n<li>crash 文件内第一行 Incident Identifier 就是该 crash 文件的 UUID.</li>\n</ol>\n<h3 id=\"结合分析crash文件\"><a href=\"#结合分析crash文件\" class=\"headerlink\" title=\"结合分析crash文件\"></a>结合分析crash文件</h3><p>根据crash report, .dSYM分析崩溃函数.</p>\n<ol>\n<li>如果使用的是友盟的话, 友盟自带的有一个分析工具. 但是要注意, 使用的时候要确保你的.xcarchive在 ~/Library/Developer/Xcode/或该路径的子目录下. .xcarchive里的.dsYM文件和.app文件是有对应的UUID的. 然后你的crash report里也是有UUID, 只有当UUID相等时才能分析对. 如果是在别人电脑上archive, 那你需要把.dSYM文件copy过来.</li>\n<li>symbolicatecrash是xcode的一个符号化crash log的命令行工具. 使用方法也就是导出.crash文件（crash log）和找到.dsYM文件, 然后进行分析. <a href=\"http://www.cnblogs.com/ningxu-ios/p/4141783.html\" target=\"_blank\" rel=\"noopener\">查看这里</a></li>\n<li>如果你有多个“.ipa”文件, 多个”.dSYMB”文件, 你并不太确定到底“dSYM”文件对应哪个”.ipa”文件, 可以使用命令行工具atos. <a href=\"http://blog.sina.com.cn/s/blog_76a1980f0102wjcf.html\" target=\"_blank\" rel=\"noopener\">查看这里</a></li>\n</ol>\n<h3 id=\"崩溃日志分析\"><a href=\"#崩溃日志分析\" class=\"headerlink\" title=\"崩溃日志分析\"></a>崩溃日志分析</h3><p>Xcode-&gt;Window-&gt;Organizer-&gt;Crashes, <a href=\"http://www.cocoachina.com/industry/20130725/6677.html\" target=\"_blank\" rel=\"noopener\">这里</a>有关于崩溃日志的详细分析.</p>\n<p>盗图一张, 关于崩溃日志的详细信息<br><img src=\"http://devma.cn/images/2016/11/ios_crash_analysis_2.png\" alt=\"崩溃日志\"></p>\n<h2 id=\"野指针分析\"><a href=\"#野指针分析\" class=\"headerlink\" title=\"野指针分析\"></a>野指针分析</h2><p>因为野指针的原因发生崩溃是常常出现的事, 而且比较随机. 所以我们要提高野指针的崩溃率好来帮我们快速找到有问题的代码. 对象释放后只有出现被随机填入的数据是不可访问的时候才会必现Crash. </p>\n<p>这个地方我们可以做一下手脚, 把这一随机的过程变成不随机的过程. 对象释放后在内存上填上不可访问的数据, 其实这种技术其实一直都有, Edit Scheme -&gt; Diagnostics -&gt;Enable Malloc Scribble 选中就可以实现这个功能</p>\n<h2 id=\"僵尸模式分析\"><a href=\"#僵尸模式分析\" class=\"headerlink\" title=\"僵尸模式分析\"></a>僵尸模式分析</h2><p>启用了NSZombieEnabled, 它会用一个僵尸来替换默认的dealloc实现, 也就是在引用计数降到0时, 该僵尸实现会将该对象转换成僵尸对象. 僵尸对象的作用是在你向它发送消息时, 它会显示一段日志并自动跳入调试器. 当启用NSZombieEnabled时, 一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象. 僵尸对象会显示接受到得信息, 然后跳入调试器, 这样你就可以查看到底是哪里出了问题.<br>一般这时崩溃的原因就是因为调用了已经释放的内存空间，或者说重复释放了某个地址空间.</p>\n<ol>\n<li>打开NSZombieEnabled之后, 如果遇到对应的崩溃类型既调用了已经释放的内存空间, 或者说重复释放了某个地址空间, 那么就能在GDB中看到对应的输出信息.</li>\n<li>如果崩溃是发生在当前调用栈, 通过上面的做法, 系统就会把崩溃原因定位到具体代码中. 但是, 如果崩溃不在当前调用栈, 系统就仅仅只能把崩溃地址告诉我们, 而没办法定位到具体代码, 这样我们也没法去修改错误. 这时就可以修改scheme, 让xcode记录每个地址alloc的历史, 这样我们就可以用命令把这个地址还原出来. Edit Scheme -&gt; Environment Variables -&gt; 加入MallocStackLoggingNoCompact, 并且设置为YES.</li>\n</ol>\n<h2 id=\"Enable-Address-Sanitizer\"><a href=\"#Enable-Address-Sanitizer\" class=\"headerlink\" title=\"Enable Address Sanitizer\"></a>Enable Address Sanitizer</h2><p>Edit Scheme -&gt; Diagnostics -&gt;Enable Address Sanitizer选中就可以实现这个功能, 设置这个参数后, 我们可以看到一些更详细的错误信息提示, 设置还有内存使用情况的展示. </p>\n<p>这类工具的理论依据是: 访问内存时, 通过比较访问的内存和程序实际分配的内存, 验证内存访问的有效性, 从而在bug发生时就检测到它们, 而不会等到副作用产生时才有所察觉.</p>\n<h2 id=\"静态分析\"><a href=\"#静态分析\" class=\"headerlink\" title=\"静态分析\"></a>静态分析</h2><p>Static Analyzer是一个非常好的工具去发现编译器警告不会提示的问题和一些个人的内错泄露和死存储(不会用到的赋了值的变量)错误. 这个方法可能大大的提高内存使用和性能, 以及提升应用的整体稳定性和代码质量.</p>\n<p>打开方式: Xcode-&gt;Product-Analyze 然后我们就能看到如下蓝色箭头所示的一些有问题的代码.</p>\n<h2 id=\"unrecognized-selector-send-to-instancd-快速定位\"><a href=\"#unrecognized-selector-send-to-instancd-快速定位\" class=\"headerlink\" title=\"unrecognized selector send to instancd 快速定位\"></a>unrecognized selector send to instancd 快速定位</h2><ol>\n<li>在debug navigator的断点栏里添加Create Symbolic Breakpoint</li>\n<li>在Symbolic中填写如下方法签名： <code>-[NSObject(NSObject) doesNotRecognizeSelector:]</code></li>\n</ol>\n<h1 id=\"常见崩溃信息类型\"><a href=\"#常见崩溃信息类型\" class=\"headerlink\" title=\"常见崩溃信息类型\"></a>常见崩溃信息类型</h1><h2 id=\"Exception-Type异常类型\"><a href=\"#Exception-Type异常类型\" class=\"headerlink\" title=\"Exception Type异常类型\"></a>Exception Type异常类型</h2><h3 id=\"SIGABRT类型\"><a href=\"#SIGABRT类型\" class=\"headerlink\" title=\"SIGABRT类型\"></a>SIGABRT类型</h3><p>在iOS中就是未被捕获的Objective-C异常(NSException)导致程序向自身发送了SIGABRT信号而崩溃, 常见的如下:</p>\n<ul>\n<li>SIGSEGV: 段错误信息（SIGSEGV）是操作系统产生的一个更严重的问题。当硬件出现错误、访问不可读的内存地址或向受保护的内存地址写入数据时，就会发生这个错误。硬件错误这一情况并不常见。当要读取保存在RAM中的数据，而该位置的RAM硬件有问题时，你会收到SIGSEGV。SIGSEGV更多是出现在后两种情况。默认情况下，代码页不允许进行写操作，而数据而不允许进行执行操作。当应用中的某个指针指向代码页并试图修改指向位置的值时，你会收到SIGSEGV。当要读取一个指针的值，而它被初始化成指向无效内存地址的垃圾值时，你也会收到SIGSEGV SIGSEGV错误调试起来更困难，而导致SIGSEGV的最常见原因是不正确的类型转换。要避免过度使用指针或尝试手动修改指针来读取私有数据结构。如果你那样做了，而在修改指针时没有注意内存对齐和填充问题，就会收到SIGSEGV。</li>\n<li>SIGBUS: 总线错误信号（SIGBUG）代表无效内存访问，即访问的内存是一个无效的内存地址。也就是说，那个地址指向的位置根本不是物理内存地址（它可能是某个硬件芯片的地址）。SIGSEGV和SIGBUS都羽毛球EXC_BAD_ACCESS的子类型。</li>\n<li>SIGTRAP: SIGTRAP代表陷阱信号。它并不是一个真正的崩溃信号。它会在处理器执行trap指令发送。LLDB调试器通常会处理此信号，并在指定的断点处停止运行。如果你收到了原因不明的SIGTRAP，先清除上次的输出，然后重新进行构建通常能解决这个问题。</li>\n<li>EXC_ARITHETIC: 当要除零时，应用会收到EXC_ARITHMETIC信号。这个错误应该很容易解决.</li>\n<li>SIGILL: SIGILL代表signal illegal instruction(非法指令信号)。当在处理器上执行非法指令时，它就会发生。执行非法指令是指，将函数指针会给另外一个函数时，该函数指针由于某种原因是坏的，指向了一段已经释放的内存或是一个数据段。有时你收到的是EXC_BAD<em>INSTRUCTION而不是SIGILL，虽然它们是一回事，不过EXC</em>*等同于此信号不依赖体系结构。</li>\n<li>SIGABRT: SIGABRT代表SIGNAL ABORT（中止信号）。当操作系统发现不安全的情况时，它能够对这种情况进行更多的控制；必要的话，它能要求进程进行清理工作。在调试造成此信号的底层错误时，并没有什么妙招。Cocos2d或UIKit等框架通常会在特定的前提条件没有满足或一些糟糕的情况出现时调用C函数abort（由它来发送此信号）。当SIGABRT出现时，控制台通常会输出大量的信息，说明具体哪里出错了。由于它是可控制的崩溃，所以可以在LLDB控制台上键入bt命令打印出回溯信息</li>\n</ul>\n<p>更多的SIGABRT信号类型看<a href=\"http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h3 id=\"EXC-BAD-ACCESS\"><a href=\"#EXC-BAD-ACCESS\" class=\"headerlink\" title=\"EXC_BAD_ACCESS\"></a>EXC_BAD_ACCESS</h3><p>EXC_BAD_ACCESS是一个比较难处理的crash, 当一个app进入一种毁坏的状态, 通常是由于内存管理问题而引起的时, 就会出现出现这样的crash. 通常Signal信号错误都会提醒EXC_BAD_ACCESS, 我们可以通过僵尸模式来捕获这种异常.</p>\n<h3 id=\"看门狗超时\"><a href=\"#看门狗超时\" class=\"headerlink\" title=\"看门狗超时\"></a>看门狗超时</h3><p>这种崩溃通常比较容易分辨, 因为错误码是固定的0x8badf00d. 在iOS上, 它经常出现在执行一个同步网络调用而阻塞主线程的情况. 因此, 永远不要进行同步网络调用.</p>\n<h2 id=\"Exception-Codes异常编码\"><a href=\"#Exception-Codes异常编码\" class=\"headerlink\" title=\"Exception Codes异常编码\"></a>Exception Codes异常编码</h2><p>0x8badf00d: 读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的。 通常是应用花费太多时间而无法启动、终止或响应用系统事件。</p>\n<p>0xbad22222: 该编码表示 VoIP 应用因为过于频繁重启而被终止。</p>\n<p>0xdead10cc: 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。</p>\n<p>0xdeadfa11: 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面</p>\n<p>#常见的崩溃类型收集</p>\n<h2 id=\"新老操作系统兼容\"><a href=\"#新老操作系统兼容\" class=\"headerlink\" title=\"新老操作系统兼容\"></a>新老操作系统兼容</h2><p>在新 iOS 上正常的应用, 到了老版本 iOS 上秒退最常见原因是系统动态链接库或Framework无法找到. 这种情况通常是由于 App 引用了一个新版操作系统里的动态库(或者某动态库的新版本)或只有新 iOS 支持的 Framework, 而又没有对老系统进行测试, 于是当 App 运行在老系统上时便由于找不到而秒退.<br>还有就是有些方法是新版操作系统才支持的, 而又没有对该方法是否存在于老系统中做出判断.</p>\n<h2 id=\"本地存储的数据结构变化\"><a href=\"#本地存储的数据结构变化\" class=\"headerlink\" title=\"本地存储的数据结构变化\"></a>本地存储的数据结构变化</h2><p>程序在升级时, 修改了本地存储的数据结构, 但是对用户既存的旧数据没有做好升级, 结果导致初始化时因为无法正确读取用户数据而秒退.</p>\n<h2 id=\"访问的数据为空或者数据类型不对\"><a href=\"#访问的数据为空或者数据类型不对\" class=\"headerlink\" title=\"访问的数据为空或者数据类型不对\"></a>访问的数据为空或者数据类型不对</h2><p>这类情况是比较常见的, 后端传回了空数据, 客户端没有做对应的判断继续执行下去了, 这样就产生了crash. 或者自己本地的某个数据为空数据而去使用了. 还有就是访问的数据类型不是期望的数据类型而产生崩溃.</p>\n<h2 id=\"操作了不该操作的对象\"><a href=\"#操作了不该操作的对象\" class=\"headerlink\" title=\"操作了不该操作的对象\"></a>操作了不该操作的对象</h2><p>这里有可能是空指针或者野指针.<br>空指针是没有存储任何内存地址的指针, 一般指nil, 但是在iOS中向nil发消息是不会崩溃的.</p>\n<p>野指针是指指向一个已删除的对象(“垃圾”内存既不可用内存)或未申请访问受限内存区域的指针. 野指针是比较危险的, 因为野指针指向的对象已经被释放了, 不能用了, 你再给被释放的对象发送消息就是违法的, 所以会崩溃.</p>\n<h2 id=\"内存处理不当\"><a href=\"#内存处理不当\" class=\"headerlink\" title=\"内存处理不当\"></a>内存处理不当</h2><p>内存管理是软件开发中一个重要的课题, iOS自从引入ARC机制后, 对于内存的管理开发者好像轻松了很多, 但是还会发生一些内存泄露之类的问题. Facebook工程师们开源了一些自动化工具来解决监测内存泄露问题:FBRetainCycleDetector、FBAllocationTracker、FBMemoryProfiler.</p>\n<h2 id=\"主线程UI长时间卡死-被系统杀掉\"><a href=\"#主线程UI长时间卡死-被系统杀掉\" class=\"headerlink\" title=\"主线程UI长时间卡死, 被系统杀掉\"></a>主线程UI长时间卡死, 被系统杀掉</h2><p>主线程被卡住是非常常见的场景, 具体表现就是程序不响应任何的UI交互. 这时按下调试的暂停按钮, 查看堆栈, 就可以看到是到底是死锁, 死循环等, 导致UI线程被卡住.</p>\n<h2 id=\"多线程之间切换访问引起的crash\"><a href=\"#多线程之间切换访问引起的crash\" class=\"headerlink\" title=\"多线程之间切换访问引起的crash\"></a>多线程之间切换访问引起的crash</h2><p>多线程引起的崩溃大部分是因为使用数据库的时候多线程同时读写数据库而造成了crash. <a href=\"https://blog.csdn.net/lixing333/article/details/42149893\" target=\"_blank\" rel=\"noopener\">这里</a>关于多线程crash的调试.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/09b6084bcd01\" target=\"_blank\" rel=\"noopener\">iOS崩溃捕捉与分析</a></p>\n<p>2.<a href=\"http://www.cocoachina.com/ios/20171026/20921.html\" target=\"_blank\" rel=\"noopener\">全面的理解和分析iOS的崩溃日志</a></p>\n<p>3.<a href=\"https://www.jianshu.com/p/3261493e6d9e\" target=\"_blank\" rel=\"noopener\">浅谈iOS Crash</a></p>\n<p>4.<a href=\"https://blog.csdn.net/womendeaiwoming/article/details/44243571\" target=\"_blank\" rel=\"noopener\">iOS中的崩溃类型</a></p>\n<p>5.<a href=\"http://devma.cn/blog/2016/11/10/ios-beng-kui-crash-jie-xi/\" target=\"_blank\" rel=\"noopener\">iOS 崩溃Crash解析</a></p>\n<p>6.<a href=\"http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html\" target=\"_blank\" rel=\"noopener\">iOS异常捕获</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS中常见的内存泄漏","url":"http://hchong.net/2018/04/04/iOS中常见的内存泄漏/","content":"<p>内存泄漏是开发中常见的一种问题, 下面我们就开发中常见的容易出现内存泄漏的场景做一个总结和分析.</p>\n<h2 id=\"Block下的循环引用\"><a href=\"#Block下的循环引用\" class=\"headerlink\" title=\"Block下的循环引用\"></a>Block下的循环引用</h2><p>在ARC下基本上不用我们内存管理释放, block中导致的内存泄漏常常就是因为强引用互相之间持有而发生了循环引用无法释放. AFNetWorking上的经典代码, 防止循环引用.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//创建__weak弱引用，防止强引用互相持有</div><div class=\"line\">__weak __typeof(self)weakSelf = self;</div><div class=\"line\">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</div><div class=\"line\">    //创建局部__strong强引用，防止多线程情况下weakSelf被析构</div><div class=\"line\">     __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">    strongSelf.networkReachabilityStatus = status;</div><div class=\"line\">    if (strongSelf.networkReachabilityStatusBlock) &#123;</div><div class=\"line\">         strongSelf.networkReachabilityStatusBlock(status);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>weak 本身是可以避免循环引用的问题的, 但是其会导致外部对象释放了之后, block 内部也访问不到这个对象的问题, 我们可以通过在 block 内部声明一个 </strong>strong 的变量来指向 weakObj, 使外部对象既能在 block 内部保持住, 又能避免循环引用的问题.</p>\n<h2 id=\"delegate循环引用问题\"><a href=\"#delegate循环引用问题\" class=\"headerlink\" title=\"delegate循环引用问题\"></a>delegate循环引用问题</h2><p>delegate循环引用问题比较基础, 只需注意将代理属性修饰为weak即可. 例如:<br>ViewController的self.view持有了UITableView. 所以UITableView的delegate和dataSource就不能持有ViewController. 所以要使用weak来修饰.</p>\n<h2 id=\"NSTimer的循环引用\"><a href=\"#NSTimer的循环引用\" class=\"headerlink\" title=\"NSTimer的循环引用\"></a>NSTimer的循环引用</h2><p>我们一般这么创建NSTimer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(timerFire) userInfo:nil repeats:YES];//timer强引用self</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//RunLoop强引用timer</div><div class=\"line\">    self.timer = timer;//self强引用timer</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)timerFire &#123;</div><div class=\"line\">    NSLog(@&quot;timer fire&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是当我们把timer添加到RunLoop的时候, 会被RunLoop强引用, timer会对目标对象进行强引用. 这个时候已经出现了循环引用. 这时候我们就不能在 <code>-dealloc</code> 里加 <code>-invalidate</code> 的方法, 因为他们之间相互引用, 永远不会走<code>-dealloc</code>方法. 我们要做的就是打破这个循环.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">__weak typeof(self) weakSelf = self;</div><div class=\"line\">NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:weakSelf selector:@selector(timerFire) userInfo:nil repeats:YES];</div></pre></td></tr></table></figure>\n<h2 id=\"非OC对象内存处理\"><a href=\"#非OC对象内存处理\" class=\"headerlink\" title=\"非OC对象内存处理\"></a>非OC对象内存处理</h2><p>对于一些非OC对象, 我们在使用完毕后, 一定要记得手动释放内存, 例如下面常用的调节图片亮度的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CIImage *beginImage = [[CIImage alloc]initWithImage:[UIImage imageNamed:@&quot;yourname.jpg&quot;]];</div><div class=\"line\">CIFilter *filter = [CIFilter filterWithName:@&quot;CIColorControls&quot;];</div><div class=\"line\">[filter setValue:beginImage forKey:kCIInputImageKey];</div><div class=\"line\">[filter setValue:[NSNumber numberWithFloat:.5] forKey:@&quot;inputBrightness&quot;];//亮度-1~1</div><div class=\"line\">CIImage *outputImage = [filter outputImage];</div><div class=\"line\">//GPU优化</div><div class=\"line\">EAGLContext * eaglContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</div><div class=\"line\">eaglContext.multiThreaded = YES;</div><div class=\"line\">CIContext *context = [CIContext contextWithEAGLContext:eaglContext];</div><div class=\"line\">[EAGLContext setCurrentContext:eaglContext];</div><div class=\"line\"></div><div class=\"line\">CGImageRef ref = [context createCGImage:outputImage fromRect:outputImage.extent];</div><div class=\"line\">UIImage *endImg = [UIImage imageWithCGImage:ref];</div><div class=\"line\">_imageView.image = endImg;</div><div class=\"line\">CGImageRelease(ref);//非OC对象需要手动内存释放</div></pre></td></tr></table></figure>\n<p>其他的对于CoreFoundation框架下的某些对象或变量需要手动释放, C语言代码中的malloc等需要对应free等都需要注意.</p>\n<h2 id=\"地图类处理\"><a href=\"#地图类处理\" class=\"headerlink\" title=\"地图类处理\"></a>地图类处理</h2><p>若项目中使用地图相关类, 一定要检测内存情况, 因为地图是比较耗费App内存的, 因此在根据文档实现某地图相关功能的同时, 我们需要注意内存的正确释放, 大体需要注意的有需在使用完毕时将地图, 代理等滞空为nil, 注意地图中标注(大头针)的复用, 并且在使用完毕时清空标注数组等.</p>\n<h2 id=\"大次数循环内存暴涨问题\"><a href=\"#大次数循环内存暴涨问题\" class=\"headerlink\" title=\"大次数循环内存暴涨问题\"></a>大次数循环内存暴涨问题</h2><p>循环内产生大量的临时对象, 直至循环结束才释放, 可能导致内存泄漏, 解决方法为在循环中创建自己的autoReleasePool, 及时释放占用内存大的临时变量, 减少内存占用峰值.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; 100000; i++) &#123;</div><div class=\"line\">   @autoreleasepool &#123;</div><div class=\"line\">       NSString *string = @&quot;Abc&quot;;</div><div class=\"line\">       string = [string lowercaseString];</div><div class=\"line\">       string = [string stringByAppendingString:@&quot;xyz&quot;];</div><div class=\"line\">       NSLog(@&quot;%@&quot;, string);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.cnblogs.com/mddblog/p/6517377.html\" target=\"_blank\" rel=\"noopener\">NSTimer定时器</a></p>\n<p>2.<a href=\"http://www.cocoachina.com/ios/20150710/12444.html\" target=\"_blank\" rel=\"noopener\">iOS中的NSTimer</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-性能优化","url":"http://hchong.net/2018/04/04/iOS开发总结系列-性能优化/","content":"<p>这里主要记录一下APP开发中, 经常遇到的一些性能问题, 以及优化的建议.</p>\n<h1 id=\"卡顿优化\"><a href=\"#卡顿优化\" class=\"headerlink\" title=\"卡顿优化\"></a>卡顿优化</h1><p>通常来说, 计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的. CPU 计算好显示内容提交到 GPU, GPU 渲染完成后将渲染结果放入帧缓冲区, 随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据, 经过可能的数模转换传递给显示器显示.</p>\n<h2 id=\"CPU主要责任\"><a href=\"#CPU主要责任\" class=\"headerlink\" title=\"CPU主要责任\"></a>CPU主要责任</h2><ul>\n<li>对象创建: 对象的创建会分配内存, 调整属性, 甚至还有读取文件等操作, 比较消耗 CPU 资源. 尽量用轻量的对象代替重量的对象, 可以对性能有所优化, 例如不需要触摸事件时我们可以使用CALayer代替UIView. 尽量推迟对象创建的时间, 并把对象的创建分散到多个任务中去, 如果对象可以复用, 并且复用的代价比释放, 创建新对象要小, 那么这类对象应当尽量放到一个缓存池里复用.</li>\n<li>对象调整: UIView 的关于显示相关的属性(比如 frame/bounds/transform)等实际上都是 CALayer 属性映射来的, 所以对 UIView 的这些属性进行调整时, 消耗的资源要远大于一般的属性. 对此你在应用中, 应该尽量减少不必要的属性修改. 当视图层次调整时, UIView、CALayer 之间会出现很多方法调用与通知, 所以在优化性能时, 应该尽量避免调整视图层次、添加和移除视图.</li>\n<li>对象销毁: 对象的销毁虽然消耗资源不多, 但累积起来也是不容忽视. 如果对象可以放到后台线程去释放, 那就挪到后台线程去. 把对象捕获到 block 中, 然后扔到后台队列去随便发送个消息以避免编译器警告, 就可以让对象在后台线程销毁了.</li>\n<li>布局计算: 不论通过何种技术对视图进行布局, 其最终都会落到对 UIView.frame/bounds/center 等属性的调整上. 上面也说过, 对这些属性的调整非常消耗资源, 所以尽量提前计算好布局, 在需要时一次性调整好对应属性, 而不要多次、频繁的计算和调整这些属性.</li>\n<li>AutoLayout: 苹果本身提倡Autolayout, 但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题. 随着视图数量的增长, Autolayout 带来的 CPU 消耗会呈指数级上升.</li>\n<li>文本计算: 如果一个界面中包含大量文本(比如微博微信朋友圈等), 文本的宽高计算会占用很大一部分资源, 并且不可避免.<br>  可以参考下 UILabel 内部的实现方式: 用 <code>-[NSAttributedString boundingRectWithSize:options:context:]</code> 来计算文本宽高, 用 <code>-[NSAttributedString drawWithRect:options:context:]</code> 来绘制文本. 尽管这两个方法性能不错, 但仍旧需要放到后台线程进行以避免阻塞主线程.<br>  如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象, 然后自己计算了, 并且 CoreText 对象还能保留以供稍后绘制使用.</li>\n<li>文本渲染: 屏幕上能看到的所有文本内容控件, 包括 UIWebView, 在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的. 当显示大量文本时, CPU 的压力会非常大. 我们可以自定义文本控件, 用 TextKit 或最底层的 CoreText 对文本异步绘制.<br>  CoreText 对象创建好后, 能直接获取文本的宽高等信息, 避免了多次计算(调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍);CoreText 对象占用内存较少, 可以缓存下来以备稍后多次渲染.</li>\n<li>图片的解码: 当你用 UIImage 或 CGImageSource 的那几个方法创建图片时, 图片数据并不会立刻解码. 图片设置到 UIImageView 或者 CALayer.contents 中去, 并且 CALayer 被提交到 GPU 前, CGImage 中的数据才会得到解码. 这一步是发生在主线程的, 并且不可避免. 如果想要绕开这个机制, 常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中, 然后从 Bitmap 直接创建图片.</li>\n<li>图像的绘制: 图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中, 然后从画布创建图片并显示这样一个过程. 这个最常见的地方就是 <code>[UIView drawRect:]</code> 里面. 由于 CoreGraphic 方法通常都是线程安全的, 所以图像的绘制可以很容易的放到后台线程进行.</li>\n</ul>\n<h2 id=\"GPU主要责任\"><a href=\"#GPU主要责任\" class=\"headerlink\" title=\"GPU主要责任:\"></a>GPU主要责任:</h2><p>相对于 CPU 来说, GPU 能干的事情比较单一: 接收提交的纹理(Texture)和顶点描述(三角形), 应用变换(transform), 混合并渲染, 然后输出到屏幕上. 通常你所能看到的内容, 主要也就是纹理(图片)和形状(三角模拟的矢量图形)两类.</p>\n<ul>\n<li>纹理的渲染: 所有的 Bitmap, 包括图片、文本、栅格化的内容, 最终都要由内存提交到显存, 绑定为 GPU Texture. 当在较短时间显示大量图片时(比如 TableView 存在非常多的图片并且快速滑动时), CPU 占用率很低, GPU 占用非常高, 界面仍然会掉帧. 所以应该尽量减少在短时间内大量图片的显示, 尽可能将多张图片合成为一张进行显示.<br>  当图片过大, 超过 GPU 的最大纹理尺寸时, 图片需要先由 CPU 进行预处理, 这对 CPU 和 GPU 都会带来额外的资源消耗. 所以纹理尺寸都不应超过上限.</li>\n<li>视图的混合: 当多个视图（或者说 CALayer）重叠在一起显示时, GPU 会首先把他们混合到一起. 如果视图结构过于复杂, 混合的过程也会消耗很多 GPU 资源. 为了减轻这种情况的 GPU 消耗, 应用应当尽量减少视图数量和层次, 并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成. 当然, 这也可以用上面的方法, 把多个视图预先渲染为一张图片来显示.</li>\n<li>图形的生成: CALayer 的 border、圆角、阴影、遮罩(mask), CASharpLayer 的矢量图形显示, 通常会触发离屏渲染. 快速滑动时, 可以观察到 GPU 资源已经占满, 而 CPU 资源消耗很少. 我们可以尝试开启 CALayer.shouldRasterize 属性, 但这会把原本离屏渲染的操作转嫁到 CPU 上去. 对于只需要圆角的某些场合, 也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果. 最彻底的解决办法, 就是把需要显示的图形在后台线程绘制为图片, 避免使用圆角、阴影、遮罩等属性.</li>\n</ul>\n<p>所以, 我们常见的性能优化技巧有以下几种: 预排版, 预渲染, 异步绘制, 全局并发控制, 异步加载图片.</p>\n<h1 id=\"编译优化\"><a href=\"#编译优化\" class=\"headerlink\" title=\"编译优化\"></a>编译优化</h1><h2 id=\"增加XCode执行的线程数\"><a href=\"#增加XCode执行的线程数\" class=\"headerlink\" title=\"增加XCode执行的线程数\"></a>增加XCode执行的线程数</h2><p>XCode默认使用与CPU核数相同的线程来进行编译, 但由于编译过程中的IO操作往往比CPU运算要多, 因此适当的提升线程数可以在一定程度上加快编译速度. 在终端输入<code>defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</code>开启多线程, 更改线程数设置<code>defaults write com.apple.Xcode PBXNumberOfParallelBuildSubtasks 5</code>.</p>\n<h2 id=\"将Debug-Information-Format改为DWARF\"><a href=\"#将Debug-Information-Format改为DWARF\" class=\"headerlink\" title=\"将Debug Information Format改为DWARF\"></a>将Debug Information Format改为DWARF</h2><p>将Target-&gt;Build Settings中, 找到Debug Information Format这一项, 将Debug时的DWARF with dSYM file改为DWARF.</p>\n<p>这一项设置的是是否将调试信息加入到可执行文件中, 改为DWARF后, 如果程序崩溃, 将无法输出崩溃位置对应的函数堆栈, 但由于Debug模式下可以在XCode中查看调试信息, 所以改为DWARF影响并不大. 这一项更改完之后, 可以大幅提升编译速度.<br>将Debug Information Format改为DWARF之后, 会导致在Debug窗口无法查看相关类类型的成员变量的值. 当需要查看这些值时, 可以将Debug Information Format改回DWARF with dSYM file, clean(必须)之后重新编译.</p>\n<h2 id=\"将Build-Active-Architecture-Only改为Yes\"><a href=\"#将Build-Active-Architecture-Only改为Yes\" class=\"headerlink\" title=\"将Build Active Architecture Only改为Yes\"></a>将Build Active Architecture Only改为Yes</h2><p>将Target-&gt;Build Settings中, 找到Build Active Architecture Only这一项, 将Debug时的 NO 改为 YES.</p>\n<p>需要注意的是, 此选项在Release模式下必须为NO, 否则发布的ipa在部分设备上将不能运行. 这一项更改完之后, 可以显著提高编译速度.</p>\n<h2 id=\"设计编译优化等级\"><a href=\"#设计编译优化等级\" class=\"headerlink\" title=\"设计编译优化等级\"></a>设计编译优化等级</h2><p>不要再项目中或者静态库中使用-O4, 因为这会让Clang链接Link Time Optimizations (LTO)使得编译更慢, 通常使用-O3. 在设置编译优化之后, XCode断点和调试信息会不正常, 所以一般静态库或者其他Target这样设置.</p>\n<h2 id=\"将常用的代码及文件打包成静态库\"><a href=\"#将常用的代码及文件打包成静态库\" class=\"headerlink\" title=\"将常用的代码及文件打包成静态库\"></a>将常用的代码及文件打包成静态库</h2><p>我们用Cocoapods来管理第三方包, 我们可以将第三方包打包成静态库, 也可以提升编译速度. 也可以将第三方包打包成二进制文件, 但是这样不方便调试.</p>\n<h2 id=\"添加预编译文件\"><a href=\"#添加预编译文件\" class=\"headerlink\" title=\"添加预编译文件\"></a>添加预编译文件</h2><p>使用.pch文件, 把常用的头文件放到预编译文件里面.</p>\n<h1 id=\"启动优化\"><a href=\"#启动优化\" class=\"headerlink\" title=\"启动优化\"></a>启动优化</h1><p>App总启动时间 = t1(main()之前的加载时间) + t2(main()之后的加载时间).<br>t1 = 系统dylib(动态链接库)和自身App可执行文件的加载;<br>t2 = main方法执行之后到AppDelegate类中的<code>- (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法执行结束前这段时间, 主要是构建第一个界面, 并完成渲染展示.</p>\n<h2 id=\"main-调用之前的加载过程\"><a href=\"#main-调用之前的加载过程\" class=\"headerlink\" title=\"main()调用之前的加载过程\"></a>main()调用之前的加载过程</h2><ol>\n<li>系统首先加载可执行文件. 自身App的所有.o文件的集合.</li>\n<li>加载动态链接库dyld, dyld是一个专门用来加载动态链接库的库.</li>\n<li>dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库. 动态链接库包括: iOS 中用到的所有系统 framework, 加载OC runtime方法的libobjc, 系统级别的libSystem, 例如libdispatch(GCD)和libsystem_blocks (Block).</li>\n</ol>\n<p>所以对于main()调用之前的耗时我们可以优化的点如下:</p>\n<ol>\n<li>减少不必要的framework, 因为动态链接比较耗时.</li>\n<li>check framework应当设为optional和required, 如果该framework在当前App支持的所有iOS系统版本都存在, 那么就设为required, 否则就设为optional, 因为optional会有些额外的检查.</li>\n<li>合并或者删减一些OC类, 关于清理项目中没用到的类.</li>\n<li>删减一些无用的静态变量.</li>\n<li>删减没有被调用到或者已经废弃的方法.</li>\n<li>将不必须在+load方法中做的事情延迟到+initialize中.</li>\n<li>尽量不要用C++虚函数(创建虚函数表有开销), C++静态对象.</li>\n</ol>\n<h2 id=\"main-调用之后的加载过程\"><a href=\"#main-调用之后的加载过程\" class=\"headerlink\" title=\"main()调用之后的加载过程\"></a>main()调用之后的加载过程</h2><p>在main()被调用之后, App的主要工作就是初始化必要的服务, 显示首页内容. 所以主要耗时操作在执行main()函数的耗时, 执行applicationWillFinishLaunching的耗时, rootViewController及其childViewController的加载、view及其subviews的加载.</p>\n<h1 id=\"瘦身优化\"><a href=\"#瘦身优化\" class=\"headerlink\" title=\"瘦身优化\"></a>瘦身优化</h1><h2 id=\"资源瘦身\"><a href=\"#资源瘦身\" class=\"headerlink\" title=\"资源瘦身\"></a>资源瘦身</h2><p>资源瘦身主要是去掉无用资源和压缩资源, 资源包括图片, 音视频文件, 配置文件以及多语言wording. 资源压缩主要对png进行无损压缩.</p>\n<h2 id=\"编译选项优化\"><a href=\"#编译选项优化\" class=\"headerlink\" title=\"编译选项优化\"></a>编译选项优化</h2><ul>\n<li>Optimization Level 使用Fastest, Smalllest. 该选项对安装包大小影响几无，但可以提高app的性能</li>\n<li>Strip Linked Product 设置为YES, 需要注意的是Strip Linked Product也受到Deployment Postprocessing设置选项的影响. 在Build Settings中, 我们可以看到， Strip Linked Product是在Deployment这栏中的, 而Deployment Postprocessing相当于是Deployment的总开关. 记得把Deployment Postprocessing也设置为YES.</li>\n<li>Symbols Hidden by Default设置为YES</li>\n<li>Make Strings Read-Only 设置为YES</li>\n</ul>\n<h2 id=\"二进制安装包\"><a href=\"#二进制安装包\" class=\"headerlink\" title=\"二进制安装包\"></a>二进制安装包</h2><p>二进制包是由各种代码文件, 静态库 动态库 经过编译后生成的可执行文件.</p>\n<ul>\n<li>XCode开启编译选项Write Link Map File XCode -&gt; target -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为yes, 并指定好linkMap的存储位置.</li>\n<li>编译后到编译目录里找到该txt文件, 文件名和路径就是上述的Path to Link Map File.<br>~/Library/Developer/Xcode/DerivedData/XXX-eumsvrzbvgfofvbfsoqokmjprvuh/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/. 这个LinkMap里展示了整个可执行文件的全貌, 列出了编译后的每一个.o目标文件的信息(包括静态链接库.a里的), 以及每一个目标文件的代码段, 数据段存储详情.</li>\n<li>到<a href=\"https://github.com/huanxsd/LinkMap\" target=\"_blank\" rel=\"noopener\">https://github.com/huanxsd/LinkMap</a>下载这个mac工程, 然后运行, 对文件进行分析.</li>\n<li>通过对上面的文件进行分析, 就知道每个类在最终的可执行文件中占据的大小. 然后有针对性的进行优化就可以了.</li>\n</ul>\n<h2 id=\"删除一些无用文件\"><a href=\"#删除一些无用文件\" class=\"headerlink\" title=\"删除一些无用文件\"></a>删除一些无用文件</h2><p>查找无用selector, 无用OC类, 扫描重复代码.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">iOS 保持界面流畅的技巧</a></p>\n<p>2.<a href=\"https://techblog.toutiao.com/2017/01/17/iosspeed/#more\" target=\"_blank\" rel=\"noopener\">今日头条iOS客户端启动速度优化</a></p>\n<p>3.<a href=\"https://github.com/skyming/iOS-Performance-Optimization\" target=\"_blank\" rel=\"noopener\">iOS-Performance-Optimization</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-生命周期","url":"http://hchong.net/2018/03/30/iOS开发总结系列-生命周期/","content":"<p>这里主要总结一下iOS开发中一些声明周期相关的知识</p>\n<h2 id=\"UIView的生命周期\"><a href=\"#UIView的生命周期\" class=\"headerlink\" title=\"UIView的生命周期\"></a>UIView的生命周期</h2><p>当创建View的时: </p>\n<ol>\n<li><code>initWithFrame:</code>, initWithFrame进行初始化时, 当rect的值不为CGRectZero时会触发layoutSubviews. init初始化不会触发layoutSubviews.</li>\n<li><code>willMoveToSuperview:</code></li>\n<li><code>didMoveToSuperview</code></li>\n<li><code>willMoveToWindow:</code></li>\n<li><code>didMoveToWindow</code></li>\n<li><code>layoutSubviews</code>, 在子视图布局变动时会多次调用.</li>\n</ol>\n<p>当View销毁时:</p>\n<ol>\n<li><code>willMoveToWindow:</code></li>\n<li><code>didMoveToWindow</code></li>\n<li><code>willMoveToSuperview:</code></li>\n<li><code>`didMoveToSuperview</code></li>\n<li><code>removeFromSuperview</code></li>\n<li><code>dealloc</code></li>\n</ol>\n<p>如果View中有子View的话, 创建时除了上面的顺序之外, 还会调用:</p>\n<ol>\n<li><code>layoutSubviews</code>, 这是因为子视图的布局变动, 所以会触发.</li>\n<li><code>didAddSubview:</code></li>\n<li><code>drawRect:</code>.</li>\n</ol>\n<p>移除时, 除了上面的顺序之外, 还会调用:</p>\n<ol>\n<li><code>willRemoveSubview:</code>, 是在dealloc后面执行的. 如果有多个子视图, willRemoveSubview会循环执行, 直到移除所有子视图.</li>\n</ol>\n<h2 id=\"UIViewController声明周期\"><a href=\"#UIViewController声明周期\" class=\"headerlink\" title=\"UIViewController声明周期\"></a>UIViewController声明周期</h2><ol>\n<li><code>initWithCoder: 或 initWithNibName:bundle:</code>, 首先从归档文件中加载UIViewController对象. 非StoryBoard创建调用<code>initWithNibName:bundle:</code>, 如果使用StoryBoard进行视图管理, 从nib中加载对象实例时, 程序不会直接初始化一个UIViewController, StoryBoard会自动初始化或在segue被触发时自动初始化<code>initWithCoder:</code>.</li>\n<li><code>awakeFromNib</code>, 从xib或者storyboard加载完毕就会调用.</li>\n<li><code>loadView</code>, 每次访问UIViewController的view(比如controller.view, self.view)而且view为nil, loadView方法就会被调用. loadView方法是用来负责创建UIViewController的view. 如果在初始化UIViewController指定了xib文件名, 就会根据传入的xib文件名加载对应的xib文件, 如果没有明显地传xib文件名, 就会加载跟UIViewController同名的xib文件. 如果没有找到相关联的xib文件, 就会创建一个空白的UIView, 然后赋值给UIViewController的view属性. 苹果设计这个方法就是给我们自定义UIViewController的view用的, 我们直接在该方法中指定UIViewController的View.</li>\n<li><code>viewDidLoad</code>, 无论你是通过xib文件还是重写loadView方法创建UIViewController的view, 在view创建完毕后, 最终都会调用viewDidLoad方法. 在这里视图层次已经加载到内存中. 通常, 我们对于各种初始化数据的载入, 初始设定, 修改约束, 移除视图等很多操作都可以这个方法中实现.</li>\n<li><code>viewWillAppear:</code>, 系统在载入所有的数据后, 将会在屏幕上显示视图, 这时会先调用这个方法, 通常我们会在这个方法对即将显示的视图做进一步的设置.</li>\n<li><code>viewWillLayoutSubviews</code>, view 即将布局其Subviews. 比如view的bounds改变了(例如:状态栏从不显示到显示,视图方向变化), 要调整Subviews的位置, 在调整之前要做的工作可以放在该方法中实现.</li>\n<li><code>viewDidLayoutSubviews</code>, view已经布局其Subviews, 这里可以放置调整完成之后需要做的工作.</li>\n<li><code>viewDidAppear:</code>, 在view被添加到视图层级中以及多视图上下级视图切换时调用这个方法, 可以对正在显示的视图做进一步的设置.</li>\n<li><code>viewWillDisappear:</code>, 当前视图在即将被移除, 或被覆盖时, 会调用该方法. 此时还没有调用removeFromSuperview.</li>\n<li><code>viewDidDisappear:</code>, view已经消失或被覆盖, 此时已经调用removeFromSuperView.</li>\n<li><code>dealloc</code>, UIViewController被销毁时调用, 此次需要对你在init和viewDidLoad中创建的对象进行释放.</li>\n<li><code>didReceiveMemoryWarning</code>, 内存不够时, 系统会自动调用这个方法. 默认实现是如果当前UIViewController的view不在应用程序的视图层次结构(View Hierarchy)中, 即view的superview为nil的时候, 就会将view释放, 并且调用viewDidUnload方法.</li>\n<li><code>viewDidUnload</code>, 收到内存警告时, 如果当前UIViewController的View的superView为nil时, 就会将View释放, 并且调用viewDidUnload.</li>\n</ol>\n<h2 id=\"AppDelegate生命周期\"><a href=\"#AppDelegate生命周期\" class=\"headerlink\" title=\"AppDelegate生命周期\"></a>AppDelegate生命周期</h2><ol>\n<li>进入main函数, 设置AppDelegate称为函数的代理.</li>\n<li>程序加载完成, -[AppDelegate application:didFinishLaunchingWithOptions:].</li>\n<li>创建window窗口</li>\n<li><code>applicationWillResignActive:</code>, 将进入后台. 当应用程序从活动状态(active)变到非活动状态(inactive)时被触发调用, 这可能发生在一些临时中断下(例如: 来电话, 来短信)又或者程序退出时, 他会先过渡到后台. 然后使用这方法去暂停正在进行的任务, 禁用计时器, 节流OpenGL ES 帧率. 在游戏中应该在这个方法里面暂停游戏.</li>\n<li><code>applicationDidEnterBackground:</code>, 已经进入后台. 使用这种方法来释放共享资源, 保存用户数据, 无效计时器, 存储足够多的应用程序状态信息来恢复您的应用程序的当前状态, 以防它终止丢失数据. 如果你的程序支持后台运行, 那么当用户退出时不会调用.</li>\n<li><code>applicationWillEnterForeground</code>, 将进入前台. 先从后台切换到非活动状态, 然后进入活动状态.</li>\n<li><code>applicationDidBecomeActive</code>, 已经进入前台. 重启所有的任务, 不管是从非活动状态还是刚启动程序, 还是后台状态.</li>\n<li><code>applicationWillTerminate</code>, 程序即将退出. 当应用将要终止时, 调用这个方法, 在这里我们可以做一些数据的保存.</li>\n</ol>\n<h2 id=\"APP启动生命周期\"><a href=\"#APP启动生命周期\" class=\"headerlink\" title=\"APP启动生命周期\"></a>APP启动生命周期</h2><ol>\n<li>系统先读取APP的可执行文件(Mach-O)文件, 从里面获取dyld的路径, 然后加载dyld, dyld去初始化运行环境. </li>\n<li>开启缓存策略, 加载程序相关依赖库(其中也包含我们的可执行文件)到内存中, 调用每个依赖库的初始化方法, 动态链接依赖库. 在这一步Runtime会被初始化.</li>\n<li>当所有依赖库的初始化后, 轮到最后一位(程序可执行文件)进行初始化, 在这时runtime会对项目中所有类进行类结构初始化, 然后调用所有的load方法.</li>\n<li>最后dyld返回main函数地址, main函数被调用, 我们就进入了程序的入口.</li>\n</ol>\n<p>Mach-O文件格式是 OS X 与 iOS 系统上的可执行文件格式, 像我们编译过程产生的.O文件, 以及程序的可执行文件, 动态库等都是Mach-O文件. 有如下几个部分组成:</p>\n<ul>\n<li>Header: 保存了一些基本信息, 包括了该文件运行的平台, 文件类型, LoadCommands的个数等等.</li>\n<li>LoadCommands: 可以理解为加载命令, 在加载Mach-O文件时会使用这里的数据来确定内存的分布以及相关的加载命令. 比如我们的main函数的加载地址, 程序所需的dyld的文件路径, 以及相关依赖库的文件路径.</li>\n<li>Data: 这里包含了具体的代码, 数据等等.</li>\n</ul>\n<p>dyld: (the dynamic link editor)动态链接器, 系统 kernel 做好启动程序的初始准备后，交给 dyld 负责.<br>ImageLoader: ImageLoader 作用是将这些文件加载进内存, 且每一个文件对应一个ImageLoader实例来负责加载. 在程序运行时它先将动态链接的 image(二进制文件) 递归加载,<br>再从可执行文件 image 递归加载所有符号.</p>\n<p>dyld 担当了 runtime 和 ImageLoader 中间的协调者, 当新 image 加载进来后交由 runtime 去解析这个二进制文件的符号表和代码.<br>整个调用栈顺序是这样的:</p>\n<ol>\n<li>dyld 开始将程序二进制文件初始化.</li>\n<li>交由 ImageLoader 读取 image, 其中包含了我们的类, 方法等各种符号.</li>\n<li>由于 runtime 向 dyld 绑定了回调, 当 image 加载到内存后, dyld 会通知 runtime 进行处理.</li>\n<li>runtime 接手后调用 map_images 做解析和处理. 接下来 load_images 中调用 call_load_methods 方法, 遍历所有加载进来的 Class, 按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法.</li>\n<li>至此, 可执行文件中和动态库所有的符号 (Class, Protocol, Selector, IMP, …) 都已经按格式成功加载到内存中, 被 runtime 所管理, 再这之后, runtime 的那些方法（动态添加 Class, swizzle 等等才能生效.</li>\n</ol>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-语言设计","url":"http://hchong.net/2018/03/27/iOS开发总结系列-语言设计/","content":"<p>这里主要是一些语言设计方面的常见问题.</p>\n<h2 id=\"NSString如何计算字符的个数\"><a href=\"#NSString如何计算字符的个数\" class=\"headerlink\" title=\"NSString如何计算字符的个数\"></a>NSString如何计算字符的个数</h2><p>首先我们要知道字符串末尾会自动加上一个<code>\\0</code>, 因此我们可以设计这么一个函数: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">int string_length(char *s) &#123;</div><div class=\"line\">    int c = 0;</div><div class=\"line\">    while (*s[c] != `\\0`)&#123;</div><div class=\"line\">        c++:</div><div class=\"line\">    &#125;</div><div class=\"line\">    return c;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过指针偏移量来获取每个元素, 同<code>\\0</code>比较, 相等时的指针偏移量就是字符串元素的个数.</p>\n<h2 id=\"NSUserDefaults性能优化\"><a href=\"#NSUserDefaults性能优化\" class=\"headerlink\" title=\"NSUserDefaults性能优化\"></a>NSUserDefaults性能优化</h2><p>当使用NSUserDefaults写入文件后, 值会被存放到Library/Preferences/com.xxx.AppName.plist文件里(com.xxx.AppName是应用的标识符). 这个文件是个plist文件, 因此, 它可以存放plist可以存放的数据类型: NSData, NSString, NSNumber, NSDate, NSArray, 或者NSDictionary.<br>它是针对每个应用适用的, 只作用于自身应用内. sandbox的安全机制保证, 它不能修改其他应用的值, 也不会被其他应用修改.</p>\n<p>NSUserDefaults是个单例, 而且它访问的文件也只有一个, NSUserDefaults帮我们做了一层优化. NSUserDefaults是带缓存的, NSUserDefaults会把访问到的key缓存到内存里, 下次再访问时, 如果内存中命中就直接访问, 如果未命中再从文件中载入. 应用会时不时调用[defaults synchronize]方法来保证内存与文件中的数据的一致性, 有时在写入一个值后也最好调用下这个方法来保证数据真正写入文件.</p>\n<p>我们不能在一个地方大规模写入NSUserDefaults, 性能会有很大影响. 用plist文件读入内存在访问的瓶颈主要在读入的过程中, 如果文件很大会比较耗时, 但是一旦载好, 在内存中读取就很快; 但是, 对内存值的写入则会造成内存与文件数据不一致, 这时为了保证数据一致性就要写入文件, 写入后又要读入内存, 这就导致延迟.</p>\n<p>NSUserDefaults对象发valueForKey:消息, 返回的数据永远是不可变类型的.</p>\n<h2 id=\"数据库为什么要创建索引\"><a href=\"#数据库为什么要创建索引\" class=\"headerlink\" title=\"数据库为什么要创建索引\"></a>数据库为什么要创建索引</h2><p>创建索引的优点:</p>\n<ol>\n<li>通过创建唯一性索引, 可以保证数据库表中每一行数据的唯一性</li>\n<li>可以加快数据的检索速度</li>\n<li>可以加速表与表之间的链接</li>\n<li>可以显著减少查询中分组和排序的时间</li>\n<li>使用索引在查询过程中使用优化隐藏器, 提高系统性能</li>\n</ol>\n<p>创建索引的缺点:</p>\n<ol>\n<li>创建索引和维护索引要耗费时间, 这种时间随着数据量增加而增加</li>\n<li>创建索引需要占用物理空间</li>\n<li>对表的数据增删改查时, 索引也要动态的维护</li>\n</ol>\n<p>因此我们经常在主键列, 常用在连接的列, 经常根据范围搜索的列, 经常排序的列, 经常使用在WHERE子句中的列上面创建索引.<br>而那些在查询中很少用的列, 数据值很少的列, text, image和bit数据类型的列(因为要么数据量大要么取值少), 修改性能远远大于检索性能时不应该创建索引.</p>\n<h2 id=\"Full-Text-Search为什么快\"><a href=\"#Full-Text-Search为什么快\" class=\"headerlink\" title=\"Full Text Search为什么快\"></a>Full Text Search为什么快</h2><p>它的工作原理是计算机索引程序通过扫描文章中的每一个词, 对每一个词建立一个索引, 指明该词在文章中出现的次数和位置, 当用户查询时, 检索程序就根据事先建立的索引进行查找, 并将查找的结果反馈给用户的检索方式.</p>\n<p>分为按字检索和按词检索: 按字检索是指对于文章中的每一个字都建立索引, 检索时将词分解为字的组合. 按词检索是指对文章中的词, 即语义单位建立索引, 检索时按词检索.</p>\n<h2 id=\"imageNamed-与imageWithContentsOfFile-对比\"><a href=\"#imageNamed-与imageWithContentsOfFile-对比\" class=\"headerlink\" title=\"imageNamed:与imageWithContentsOfFile:对比\"></a>imageNamed:与imageWithContentsOfFile:对比</h2><p>使用imageNamed这个方法生成的UIImage对象, 会在应用的main bundle中寻找图片, 如果找到则Cache到系统缓存中, 作为内存的cache, 而程序员是无法操作cache的, 只能由系统自动处理, 如果我们需要重复加载一张图片, 那这无疑是一种很好的方式, 因为系统能很快的从内存的cache找到这张图片. 但是试想, 如果加载很多很大的图片的时候, 内存消耗过大的时候, 就会会强制释放内存, 即会遇到内存警告(memory warnings). 由于在iOS系统中释放图片的内存比较麻烦, 所以冲易产生内存泄露.<br>经常使用在图片资源反复使用到, 而且占用内存少的场景下.</p>\n<p>相比上面的imageNamed这个方法要写的代码多了几行, 使用imageWithContentsOfFile的方式加载的图片, 图片会被系统以数据的方式进行加载. 返回的对象不会保存在缓存中, 一旦对象销毁就会释放内存, 所以一般不会因为加载图片的方法遇到内存问题.<br>经常使用在图片资源较大, 加载到内存后, 比较耗费内存资源, 图片一般只使用一次的场景下.</p>\n<h2 id=\"Image的加载以及内存计算\"><a href=\"#Image的加载以及内存计算\" class=\"headerlink\" title=\"Image的加载以及内存计算\"></a>Image的加载以及内存计算</h2><p>iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤: </p>\n<ol>\n<li>从磁盘拷贝数据到内核缓冲区.</li>\n<li>从内核缓冲区复制数据到用户空间.</li>\n<li>生成UIImageView, 把图像数据赋值给UIImageView.</li>\n<li>如果图像数据为未解码的PNG/JPG, 解码为位图数据.</li>\n<li>CATransaction捕获到UIImageView layer树的变化.</li>\n<li>主线程Runloop提交CATransaction, 开始进行图像渲染.<ul>\n<li>分配内存缓冲区用于管理文件 IO 和解压缩操作</li>\n<li>将文件数据从磁盘读到内存中</li>\n<li>将压缩的图片数据解码成未压缩的位图形式, 这是一个非常耗时的 CPU 操作.</li>\n<li>如果数据没有字节对齐, Core Animation会再拷贝一份数据, 进行字节对齐.</li>\n<li>GPU处理位图数据, 进行渲染.</li>\n</ul>\n</li>\n</ol>\n<p>位图就是一个像素数组, 数组中的每个像素就代表着图片中的一个点. 我们在应用中经常用到的 JPEG 和 PNG 图片就是位图.</p>\n<p>不管是 JPEG 还是 PNG 图片, 都是一种压缩的位图图形格式. 只不过 PNG 图片是无损压缩, 并且支持 alpha 通道, 而 JPEG 图片则是有损压缩. 因此, 在将磁盘中的图片渲染到屏幕之前, 必须先要得到图片的原始像素数据, 才能执行后续的绘制操作, 这就是为什么需要对图片解压缩的原因.</p>\n<p>解压缩后的图片大小 = 图片的像素宽 <em> 图片的像素高 </em> 每个像素所占的字节数. 因为位图不用解压缩, 所以位图的内存大小就是图片的实际大小. 非位图的图片要解压缩, 所以非位图的图片在内存中的大小就是上面的公式.</p>\n<p>强制解压缩的原理就是对图片进行重新绘制, 得到一张新的解压缩后的位图. 其中, 用到的最核心的函数是 <code>CGBitmapContextCreate:</code>.</p>\n<h2 id=\"isEqual与hash\"><a href=\"#isEqual与hash\" class=\"headerlink\" title=\"==, isEqual与hash\"></a>==, isEqual与hash</h2><ul>\n<li>对于基本类型, ==运算符比较的是值; 对于对象类型, ==运算符比较的是对象的地址(即是否为同一对象)</li>\n<li>常见类型的isEqual方法还有NSString isEqualToString / NSDate isEqualToDate / NSArray isEqualToArray / NSDictionary isEqualToDictionary / NSSet isEqualToSet. isEqual比较对象值是否相等, 如果是自定义对象, 那么对象所有的属性也要像等.</li>\n<li><p>hash 值决定了该对象在 hash 表中存储的位置. hash值是对象判等的必要非充分条件, 集成成员的hash值和目标hash值相等, 并且进行对象判等为true, 则hash返回true.</p>\n<ul>\n<li>作为判等的结果 hash方法只在对象被添加至NSSet和设置为NSDictionary的key时会调用. </li>\n<li>基于hash值索引的Hash Table查找某个成员的过程就是: 通过hash值直接找到查找目标的位置, 如果目标位置上有多个相同hash值得成员, 此时再按照数组方式进行查找.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"NSDictionary-内部结构、实现原理\"><a href=\"#NSDictionary-内部结构、实现原理\" class=\"headerlink\" title=\"NSDictionary 内部结构、实现原理\"></a>NSDictionary 内部结构、实现原理</h2><p>NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的, hash函数设计的好坏影响着数据的查找访问效率.</p>\n<p>Objective-C 中的字典 NSDictionary 底层其实是一个哈希表, 实际上绝大多数语言中字典都通过哈希表实现. 哈希表的本质是一个数组, 数组中每一个元素称为一个箱子(bin), 箱子中存放的是键值对.</p>\n<ol>\n<li>根据 key 计算出它的哈希值 h.</li>\n<li>假设箱子的个数为 n, 那么这个键值对应该放在第 (h % n) 个箱子中.</li>\n<li>如果该箱子中已经有了键值对, 那么就会有冲突, 如何解决冲突:<ul>\n<li>开放寻址法. </li>\n<li>链地址法. 每个箱子其实是一个链表, 属于同一个箱子的所有键值对都会排列在链表中</li>\n<li>再哈希法. 当发生冲突时, 使用第二个, 第三个, 哈希函数计算地址, 直到无冲突. 缺点: 计算时间增加. 比如对字符串首字母进行哈希, 如果产生冲突可以按照字符串字母第二位进行哈希, 再冲突, 第三位, 直到不冲突为止.</li>\n<li>建立一个公共溢出区. 假设哈希函数的值域为[0,m-1], 则设向量HashTable[0..m-1]为基本表, 另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录.</li>\n</ul>\n</li>\n</ol>\n<p>负载因子(load factor), 它用来衡量哈希表的 空/满 程度, 一定程度上也可以体现查询的效率, 计算公式为: <code>负载因子 = 总键值对数 / 箱子个数</code>. 负载因子越大, 意味着哈希表越满, 越容易导致冲突, 性能也就越低. 因此, 一般来说, 当负载因子大于某个常数(可能是 1, 或者 0.75 等)时, 哈希表将自动扩容.<br>哈希表在自动扩容时, 一般会创建两倍于原来个数的箱子, 因此即使 key 的哈希值不变, 对箱子个数取余的结果也会发生改变, 因此所有键值对的存放位置都有可能发生改变, 这个过程也称为重哈希(rehash).</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"获取设备唯一标识符","url":"http://hchong.net/2018/03/27/获取设备唯一标识符/","content":"<p>获取设备的唯一标识符具体可以分为如下几种：UDID MAC IDFA IDFV UUID. 下面分别来介绍下.</p>\n<h2 id=\"UDID-Unique-Device-Identifier-Description\"><a href=\"#UDID-Unique-Device-Identifier-Description\" class=\"headerlink\" title=\"UDID (Unique Device Identifier Description)\"></a>UDID (Unique Device Identifier Description)</h2><p>UDID 是由子母和数字组成的40个字符串的序号, 用来区别每一个唯一的iOS设备, 这些编码看起来是随机的, 但实际上是跟硬件设备特点相关联的. 我们平时用开发者账号在设备上安装测试应用时, 往开发者账号上添加的就是设备的UDID.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSString *UDID = [[UIDevice currentDevice] uniqueIdentifier];</div></pre></td></tr></table></figure>\n<p>由于UDID是跟设备唯一对应的, 许多开发者试图通过UDID获取到用户的真实姓名, 密码, 地址等隐私数据. 为了避免引起麻烦, 苹果在iOS 5.0 的时候废除了UDID的代码获取权限, 现在应用试图获取UDID已被禁止且不允许上架.</p>\n<h2 id=\"MAC-Medium-Media-Access-Control\"><a href=\"#MAC-Medium-Media-Access-Control\" class=\"headerlink\" title=\"MAC (Medium/Media Access Control)\"></a>MAC (Medium/Media Access Control)</h2><p>这个就是常说的网卡地址, 一部iPhone上可能有多个MAC地址, 包括WIFI的, SIM的等. 具有全球唯一性, 这样就可以非常好的标识设备唯一性.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (NSString *) getMacAddress &#123;  </div><div class=\"line\">        int mib[6];  </div><div class=\"line\">        size_t len;  </div><div class=\"line\">        charchar *buf;  </div><div class=\"line\">        unsigned charchar *ptr;  </div><div class=\"line\">        struct if_msghdr *ifm;  </div><div class=\"line\">        struct sockaddr_dl *sdl;  </div><div class=\"line\">   </div><div class=\"line\">        mib[0] = CTL_NET;  </div><div class=\"line\">        mib[1] = AF_ROUTE;  </div><div class=\"line\">        mib[2] = 0;  </div><div class=\"line\">        mib[3] = AF_LINK;  </div><div class=\"line\">        mib[4] = NET_RT_IFLIST;  </div><div class=\"line\">        </div><div class=\"line\">        if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123;  </div><div class=\"line\">            printf(&quot;Error: if_nametoindex error/n&quot;);  </div><div class=\"line\">            return NULL;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">        if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123;  </div><div class=\"line\">            printf(&quot;Error: sysctl, take 1/n&quot;);  </div><div class=\"line\">            return NULL;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">        if ((buf = malloc(len)) == NULL) &#123;  </div><div class=\"line\">            printf(&quot;Could not allocate memory. error!/n&quot;);  </div><div class=\"line\">            return NULL;  </div><div class=\"line\">        &#125;  </div><div class=\"line\"> </div><div class=\"line\">        if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123;  </div><div class=\"line\">            printf(&quot;Error: sysctl, take 2&quot;);  </div><div class=\"line\">            return NULL;  </div><div class=\"line\">        &#125;  </div><div class=\"line\"></div><div class=\"line\">        ifm = (struct if_msghdr *)buf;  </div><div class=\"line\">        sdl = (struct sockaddr_dl *)(ifm + 1);  </div><div class=\"line\">        ptr = (unsigned charchar *)LLADDR(sdl);  </div><div class=\"line\">        NSString *outstring = [NSString stringWithFormat:@&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];  </div><div class=\"line\">        free(buf);  </div><div class=\"line\"></div><div class=\"line\">        return [outstring uppercaseString]; </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>但MAC地址跟UDID一样, 存在隐私问题, 所以在 iOS 7.0 之后, Mac地址再次遭到苹果的无情封杀. 如果使用之前的方法请求Mac地址都会返回一个固定值 02:00:00:00:00:00, 这一条路再次被堵死.</p>\n<h2 id=\"IDFA-Identifier-For-Identifier\"><a href=\"#IDFA-Identifier-For-Identifier\" class=\"headerlink\" title=\"IDFA (Identifier For Identifier)\"></a>IDFA (Identifier For Identifier)</h2><p>这是 iOS 6.0中提供的一个新方法, 在同一个设备上的所有App都会取到相同的值, 是苹果专门给各广告提供商用来追踪用户而设的. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#import &lt;AdSupport/AdSupport.h&gt;</div><div class=\"line\"></div><div class=\"line\">NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</div></pre></td></tr></table></figure>\n<p>IDFA并不是唯一不变的, 如果用户完全重置系统(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私), 这个广告标示符会重新生成. 另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符), 那么广告标示符也会重新生成. 在iOS 10.0以后如果用户打开限制广告跟踪(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 限制广告跟踪), 则获取到的IDFA为一个固定值00000000-0000-0000-0000-000000000000. 因此, 通过IDFA也无法唯一标识一个设备.<br>如果使用IDFA, 在上传Appstore时必须在iTunes Connect中的上传页面进行相应的设置.</p>\n<h2 id=\"IDFV（Identifier-For-Vendor）\"><a href=\"#IDFV（Identifier-For-Vendor）\" class=\"headerlink\" title=\"IDFV（Identifier For Vendor）\"></a>IDFV（Identifier For Vendor）</h2><p>IDFV是给Vendor标识用户用的, 每个设备在所属同一个Vendor的应用里, 都有相同的值. 其中的Vendor是指应用提供商, 准确的说, 是通过BundleID的反转的前两部分进行匹配, 如果相同就是同一个Vendor, 例如对于com.abc.app1, com.abc.app2 这两个BundleID来说, 就属于同一个Vendor, 共享同一个IDFV的值. 当然, 对于同一个设备不同Vendor的话, 获取到的值是不同的. 和IDFA不同的是, IDFV的值是一定能取到的. 它是iOS 6中新增的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSString *strIDFV = [[[UIDevice currentDevice] identifierForVendor] UUIDString];</div></pre></td></tr></table></figure>\n<p>但是使用IDFV也会存在一些问题, 如果用户将属于此Vendor的所有App卸载, 则IDFV的值会被重置, 即再重装此Vendor的App, IDFV的值也会和之前的不同.</p>\n<h2 id=\"UUID-Universally-Unique-Identifier\"><a href=\"#UUID-Universally-Unique-Identifier\" class=\"headerlink\" title=\"UUID (Universally Unique Identifier)\"></a>UUID (Universally Unique Identifier)</h2><p>UUID是Universally Unique Identifier的缩写, 中文意思是通用唯一识别码. 它是苹果提供的一个获取大随机数的方法, 据说UUID随机数算法得到的数重复概率为170亿分之一. 这样, 每个人都可以建立不与其它人冲突的 UUID.</p>\n<h3 id=\"CFUUID\"><a href=\"#CFUUID\" class=\"headerlink\" title=\"CFUUID\"></a>CFUUID</h3><p>从iOS 2.0开始, CFUUID就已经出现了. 它是CoreFoundation包的一部分, 因此API属于C语言风格.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CFUUIDRef cfuuid = CFUUIDCreate(kCFAllocatorDefault);</div><div class=\"line\">NSString *cfuuidString = (NSString*)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, cfuuid));</div></pre></td></tr></table></figure>\n<h3 id=\"NSUUID\"><a href=\"#NSUUID\" class=\"headerlink\" title=\"NSUUID\"></a>NSUUID</h3><p>NSUUID在iOS 6.0中才出现, 这跟CFUUID几乎完全一样, 只不过它是Objective-C接口. 通过下面的代码可以获得一个UUID字符串:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSString *uuid = [[NSUUID UUID] UUIDString];</div></pre></td></tr></table></figure>\n<h2 id=\"比较完善的做法\"><a href=\"#比较完善的做法\" class=\"headerlink\" title=\"比较完善的做法\"></a>比较完善的做法</h2><pre><code>//获取UQID\n+ (NSString *)getUQID {\n    //从本地沙盒取\n    NSString *uqid = [[NSUserDefaults standardUserDefaults] objectForKey:UQID_KEY];\n\n    if (!uqid) {\n        //从keychain取\n        uqid = (NSString *)[YDKeyChain readObjectForKey:UQID_KEY];\n\n        if (uqid) {\n            [[NSUserDefaults standardUserDefaults] setObject:uqid forKey:UQID_KEY];\n            [[NSUserDefaults standardUserDefaults] synchronize];\n\n        } else {\n            //从pasteboard取\n            UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n            id data = [pasteboard dataForPasteboardType:UQID_KEY];\n            if (data) {\n                uqid = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n            }\n\n            if (uqid) {\n                [[NSUserDefaults standardUserDefaults] setObject:uqid forKey:UQID_KEY];\n                [[NSUserDefaults standardUserDefaults] synchronize];\n                [YDKeyChain saveObject:uqid forKey:UQID_KEY];\n\n            } else {\n\n                //获取idfa\n                uqid = [self getIDFA];\n\n                //idfa获取失败的情况，获取idfv\n                if (!uqid || [uqid isEqualToString:@&quot;00000000-0000-0000-0000-000000000000&quot;]) {\n                    uqid = [self getIDFV];\n\n                    //idfv获取失败的情况，获取uuid\n                    if (!uqid) {\n                        uqid = [self getUUID];\n                    }\n                }\n\n                [[NSUserDefaults standardUserDefaults] setObject:uqid forKey:UQID_KEY];\n                [[NSUserDefaults standardUserDefaults] synchronize];\n\n                [YDKeyChain saveObject:uqid forKey:UQID_KEY];\n\n                UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n                NSData *data = [uqid dataUsingEncoding:NSUTF8StringEncoding];\n                [pasteboard setData:data forPasteboardType:UQID_KEY];\n\n            }\n        }\n    }\n    return uqid;\n</code></pre>","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-网络编程","url":"http://hchong.net/2018/03/26/iOS开发总结系列-网络编程/","content":"<p>这里主要是一些计算机的基础知识部分, 在平常业务中不怎么用, 但是对深入了解计算机原理有很大帮助.</p>\n<h2 id=\"HTTP请求中的GET和POST\"><a href=\"#HTTP请求中的GET和POST\" class=\"headerlink\" title=\"HTTP请求中的GET和POST\"></a>HTTP请求中的GET和POST</h2><p>GET和POST是网络请求到的两种基本方式.<br>GET把参数包含在URL中, POST通过request body传递参数.<br>GET在浏览器回退时是无害, 而POST会再次提交请求.<br>GET产生的URL地址可以保存为书签, 而POST不可以.<br>GET请求会被浏览器主动cache, 而POST不会, 除非手动设置.<br>GET请求只能进行url编码, 而POST支持多种编码方式.<br>GET请求参数会被完整保留在浏览器历史记录里, 而POST中的参数不会被保留.<br>GET请求在URL中传送的参数是有长度限制的, 而POST没有.<br>对参数的数据类型, GET只接受ASCII字符, 而POST没有限制.<br>GET比POST更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息.<br>GET参数通过URL传递, POST放在Request body中.<br>GET和POST都是HTTP协议中的两种发送请求的方法.HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议.HTTP的底层是TCP/IP, 所以GET和POST的底层也是TCP/IP. 也就是说, GET/POST都是TCP链接. GET和POST能做的事情是一样一样的. 你要给GET加上request body, 给POST带上url参数, 技术上是完全行的通的</p>\n<h2 id=\"TCP与UDP\"><a href=\"#TCP与UDP\" class=\"headerlink\" title=\"TCP与UDP\"></a>TCP与UDP</h2><p>TCP面向连接（如打电话要先拨号建立连接); UDP是无连接的, 即发送数据之前不需要建立连接.<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道.<br>TCP协议会向对方发一个带有ACK标志的空数据包（KeepAlive探针）, 对方在收到ACK包以后，如果连接一切正常，应该回复一个ACK；如果连接出现错误了，则应当回复一个RST；如果对方没有回复，服务器每隔intvl的时间再发ACK，如果连续probes个包都被无视了，说明连接被断开了; UDP协议的客户端需要定时向服务器发送心跳包，告诉服务器自己在线. </p>\n<p>TCP: 面向连接, 传输可靠(保证数据正确性, 保证数据顺序), 用于传输大量数据(流模式), 速度慢, 建立连接需要开销较多(时间, 系统资源).<br>UDP: 面向非连接, 传输不可靠, 用于传输少量数据(数据包模式), 速度快.</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>第一次握手: 建立连接, 客户端发送连接请求报文段, 将SYN位置为1, Sequence Number置为x; 然后, 客户端进入SYN_SEND状态, 等待服务器确认.<br>第二次握手: 服务器收到SYN报文段, 服务器收到客户端的SYN报文段, 需要对这个报文段确认, 设置Acknowledgment Number为x+1(Sequence Number+1); 同时, 自己还要发送SYN请求信息, 将SYN位置为1, Sequence Number为y; 服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中, 一并发送给客户端, 此时服务器进入SYN_RECV状态.<br>第三次握手: 客户端收到服务器的SYN+ACK报文段, 然后将Acknowledgment Number设置为y+1, 向服务器发送ACK报文段, 这个报文段发送完毕以后, 客户端和服务器端都进入ESTABLISHED状态, 完成TCP三次握手. 完成了三次握手, 客户端和服务器端就可以开始传送数据.</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>第一次挥手: 主机1(可以使客户端, 也可以是服务端), 设置设置Sequence Number和Acknowledgment Number, 向主机2发送一个FIN报文段; 此时，主机1进入FIN_WAIT_1状态; 这表示主机1没有数据要发送给主机2了.<br>第二次挥手: 主机2收到了主机1发送的FIN报文段, 向主机1回一个ACK报文段, Acknowledgment Number为Sequence Number加1; 主机1进入FIN_WAIT_2状态; 主机2告诉主机1, 我”同意”你的关闭请求.<br>第三次挥手: 主机2向主机1发送FIN报文段, 请求关闭连接, 同时主机2进入LAST_ACK状态.<br>第四次挥手: 主机1收到主机2发送的FIN报文段, 向主机2发送ACK报文段, 然后主机1进入TIME_WAIT状态; 主机2收到主机1的ACK报文段以后, 就关闭连接; 此时, 主机1向等待2MSL后依然没有收到回复, 则证明主机2已经正常关闭, 那么主机1也就此关闭.</p>\n<h2 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h2><p>HTTPS的主要思想是在不安全的网络上创建一安全信道, 并可在使用适当的加密包和服务器证书可被验证且可被信任时, 对窃听和中间人攻击提供合理的防护. HTTPS的信任继承基于预先安装在浏览器中的证书颁发机构.<br>HTTPS中的S指的就是TLS(SSL), 相当于是HTTP over SSL. 使用SSL/TLS协议进行加解密, 下面我们来详细说一下是如何加密的. HTTP默认端口是80, HTTPS默认端口是443.</p>\n<ol>\n<li>客户端给出协议号和一个随机数A, 以及客户端支持的加密算法.</li>\n<li>服务端确认双方使用的加密算法, 并给出数字证书(包含了网站的地址, 加密用的公钥, 以及证书的颁发机构, 过期时间等), 以及一个服务器生成的随机数B.</li>\n<li>客户端解析证书, 传送加密信息: 确认数字证书有效, 然后生成一个新的随机数C, 并且使用数字证书中的公钥, 加密这个随机数, 发送给服务端.</li>\n<li>服务端解密信息: 服务端使用自己的私钥进行解密, 获取客户端发来的随机数, 使用该随机序列号, 对该消息进行加密, 验证的到的校验值是否与客户端发来的一致.</li>\n<li>客户端和服务端使用约定的加密方法, 使用前面的三个随机数, 生成对话密钥, 用对话密钥来加密接下来的整个过程.</li>\n</ol>\n<h2 id=\"数字签名和数字证书\"><a href=\"#数字签名和数字证书\" class=\"headerlink\" title=\"数字签名和数字证书\"></a>数字签名和数字证书</h2><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"noopener\">这里</a>讲的特别详细, 我做一个总结和整理.</p>\n<ol>\n<li>服务端有两把钥匙, 一个公钥一个私钥. </li>\n<li>服务端把公钥发送到客户端.</li>\n<li>客户端向服务端传输信息可以使用公钥来加密, 以达到保密的效果. 服务端收到信息后, 用私钥解密. 只要服务端的私钥不泄密, 意味着这封信就是安全的.</li>\n<li>服务端向客户端发送信息, 对信息Hash化, 生成信息的摘要, 然后再使用私钥对这个摘要进行加密, 加密的结果就是<em>数字签名</em>. 服务端将这个签名附在信息中, 一起下发给客户端.</li>\n<li>客户端收到信息后, 将数字签名用公钥解密, 得到信息的摘要, 这就可以证明这些信息是由服务端下发的.</li>\n<li>客户端再对信息本身Hash化, 将得到的结果与上一步骤中的摘要对比, 如果两者一致, 就说明信息没有被篡改过.</li>\n<li>那么如果有一个第三方, 拦截了客户端与原服务端的传递, 用自己的公钥换走了原服务端的公钥, 那么此时客户端使用的就是第三方的公钥和数字签名, 原服务端给客户端发消息, 就是第三方的假消息, 而不是原服务端的消息.</li>\n<li>这时候我们无法保证公钥属于原服务端还是第三方, 那么我们就要去找证书中心(CA), 为公钥做认证. 证书中心用自己的私钥, 对原服务端的一些相关信息一起加密, 生成<em>数字证书</em>.</li>\n<li>原服务端拿到数字证书后, 再给客户端下发信息, 就可以把数字证书附在信息中.</li>\n<li>客户端收到信息后, 用CA的公钥解开数字证书, 就可以拿到服务端真正的公钥了, 然后就知道数字签名是不是真服务端签的.</li>\n</ol>\n<p>举例: 客户端向服务端发出加密请求, 服务端用自己的私钥加密后, 连同数字证书一起发送给客户端. 客户端(浏览器)中内置有证书管理器, 有”受信任的根证书颁发机构”列表. 客户端会根据这张表查看解开数字证书的公钥是否在列表内. 如果数字证书记载的网址与浏览的不一致, 就说明这张证书被冒用, 浏览器会发出警告. 如果这张数字证书不是由受信任的机构颁发的, 浏览器会发出另一种警告(12306)就是第二种警告. 如果数字证书是可靠的, 客户端就可以使用证书中的服务器公钥, 对信息进行加密, 然后与服务器交换加密信息.</p>\n<h2 id=\"HTTP如何做缓存\"><a href=\"#HTTP如何做缓存\" class=\"headerlink\" title=\"HTTP如何做缓存\"></a>HTTP如何做缓存</h2><p>http1.0 时代给客户端设定缓存方式可通过两个字段: Pragma和Expires来规范.<br>当该字段值为no-cache的时候(事实上现在RFC中也仅标明该可选值), 会知会客户端不要对该资源读缓存, 即每次都得向服务器发一次请求才行. 有了Pragma来禁用缓存, 自然也需要有个东西来启用缓存和定义缓存时间, 对http1.0而言, Expires就是做这件事的首部字段. Expires的值对应一个GMT(格林尼治时间), 比如Mon, 22 Jul 2002 11:12:01 GMT来告诉浏览器资源缓存过期时间, 如果还没过该时间点则不发请求.</p>\n<p>HTTP1.1后, 新增了 Cache-Control 来定义缓存过期时间. 注意: 若报文中同时出现了 Expires 和 Cache-Control, 则以 Cache-Control 为准. 也就是说优先级从高到低分别是 Pragma -&gt; Cache-Control -&gt; Expires.</p>\n<p>作为request的header时, cache-directive 的可选值有:<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FkctxGN8VXdie7M8Fbx6U5Bpfi4c\" alt=\"作为request的header\"><br>作为response的header时, cache-directive 的可选值有:<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FixnilG9OWm4w4qUNZGKSkYXZ4gu\" alt=\"作为response的header\"><br>Cache-Control 允许自由组合可选值.</p>\n<p>另外还有两个字段Last-Modified和ETag.<br>服务器将资源传递给客户端时, 会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端. 格式为: <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code>. 客户端会为资源标记上该信息, 下次再次请求时, 会把该信息附带在请求报文中一并带给服务器去做检查, 若传递的时间值与服务器上该资源最终修改时间是一致的, 则说明该资源没有被修改过, 直接返回304状态码, 内容为空, 这样就节省了传输数据量. 如果两个时间不一致, 则服务器会发回该资源并返回200状态码, 和第一次请求时类似. 这样保证不向客户端重复发出资源, 也保证当服务器有变化时, 客户端能够得到最新的资源. 一个304响应比一个静态资源通常小得多, 这样就节省了网络带宽.</p>\n<p>为了解决上述Last-Modified可能存在的不准确的问题, Http1.1还推出了 ETag 实体首部字段. 服务器会通过某种算法, 给资源计算得出一个唯一标志符(比如md5标志), 在把资源响应给客户端的时候, 会在实体首部加上”ETag: 唯一标识符”一起返回给客户端.</p>\n<p>更多内容可以看<a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"HTTP长连接-vs-TCP连接-vs-websocket\"><a href=\"#HTTP长连接-vs-TCP连接-vs-websocket\" class=\"headerlink\" title=\"HTTP长连接 vs TCP连接 vs websocket\"></a>HTTP长连接 vs TCP连接 vs websocket</h2><h3 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h3><p>长连接: 在HTTP 1.1, 客户端发出请求, 服务端接收请求, 双方建立连接, 在服务端没有返回之前保持连接, 当客户端再发送请求时, 它会使用同一个连接. 这一直继续到客户端或服务器端认为会话已经结束, 其中一方中断连接.</p>\n<p>优势: 减少了连接请求, 降低TCP阻塞, 减少了延迟, 实时性较好.<br>劣势: 可能会影响性能, 因为它在文件被请求之后还保持了不必要的连接很长时间.</p>\n<p>HTTP是无状态, 的也就是说, 浏览器和服务器每进行一次HTTP操作, 就建立一次连接, 但任务结束就中断连接(短连接). 当需要建立 HTTP 长连接时, HTTP 请求头将包含如下内容: <code>Connection: Keep-Alive</code>. 如果服务端同意建立长连接, HTTP 响应头也将包含如下内容: <code>Connection: Keep-Alive</code>. 当需要关闭连接时, HTTP 头中会包含如下内容: <code>Connection: Close</code>.</p>\n<h3 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h3><p>TCP 连接两端好比两个人, 这两个人之间保持通信往来(建立 TCP 连接). 如果他俩经常通信(经常发送 TCP 数据), 那这个 TCP 连接自然是建立着的. 但如果两人只是偶尔通信, 那么, 其中一个人(或两人同时)想知道对方是否还在, 就会定期发送一份邮件(Keep Alive 探测包), 这个邮件没有实质内容, 只是问对方是否还在, 如果对方收到, 就会回复说还在(对这个探测包的 ACK 回应).<br>TCP Keep Alive 用于探测对端是否存在, 而 HTTP Keep Alive 用于协商以复用 TCP 连接. 即便一个 TCP 连接未启用 Keep Alive 功能, 也不妨碍 HTTP 层面开启长连接.</p>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><p>很多网站为了实现推送技术, 所用的技术都是轮询. 轮询是在特定的的时间间隔(如每1秒), 由浏览器对服务器发出HTTP请求, 然后由服务器返回最新的数据给客户端的浏览器. 这种传统的模式带来很明显的缺点, 即浏览器需要不断的向服务器发出请求, 然而HTTP请求可能包含较长的头部, 其中真正有效的数据可能只是很小的一部分, 显然这样会浪费很多的带宽等资源. 因此HTML5定义了WebSocket协议, 能更好的节省服务器资源和带宽, 并且能够更实时地进行通讯.</p>\n<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单, 允许服务端主动向客户端推送数据. 在 WebSocket API 中, 客户端发送一次http websocket请求, 服务器响应请求, 浏览器和服务器只需要完成一次握手, 建立持久连接，并进行双向数据传输，后面不进行HTTP连接，而是使用TCP连接.</p>\n<p>websocket有以下优点: </p>\n<ol>\n<li>较少的控制开销. 在连接创建后, 服务器和客户端之间交换数据时, 用于协议控制的数据包头部相对较小, 相对于HTTP请求每次都要携带完整的头部, 此项开销显著减少了.</li>\n<li>更强的实时性. 协议是全双工的, 服务端可以随时下发信息到客户端, HTTP请求需要等待客户端发起请求服务端才能响应.</li>\n<li>保持连接状态. Websocket需要先创建连接, 这就使得其成为一种有状态的协议, 之后通信时可以省略部分状态信息. 而HTTP请求可能需要在每个请求都携带状态信息(如身份认证等).</li>\n<li>更好的二进制支持. Websocket定义了二进制帧, 相对HTTP, 可以更轻松地处理二进制内容.</li>\n<li>Websocket定义了扩展, 用户可以扩展协议, 实现部分自定义的子协议. 如部分浏览器支持压缩等.</li>\n<li>更好的压缩效果. 相对于HTTP压缩, Websocket在适当的扩展支持下, 可以沿用之前内容的上下文, 在传递类似的数据时, 可以显著地提高压缩率.</li>\n</ol>\n<h2 id=\"HTTP2-0针对同一个域名的多个请求-会建立多少个tcp连接\"><a href=\"#HTTP2-0针对同一个域名的多个请求-会建立多少个tcp连接\" class=\"headerlink\" title=\"HTTP2.0针对同一个域名的多个请求, 会建立多少个tcp连接\"></a>HTTP2.0针对同一个域名的多个请求, 会建立多少个tcp连接</h2><p>这里主要是HTTP2.0的多路复用机制.</p>\n<p>在同一个域名下, 开启一个TCP的connection, 每个请求以stream的方式发送, 每个steam有一个唯一标识. connection一旦建立, 后续的请求都可以复用这个connection并且可以同时发送, server端可以根据stream的唯一标识来相应对应的请求.<br>直到客户端不需要与服务器进行进一步的通信(例如主动用户离开这个页面), 或者服务器主动关闭connection, 这个connection就断开.</p>\n<p>stream的基本组成单位是frame(二进制帧), 每种frame又分为很多种类型例如HEADERS Frame(头部帧), DATA Frame(内容帧)等等. 请求头HEADERS Frame组成了resquest, 返回头HEADERS Frame和DATA Frame组成了response, request和response组成了一个stream.</p>\n<h2 id=\"TCP的拥塞控制机制\"><a href=\"#TCP的拥塞控制机制\" class=\"headerlink\" title=\"TCP的拥塞控制机制\"></a>TCP的拥塞控制机制</h2><p>拥塞控制是TCP协议的意向重要功能, TCP的拥塞机制是从端到端的角度, 推测网络是否发生拥堵, 如果拥堵则降低数据发送效率, 以缓解网络拥塞. 拥塞机制控制算法包括了慢启动, 拥塞避免, 快速重传, 快速恢复四部分.<br>TCP的拥塞控制采用的是窗口机制, TCP的发送端维持一个称为拥塞窗口cwnd的变量, 单位为字节, 用于表示在未收到接收端确认的情况下, 可以连续发送的数据字节数. 他会动态变化, 与网络拥塞情况成反比.</p>\n<ul>\n<li>慢启动指的是, 在TCP的开始传输阶段, 因为不知道网络负荷情况, 因此采用试探的方法, 逐渐增大拥塞窗口.</li>\n<li>拥塞避免指的是, 为了防止拥塞窗口增长过快而引起网络拥塞, TCP还需要设置一个慢启动阈值ssthresh, 当拥塞窗口的值增加到阈值时, 就减缓拥塞窗口的增长速度. 当网络拥塞时, 我们重新执行慢启动算法. </li>\n<li>快速重传指的是, 接收端每收到一个失序的数据报文段后就立即发出重复确认, 以便更早地通知发送端有丢包的情况发生. 举例: 接收端收到了1, 2两个报文, 接下来应该收到3. 但是, 直接收到了4, 这时就会向发送端发送2号数据报文段的确认, 这个称为重复确认. 继续往下走接收到了5, 6报文, 接收端仍然要向发送端发出2号数据报文段的重复确认. 这时发送端会收到多个2号数据报文段的重复确认, 则认为3号数据报文段发生了丢包, 需要立即向接收端重传3号数据报文段, 而不需要等待重传计时器到期再重传. 快速重传算法中规定如果收到某数据报文段的三个重复确认, 则立即重传下一个数据报文段.</li>\n<li>快速重连指的是, 当发送端连续收到三个重复确认时, 就将慢启动阈值ssthresh减半, 以预防网络拥塞的发生, 并且将拥塞窗口cwnd的值置为减半后的ssthresh, 然后开始执行拥塞避免算法, 使得cwnd缓慢地加性增大.</li>\n</ul>\n<h2 id=\"HTTP-post的body体使用form-urlencoded和multipart-form-data的区别\"><a href=\"#HTTP-post的body体使用form-urlencoded和multipart-form-data的区别\" class=\"headerlink\" title=\"HTTP post的body体使用form-urlencoded和multipart/form-data的区别\"></a>HTTP post的body体使用form-urlencoded和multipart/form-data的区别</h2><ul>\n<li>form-urlencoded是默认的mime内容编码类型, 是通用的, 但是它在传输比较大的二进制或者文本数据时效率极低.</li>\n<li>multipart/form-data是当上传文件或者二进制数据和非ASCII数据使用.</li>\n</ul>\n<h2 id=\"网络基本模型\"><a href=\"#网络基本模型\" class=\"headerlink\" title=\"网络基本模型\"></a>网络基本模型</h2><p>OSI 模型(Open System Interconnection model)是一个由国际标准化组织􏰁提出的概念模型,试图􏰁供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架. 它将计算机网络体系结构划分为七层, 每层都可以􏰁供抽象良好的接口. 了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议. OSI 模型从最底层到最高层依次是下面七层结构. 在TCP/IP的四层模型中应用层, 表示层, 会话层统称为应用层. 数据链路层和物理层统称为网络接口层. 见下图:<br><img src=\"https://upload-images.jianshu.io/upload_images/2667071-60c63f19bb202a10.jpg?imageMogr2/auto-orient/\" alt=\"网络基本模型\"></p>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><p>物理层主要是利用传输介质为数据链路层提供物理连接, 实现比特流的透明传输. 规定了激活, 维持, 关闭通信端点之间的机械特性, 电气特性, 功能特性以及过程特性. 为上层协议提供了一个传输数据的物理媒体. 在这一层协议数据单元为比特(bit). 物理层的互联设备包括: 集线器, 中继器等.</p>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h3><p>控制网络层与物理层之间的通信, 主要作用是在不可靠的物理介质上提供可靠的传输. 数据链路层的作用主要包括: 物理地址殉职, 数据的成帧, 流量控制, 数据的检错, 重发等. 在这一层协议数据单元为帧(frame). 数据链路层的互联设备包括: 网桥, 交换机等.</p>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><p>网络层的主要作用是将网络地址翻译成对应的物理地址, 并决定如何将数据从发送方路由到接收方, 建立的是主机到主机的通信. 该层的作用包括: 对子网见的数据包进行路由选择, 实现拥塞控制, 网际互联等功能. 在这一层协议数据单元为数据包(packet). 网络层的互联设备包括: 路由器等.</p>\n<p>网络层主要解决的问题有: 根据MAC地址寻址. 规定不同的信息交换方式. 根据路由算法将数据分组, 并且将信息星最合适的路径由发送端传送到接收端. 控制从源节点到目的节点间的流量.</p>\n<p>网络层的作用是引进一套新的地址, 使得我们能够区分不同的计算机是否属于同一个子网络. 这套地址就叫做”网络地址”, 简称”网址”. 规定网络地址的协议, 叫做IP协议, 他所定义的地址就被称为IP地址. </p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><p>传输层是最重要的一部分, 建立端口到端口的通信. 每个数据包都发到主机的特定端口, 所以不同的程序就能取到自己所需要的数据. </p>\n<p>传输层的主要功能是负责将上层数据分段并提供端到端的, 可靠活着不可靠的传输. 此外, 传输层还要处理端到端的差错控制和流量控制等问题. 在传输层协议数据单元为数据段(segment). 传输层协议的代表包括: TCP, UDP, SPX等.</p>\n<h3 id=\"会话层\"><a href=\"#会话层\" class=\"headerlink\" title=\"会话层\"></a>会话层</h3><p>会话层主要是管理主机之间的会话进程, 负责建立, 管理, 终止进程之间的会话. 主要功能是建立通信链接, 保持会话过程通信链接的畅通, 利用在数据中插入校验点来同步两个时间点之间的对话. 决定通信是否被中断以及通信中断是决定从何处重新发送.</p>\n<h3 id=\"表示层\"><a href=\"#表示层\" class=\"headerlink\" title=\"表示层\"></a>表示层</h3><p>表示层是应用程序和网络之间的翻译官, 负责对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解. 表示层的数据转换包括数据的解密和加密, 压缩格式转换等.</p>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><p>应用层负责为操作系统或网络应用程序提供访问网络服务的接口, 规定应用程序的数据格式. 应用层提供的服务包括文件传输, 文件管理, 以及电子邮件的信息处理. 在应用层的互联设备主要包括: 网关(Gateway)等.</p>\n<p>常见的应用层协议有: 文本传输协议(FTP), 端口号是21. 超文本传输协议(HTTP), 端口是80. 简单网络管理协议(SNMP). 域名服务协议(DNS). 网络文件系统(NFS). 远程终端协议(Telent).</p>\n<h2 id=\"完整的网络请求过程解析\"><a href=\"#完整的网络请求过程解析\" class=\"headerlink\" title=\"完整的网络请求过程解析\"></a>完整的网络请求过程解析</h2><p><a href=\"http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html\" target=\"_blank\" rel=\"noopener\">这里</a>讲的挺详细, 大概做下总结.</p>\n<p>首先电脑要上网我们必须需要四个参数, 分别是: </p>\n<ul>\n<li>本机的IP地址(动态的或者静态的)</li>\n<li>子网掩码</li>\n<li>网关的IP地址</li>\n<li>DNS的IP地址</li>\n</ul>\n<p>我们在浏览器里面输入了一个网址www.google.com, 这意味着浏览器要向Google发送一个网页请求的数据包. </p>\n<ol>\n<li>我们知道了网址但是不知道IP地址, 那么我们就需要DNS协议帮助我们将网址转换为IP地址. 于是我们想DNS服务器(DNS的IP地址, 端口是53)发送一个DNS数据包, DNS服务器告诉我们Google的IP地址, 于是我们知道了Google的IP地址.</li>\n<li>接下来, 我们要判断Google的IP地址是不是和本机的IP地址在同一个子网络里面, 这里我们要用到子网掩码. 我们通过子网掩码分别对本机IP地址和Google的IP地址做&amp;运算, 如果结果不同就表示不在同一个自网络. 很显然我们和Google的IP地址不在同一个自网络. 因此, 我们要向Google发送数据包, 必须通过网关转发. 也就是说, 接收方的MAC地址将是网关的MAC地址.</li>\n<li>浏览网页用的是HTTP协议, HTTP协议包含一些请求方式, HOST, User-Agent, Accept-Encoding, Accept-Language, Accept-Charset, Cookie等信息.</li>\n<li>TCP数据包需要设置端口, Google默认是80端口, 本机随机生成一个端口号. 然后把HTTP的数据包嵌入到TCP的数据包中.</li>\n<li>TCP数据包再嵌入IP数据包, IP数据包需要设置双方的IP地址, 这个我们在前面已经解析出来了.</li>\n<li>最后, IP数据包嵌入以太网数据包. 以太网数据包需要设置双方的MAC地址, 发送方为本机的网卡MAC地址, 接收方为网关的MAC地址(通过ARP协议得到).</li>\n<li>以太网数据包的数据部分, 最大长度为1500字节. 因此IP数据包必须分割成若干个包. 每个包都有自己的IP标头(20字节).</li>\n<li>经过多个网关的转发, Google的服务器(解析出来的IP地址), 收到了这若干个以太网数据包. 根据IP标头的序号, Google将四个包拼起来, 取出完整的TCP数据包, 然后读出里面的”HTTP请求”, 接着做出”HTTP响应”, 再用TCP协议发回来. 本机收到HTTP响应以后, 就可以将网页显示出来, 完成一次网络通信.</li>\n</ol>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-多线程","url":"http://hchong.net/2018/03/24/iOS开发总结系列-多线程/","content":"<p>这一篇主要总结开发中的多线程问题, 之前已经写过一篇多线程总结, 可以看<a href=\"http://hchong.net/2017/11/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/\">这里</a>.</p>\n<h2 id=\"GCD里面有哪几种Queue\"><a href=\"#GCD里面有哪几种Queue\" class=\"headerlink\" title=\"GCD里面有哪几种Queue\"></a>GCD里面有哪几种Queue</h2><ol>\n<li>主队列 dispatch_main_queue(); 串行, 主要用来更新UI </li>\n<li>全局队列 dispatch_global_queue(); 并行, 四个优先级：background, low, default, high </li>\n<li>自定义队列 dispatch_queue_t queue; 可以自定义是并行DISPATCH_QUEUE_CONCURRENT 或者 串行DISPATCH_QUEUE_SERIAL.</li>\n</ol>\n<h2 id=\"若干个url异步加载多张图片，然后在都下载完成后合成一张整图\"><a href=\"#若干个url异步加载多张图片，然后在都下载完成后合成一张整图\" class=\"headerlink\" title=\"若干个url异步加载多张图片，然后在都下载完成后合成一张整图\"></a>若干个url异步加载多张图片，然后在都下载完成后合成一张整图</h2><p>使用dispatch_group, 有两种使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); </div><div class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        // 合并图片</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)groupTest2 &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_enter(group);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        sleep(2); //这里线程睡眠1秒钟，模拟异步请求</div><div class=\"line\">        NSLog(@&quot;%@ one finish&quot;, [NSThread currentThread]);</div><div class=\"line\">        dispatch_group_leave(group);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_enter(group);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        sleep(2); //这里线程睡眠1秒钟，模拟异步请求</div><div class=\"line\">        NSLog(@&quot;%@ two finish&quot;, [NSThread currentThread]);</div><div class=\"line\">        dispatch_group_leave(group);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;group finished&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"dispatch-barrier-async的作用\"><a href=\"#dispatch-barrier-async的作用\" class=\"headerlink\" title=\"dispatch_barrier_async的作用\"></a>dispatch_barrier_async的作用</h2><p>在并行队列中, 为了保持某些任务的顺序, 需要等待一些任务完成后才能继续进行, 使用 barrier 来等待之前任务完成, 避免数据竞争等问题. 假设一个并行队列中添加了五个异步任务, 虽然遵循FIFO的原则, 这五个任务的执行必定是无序的. 当我们在第三个任务之后加入dispatch_barrier_async任务, 那么这五个任务就被分割成两部分, 前三次无序执行, 然后执行dispatch_barrier_async任务, 然后再无序执行后两次任务. 注意此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)barrierTest &#123;</div><div class=\"line\">    </div><div class=\"line\">    //此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行</div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;barrierTest&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;2&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;3&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">        sleep(3);</div><div class=\"line\">        NSLog(@&quot;插入执行&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;4&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;5&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"为什么要废弃dispatch-get-current-queue\"><a href=\"#为什么要废弃dispatch-get-current-queue\" class=\"headerlink\" title=\"为什么要废弃dispatch_get_current_queue\"></a>为什么要废弃dispatch_get_current_queue</h2><p>dispatch_get_current_queue可能造成死锁, 详细的原因看<a href=\"为什么dispatch_get_current_queue被废弃\">这里</a></p>\n<h2 id=\"如何取消一个正在运行的线程\"><a href=\"#如何取消一个正在运行的线程\" class=\"headerlink\" title=\"如何取消一个正在运行的线程\"></a>如何取消一个正在运行的线程</h2><h3 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h3><ol>\n<li><p>使用dispatch_block_cancel(iOS8之后)来取消, 但是必须使用 dispatch_block_create 创建 dispatch_block_t.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)gcdBlockCancel&#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.gcdtest.www&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_block_t block1 = dispatch_block_create(0, ^&#123;</div><div class=\"line\">        sleep(5);</div><div class=\"line\">        NSLog(@&quot;block1 %@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_block_t block2 = dispatch_block_create(0, ^&#123;</div><div class=\"line\">        NSLog(@&quot;block2 %@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_block_t block3 = dispatch_block_create(0, ^&#123;</div><div class=\"line\">        NSLog(@&quot;block3 %@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_async(queue, block1);</div><div class=\"line\">    dispatch_async(queue, block2);</div><div class=\"line\">    dispatch_block_cancel(block3);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意: dispatch_block_cancel只能取消尚未执行的任务, 对正在执行的任务不起作用.</p>\n</li>\n<li>模仿NSOperation, 定义外部变量, 标记block是否需要取消</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, assign) BOOL isCancel;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    self.view.backgroundColor = [UIColor whiteColor];</div><div class=\"line\">    [self gcdCancel];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        self.isCancel = YES;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)gcdCancel &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        for (int i = 0; i &lt; 10000; i++) &#123;</div><div class=\"line\">            NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">            if (self.isCancel) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不等循环结束, self.isCancel已经被标记为YES, 线程就已经return, 结束.</p>\n<h3 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h3><p>NSOperation提供了cancel方法, 但是这也只是把状态标记为cancel, 已经执行的任务是还在继续跑的, 所以我们要要在Operation的声明周期函数中, 频繁的检查 .cancelled 状态, 只要 .cancelled == true我们就把operation的 finished 状态, 设置为true, 并且结束没有完成的任务.</p>\n<p>我们要在<code>- start</code>, <code>- main</code>等任何声明周期函数中检查, 也可以通过KVO观察cancel的变化来做相应的操作. </p>\n<blockquote>\n<p>In life cycle of operation, you should frequently check .cancelled whenever .cancelled == true, you should stop operation and set .finished == true<br>In macOS 10.6 and later, if you call the cancel method on an operation that is in an operation queue and has unfinished dependent operations, those dependent operations are subsequently ignored. Because the operation is already cancelled, this behavior allows the queue to call the operation’s start method to remove the operation from the queue without calling its main method. If you call the cancel method on an operation that is not in a queue, the operation is immediately marked as being cancelled. In each case, marking the operation as ready or finished results in the generation of the appropriate KVO notifications.</p>\n</blockquote>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中, 因争夺资源而造成的一种互相等待的现象, 若无外力作用, 它们都将无法推进下去.</p>\n<p>死锁产生的主要原因:</p>\n<ul>\n<li>系统资源不足</li>\n<li>进程运行推进的顺序不合适</li>\n<li>资源分配不当</li>\n</ul>\n<p>产生死锁的四个必要条件:</p>\n<ul>\n<li>互斥条件: 一个资源每次只能被一个进程使用. 这个无法预防, 恰恰是设备的固有属性, 我们还应该保护.</li>\n<li>占有且等待: 一个进程因请求资源而阻塞时, 对已获得的资源保持不放. 这个我们可以通过要求进程一次性的请求所有需要的资源, 并且阻塞这个进程直到所有请求都同时满足来预防. </li>\n<li>不可强行占有: 进程已获得的资源, 在未使用完成之前, 不能强行剥夺. 如果占有某些资源的一个进程进行进一步资源请求时被拒绝, 则该进程必须释放它最初占有的资源, 或者抢占另外一条进程并要求释放资源这两种方式来预防.</li>\n<li>循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系. 我们可以通过定义资源类型的线性顺序来预防.</li>\n</ul>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发中的锁","url":"http://hchong.net/2018/03/21/iOS开发中的锁/","content":"<p>锁是比较常用的同步工具, 用于保证一段代码段在同一个时间只能允许被有限个线程访问, 下面我们来介绍下iOS开发中常见的锁.</p>\n<h2 id=\"NSLock\"><a href=\"#NSLock\" class=\"headerlink\" title=\"NSLock\"></a>NSLock</h2><blockquote>\n<p>The NSLock class uses POSIX threads to implement its locking behavior. When sending an unlock message to an NSLock object, you must be sure that message is sent from the same thread that sent the initial lock message. Unlocking a lock from a different thread can result in undefined behavior.</p>\n</blockquote>\n<p>NSLock是一个对象锁, 遵循 NSLocking 协议, 加锁和解锁务必在同一线程中完成. 常用方法有以下几个: <code>-lock</code> 方法是加锁, <code>-unlock</code> 是解锁, <code>-tryLock</code> 是尝试加锁, 如果失败的话返回 NO, <code>-lockBeforeDate:</code> 是在指定Date之前尝试加锁, 如果在指定时间之前都不能加锁, 则返回NO. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//主线程中</div><div class=\"line\">NSLock *lock = [[NSLock alloc] init];</div><div class=\"line\">    </div><div class=\"line\">//线程1</div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">   NSLog(@&quot;进入线程1&quot;);</div><div class=\"line\">   [lock lock];</div><div class=\"line\">   NSLog(@&quot;线程1&quot;);</div><div class=\"line\">   sleep(5);</div><div class=\"line\">   [lock unlock];</div><div class=\"line\">   NSLog(@&quot;线程1解锁成功&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\">    </div><div class=\"line\">//线程2</div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">   NSLog(@&quot;进入线程2&quot;);</div><div class=\"line\">   sleep(1);</div><div class=\"line\">   [lock lock];</div><div class=\"line\">   NSLog(@&quot;线程2&quot;);</div><div class=\"line\">   [lock unlock];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>执行结果是: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2018-03-25 14:20:16.642007+0800 HCLock[9802:336637] 进入线程1</div><div class=\"line\">2018-03-25 14:20:16.642007+0800 HCLock[9802:336636] 进入线程2</div><div class=\"line\">2018-03-25 14:20:16.642181+0800 HCLock[9802:336637] 线程1</div><div class=\"line\">2018-03-25 14:20:21.647601+0800 HCLock[9802:336637] 线程1解锁成功</div><div class=\"line\">2018-03-25 14:20:21.647624+0800 HCLock[9802:336636] 线程2</div></pre></td></tr></table></figure>\n<p>这里说一下lock的具体过程: 首先两个异步线程, 分别进入两个线程. 当线程1 lock 时, 这时会阻塞线程. 因为线程2中也有lock, 这时会空转(可以理解为跑一个while循环), 不断去申请加锁(在空转1s后, 线程会进入waiting状态, 此时线程就不占用CPU资源了), 等锁可用的时候, 这个线程会立即被唤醒. </p>\n<p>这里值得注意的是tryLock是不会阻塞线程的. lockBeforeDate: 方法会在所指定 Date 之前尝试加锁, 会阻塞线程, 如果在指定时间之前都不能加锁, 则返回 NO, 指定时间之前能加锁, 则返回 YES.</p>\n<p>NSLock实际是在内部封装了pthread_mutex, 属性为 PTHREAD_MUTEX_ERRORCHECK, 它会损失一定性能换来错误提示.</p>\n<h2 id=\"NSConditionLock\"><a href=\"#NSConditionLock\" class=\"headerlink\" title=\"NSConditionLock\"></a>NSConditionLock</h2><p>NSConditionLock是一个条件锁, 和 NSLock 类似, 都遵循 NSLocking 协议, 方法都类似, 只是多了一个 condition 属性, 以及每个操作都多了一个关于 condition 属性的方法, 例如 tryLock, tryLockWhenCondition:, NSConditionLock 可以称为条件锁, 只有 condition 参数与初始化时候的 condition 相等, lock 才能正确进行加锁操作. 而 unlockWithCondition: 并不是当 Condition 符合条件时才解锁, 而是解锁之后, 修改 Condition 的值. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;</div><div class=\"line\">@private</div><div class=\"line\">    void *_priv;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;</div><div class=\"line\"></div><div class=\"line\">@property (readonly) NSInteger condition;</div><div class=\"line\">- (void)lockWhenCondition:(NSInteger)condition;</div><div class=\"line\">- (BOOL)tryLock;</div><div class=\"line\">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</div><div class=\"line\">- (void)unlockWithCondition:(NSInteger)condition;</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class=\"line\">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</div><div class=\"line\"></div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>关于上面几个方法有几点要说明: </p>\n<ul>\n<li>初始化时候的 condition 参数为 0.</li>\n<li>lockWhenCondition加锁失败会阻塞线程, tryLockWhenCondition则不会.</li>\n<li>NSConditionLock 可以通过Condition来实现任务之间的依赖</li>\n</ul>\n<p>具体使用的案例可以看<a href=\"https://www.jianshu.com/p/ddbe44064ca4\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"NSRecursiveLock\"><a href=\"#NSRecursiveLock\" class=\"headerlink\" title=\"NSRecursiveLock\"></a>NSRecursiveLock</h2><p>NSRecursiveLock是一个递归锁, 他和 NSLock 的区别在于, NSRecursiveLock 可以在一个线程中重复加锁(单线程内任务是按顺序执行的, 不会出现资源竞争问题), NSRecursiveLock 会记录上锁和解锁的次数, 当二者平衡的时候, 才会释放锁, 其它线程才可以上锁成功.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface NSRecursiveLock : NSObject &lt;NSLocking&gt; &#123;</div><div class=\"line\">@private</div><div class=\"line\">    void *_priv;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)tryLock;</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class=\"line\"></div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>递归锁也是通过 pthread_mutex_lock 函数来实现, 在函数内部会判断锁的类型, 如果显示是递归锁, 就允许递归调用, 仅仅将一个计数器加一. 锁的释放过程也是同理.</p>\n<h2 id=\"NSCondition\"><a href=\"#NSCondition\" class=\"headerlink\" title=\"NSCondition\"></a>NSCondition</h2><p>NSCondition是一个条件锁, 是封装了一个互斥锁和条件变量, 锁上之后其它线程也能上锁, 而之后可以根据条件决定是否继续运行线程, 即线程是否要进入 waiting 状态. NSCondition 并不会像上文的那些锁一样, 先轮询, 而是直接进入 waiting 状态, 当其它线程中的该锁执行 signal 或者 broadcast 方法时, 线程被唤醒, 继续运行之后的方法.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;</div><div class=\"line\">@private</div><div class=\"line\">    void *_priv;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)wait;//让当前线程处于等待状态</div><div class=\"line\">- (BOOL)waitUntilDate:(NSDate *)limit;</div><div class=\"line\">- (void)signal;</div><div class=\"line\">- (void)broadcast;//CPU发信号告诉线程不用在等待, 可以继续执行</div><div class=\"line\"></div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>一般用于多线程同时访问, 修改同一个数据源, 保证在同一时间内数据源只被访问, 修改一次, 其他线程的命令需要在lock 外等待, 只到unlock, 才可访问.</p>\n<p>NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的. 条件变量有点像信号量, 提供了线程阻塞与信号机制, 因此可以用来阻塞某个线程, 并等待某个数据就绪, 随后唤醒线程.</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h2><p>这其实是一个 OC 层面的锁, 是一个互斥锁. 主要是通过牺牲性能换来语法上的简洁与可读. @synchronized 后面需要紧跟一个 OC 对象, 它实际上是把这个对象当做锁来使用. 这是通过一个哈希表来实现的, OC 在底层使用了一个互斥锁的数组(可以理解为锁池), 通过对对象去哈希值来得到对应的互斥锁.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//主线程中</div><div class=\"line\">NSObject *obj = [[NSObject alloc] init];</div><div class=\"line\">//线程1</div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">   @synchronized(obj)&#123;</div><div class=\"line\">       NSLog(@&quot;线程1&quot;);</div><div class=\"line\">       sleep(10);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">//线程2</div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">   sleep(1);</div><div class=\"line\">   NSLog(@&quot;进入线程2&quot;);</div><div class=\"line\">   @synchronized(obj)&#123;</div><div class=\"line\">       NSLog(@&quot;线程2&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>执行结果如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2018-03-25 15:41:26.477502+0800 HCLock[10997:451231] 线程1</div><div class=\"line\">2018-03-25 15:41:27.477745+0800 HCLock[10997:451230] 进入线程2</div><div class=\"line\">2018-03-25 15:41:36.478718+0800 HCLock[10997:451230] 线程2</div></pre></td></tr></table></figure>\n<p>@synchronized指令使用的obj为该锁的唯一标识, 只有当标识相同时, 才为满足互斥. @synchronized也是会轮询, 需要加锁的对象是否可以使用.<br>@synchronized块会隐式的添加一个异常处理例程来保护代码, 该处理例程会在异常抛出的时候自动的释放互斥锁.<br>@sychronized(object){} 内部 object 被释放或被设为 nil 没有问题, 但如果 object 一开始就是 nil, 则失去了锁的功能. 不过虽然 nil 不行, 但 @synchronized([NSNull null]) 是完全可以的.<br>调用 @sychronized 的每个对象, Objective-C runtime 都会为其分配一个递归锁并存储在哈希表中. </p>\n<h2 id=\"dispatch-semaphore\"><a href=\"#dispatch-semaphore\" class=\"headerlink\" title=\"dispatch_semaphore\"></a>dispatch_semaphore</h2><p>dispatch_semaphore 是 GCD 用来同步的一种方式, 与他相关的只有三个函数, 一个是创建信号量, 一个是等待信号, 一个是发送信号.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">dispatch_semaphore_create(long value);</div><div class=\"line\"></div><div class=\"line\">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</div><div class=\"line\"></div><div class=\"line\">dispatch_semaphore_signal(dispatch_semaphore_t dsema);</div></pre></td></tr></table></figure>\n<p>dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式，但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）。而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t 类型的信号量。</p>\n<p>dispatch_semaphore_create(1) 方法可以创建一个 dispatch_semaphore_t 类型的信号量，设定信号量的初始值为 1。注意，这里的传入的参数必须大于或等于 0，否则 dispatch_semaphore_create 会返回 NULL。</p>\n<p>dispatch_semaphore_wait(signal, overTime); 方法会判断 signal 的信号值是否大于 0。大于 0 不会阻塞线程，消耗掉一个信号，执行后续任务。如果信号值为 0，该线程会和 NSCondition 一样直接进入 waiting 状态，等待其他线程发送信号唤醒线程去执行后续任务，或者当 overTime  时限到了，也会执行后续任务。</p>\n<p>dispatch_semaphore_signal(signal); 发送信号，如果没有等待的线程接受信号，则使 signal 信号值加一（做到对信号的保存）。</p>\n<p>从上面的实例代码可以看到，一个 dispatch_semaphore_wait(signal, overTime); 方法会去对应一个 dispatch_semaphore_signal(signal); 看起来像 NSLock 的 lock 和 unlock，其实可以这样理解，区别只在于有信号量这个参数，lock unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatch_semaphore 的信号量初始值为 x ，则可以有 x 个线程同时访问被保护的临界区.</p>\n<h2 id=\"OSSpinLock\"><a href=\"#OSSpinLock\" class=\"headerlink\" title=\"OSSpinLock\"></a>OSSpinLock</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#import &lt;libkern/OSAtomic.h&gt;</div><div class=\"line\"></div><div class=\"line\">__block OSSpinLock theLock = OS_SPINLOCK_INIT;</div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">   OSSpinLockLock(&amp;theLock);</div><div class=\"line\">   NSLog(@&quot;线程1&quot;);</div><div class=\"line\">   sleep(10);</div><div class=\"line\">   OSSpinLockUnlock(&amp;theLock);</div><div class=\"line\">   NSLog(@&quot;线程1解锁成功&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\">    </div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">   sleep(1);</div><div class=\"line\">   OSSpinLockLock(&amp;theLock);</div><div class=\"line\">   NSLog(@&quot;线程2&quot;);</div><div class=\"line\">   OSSpinLockUnlock(&amp;theLock);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>OSSpinLock 是一种自旋锁, 只有加锁, 解锁, 尝试加锁三个方法. 和 NSLock 不同的是 NSLock 请求加锁失败的话, 会先轮询, 但一秒过后便会使线程进入 waiting 状态, 等待唤醒. 而 OSSpinLock 会一直轮询, 等待时会消耗大量 CPU 资源, 不适用于较长时间的任务.</p>\n<p>如果一个低优先级的线程获得锁并访问共享资源, 这时一个高优先级的线程也尝试获得这个锁, 它会处于 spin lock 的忙等状态从而占用大量 CPU. 此时低优先级线程无法与高优先级线程争夺 CPU 时间, 从而导致任务迟迟完不成、无法释放 lock. 因为上面的特性, 导致这个锁已经被废弃, </p>\n<p>具体看<a href=\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h2 id=\"pthread-mutex\"><a href=\"#pthread-mutex\" class=\"headerlink\" title=\"pthread_mutex\"></a>pthread_mutex</h2><p>pthread_mutex 表示互斥锁. 互斥锁的实现原理与信号量非常相似, 不是使用忙等, 而是阻塞线程并睡眠, 需要进行上下文切换. 常见的API有:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pthread_mutexattr_t attr;  </div><div class=\"line\">pthread_mutexattr_init(&amp;attr);  </div><div class=\"line\">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性</div><div class=\"line\"></div><div class=\"line\">pthread_mutex_t mutex;  </div><div class=\"line\">pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁</div><div class=\"line\"></div><div class=\"line\">pthread_mutex_lock(&amp;mutex); // 申请锁</div><div class=\"line\">pthread_mutex_unlock(&amp;mutex); // 释放锁</div></pre></td></tr></table></figure>\n<p>一般情况下, 一个线程只能申请一次锁, 也只能在获得锁的情况下才能释放锁, 多次申请锁或释放未获得的锁都会导致崩溃. 假设在已经获得锁的情况下再次申请锁, 线程会因为等待锁的释放而进入睡眠状态, 因此就不可能再释放锁, 从而导致死锁.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)example5 &#123;</div><div class=\"line\">    pthread_mutex_init(&amp;theLock, NULL);//初始化一个锁&amp;theLock</div><div class=\"line\">    </div><div class=\"line\">    pthread_mutexattr_t attr;</div><div class=\"line\">    pthread_mutexattr_init(&amp;attr);</div><div class=\"line\">    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</div><div class=\"line\">    pthread_mutex_init(&amp;theLock, &amp;attr);</div><div class=\"line\">    pthread_mutexattr_destroy(&amp;attr);</div><div class=\"line\">    </div><div class=\"line\">    pthread_t thread;</div><div class=\"line\">    pthread_create(&amp;thread, NULL, threadMethord, 5);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void *threadMethord(int value) &#123;</div><div class=\"line\">    pthread_mutex_lock(&amp;theLock);</div><div class=\"line\">    </div><div class=\"line\">    if (value &gt; 0) &#123;</div><div class=\"line\">        printf(&quot;Value:%i\\n&quot;, value);</div><div class=\"line\">        sleep(1);</div><div class=\"line\">        threadMethord(value - 1);</div><div class=\"line\">    &#125;</div><div class=\"line\">    pthread_mutex_unlock(&amp;theLock);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>int pthread_mutex_init(pthread_mutex_t * __restrict, const pthread_mutexattr_t * __restrict);</code>表示初始化一个锁, pthread_mutexattr_t表示互斥锁的类型, 传NULL表示默认类型, 一共有四种类型.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">PTHREAD_MUTEX_NORMAL 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。</div><div class=\"line\"></div><div class=\"line\">PTHREAD_MUTEX_ERRORCHECK 检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。</div><div class=\"line\"></div><div class=\"line\">PTHREAD_MUTEX_RECURSIVE 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。</div><div class=\"line\"></div><div class=\"line\">PTHREAD_MUTEX_DEFAULT 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列。</div></pre></td></tr></table></figure>\n<h2 id=\"互斥锁与信号量的区别\"><a href=\"#互斥锁与信号量的区别\" class=\"headerlink\" title=\"互斥锁与信号量的区别\"></a>互斥锁与信号量的区别</h2><p>信号量用在多线程多任务同步的, 一个线程完成了某一个动作就通过信号量告诉别的线程, 别的线程再进行某些动作. 信号量的作用域是进程间或线程间.<br>而互斥锁是用在多线程多任务互斥的, 一个线程占用了某一个资源, 那么别的线程就无法访问, 直到这个线程unlock, 其他的线程才开始可以利用这个资源. 比如对全局变量的访问, 有时要加锁, 操作完了再解锁. 有的时候锁和信号量会同时使用. 互斥锁的作用域是线程间.<br>信号量不一定是锁定某一个资源, 而是流程上的概念, 比如: 有A, B两个线程, B线程要等A线程完成某一任务以后再进行自己下面的步骤, 这个任务并不一定是锁定某一资源, 还可以是进行一些计算或者数据处理之类. 而线程互斥量则是”锁住某一资源”的概念, 在锁定期间内, 其他线程无法对被保护的数据进 行操作. 在有些情况下两者可以互换.<br>具体看<a href=\"https://blog.csdn.net/jenny8080/article/details/52094140\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://mrpeak.cn/blog/synchronized/\" target=\"_blank\" rel=\"noopener\">正确使用多线程同步锁@synchronized()</a></p>\n<p>2.<a href=\"https://www.jianshu.com/p/1e59f0970bf5\" target=\"_blank\" rel=\"noopener\">iOS 中几种常用的锁总结</a></p>\n<p>3.<a href=\"https://blog.csdn.net/jenny8080/article/details/52094140\" target=\"_blank\" rel=\"noopener\">线程同步(互斥锁与信号量的作用与区别)</a></p>\n<p>4.<a href=\"http://www.cocoachina.com/ios/20171218/21570.html\" target=\"_blank\" rel=\"noopener\">iOS的线程安全与锁</a></p>\n<p>5.<a href=\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/\" target=\"_blank\" rel=\"noopener\">不再安全的 OSSpinLock</a></p>\n<p>6.<a href=\"http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/\" target=\"_blank\" rel=\"noopener\">关于 @synchronized，这儿比你想知道的还要多</a></p>\n<p>7.<a href=\"https://www.jianshu.com/p/ddbe44064ca4\" target=\"_blank\" rel=\"noopener\">iOS 常见知识点（三）：Lock</a></p>\n<p>8.<a href=\"https://bestswifter.com/ios-lock/\" target=\"_blank\" rel=\"noopener\">深入理解 iOS 开发中的锁</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Autoreleasepool原理分析","url":"http://hchong.net/2018/03/12/Autoreleasepool原理分析/","content":"<p>Autoreleasepool是用来管理内存的好工具, 官方推荐了几个我们要使用的地方:</p>\n<ul>\n<li>If you are writing a program that is not based on a UI framework, such as a command-line tool.</li>\n<li>If you write a loop that creates many temporary objects. You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</li>\n<li>If you spawn a secondary thread. You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. </li>\n</ul>\n<p>下面我们来分析下他其中的实现. 本文是对大神博客的理解和拾遗. </p>\n<h2 id=\"AutoreleasePoolPage\"><a href=\"#AutoreleasePoolPage\" class=\"headerlink\" title=\"AutoreleasePoolPage\"></a>AutoreleasePoolPage</h2><p>ARC下我们使用<code>@autoreleasepool{}</code>来使用一个AutoreleasePool, 随后编译器将其改写成下面的样子: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">void *context = objc_autoreleasePoolPush();</div><div class=\"line\">// &#123;&#125;中的代码</div><div class=\"line\">objc_autoreleasePoolPop(context);</div></pre></td></tr></table></figure>\n<p>而这两个函数都是对AutoreleasePoolPage的简单封装, 所以核心在AutoreleasePoolPage. AutoreleasePoolPage是一个C++类. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">magic_t const magic;</div><div class=\"line\">id *next;</div><div class=\"line\">pthread_t const thread;</div><div class=\"line\">AutoreleasePoolPage * const parent;</div><div class=\"line\">AutoreleasePoolPage *child;</div><div class=\"line\">uint32_t const depth;</div><div class=\"line\">uint32_t hiwat;</div></pre></td></tr></table></figure>\n<p>他并没有单独的节后是由若干个AutoreleasePoolPage以双向链表的形式组合而成. AutoreleasePool是按线程一一对应的. AutoreleasePoolPage每个对象会开辟4096字节内存(也就是虚拟内存一页的大小), 除了上面的实例变量所占空间, 剩下的空间全部用来储存autorelease对象的地址. <code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置. 一个AutoreleasePoolPage的空间被占满时, 会新建一个AutoreleasePoolPage对象, 连接链表, 后来的autorelease对象在新的page加入.</p>\n<p>下面是AutoreleasePoolPage中存储数据的示例,<br><img src=\"http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg\" alt=\"AutoreleasePoolPage存储示例\"><br>如果这一页满了的话(next指针马上指向栈顶), 这是就要建立下一页page对象, 与这一页链表链接完成后, 新page的next指针被初始化在栈底, 然后继续向栈中添加对象.<br>所以, 向一个对象发送- autorelease消息, 就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置.</p>\n<h2 id=\"释放时刻\"><a href=\"#释放时刻\" class=\"headerlink\" title=\"释放时刻\"></a>释放时刻</h2><p>每次调用<code>objc_autoreleasePoolPush</code>时, runtime就向AutoreleasePoolPage中add一个哨兵对象, 值为nil. objc_autoreleasePoolPush的返回值正是这个哨兵对象的地址, 被objc_autoreleasePoolPop(哨兵对象)作为入参.</p>\n<p>根据传入的哨兵对象地址找到哨兵对象所处的page, 在当前page中, 将晚于哨兵对象插入的所有autorelease对象都发送一次release, 从最新加入的对象一直向前清理, 可以向前跨越若干个page, 直到哨兵所在的page. 然后将next指针指向正确的位置.</p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">黑幕背后的Autorelease</a></p>\n<p>2.<a href=\"https://draveness.me/autoreleasepool\" target=\"_blank\" rel=\"noopener\">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></p>\n<p>3.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-RunLoop","url":"http://hchong.net/2018/03/11/iOS开发总结系列-RunLoop/","content":"<p>这篇主要是RunLoop相关的知识, 具体关于RunLoop可以看<a href=\"http://hchong.net/2017/12/11/RunLoop%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">RunLoop用法与分析</a></p>\n<h2 id=\"RunLoop和线程是什么关系\"><a href=\"#RunLoop和线程是什么关系\" class=\"headerlink\" title=\"RunLoop和线程是什么关系\"></a>RunLoop和线程是什么关系</h2><p>普通线程执行的任务是一条直线, 任务执行完就释放掉. RunLoop可以理解为特殊的线程, 这个现成不断的循环. 每个线程, 包括程序的主线程（main thread）都有与之相应的run loop对象.</p>\n<p>他们之间的关系(CFDictionarySetValue(loopsDic, thread, loop);), 线程和 RunLoop 之间是一一对应的, 他们之间的关系保存在一个全局的字典中(key 是 pthread_t, value 是 CFRunLoopRef), 线程刚创建时是没有RunLoop的, 如果不主动获取就一直不会有, RunLoop的创建是发生在第一次获取时, RunLoop的销毁发生自线程结束时. 只能在一个线程的内部获取其RunLoop.</p>\n<h2 id=\"runloop的mode作用是什么\"><a href=\"#runloop的mode作用是什么\" class=\"headerlink\" title=\"runloop的mode作用是什么\"></a>runloop的mode作用是什么</h2><p>主要是用来指定事件在运行循环中的优先级, 系统默认注册了5个Mode: </p>\n<ul>\n<li>NSDefaultRunLoopMode:(kCFRunLoopDefaultMode, 公开) App的默认Mode, 通常主线程是在这个Mode下运行, App 平时就是处在这个状态.</li>\n<li>UITrackingRunLoopMode: 界面跟踪 Mode, 用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响.</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode, 启动完成后就不再使用.</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode, 通常用不到.</li>\n<li>NSRunLoopCommonModes:(kCFRunLoopCommonModes, 公开) 这是一个占位用的Mode, 不是一种真正的Mode</li>\n</ul>\n<p>一个runloop可以包含多个model, 每个model都是独立的, 而且runloop只能选择一个model运行, 也就是currentModel. 如果需要切换 Mode, 只能退出 Loop, 再重新指定一个 Mode 进入. 这样做主要是为了分隔开不同组的 Source/Timer/Observer, 让其互不影响. </p>\n<p>这里有个概念叫 “CommonModes”: 一个 Mode 可以将自己标记为”Common”属性(通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中). 每当 RunLoop 的内容发生变化时, RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common”标记的所有Mode里.</p>\n<h2 id=\"以-scheduledTimerWithTimeInterval的方式触发的timer-在滑动页面上的列表时-timer会暂定回调，为什么？如何解决\"><a href=\"#以-scheduledTimerWithTimeInterval的方式触发的timer-在滑动页面上的列表时-timer会暂定回调，为什么？如何解决\" class=\"headerlink\" title=\"以+ scheduledTimerWithTimeInterval的方式触发的timer, 在滑动页面上的列表时, timer会暂定回调，为什么？如何解决\"></a>以+ scheduledTimerWithTimeInterval的方式触发的timer, 在滑动页面上的列表时, timer会暂定回调，为什么？如何解决</h2><p>RunLoop只能运行在一种mode下, 如果要换mode, 当前的loop也需要停下重启成新的. 利用这个机制, ScrollView滚动过程中NSDefaultRunLoopMode(kCFRunLoopDefaultMode)的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动: 只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动. 如果我们把一个NSTimer对象以NSDefaultRunLoopMode(kCFRunLoopDefaultMode)添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换, 而导致NSTimer将不再被调度.<br>正常情况下, 我们可能这样使用NSTimer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[NSTimer scheduledTimerWithTimeInterval:1.0</div><div class=\"line\">                                 target:self</div><div class=\"line\">                               selector:@selector(timerTick)</div><div class=\"line\">                               userInfo:nil</div><div class=\"line\">                                repeats:YES];</div></pre></td></tr></table></figure>\n<p>这个问题有两个解决方案:</p>\n<ol>\n<li><p>我们使用创建一个NSTimer对象, 我们把它添加到当前的RunLoop中去, 指定他的Mode为NSRunLoopCommonModes, 或者分别加入到NSDefaultRunLoopMode和UITrackingRunLoopMode中.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSTimer *timer = [NSTimer timerWithTimeInterval:1.0</div><div class=\"line\">     target:self</div><div class=\"line\">     selector:@selector(timerTick:)</div><div class=\"line\">     userInfo:nil</div><div class=\"line\">     repeats:YES];</div><div class=\"line\">//分别加入两种Mode中</div><div class=\"line\">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</div><div class=\"line\">[[NSRunLoop mainRunLoop] addTimer:timer forMode: UITrackingRunLoopMode];</div><div class=\"line\">//加入CommonMode中</div><div class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用GCD定时器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) dispatch_source_t timer;</div><div class=\"line\"></div><div class=\"line\">// 获得队列</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</div><div class=\"line\">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</div><div class=\"line\">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">// 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）</div><div class=\"line\">// GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）</div><div class=\"line\">// 比当前时间晚1秒开始执行</div><div class=\"line\">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));</div><div class=\"line\">//每隔一秒执行一次</div><div class=\"line\">uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);</div><div class=\"line\">dispatch_source_set_timer(self.timer, start, interval, 0);</div><div class=\"line\">// 设置回调</div><div class=\"line\">dispatch_source_set_event_handler(self.timer, ^&#123;</div><div class=\"line\">    NSLog(@&quot;------------%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;);</div><div class=\"line\">// 启动定时器</div><div class=\"line\">dispatch_resume(self.timer);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"猜想runloop内部是如何实现的\"><a href=\"#猜想runloop内部是如何实现的\" class=\"headerlink\" title=\"猜想runloop内部是如何实现的\"></a>猜想runloop内部是如何实现的</h2><p><img src=\"https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png\" alt=\"RunLoop内部逻辑\"></p>\n<ol>\n<li>通知观察者, RunLoop已经启动.</li>\n<li>通知观察者, 将要处理定时器.</li>\n<li>通知观察者, 将要处理Source0(即将启动的非基于端口的源).</li>\n<li>启动任何准备好的Source0(非基于端口的源).</li>\n<li>如果有任何Source1(基于端口的源)准备好并且处于等待状态, 立即启动, 并进入步骤9.</li>\n<li>通知所有观察者, 线程即将进入休眠.</li>\n<li>线程处于休眠状态, 直到遇到下列事件中的任意一个:<ul>\n<li>某一事件到达Source0(非基于端口的源)</li>\n<li>NSTimer定时器启动</li>\n<li>RunLoop设置的时间已经超时</li>\n<li>RunLoop被外部手动显示唤醒.</li>\n</ul>\n</li>\n<li>通知观察者, 线程刚被唤醒</li>\n<li>处理唤醒时收到的事件:<ul>\n<li>如果是定时器启动, 处理定时器并重启RunLoop, 进入步骤2</li>\n<li>如果是输入源启动, 传递相应的消息</li>\n<li>如果是RunLoop被显式唤醒(Source1), 重启RunLoop, 进入步骤2</li>\n</ul>\n</li>\n<li>通知观察者RunLoop即将结束.<br>详细内容参考<a href=\"http://hchong.net/2017/12/11/RunLoop%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">RunLoop用法与分析</a>.<h2 id=\"autoreleasepool如何实现-一个autoreleasepool对象何时释放\"><a href=\"#autoreleasepool如何实现-一个autoreleasepool对象何时释放\" class=\"headerlink\" title=\"autoreleasepool如何实现, 一个autoreleasepool对象何时释放\"></a>autoreleasepool如何实现, 一个autoreleasepool对象何时释放</h2>可以看<a href=\"https://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"noopener\">这里</a>, <a href=\"https://draveness.me/autoreleasepool\" target=\"_blank\" rel=\"noopener\">这里</a>, <a href=\"http://hchong.net/2018/03/23/Autoreleasepool%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/\">这里</a></li>\n</ol>\n<p>autoreleasepool实际上被两个函数<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>包括, 这两个函数的实质又是AutoreleasePoolPage.<br>AutoreleasePoolPage是一个双向链表, 存储了对象的内存地址. AutoreleasePoolPage里面有个next指针, 当向一个对象发送- autorelease消息, 就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置.<br>每次调用<code>objc_autoreleasePoolPush()</code>, runtime就向链表中插入一个哨兵对象(nil), <code>objc_autoreleasePoolPush()</code>的返回值正是这个哨兵对象的地址. <code>objc_autoreleasePoolPop()</code>的入参也是这个哨兵对象的地址, 根据传入的哨兵对象地址找到哨兵对象所处的page, 在当前page中(从最新加入的对象一直向前清理, 可以向前跨越若干个page, 直到哨兵所在的page), 将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息, 并向回移动next指针到正确位置.</p>\n<p>在没有手加Autorelease Pool的情况下, Autorelease对象是在当前的runloop迭代结束时释放的, 而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop.</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"iOS开发总结系列-Runtime","url":"http://hchong.net/2018/03/07/iOS开发总结系列-Runtime/","content":"<p>这篇主要是RunTime相关的知识, 具体关于RunTime可以看<a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">RunTime用法与分析</a></p>\n<h2 id=\"什么时候会报unrecognized-selector的异常\"><a href=\"#什么时候会报unrecognized-selector的异常\" class=\"headerlink\" title=\"什么时候会报unrecognized selector的异常\"></a>什么时候会报unrecognized selector的异常</h2><p>涉及到消息的转发阶段知识<a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">Runtime用法与分析</a></p>\n<p>当调用该对象上某个方法, 而该对象上没有实现这个方法的时候, 可以通过“消息转发”进行解决. objc在向一个对象发送消息时, runtime库会根据对象的isa指针找到该对象实际所属的类, 然后在该类中的方法列表以及其父类方法列表中寻找方法运行, 如果在最顶层的父类中依然找不到相应的方法时, 程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX. 但是在这之前, objc的运行时会给出三次拯救程序崩溃的机会.</p>\n<ol>\n<li>Method resolution阶段. objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>, 让你有机会提供一个函数实现. 如果你添加了函数, 那运行时系统就会重新启动一次消息发送的过程, 否则, 运行时就会移到下一步, 消息转发(Message Forwarding).</li>\n<li>Fast forwarding阶段. 如果目标对象实现了<code>-forwardingTargetForSelector:</code>方法, Runtime这时就会调用这个方法, 给你把这个消息转发给其他对象的机会. 只要这个方法返回的不是nil和self, 整个消息发送过程会被重启, 当然发送的对象会变成你返回的那个对象. 否则就会继续Normal fowarging. 这里叫做Fast只是为了区别下一步的转发机制, 因为这一步不会创建任何新的对象, 但下一步会转发会创建一个NSInvocation对象, 所以相对更快一点.</li>\n<li>Normal forwarding阶段. 这一步是Runtime最后给你的挽救机会. 首先会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型. 如果<code>-methodSignatureForSelector:</code>返回nil, Runtime就会发出<code>-doesNotRecognizeSelector:</code>消息, 程序这时候就挂掉了. 如果返回了一个函数签名, Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象. </li>\n</ol>\n<h2 id=\"一个objc对象如何进行内存布局\"><a href=\"#一个objc对象如何进行内存布局\" class=\"headerlink\" title=\"一个objc对象如何进行内存布局\"></a>一个objc对象如何进行内存布局</h2><p>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.<br>每一个对象内部都有一个isa指针, 指向他的类对象, 类对象中存放着本对象的对象方法列表, 成员列表的变量, 属性列表.<br>类的内部也有一个isa指针, 指向原类, 原类内部存放得失类方法列表, 内部也有一个superclass指针, 指向他的父类对象.</p>\n<h2 id=\"objc-msgForward函数是做什么的-直接调用它将会发生什么\"><a href=\"#objc-msgForward函数是做什么的-直接调用它将会发生什么\" class=\"headerlink\" title=\"_objc_msgForward函数是做什么的, 直接调用它将会发生什么\"></a>_objc_msgForward函数是做什么的, 直接调用它将会发生什么</h2><p>_objc_msgForward是 IMP 类型, 用于消息转发: 当向一个对象发送一条消息, 但它并没有实现的时候, _objc_msgForward会尝试做消息转发.</p>\n<p>首先我们从消息的查找看起:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">id objc_msgSend(id self, SEL op, ...) &#123;</div><div class=\"line\">    if (!self) return nil;</div><div class=\"line\">\tIMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);</div><div class=\"line\">\timp(self, op, ...); //调用这个函数，伪代码...</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">//查找IMP</div><div class=\"line\">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</div><div class=\"line\">    if (!cls || !sel) return nil;</div><div class=\"line\">    IMP imp = lookUpImpOrNil(cls, sel);</div><div class=\"line\">    if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发</div><div class=\"line\">    return imp;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">IMP lookUpImpOrNil(Class cls, SEL sel) &#123;</div><div class=\"line\">    if (!cls-&gt;initialize()) &#123;</div><div class=\"line\">        _class_initialize(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    Class curClass = cls;</div><div class=\"line\">    IMP imp = nil;</div><div class=\"line\">    do &#123; //先查缓存,缓存没有时重建,仍旧没有则向父类查询</div><div class=\"line\">        if (!curClass) break;</div><div class=\"line\">        if (!curClass-&gt;cache) fill_cache(cls, curClass);</div><div class=\"line\">        imp = cache_getImp(curClass, sel);</div><div class=\"line\">        if (imp) break;</div><div class=\"line\">    &#125; while (curClass = curClass-&gt;superclass);</div><div class=\"line\"> </div><div class=\"line\">    return imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看出, _objc_msgForward 是一个函数指针(和 IMP 的类型一样), 是用于消息转发的: 当向一个对象发送一条消息, 但没有实现的时候, _objc_msgForward会尝试做消息转发.</p>\n<p>我们向一个对象发送一条错误的消息, 然后在程序中加入断点或者暂停程序运行, 并在 gdb 中输入下面的命令: <code>call (void)instrumentObjcMessageSends(YES)</code>. 之后, 运行时发送的所有消息都会打印到/tmp/msgSend-xxxx文件里了. 终端中输入命令<code>open /private/tmp</code>前往文件夹, 找到最新生成的, 双击打开.</p>\n<p>在里面我们可以看到整个程序运行时调用的方法, 排除NSObject做的事, 剩下的就是<code>_objc_msgForward</code>消息转发做的事(实际也是消息转发的整个完整流程, <a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">Runtime用法与分析</a>). </p>\n<ol>\n<li>调用resolveInstanceMethod:方法 (或 resolveClassMethod:). 允许用户在此时为该 Class 动态添加实现. 如果有实现了, 则调用并返回YES, 那么重新开始objc_msgSend流程. 这一次对象会响应这个选择器, 一般是因为它已经调用过class_addMethod. 如果仍没实现, 继续下面的动作.</li>\n<li>调用forwardingTargetForSelector:方法, 尝试找到一个能响应该消息的对象. 如果获取到, 则直接把消息转发给它, 返回非 nil 对象. 否则返回 nil, 继续下面的动作. 注意, 这里不要返回 self, 否则会形成死循环.</li>\n<li>调用methodSignatureForSelector:方法, 尝试获得一个方法签名. 如果获取不到, 则直接调用doesNotRecognizeSelector抛出异常. 如果能获取, 则返回非nil: 创建一个 NSlnvocation 并传给forwardInvocation:.</li>\n<li>调用forwardInvocation:方法, 将第3步获取到的方法签名包装成 Invocation 传入, 如何处理就在这里面了, 并返回非nil.</li>\n<li>调用doesNotRecognizeSelector:, 默认的实现是抛出异常. 如果第3步没能获得一个方法签名, 执行该步骤.</li>\n</ol>\n<p>上面前4个方法均是模板方法, 开发者可以override, 由 runtime 来调用. 最常见的实现消息转发: 就是重写方法3和4, 忽略掉一个消息或者代理给其他对象.</p>\n<p>一旦调用_objc_msgForward, 将跳过查找 IMP 的过程, 直接触发”消息转发”. 具体可以看上面消息查找的具体过程. 可能会导致抛出unrecoginised selector的异常而导致程序crash. </p>\n<h2 id=\"能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h2><p>不能向编译后的类中增加实例变量, 因为已经注册在runtime中, 类结构体中的objc_ivar_list(实例变量链表)和instance_size(实例变量的内存大小)已经确定, 同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用, 所以不能向存在的类中添加实例变量.</p>\n<p>可以向运行时创建的类中添加实例变量, 直接调用class_addIvar函数, 但是得在调用 objc_allocateClassPair 之后, objc_registerClassPair 之前, 原因同上.</p>\n<h2 id=\"load-vs-initialize\"><a href=\"#load-vs-initialize\" class=\"headerlink\" title=\"+load vs +initialize\"></a>+load vs +initialize</h2><p>+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的, 实现这个方法可以让我们在类加载的时候执行一些类相关的行为. 子类的 +load 方法会在它的所有父类的 +load 方法之后执行, 而分类的 +load 方法会在它的主类的 +load 方法之后执行. 但是不同的类之间的 +load 方法的调用顺序是不确定的.<br>对 +load 方法进行调用使用的是<code>(*load_method)(cls, SEL_load)</code>，而不是使用发送消息 objc_msgSend 的方式. 这样的调用方式就使得 +load 方法拥有了一个非常有趣的特性, 那就是子类、父类和分类中的 +load 方法的实现是被区别对待的. 也就是说如果子类没有实现 +load 方法, 那么当它被加载时 runtime 是不会去调用父类的 +load 方法的. 同理, 当一个类和它的分类都实现了 +load 方法时, 两个方法都会被调用.</p>\n<p>+initialize 方法是在类或它的子类收到第一条消息之前被调用的, 这里所指的消息包括实例方法和类方法的调用. 也就是说 +initialize 方法是以懒加载的方式被调用的, 如果程序一直没有给某个类或它的子类发送消息, 那么这个类的 +initialize 方法是永远不会被调用的. 这么做节省了系统资源, 避免浪费.<br>runtime 使用了发送消息 objc_msgSend 的方式对 +initialize 方法进行调用. 也就是说 +initialize 方法的调用与普通方法的调用是一样的, 走的都是发送消息的流程. 如果子类没有实现 +initialize 方法, 那么继承自父类的实现会被调用; 如果一个类的分类实现了 +initialize 方法, 那么就会对这个类中的实现造成覆盖.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>+load</th>\n<th>+initialize</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本质</td>\n<td>(*load_method)(cls, SEL_load)</td>\n<td>(*load_method)(cls, SEL_load)</td>\n</tr>\n<tr>\n<td>调用时机</td>\n<td>被添加到runtime时</td>\n<td>直到给他的某个分类或它的子类发送消息</td>\n</tr>\n<tr>\n<td>调用顺序</td>\n<td>父类-&gt;子类-&gt;分类</td>\n<td>父类-&gt;子类</td>\n</tr>\n<tr>\n<td>调用次数</td>\n<td>1次</td>\n<td>多次</td>\n</tr>\n<tr>\n<td>是否需要显式调用父类实现</td>\n<td>不会</td>\n<td>不会</td>\n</tr>\n<tr>\n<td>是否沿用父类方法</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>分类中的实现</td>\n<td>类和分类都执行</td>\n<td>分类会覆盖类中的方法, 只执行分类的实现</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Method-swizzling\"><a href=\"#Method-swizzling\" class=\"headerlink\" title=\"Method swizzling\"></a>Method swizzling</h2><p>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP.<br>我们可以利用 class_replaceMethod 来修改类.<br>我们可以利用 method_setImplementation 来直接设置某个方法的IMP.<br>…<br>归根到底都是更换selector的IMP(函数指针, 指向方法的实现).</p>\n<h2 id=\"如何使用runtime-hook类方法和实例方法\"><a href=\"#如何使用runtime-hook类方法和实例方法\" class=\"headerlink\" title=\"如何使用runtime hook类方法和实例方法\"></a>如何使用runtime hook类方法和实例方法</h2><p>使用Method Swizzling 方法. swizzling大多时候是在category中的+load方法中使用, 也可以创建hook的管理类, 放在里面使用.</p>\n<p>使用<code>class_getInstanceMethod</code>来获取实例方法, 使用<code>class_getClassMethod</code>来获取类方法. </p>\n<ul>\n<li>我们可以利用 <code>class_addMethod</code>来检测方法是否存在.</li>\n<li>我们可以利用 <code>method_exchangeImplementations</code> 来交换2个方法中的IMP.</li>\n<li>我们可以利用 <code>class_replaceMethod</code> 来修改类.</li>\n<li>我们可以利用 <code>method_setImplementation</code> 来直接设置某个方法的IMP.</li>\n</ul>\n<p>下面是AFN中的写法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">static inline void af_swizzleSelector(Class class, SEL originalSelector, SEL swizzledSelector) &#123;</div><div class=\"line\">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class=\"line\">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class=\"line\">    if (class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123;</div><div class=\"line\">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>在iOS中代理的本质就是代理对象内存的传递和操作, 我们在委托方设置代理属性后, 实际上只是用一个id类型的指针将代理对象进行了一个弱引用. 委托方让代理方执行协议, 实际上是在委托方中向这个id类型的指针指向的对象(代理方对象)发送消息.</p>\n<p>委托方的代理属性本质上就是代理对象自身, 设置委托代理就是代理属性指针指向代理对象, 相当于代理对象只是在委托方中调用自己的方法. 如果方法没有实现就会报错(代理方没有实现委托方中协议中的方法).</p>\n<p>协议只是一种语法, 是声明委托方中的代理属性可以调用协议中声明的方法. 如果代理方遵守协议那么协议中方法的实现就会加入到代理方类的objc_protocol_list中去. 委托方的self.delegate实际指向代理方的地址, 消息转发到代理方那里, 调用代理方objc_protocol_list中的实现.</p>\n<h2 id=\"为什么category不能添加属性可以添加方法\"><a href=\"#为什么category不能添加属性可以添加方法\" class=\"headerlink\" title=\"为什么category不能添加属性可以添加方法\"></a>为什么category不能添加属性可以添加方法</h2><p>因为category在runtime中是用一个结构体表示的, 结构体在C中是初始化完成后是不能改变的, 但是方法是一个链表, 他是可以往里面添加新的方法的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">struct _category_t &#123;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    struct _class_t *cls;</div><div class=\"line\">    const struct _method_list_t *instance_methoods;</div><div class=\"line\">    const struct _method_list_t *class_methods;</div><div class=\"line\">    const struct _protocol_list_t *protocols;</div><div class=\"line\">    const struct _prop_list_t *properties;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里面虽然可以添加property, 但是这些property并不会自动生成Ivar, 也就是不会有 @synthesize 的作用. dyld加载的期间, 这些categories会被加载并patch到相应的类中, 这个过程是动态的, Ivar不能动态添加, 因为表示ObjC类的结构体运行时并不能改变. </p>\n","categories":["基础知识"],"tags":["基础知识","Runtime"]},{"title":"iOS开发总结系列-属性关键字","url":"http://hchong.net/2018/03/01/iOS开发总结系列-属性关键字/","content":"<p>常见的问题, 在这里做一个汇总. 只讲结论, 内部细节, 慢慢填坑.</p>\n<h2 id=\"什么情况使用-weak-关键字，相比-assign-有什么不同\"><a href=\"#什么情况使用-weak-关键字，相比-assign-有什么不同\" class=\"headerlink\" title=\"什么情况使用 weak 关键字，相比 assign 有什么不同\"></a>什么情况使用 weak 关键字，相比 assign 有什么不同</h2><p>weak常用在有可能出现循环引用的地方, 他表示一种非拥有关系, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 与assign类似, 但是不同的是当属性所指的对象被释放时, 属性值会被置为nil, 而assign只执行基础类型的简单赋值操作. </p>\n<p>weak必须用于OC对象类型, assign可以用于基础类型.</p>\n<h2 id=\"怎么用-copy-关键字\"><a href=\"#怎么用-copy-关键字\" class=\"headerlink\" title=\"怎么用 copy 关键字\"></a>怎么用 copy 关键字</h2><ol>\n<li>NSString, NSArray, NSDictionary 等等经常使用copy关键字, 是因为他们有对应的可变类型: NSMutableString, NSMutableArray, NSMutableDictionary. </li>\n<li>若想令自己所写的对象具有拷贝功能要实现NSCopying. 如果自定义的对象分为可变版本与不可变版本, 那么就要同时实现 NSCopying 与 NSMutableCopying 协议.</li>\n<li>block 也经常使用 copy 关键字. </li>\n</ol>\n<p>对可变对象进行copy, 返回的会是一个不可变对象, 并不是一般意义上的copy行为, 因为copy后的对象类型不同了.<br>对可变对象进行mutableCopy, 返回的是另一个可变对象, 这种才是copy行为, 两个对象内容一样, 类型一样, 地址不同.<br>对不可变对象进行copy, 系统不会再创建对象, 而是直接返回源对象地址.<br>对不可变对象进行mutableCopy则返回一个可变对象, 同样不是一般意义上的copy.</p>\n<p>block使用关键字copy是MRC时代的产物, 因为Block有三种类型, _NSConcreteStackBlock, _NSConcreteGlobalBlock, _NSConcreteMallocBlock. 由于_NSConcreteStackBlock存储在栈上面, 一旦返回之后所属的变量域一旦结束, 就被系统销毁了, 所以他是不安全的, 我们通过copy属性可以把它存储在堆上面, 生命周期我们就可以控制了. 在 MRC 中, 方法内部的 block 是在栈区的, 使用 copy 可以把它放到堆区. 在 ARC 中写不写都行: 对于 block 使用 copy 还是 strong 效果是一样的. 可以参考<a href=\"http://hchong.net/2017/07/04/Block%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/\">这里</a>.</p>\n<h2 id=\"对象的copy与mutableCopy\"><a href=\"#对象的copy与mutableCopy\" class=\"headerlink\" title=\"对象的copy与mutableCopy\"></a>对象的copy与mutableCopy</h2><p>在集合类对象中, 对不可变对象进行 copy, 是指针复制(浅copy), mutableCopy 是内容复制(深copy); 对可变对象进行 copy 和 mutableCopy 都是内容复制(深copy). 但是集合对象的内容复制仅限于对象本身, 对象元素仍然是指针复制. </p>\n<p>可以参考<a href=\"http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/\">这里</a>.</p>\n<h2 id=\"runtime-如何实现-weak-属性\"><a href=\"#runtime-如何实现-weak-属性\" class=\"headerlink\" title=\"runtime 如何实现 weak 属性\"></a>runtime 如何实现 weak 属性</h2><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship). 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 此特质同 assign 类似, 然而在属性所指的对象遭到摧毁时, 属性值也会清空(nil out).</p>\n<p>Runtime维护了一个weak表, 用于存储指向某个对象的所有weak指针. weak表其实是一个hash表, Key是所指对象的地址, Value是weak指针的地址(这个地址的值是所指对象的地址)数组. 当此对象的引用计数为0的时候会 dealloc, 假如 weak 指向的对象内存地址是a, 那么就会以a为键, 在这个 weak 表中搜索, 找到所有以a为键的 weak 对象, 从而设置为 nil. </p>\n<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil, ARC 会自动帮我们处理.</p>\n<p>详细的可以看<a href=\"http://www.cocoachina.com/ios/20170328/18962.html\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"property中有哪些属性关键字？-property-后面可以有哪些修饰符？\"><a href=\"#property中有哪些属性关键字？-property-后面可以有哪些修饰符？\" class=\"headerlink\" title=\"@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？\"></a>@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h2><ol>\n<li>原子性: nonatomic, atomic(默认值).</li>\n<li>读/写权限: readwrite(默认值), readonly.</li>\n<li>内存管理: assign, strong, weak, unsafe_unretained, copy.</li>\n<li>方法名: getter, setter.</li>\n<li>其他: nonnull, null_resettable, nullable.</li>\n</ol>\n<p>基本数据类型默认关键字: atomic, assign, readwrite. 对象类型默认关键字: atomic, strong, readwrite.</p>\n<p>atomic 会加一个@synchronized()锁, 并且引用计数会 +1, 来向调用者保证这个对象会一直存在, 但是这个锁并不能保证线程安全. </p>\n<h2 id=\"protocol-和-category-中如何使用-property\"><a href=\"#protocol-和-category-中如何使用-property\" class=\"headerlink\" title=\"@protocol 和 category 中如何使用 @property\"></a>@protocol 和 category 中如何使用 @property</h2><p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明, 我们使用属性的目的, 是希望遵守我协议的对象能实现该属性.</p>\n<p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明, 如果我们真的需要给 category 增加属性的实现, 需要借助于运行时的两个函数<code>objc_setAssociatedObject</code>和<br><code>objc_getAssociatedObject</code>.</p>\n<h2 id=\"property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h2><p>@property的本质是 ivar(实例变量) + getter + setter.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef struct objc_property *objc_property_t;</div><div class=\"line\"></div><div class=\"line\">struct property_t &#123;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    const char *attributes;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">typedef struct &#123;</div><div class=\"line\">    const char *name;           /**&lt; The name of the attribute */</div><div class=\"line\">    const char *value;          /**&lt; The value of the attribute (usually empty) */</div><div class=\"line\">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>\n<p>attributes的具体内容包含: 类型, 原子性, 内存语义和对应的实例变量.</p>\n<p>我们每次在增加一个属性, 系统都会在 ivar_list 中添加一个成员变量的描述, 在 method_list 中增加 setter 与 getter 方法的描述, 在属性列表中增加一个属性的描述, 然后计算该属性在对象中的偏移量, 然后给出 setter 与 getter 方法对应的实现, 在 setter 方法中从偏移量的位置开始赋值, 在 getter 方法中从偏移量开始取值, 为了能够读取正确字节数, 系统对象偏移量的指针类型进行了类型强转.</p>\n<p>详见<a href=\"http://hchong.net/2017/12/11/Runtime%E7%94%A8%E6%B3%95%E4%B8%8E%E5%88%86%E6%9E%90/\">Runtime用法与分析</a></p>\n<h2 id=\"synthesize和-dynamic分别有什么作用\"><a href=\"#synthesize和-dynamic分别有什么作用\" class=\"headerlink\" title=\"@synthesize和@dynamic分别有什么作用\"></a>@synthesize和@dynamic分别有什么作用</h2><p>@property有两个关键词, @synthesize(默认值)和@dynamic. </p>\n<p>@synthesize表示系统会默认添加一个@syntheszie var = _var的实例变量, 并且自动生成setter和getter方法. @synthesize 合成实例变量有以下几点规则:</p>\n<ol>\n<li>如果指定了成员变量的名称, 会生成一个指定的名称的成员变量.</li>\n<li>如果这个成员已经存在就不再生成了.</li>\n<li>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量.</li>\n</ol>\n<p>@synthesize的使用场景: </p>\n<ol>\n<li>同时重写了setter和getter时</li>\n<li>重写了只读属性的getter时</li>\n<li>在使用了@dynamic时</li>\n<li>在@Protocol和category中定义属性时</li>\n<li>重载父类的属性时, 来手动合成Ivar(实例变量/成员变量).</li>\n</ol>\n<p>@dynamic表示我们不需要系统自动生成, 由用户自己实现, 如果没有手动生成的话, 在使用过程中是会奔溃的.</p>\n<h2 id=\"block-vs-weak\"><a href=\"#block-vs-weak\" class=\"headerlink\" title=\"block vs weak\"></a><strong>block vs </strong>weak</h2><p><strong>weak主要是用来避免循环引用的. </strong>weak修饰的变量, 在block内部被捕获后, 和外部的实际不是用一个变量. 他是对外部<strong>weak修饰的对象进行了一个弱引用. 当我们在block外部把</strong>weak修饰的变量释放后, block内部夜读不到这个变量. 如果外部被__weak修饰的变量被置为nil, 那么内部的对象实际上也是nil, 就会被释放掉. </p>\n<p><strong>block实际上是提升了变量的作用域, 我们在block内外, 用</strong>block修饰的变量实际上不是同一个, 在block内部使用相当于被强引用了一份. <strong>block 本身无法避免循环引用的问题, 但是我们可以通过在 block 内部手动把 blockObj 赋值为 nil 的方式来避免循环引用的问题.<br>这里需要注意, 我们只能在堆上面block对象使用</strong>block修饰的对象, ARC下一旦block赋值就会触发copy, block就会被复制到堆上因此可以直接使用, 但是MRC下我们则需要手动调用copy, 否则会编译报错.<br>MRC下<strong>block修饰的变量在block中使用是不會retain的, ARC下是会retain的. 可以使用</strong>weak(ARC下使用, 但只支持iOS5以后)或是__unsafe_unretained来代替.</p>\n<h2 id=\"nonatomic和atomic的线程安全\"><a href=\"#nonatomic和atomic的线程安全\" class=\"headerlink\" title=\"nonatomic和atomic的线程安全\"></a>nonatomic和atomic的线程安全</h2><p>atomic: 原子操作, 系统会为setter方法加锁(@synchronized), 需要消耗大量系统资源来为属性加锁. atomic所说的线程安全只是保证了getter和setter存取方法的线程安全, 并不能保证整个对象是线程安全的.<br>例如当线程A进行写操作, 这时其他线程的读或者写操作会因为该操作而等待. 当A线程的写操作结束后, B线程进行写操作, 然后当A线程需要读操作时, 却获得了在B线程中的值, 这就破坏了线程安全, 如果有线程C在A线程读操作前release了该属性, 那么还会导致程序崩溃. 所以仅仅使用atomic并不会使得线程安全, 我们还要为线程添加lock来确保线程的安全.</p>\n<p>nonatomic: 不会为setter方法加锁, 线程不安全, 适合内存较小的移动设备.</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"KVO用法与自定义实现","url":"http://hchong.net/2018/01/24/KVO详解/","content":"<h1 id=\"KVO用法与自定义实现\"><a href=\"#KVO用法与自定义实现\" class=\"headerlink\" title=\"KVO用法与自定义实现\"></a>KVO用法与自定义实现</h1><h2 id=\"KVO用法\"><a href=\"#KVO用法\" class=\"headerlink\" title=\"KVO用法\"></a>KVO用法</h2><p>KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知. KVO的用法在这里不做叙述, 十分简单. 首先注册, 添加一个观察者:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)addObserver:(NSObject *)observer</div><div class=\"line\">         forKeyPath:(NSString *)keyPath</div><div class=\"line\">            options:(NSKeyValueObservingOptions)options</div><div class=\"line\">            context:(void *)context</div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><p>observer: 观察者，负责处理监听事件的对象, 注册 KVO 通知的对象。观察者必须实现 key-value observing 方法 observeValueForKeyPath:ofObject:change:context:</p>\n</li>\n<li><p>keyPath: 要监听的属性, 观察者的属性的 keypath，相对于接受者，值不能是 nil。</p>\n</li>\n<li><p>options: 观察的选项(观察新、旧值，也可以都观察), NSKeyValueObservingOptions 的组合，它指定了观察通知中包含了什么，可以查看 “NSKeyValueObservingOptions”。</p>\n</li>\n<li><p>context: 上下文，用于传递数据，可以利用上下文区分不同的监听, 在 observeValueForKeyPath:ofObject:change:context: 传给 observer 参数的随机数据</p>\n</li>\n</ul>\n</blockquote>\n<p>当 keyPath 的值改变的时候这个方法会被调用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class=\"line\">                      ofObject:(id)object</div><div class=\"line\">                        change:(NSDictionary *)change</div><div class=\"line\">                       context:(void *)context</div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><p>keyPath 监听的属性名</p>\n</li>\n<li><p>object  属性所属的对象</p>\n</li>\n<li><p>change  属性的修改情况（属性原来的值<code>oldValue</code>、属性最新的值<code>newValue</code>）</p>\n</li>\n<li><p>context 传递的上下文数据，与监听的时候传递的一致，可以利用上下文区分不同的监听</p>\n</li>\n</ul>\n</blockquote>\n<p>当一个观察者完成了监听一个对象的改变, 经常在 <code>-observeValueForKeyPath:ofObject:change:context:</code>，或者 <code>-dealloc</code> 中调用注销监听的方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)removeObserver:(NSObject *)anObserver</div><div class=\"line\">            forKeyPath:(NSString *)keyPath</div></pre></td></tr></table></figure>\n<hr>\n<p>这里有几个特殊的方法需要着重说明一下, </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)willChangeValueForKey:(NSString *)key;</div><div class=\"line\">- (void)didChangeValueForKey:(NSString *)key;</div><div class=\"line\">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;</div></pre></td></tr></table></figure>\n<p><code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>默认是在setter方法中实现的, 用KVO做键值观察后, 系统会在运行时重写属性的set方法, 并且在赋值前后分别调用.</p>\n<p><code>automaticallyNotifiesObserversForKey:</code>控制是否自动发送通知, 如果返回NO, KVO无法自动运作, 需手动触发.</p>\n<h2 id=\"KVO的原理\"><a href=\"#KVO的原理\" class=\"headerlink\" title=\"KVO的原理\"></a>KVO的原理</h2><p>KVO 的实现也依赖于 Objective-C 强大的 Runtime. Apple 的文档有简单提到过 KVO 的实现: </p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>\n<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>\n<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>\n<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>\n</blockquote>\n<p>概述下KVO的实现就是: </p>\n<p>当你观察一个对象时, 会动态创建一个新的类. 这个类继承自该对象的原本的类, 并重写了被观察属性的 setter 方法. 自然, 重写的 setter 方法会负责在调用原 setter 方法之前和之后, 通知所有观察对象值的更改. 最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类, 对象就神奇的变成了新创建的子类的实例. 这个中间类, 继承自原本的那个类. 不仅如此, Apple 还重写了 -class 方法, 企图欺骗我们这个类没有变, 就是原本那个类.</p>\n<h2 id=\"如何实现带block回调的KVO\"><a href=\"#如何实现带block回调的KVO\" class=\"headerlink\" title=\"如何实现带block回调的KVO\"></a>如何实现带block回调的KVO</h2><p> 根据Apple的官方文档, 我们不难发现自定义KVO需要的几个步骤:</p>\n<ol>\n<li><p>创建注册子类, 重写子类的class方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//1.创建注册子类</div><div class=\"line\">//1.1获取被监听对象的类名称</div><div class=\"line\">Class class = object_getClass(self);</div><div class=\"line\">NSString *className = NSStringFromClass(class);</div><div class=\"line\">//1.2检查被检测对象的class的前缀是否被替换过(通过检查前缀来判断), 如果被替换过就说明正在被观测</div><div class=\"line\">if (![className hasPrefix:kHCKVOClassPrefix]) &#123;</div><div class=\"line\">    class = [self makeKvoClassWithOriginalClassName:className];</div><div class=\"line\">    //为观测的对象设置一个指定的类</div><div class=\"line\">    object_setClass(self, class);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>为新的子类添加set方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"> //2.为新的子类添加set方法</div><div class=\"line\">//2.1得到Setter方法</div><div class=\"line\">SEL setterSelector = NSSelectorFromString(setterForGetter(key));</div><div class=\"line\">//2.2得到指定类的实例方法</div><div class=\"line\">Method setterMethod = class_getInstanceMethod([self class], setterSelector);</div><div class=\"line\">if (!setterMethod) &#123;</div><div class=\"line\">    @throw @&quot;没有对应的Setter方法&quot;;</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\">//2.3为新类添加set方法</div><div class=\"line\">if (![self hasSelector:setterSelector]) &#123;</div><div class=\"line\">    const char *types = method_getTypeEncoding(setterMethod);</div><div class=\"line\">    class_addMethod(class, setterSelector, (IMP)kvo_setter, types);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>改变isa指针, 指向新的子类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//3改变isa指针，指向子类</div><div class=\"line\">object_setClass(self, class);</div></pre></td></tr></table></figure>\n</li>\n<li><p>保存set, get方法, 保存block</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//保存set、get方法名</div><div class=\"line\">    objc_setAssociatedObject(self, kHCKVO_getter_key, key, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    objc_setAssociatedObject(self, kHCKVO_setter_key, setterForGetter(key), OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    //保存block</div><div class=\"line\">    objc_setAssociatedObject(self, kHCKVO_block_key, block, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里面主要的难点在重写属性的set方法, 代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//新类的set方法</div><div class=\"line\">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</div><div class=\"line\">    //包括调用父类的set方法，获取旧值、新值，获取observer并通知observer</div><div class=\"line\">    NSString *setterName = NSStringFromSelector(_cmd);</div><div class=\"line\">    NSString *getterName = getterForSetter(setterName);</div><div class=\"line\">    </div><div class=\"line\">    if (!getterName) &#123;</div><div class=\"line\">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have getter %@&quot;, self, setterName];</div><div class=\"line\">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class=\"line\">                                       reason:reason</div><div class=\"line\">                                     userInfo:nil];</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /*</div><div class=\"line\">     //使用objc_msgSendSuper向父类发消息, 调用父类set方法</div><div class=\"line\">    id oldValue = [self valueForKey:getterName];</div><div class=\"line\">    </div><div class=\"line\">    //superclass</div><div class=\"line\">    struct objc_super superclazz = &#123;</div><div class=\"line\">        .receiver = self,</div><div class=\"line\">        .super_class = class_getSuperclass(object_getClass(self))</div><div class=\"line\">    &#125;;</div><div class=\"line\">    // cast our pointer so the compiler won&apos;t complain</div><div class=\"line\">    void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper;</div><div class=\"line\">    // call super&apos;s setter, which is original class&apos;s setter method</div><div class=\"line\">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    //保存子类类型</div><div class=\"line\">    Class class = [self class];</div><div class=\"line\">    //isa指向原类</div><div class=\"line\">    object_setClass(self, class_getSuperclass(class));</div><div class=\"line\">    //调用原类get方法，获取oldValue</div><div class=\"line\">    id oldValue = objc_msgSend(self, NSSelectorFromString(getterName));</div><div class=\"line\">    //调用原类set方法</div><div class=\"line\">    objc_msgSend(self, _cmd, newValue);</div><div class=\"line\">    //isa改回子类类型</div><div class=\"line\">    object_setClass(self, class);</div><div class=\"line\"></div><div class=\"line\">    </div><div class=\"line\">    //取出block</div><div class=\"line\">    HCObservingBlock block = objc_getAssociatedObject(self, kHCKVO_block_key);</div><div class=\"line\">    block(self, getterName, oldValue, newValue);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中, 关于调用父类的set方法有两种方式. 一种是直接向新类的superClass发送消息, 另外一种是先改变isa指向superclass, 调用完set方法后重新再改变isa指向新类.</p>\n<h2 id=\"如何实现系统自带的KVO\"><a href=\"#如何实现系统自带的KVO\" class=\"headerlink\" title=\"如何实现系统自带的KVO\"></a>如何实现系统自带的KVO</h2><p>系统自带KVO的实现方法和自定义带block回调的KVO的实现方法一样, 不同的是我们在重写新类的set方法中不是调用父类的set方法, 而是调用父类的<code>observeValueForKeyPath: ofObject: change: context:</code>方法.</p>\n<hr>\n<p>完整代码查看<a href=\"https://github.com/HChong3210/HCKVO\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<hr>\n<p>参考资料:<br>1.<a href=\"http://nshipster.cn/key-value-observing/\" target=\"_blank\" rel=\"noopener\">Key-Value Observing</a></p>\n<p>2.<a href=\"https://draveness.me/kvocontroller\" target=\"_blank\" rel=\"noopener\">如何优雅地使用 KVO</a></p>\n<p>3.<a href=\"https://github.com/facebook/KVOController\" target=\"_blank\" rel=\"noopener\">KVOController</a></p>\n<p>4.<a href=\"http://tech.glowing.com/cn/implement-kvo/\" target=\"_blank\" rel=\"noopener\">如何自己动手实现 KVO</a></p>\n","categories":["基础知识"],"tags":["基础知识","Runtime"]},{"title":"脚本批量下载网易云音乐歌曲","url":"http://hchong.net/2017/12/20/脚本批量下载网易云音乐歌曲/","content":"<h1 id=\"脚本批量下载网易云音乐歌曲\"><a href=\"#脚本批量下载网易云音乐歌曲\" class=\"headerlink\" title=\"脚本批量下载网易云音乐歌曲\"></a>脚本批量下载网易云音乐歌曲</h1><p>闲来无事用Python撸了一个可以批量下载网易云音乐的脚本, 大致实现方式如下:</p>\n<ol>\n<li>获取到要下载的歌曲的ID</li>\n<li>通过<code>http://music.163.com/song/media/outer/url?id=%s.mp3</code>链接来获取下载的真实链接</li>\n<li>伪造浏览器访问, 循环遍历下载至本地.</li>\n</ol>\n<p>当然在这里面也是有很多坑的, 如何获取歌曲ID, 因为我只想获取<em>我喜欢的歌</em>列表, 通过Charles抓包, 或者在浏览器里面<code>alt + command + J</code>打开开发者模式在Network中获取列表的JSON结果, 再通过正则来获取到有用的信息. 这个脚本需要改进的一点就是, 不能自己调用最喜欢的歌曲的API来自动获取JSON结果, 需要我们先复制进去.</p>\n<p>需要注意的是, 这样下载的歌曲不是最高音质的, 如果想要获取高音质的下载链接还有三种方式:</p>\n<ul>\n<li>播放音乐时通过Charles抓包来获取真实下载地址</li>\n<li>通过查看本地的Log日志, 来获取播放音乐的真实地址</li>\n<li>在缓存目录中查找已经听过的歌.</li>\n</ul>\n<p>上面这三种方式均可以获取真实有效地址, 但是不能批量获取, 并且名字都是一长串经过加密的字符串. </p>\n<hr>\n<p><a href=\"https://github.com/HChong3210/163musicDownload\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"http://blog.csdn.net/Ciiiiiing/article/details/62434438\" target=\"_blank\" rel=\"noopener\">网易云音乐API分析</a></p>\n<p>2.<a href=\"http://blog.csdn.net/jiisd/article/details/52207199\" target=\"_blank\" rel=\"noopener\"> 在 Mac 端获取【网易云音乐】付费音乐的播放地址</a></p>\n<p>3.<a href=\"http://www.889.name/gcw/rj/rj823.html\" target=\"_blank\" rel=\"noopener\">网易云音乐mp3外链、真实地址下载方法</a></p>\n<p>4.<a href=\"https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%8e%b7%e5%8f%96%e7%b2%be%e5%93%81%e6%ad%8c%e5%8d%95\" target=\"_blank\" rel=\"noopener\">网易云音乐 API</a></p>\n","categories":["Python"],"tags":["Python","脚本"]},{"title":"链式编程实践","url":"http://hchong.net/2017/12/17/链式编程实践/","content":"<p>链式编程是将多个操作, 通过<code>.</code>的形式连接在一起, 形成一句话, 以增强代码的阅读性. 链式编程的核心在于, 方法的返回值必须是<code>返回值是self, 参数为需要操作的值的block</code>. 下面我们来看一下Masonry中链式编程的应用.</p>\n<h2 id=\"Masonry中的应用\"><a href=\"#Masonry中的应用\" class=\"headerlink\" title=\"Masonry中的应用\"></a>Masonry中的应用</h2><p>Masonry的使用大致如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">UIView *demo = [[UIView alloc] init];</div><div class=\"line\">[self.view addSubview:demo];</div><div class=\"line\">[demo mas_updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">   make.left.equalTo(self.mas_left).offset(16);</div><div class=\"line\">   make.centerY.equalTo(self.mas_centerY).offset(0);</div><div class=\"line\">   make.width.height.equalTo(@(200));</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>这里只简单分析一下他链式编程的实现. 我们先看下<code>mas_makeConstraints</code>方法.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</div><div class=\"line\">    self.translatesAutoresizingMaskIntoConstraints = NO;</div><div class=\"line\">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</div><div class=\"line\">    block(constraintMaker);</div><div class=\"line\">    return [constraintMaker install];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里一共有三步:</p>\n<ol>\n<li>创建一个<code>MASConstraintMaker</code>对象<code>constraintMaker</code>.</li>\n<li>调用<code>block(constraintMaker)</code>, 这样在外面我们调用<code>mas_makeConstraints</code>方法里面的<code>make</code>实际就是这里的<code>constraintMaker</code>. 相当于我们在外面调用地方写的控件的约束全部都保存到<code>constraintMaker</code>对象里面了.</li>\n<li>调用<code>[constraintMaker install]</code>方法, 先遍历卸载之前的约束, 再安装新的约束, 最后返回包含所有约束的数组.</li>\n</ol>\n<p>下面我们再看一下添加约束的步骤, 以<code>make.width.height.equalTo(@(200))</code>为例.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@implementation MASConstraint</div><div class=\"line\">- (MASConstraint *)width &#123;</div><div class=\"line\">    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeWidth];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (MASConstraint *)height &#123;</div><div class=\"line\">    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeHeight];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (MASConstraint * (^)(id))equalTo &#123;</div><div class=\"line\">    return ^id(id attribute) &#123;</div><div class=\"line\">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</div><div class=\"line\">    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>我们可以发现, <code>width</code>和<code>height</code>方法的返回值都是<code>MASConstraint</code>对象, 方法内部封装了 一些内部实现, 这样就可以无限的<code>.</code>下去.<br><code>equalTo</code>这样的方法需要通过<code>()</code>的方式传参进去, 并且还行要能一直<code>.</code>下去. 通过<code>()</code>的方式传参只有通过block, 想持续<code>.</code>必须返回<code>MASConstraint</code>对象, 所以<code>equalTo</code>的返回值是一个block<code>MASConstraint * (^)(id)</code>(返回值是self, 并且还有参数).</p>\n<p>总结一下核心就是:</p>\n<ul>\n<li>把要做的事封装到block, 给外界提供一个返回这个block的方法.</li>\n<li>方法返回值必须是block, block的返回值是方法调用者(一般就是self), block的参数是传入的需要操作的内容.</li>\n</ul>\n<h2 id=\"链式编程的Demo\"><a href=\"#链式编程的Demo\" class=\"headerlink\" title=\"链式编程的Demo\"></a>链式编程的Demo</h2><p>我们以完成一个计算器的Demo为例. 我们新建一个<code>Caculator</code>类来做计算, 实现<code>add</code>方法如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface Caculator : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, assign) NSInteger result;//结果</div><div class=\"line\"></div><div class=\"line\">//返回值是block(Caculator *(^)(NSInteger number)), 该block的返回值是Caculator*, 参数为NSInteger类型</div><div class=\"line\">- (Caculator *(^)(NSInteger number))add;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation Caculator</div><div class=\"line\"></div><div class=\"line\">- (Caculator *(^)(NSInteger number))add &#123;</div><div class=\"line\">    return ^Caculator *(NSInteger number) &#123;</div><div class=\"line\">        self.result += number;</div><div class=\"line\">        return self;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>要实现类似Masonry的调用方式, 就要再封装一层:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface NSObject (Calculator)</div><div class=\"line\"></div><div class=\"line\">+ (NSInteger)makeCaculators:(void(^)(Caculator *make))block;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation NSObject (Calculator)</div><div class=\"line\"></div><div class=\"line\">+ (NSInteger)makeCaculators:(void(^)(Caculator *make))block &#123;</div><div class=\"line\">    Caculator *mgr = [[Caculator alloc] init];</div><div class=\"line\">    block(mgr);</div><div class=\"line\">    return mgr.result;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在计算时调用这个方法，创建计算制造者，然后调用传入的block, 并且返回结果.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSInteger result = [NSObject makeCaculators:^(Caculator *make) &#123;</div><div class=\"line\">    make.add(4).multiply(5).minus(4).divide(8).add(13);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<hr>\n<p>完整Demo地址在<a href=\"https://github.com/HChong3210/MethodChaining\" target=\"_blank\" rel=\"noopener\">这里</a>. <a href=\"https://www.jianshu.com/p/f53a3182f659\" target=\"_blank\" rel=\"noopener\">这篇</a>循序渐进, 写的也不错.</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Vue实践指南","url":"http://hchong.net/2017/12/11/Vue实践指南/","content":"","categories":[],"tags":[]},{"title":"Swift实践指南","url":"http://hchong.net/2017/12/11/Swift实践指南/","content":"","categories":[],"tags":[]},{"title":"HTTP请求中的GET与POST","url":"http://hchong.net/2017/12/11/HTTP请求中的GET与POST/","content":"<h1 id=\"HTTP请求中的GET与POST\"><a href=\"#HTTP请求中的GET与POST\" class=\"headerlink\" title=\"HTTP请求中的GET与POST\"></a>HTTP请求中的GET与POST</h1><p>GET和POST是网络请求到的两种基本方式, GET把参数包含在URL中, POST通过request body传递参数. </p>\n<p>GET在浏览器回退时是无害, 而POST会再次提交请求.<br>GET产生的URL地址可以保存为书签, 而POST不可以.<br>GET请求会被浏览器主动cache, 而POST不会, 除非手动设置.<br>GET请求只能进行url编码, 而POST支持多种编码方式.<br>GET请求参数会被完整保留在浏览器历史记录里, 而POST中的参数不会被保留.<br>GET请求在URL中传送的参数是有长度限制的, 而POST没有.<br>对参数的数据类型, GET只接受ASCII字符, 而POST没有限制.<br>GET比POST更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息.<br>GET参数通过URL传递, POST放在Request body中.</p>\n<p>GET和POST都是HTTP协议中的两种发送请求的方法.HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议.</p>\n<p>HTTP的底层是TCP/IP, 所以GET和POST的底层也是TCP/IP. 也就是说, GET/POST都是TCP链接. GET和POST能做的事情是一样一样的. 你要给GET加上request body, 给POST带上url参数, 技术上是完全行的通的.</p>\n<p>GET产生一个TCP数据包. POST产生两个TCP数据包.对于GET方式的请求, 浏览器会把http header和data一并发送出去, 服务器响应200(返回数据). 而对于POST, 浏览器先发送header, 服务器响应100 continue, 浏览器再发送data, 服务器响应200 ok(返回数据).</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"RunLoop用法与分析","url":"http://hchong.net/2017/12/11/RunLoop用法与分析/","content":"<p>RunLoop是iOS开发中一个常用的概念, 用来保证线程能够随时处理事件, 但是并不退出. 代码逻辑通常是这样的: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function loop() &#123;</div><div class=\"line\">    initialize();</div><div class=\"line\">    do &#123;</div><div class=\"line\">        var message = get_next_message();</div><div class=\"line\">        process_message(message);</div><div class=\"line\">    &#125; while (message != quit);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在iOS开发中RunLoop的主要作用是:</p>\n<ol>\n<li>保持程序的持续运行(如: 程序一启动就会开启一个主线程(线程中的 runloop 是自动创建并运行), runloop 保证主线程不会被销毁, 也就保证了程序的持续运行). </li>\n<li>处理App中的各种事件(如: touches 触摸事件, NSTimer 定时器事件, Selector事件(选择器 performSelector)).</li>\n<li>节省CPU资源, 提高程序性能(有事情就做事情, 没事情就休息(其资源释放)). </li>\n<li>负责渲染屏幕上的所有UI.</li>\n</ol>\n<p><a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>讲的实在太详细了, 这里只是做一个总结和拾遗. 官方文档可以看<a href=\"https://developer.apple.com/documentation/corefoundation/cfrunloop?language=objc\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"RunLoop的概念\"><a href=\"#RunLoop的概念\" class=\"headerlink\" title=\"RunLoop的概念\"></a>RunLoop的概念</h2><p>RunLoop实际上是一个对象, 这个对象管理了其需要处理的时间和消息, 并提供了一个入口函数来执行上面的逻辑, 线程执行了这个函数后, 就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中, 直到这个循环结束(比如传入 quit 的消息), 函数返回.</p>\n<p>iOS提供了两个这样的对象: NSRunLoop 和 CFRunLoopRef. CFRunLoopRef 是在 CoreFoundation 框架内的, 它提供了纯 C 函数的 API, 所有这些 API 都是线程安全的.<br>NSRunLoop 是基于 CFRunLoopRef 的封装, 提供了面向对象的 API, 但是这些 API 不是线程安全的.</p>\n<h2 id=\"RunLoop与线程的关系\"><a href=\"#RunLoop与线程的关系\" class=\"headerlink\" title=\"RunLoop与线程的关系\"></a>RunLoop与线程的关系</h2><p>CFRunLoop 是基于 pthread 来管理的. 苹果不允许直接创建 RunLoop, 它只提供了两个自动获取的函数: CFRunLoopGetMain() 和 CFRunLoopGetCurrent(). </p>\n<p>线程与RunLoop之间是一一对应的关系, 他们之间的关系(<code>CFDictionarySetValue(loopsDic, thread, loop);</code>)保存在一个全局的字典中(key 是 pthread_t, value 是 CFRunLoopRef), 线程刚创建时是没有RunLoop的, 如果不主动获取就一直不会有, RunLoop的创建是发生在第一次获取时, RunLoop的销毁发生自线程结束时. 只能在一个线程的内部获取其RunLoop. </p>\n<h2 id=\"RunLoop对外的接口\"><a href=\"#RunLoop对外的接口\" class=\"headerlink\" title=\"RunLoop对外的接口\"></a>RunLoop对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中 CFRunLoopModeRef 类并没有对外暴露, 只是通过 CFRunLoopRef 的接口进行了封装, 他们之间的关系如图所示.<br><img src=\"https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png\" alt=\"RunLoop类之间的关系\"></p>\n<p>Source/Timer/Observer 被统称为 mode item, 一个 item 可以被同时加入多个 mode. 但一个 item 被重复加入同一个 mode 时是不会有效果的. 如果一个 mode 中一个 item 都没有, 则 RunLoop 会直接退出, 不进入循环. </p>\n<h3 id=\"CFRunLoopSourceRef\"><a href=\"#CFRunLoopSourceRef\" class=\"headerlink\" title=\"CFRunLoopSourceRef\"></a>CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef是事件源(输入源), 例如外部的触摸, 点击事件和系统内部进程间的通信等. 按照官方文档Source主要分为: </p>\n<ul>\n<li>Input Sources: Input Sources以异步的方式将事件传递给线程, 通过分为两种:<ul>\n<li>Port-based input sources: Cocoa和Core Foundation提供了内置的支持, 可以使用端口相关的对象和函数创建基于端口的输入源. 我们不必直接创建输入源, 只需创建一个端口对象, 并使用NSPort的方法将该端口添加到运行循环中. 它是来监视应用程序的Mach端口, 消息由内核发出.</li>\n<li>Custom Input Sources: 我们使用CFRunLoopSourceRef来创建自定义输入源, 监视事件的自定义源, 消息由其他线程手动发出.</li>\n</ul>\n</li>\n<li>Cocoa Perform Selector Sources: 与基于端口的源不同, 我们可以在任何线程上perform a selector, 并且执行选择器源在执行选择器之后从运行循环中移除自己.</li>\n<li>Timer Sources: 在将来的预定时间内, 计时器源会同步地将事件发送到线程.<br>更多详细信息可以看<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1\" target=\"_blank\" rel=\"noopener\">Threading Programming Guide</a>.</li>\n</ul>\n<p>按照函数调用栈, Source主要分为两类:</p>\n<ul>\n<li>Source0: 非基于Port的. 只包含了一个回调(函数指针), 它并不能主动触发事件. 使用时, 需要先调用 CFRunLoopSourceSignal(source), 将这个 Source 标记为待处理, 然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop, 让其处理这个事件. </li>\n<li>Source1: 基于Port的, 通过内核和其他线程通信, 接收, 分发系统事件. 这种 Source 能主动唤醒 RunLoop 的线程. 创建常驻线程就是在线程中添加一个NSport来实现的.<h3 id=\"CFRunLoopObserverRef\"><a href=\"#CFRunLoopObserverRef\" class=\"headerlink\" title=\"CFRunLoopObserverRef\"></a>CFRunLoopObserverRef</h3>每个 Observer 都包含了一个回调(函数指针)当 RunLoop 的状态发生变化时, 观察者就能通过回调接受到这个变化. 可以观测的时间点有以下几个: </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class=\"line\">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop     （1）</div><div class=\"line\">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer   （2）</div><div class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source  （4）</div><div class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠      （32）</div><div class=\"line\">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒     (64)</div><div class=\"line\">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop      (128)</div><div class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFU, // 包含上面所有状态</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"CFRunLoopTimerRef\"><a href=\"#CFRunLoopTimerRef\" class=\"headerlink\" title=\"CFRunLoopTimerRef\"></a>CFRunLoopTimerRef</h3><p>是基于时间的触发器, 它和 NSTimer 是toll-free bridged 的, 可以混用, 我们基本上可以认为他就是NSTimer,  其包含一个时间长度和一个回调(函数指针), 当其加入到 RunLoop 时, RunLoop会注册对应的时间点, 当时间点到时, RunLoop会被唤醒以执行那个回调.<br>它受RunLoop的Mode影响, GCD的定时器不受RunLoop的Mode影响.<br>注意, 这里这个NSTimer实际是有误差的</p>\n<h3 id=\"CFRunLoopModeRef\"><a href=\"#CFRunLoopModeRef\" class=\"headerlink\" title=\"CFRunLoopModeRef\"></a>CFRunLoopModeRef</h3><p>一个runloop可以包含多个model, 每个model都是独立的, 而且runloop只能选择一个model运行, 也就是currentModel. 如果需要切换 Mode, 只能退出 Loop, 再重新指定一个 Mode 进入. 这样做主要是为了分隔开不同组的 Source/Timer/Observer, 让其互不影响.</p>\n<p>系统默认注册了5个Mode:<br>NSDefaultRunLoopMode: App的默认Mode, 通常主线程是在这个Mode下运行, App 平时就是处在这个状态.<br>UITrackingRunLoopMode: 界面跟踪 Mode, 用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响.<br>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode, 启动完成后就不再使用.<br>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode, 通常用不到.<br>NSRunLoopCommonModes: 这是一个占位用的Mode, 不是一种真正的Mode.</p>\n<p>这里有个概念叫 “CommonModes”: 一个 Mode 可以将自己标记为”Common”属性(通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中). 每当 RunLoop 的内容发生变化时, RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common”标记的所有Mode里.<br>应用场景举例: 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作. 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到commonMode 中。那么所有被标记为commonMode的mode（defaultMode和TrackingMode）都会执行该timer。这样你在滑动界面的时候也能够调用timer，下面会有实例讲解</p>\n<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</div><div class=\"line\">CFRunLoopRunInMode(CFStringRef modeName, ...);</div></pre></td></tr></table></figure>\n<p>Mode暴露的管理Mode item的接口有下面几个: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class=\"line\">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class=\"line\">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class=\"line\">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class=\"line\">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class=\"line\">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure>\n<p>你只能通过 mode name 来操作内部的 mode, 当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时, RunLoop会自动帮你创建对应的 CFRunLoopModeRef. 对于一个 RunLoop 来说, 其内部的 mode 只能增加不能删除.</p>\n<h2 id=\"RunLoop的内部逻辑\"><a href=\"#RunLoop的内部逻辑\" class=\"headerlink\" title=\"RunLoop的内部逻辑\"></a>RunLoop的内部逻辑</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/277755-1184c261c96d3116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"官方的RunLoop逻辑\"></p>\n<p>盗图一张, 大神总结的.<br><img src=\"https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png\" alt=\"RunLoop内部逻辑\"><br>运行RunLoop具体的流程如下: </p>\n<ol>\n<li>通知观察者, RunLoop已经启动.</li>\n<li>通知观察者, 将要处理定时器.</li>\n<li>通知观察者, 将要处理Source0(即将启动的非基于端口的源).</li>\n<li>启动任何准备好的Source0(非基于端口的源).</li>\n<li>如果有任何Source1(基于端口的源)准备好并且处于等待状态, 立即启动, 并进入步骤9.</li>\n<li>通知所有观察者, 线程即将进入休眠.</li>\n<li>线程处于休眠状态, 直到遇到下列事件中的任意一个:<ul>\n<li>某一事件到达Source0(非基于端口的源)</li>\n<li>NSTimer定时器启动</li>\n<li>RunLoop设置的时间已经超时</li>\n<li>RunLoop被外部手动显示唤醒.</li>\n</ul>\n</li>\n<li>通知观察者, 线程刚被唤醒</li>\n<li>处理唤醒时收到的事件<ul>\n<li>如果是定时器启动, 处理定时器并重启RunLoop, 进入步骤2</li>\n<li>如果是输入源启动, 传递相应的消息</li>\n<li>如果是RunLoop被显式唤醒(Source1), 重启RunLoop, 进入步骤2</li>\n</ul>\n</li>\n<li>通知观察者RunLoop即将结束.</li>\n</ol>\n<p>实际上 RunLoop 内部是一个 do-while 循环函数. 当你调用 CFRunLoopRun() 时, 线程就会一直停留在这个循环里; 直到超时或被手动停止, 该函数才会返回. </p>\n<h2 id=\"系统中RunLoop的常见实现\"><a href=\"#系统中RunLoop的常见实现\" class=\"headerlink\" title=\"系统中RunLoop的常见实现\"></a>系统中RunLoop的常见实现</h2><p>下面列举几个Apple中常见的RunLoop的使用场景.</p>\n<h3 id=\"AutoreleasePool\"><a href=\"#AutoreleasePool\" class=\"headerlink\" title=\"AutoreleasePool\"></a>AutoreleasePool</h3><p>APP启动后, 系统在主线程RunLoop中注册了两个Observer, 其回调都是 _wrapRunLoopWithAutoreleasePoolHandler().</p>\n<p>第一个Observer监视的事件是kCFRunLoopEntry(进入RunLoop), 会调用_objc_autoreleasePoolPush() 创建自动释放池, 其 order 是-2147483647, 优先级最高, 保证创建释放池发生在其他所有回调之前.<br>第二个Observer监视的事件是kCFRunLoopBeforeWaiting(RunLoop休眠)和kCFRunLoopExit(RunLoop退出). 会在休眠是调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池; 会在退出时调用 _objc_autoreleasePoolPop() 来释放自动释放池. 这个 Observer 的 order 是 2147483647, 优先级最低, 保证其释放池子发生在其他所有回调之后.</p>\n<p>在主线程执行的代码, 通常是写在诸如事件回调, Timer回调内的. 这些回调会被 RunLoop 创建好的 AutoreleasePool 包围, 所以不会出现内存泄漏, 开发者也不必显示创建 Pool 了.</p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port) 用来接收系统事件, 其回调函数为 __IOHIDEventSystemClientQueueCallback(). </p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后,  IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收. SpringBoard 只接收按键(锁屏/静音等), 触摸, 加速, 接近传感器等几种 Event, 随后用 mach port 转发给需要的App进程. 随后苹果注册的那个 Source1 就会触发回调, 并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发.<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发, 其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等. 通常事件比如 UIButton 点击, touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的.</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当_UIApplicationHandleEventQueue() 识别了一个手势时, 其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断. 随后系统将对应的 UIGestureRecognizer 标记为待处理.<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件, 这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver(), 其内部会获取所有刚被标记为待处理的 GestureRecognizer, 并执行GestureRecognizer的回调.<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时, 这个回调都会进行相应处理.</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI, 比如改变了 Frame, 更新了 UIView/CALayer 的层次时, 或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后, 这个 UIView/CALayer 就被标记为待处理, 并被提交到一个全局的容器去.<br>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件, 回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv(). 这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整, 并更新 UI 界面.</p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef, 他们之间是 toll-free bridged 的. 一个 NSTimer 注册到 RunLoop 后, RunLoop 会为其重复的时间点注册好事件. 例如 10:00, 10:10, 10:20 这几个时间点. RunLoop为了节省资源, 并不会在非常准确的时间点回调这个Timer. Timer 有个属性叫做 Tolerance (宽容度), 标示了当时间点到后, 容许有多少最大误差.<br>如果某个时间点被错过了, 例如执行了一个很长的任务, 则那个时间点的回调也会跳过去, 不会延后执行.</p>\n<h3 id=\"performSelecter方法\"><a href=\"#performSelecter方法\" class=\"headerlink\" title=\"performSelecter方法\"></a>performSelecter方法</h3><p>调用 NSObject 的 performSelecter:afterDelay: 后, 实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中. 所以如果当前线程没有 RunLoop, 则这个方法会失效.<br>当调用 performSelector:onThread: 时, 实际上其会创建一个 Timer 加到对应的线程去, 同样的, 如果对应线程没有 RunLoop 该方法也会失效.</p>\n<h2 id=\"开发中RunLoop的常见使用\"><a href=\"#开发中RunLoop的常见使用\" class=\"headerlink\" title=\"开发中RunLoop的常见使用\"></a>开发中RunLoop的常见使用</h2><h3 id=\"滚动scrollView导致定时器失效\"><a href=\"#滚动scrollView导致定时器失效\" class=\"headerlink\" title=\"滚动scrollView导致定时器失效\"></a>滚动scrollView导致定时器失效</h3><p>如果在界面上有一个UIscrollview控件(tableview, collectionview等), 如果此时还有一个定时器在执行一个事件, 你会发现当你滚动scrollview的时候, 定时器会失效. </p>\n<p>原因是当滚动UIscrollview的时候, runloop会进入UITrackingRunLoopMode 模式, 而定时器运行在defaultMode下面, 系统一次只能处理一种模式的runloop, 所以导致defaultMode下的定时器失效. 解决方案有两种:</p>\n<ol>\n<li><p>把定时器的runloop的model改为NSRunLoopCommonModes 模式, 这个模式是一种占位mode, 并不是真正可以运行的mode, 它是用来标记一个mode的. 默认情况下default和tracking这两种mode 都会被标记上NSRunLoopCommonModes 标签 改变定时器的mode为commonmodel, 可以让定时器运行在defaultMode和trackingModel两种模式下, 不会出现滚动scrollview导致定时器失效的故障. </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用GCD创建定时器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 获得队列</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</div><div class=\"line\"></div><div class=\"line\">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</div><div class=\"line\">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\"></div><div class=\"line\">// 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）</div><div class=\"line\">// GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）</div><div class=\"line\">// 比当前时间晚1秒开始执行</div><div class=\"line\">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));</div><div class=\"line\"></div><div class=\"line\">//每隔一秒执行一次</div><div class=\"line\">uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);</div><div class=\"line\">dispatch_source_set_timer(self.timer, start, interval, 0);</div><div class=\"line\"></div><div class=\"line\">// 设置回调</div><div class=\"line\">dispatch_source_set_event_handler(self.timer, ^&#123;</div><div class=\"line\">    NSLog(@&quot;------------%@&quot;, [NSThread currentThread]);</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 启动定时器</div><div class=\"line\">dispatch_resume(self.timer);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"图片下载\"><a href=\"#图片下载\" class=\"headerlink\" title=\"图片下载\"></a>图片下载</h3><p>由于图片渲染到屏幕需要消耗较多资源, 为了提高用户体验, 当用户滚动UIscrollview的时候, 只在后台下载图片, 但是不显示图片, 当用户停下来的时候才显示图片. 核心代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];</div></pre></td></tr></table></figure>\n<p>这是因为限定了方法setImage只能在NSDefaultRunLoopMode 模式下使用. 而滚动UIscrollview的时候, 程序运行在tracking模式下面, 所以方法setImage不会执行. </p>\n<h3 id=\"常驻线程\"><a href=\"#常驻线程\" class=\"headerlink\" title=\"常驻线程\"></a>常驻线程</h3><p>需要创建一个在后台一直存在的程序, 来做一些需要频繁处理的任务. 比如检测网络状态等. 默认情况一个线程创建出来, 运行完要做的事情, 线程就会消亡. 而程序启动的时候, 就创建的主线程已经加入到runloop, 所以主线程不会消亡. AFN里面就有一条通过添加NSPort来实现常驻的线程, 常见的有两种方式: </p>\n<ol>\n<li><p>添加NSPort</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class=\"line\">    [self.thread start];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)run &#123;</div><div class=\"line\">    NSLog(@&quot;----------run----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    @autoreleasepool&#123;</div><div class=\"line\">    /*如果不加这句，会发现runloop创建出来就挂了，因为runloop如果没有CFRunLoopSourceRef事件源输入或者定时器，就会立马消亡。</div><div class=\"line\">      下面的方法给runloop添加一个NSport，就是添加一个事件源，也可以添加一个定时器，或者observer，让runloop不会挂掉*/</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\"></div><div class=\"line\">    // 方法1 ,2，3实现的效果相同，让runloop无限期运行下去</div><div class=\"line\">    [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">    // 方法2</div><div class=\"line\">    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class=\"line\"></div><div class=\"line\">    // 方法3</div><div class=\"line\">    [[NSRunLoop currentRunLoop] runUntilDate:[NSDate distantFuture]];</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;---------&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)test &#123;</div><div class=\"line\">    NSLog(@&quot;----------test----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</div><div class=\"line\">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加NSTimer</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class=\"line\">    [self.thread start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)run &#123;</div><div class=\"line\">    [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES];</div><div class=\"line\"></div><div class=\"line\">    [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果没有实现添加NSPort或者NSTimer, 会发现执行完run方法, 线程就会消亡, 后续再执行touchbegan方法无效. 我们必须保证线程不消亡, 才可以在后台接受时间处理.</p>\n<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source, 所以在 <code>[runLoop run]</code> 之前先创建了一个新的 NSMachPort 添加进去了. 通常情况下, 调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内; 但此处添加 port 只是为了让 RunLoop 不至于退出, 并没有用于实际的发送消息. </p>\n<p>可以发现执行完了run方法, 这个时候再点击屏幕, 可以不断执行test方法, 因为线程self.thread一直常驻后台, 等待事件加入其中, 然后执行.</p>\n<h3 id=\"在所有UI相应操作之前处理任务\"><a href=\"#在所有UI相应操作之前处理任务\" class=\"headerlink\" title=\"在所有UI相应操作之前处理任务\"></a>在所有UI相应操作之前处理任务</h3><p>主要思路就是我们可以新建一个Observer, 来观察RUnLoop的状态, 因为我们的UI操作都会导致RunLoop状态的变动, 通过日志我们可以发现, 在执行按钮事件之前, 先执行Observer里面的方法, 这样就可以拦截事件, 让我们的代码在UI事件之前执行.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (IBAction)btnClick:(id)sender &#123;</div><div class=\"line\">    NSLog(@&quot;btnClick----------&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    [self observer];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)observer &#123;</div><div class=\"line\">    // 创建observer，参数kCFRunLoopAllActivities表示监听所有状态</div><div class=\"line\">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class=\"line\">        NSLog(@&quot;----监听到RunLoop状态发生改变---%zd&quot;, activity);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    // 添加观察者：监听RunLoop的状态</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</div><div class=\"line\">    </div><div class=\"line\">    // 释放Observer</div><div class=\"line\">    CFRelease(observer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class=\"line\">    kCFRunLoopEntry = (1UL &lt;&lt; 0),   //1</div><div class=\"line\">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    //2</div><div class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   //4</div><div class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   //32</div><div class=\"line\">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    //64</div><div class=\"line\">    kCFRunLoopExit = (1UL &lt;&lt; 7),    //128</div><div class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"其他用法\"><a href=\"#其他用法\" class=\"headerlink\" title=\"其他用法\"></a>其他用法</h3><p>例如我们实现Cell高度的缓存计算, 我们可以在RunLoop空闲时来计算, 所以我们可以创建一个Observer, 来监听RunLoop的kCFRunLoopBeforeWaiting状态(这一次 RunLoop 迭代处理完成了所有事件, 马上要休眠时), 在其中来计算高度并且缓存, </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</div><div class=\"line\">CFStringRef runLoopMode = kCFRunLoopDefaultMode;</div><div class=\"line\">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler</div><div class=\"line\">(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123;</div><div class=\"line\">    // TODO here</div><div class=\"line\">&#125;);</div><div class=\"line\">CFRunLoopAddObserver(runLoop, observer, runLoopMode);</div><div class=\"line\">在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer</div></pre></td></tr></table></figure>\n<hr>\n<p>参考资料: </p>\n<p>1.<a href=\"http://www.bijishequ.com/detail/355655?p=70-67\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a></p>\n<p>2.<a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a>, 这个是经典之作</p>\n<p>3.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1\" target=\"_blank\" rel=\"noopener\">Threading Programming Guide</a>, 官方</p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Runtime用法与分析","url":"http://hchong.net/2017/12/11/Runtime用法与分析/","content":"<p>Objective-C 是C的语言的超集, C是一门静态语言而Objective-C却是一门动态语言, 这个动态特性就是由基于<a href=\"https://zh.wikipedia.org/wiki/Smalltalk\" target=\"_blank\" rel=\"noopener\">Smalltalk</a>消息传递特性的<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1\" target=\"_blank\" rel=\"noopener\">Runtime</a>来提供的. 那么什么是Runtime, 官方的说法是这样的:</p>\n<blockquote>\n<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.<br>大致翻译一下就是: Objective-C尽可能的提供更多策略把原本需要在编译和链接时做的事尽一切可能放到了运行时来动态的处理. 那也就意味着我们不仅需要一套编译系统, 还需要一套运行时系统来执行编译后的代码. 对于Objective-C来说, Runtime就是这样的一套运行时操作系统; Runtime为Objective-C的的动态特性提供了底层的技术支持.</p>\n</blockquote>\n<p>Runtime其实有两个版本: Modern和Legacy. 我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统, 只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中. 而 maxOS 较老的32位程序仍采用 Objective-C 1 中的早期(Legacy)版本的 Runtime 系统. 这两个版本最大的区别在于当你更改一个类的实例变量的布局时, 在早期版本中你需要重新编译它的子类, 而现行版就不需要.</p>\n<h2 id=\"Runtime简介\"><a href=\"#Runtime简介\" class=\"headerlink\" title=\"Runtime简介\"></a>Runtime简介</h2><p>Objective-C在三种层面上与Runtime系统进行交互: </p>\n<ol>\n<li>通过 Objective-C 源代码<br> Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码, 在运行时确定对应的数据结构和调用具体哪个方法.</li>\n<li>通过 Foundation 框架的 NSObject 类定义的方法<br> NSObject类是遵守NSObject协议的, 在这个协议里面有很多方法是和Runtime相关, 或者直接从Runtime中获取信息的, 具体的可以看这里<a href=\"https://developer.apple.com/documentation/objectivec/1418956-nsobject?language=objc\" target=\"_blank\" rel=\"noopener\">NSObject Protocol Reference</a>.</li>\n<li>通过对 Runtime 库函数的直接调用<br> 在这里需要注意一下, 系统本身是默认关闭了Runtime的代码提示的, 我们需要在BuildSettings -&gt; Enable Strict Checking objc_msgSend Calls -&gt;设置为NO<br> Objective-C 的 Runtime 为我们提供了很多运行时状态下跟类与对象相关的函数, 具体的可以看<a href=\"https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime Reference</a>.</li>\n</ol>\n<h2 id=\"Runtime-基础数据结构\"><a href=\"#Runtime-基础数据结构\" class=\"headerlink\" title=\"Runtime 基础数据结构\"></a>Runtime 基础数据结构</h2><p>这里我们需要先关注了解几个概念: Object(对象), Class(类), Meta Class(原类), id. 通过objc_class的定义我们大致可以看出他们之间的关系:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef struct objc_class *Class;  </div><div class=\"line\">typedef struct objc_object *id;</div><div class=\"line\"></div><div class=\"line\">@interface Object &#123; </div><div class=\"line\">    Class isa; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@interface NSObject &lt;NSObject&gt; &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct objc_object &#123;  </div><div class=\"line\">private:  </div><div class=\"line\">    isa_t isa;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct objc_class : objc_object &#123;  </div><div class=\"line\">    // Class ISA;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             // formerly cache pointer and vtable</div><div class=\"line\">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">union isa_t  </div><div class=\"line\">&#123;</div><div class=\"line\">    isa_t() &#123; &#125;</div><div class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class=\"line\">    Class cls;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用文字总结一下就是: </p>\n<ol>\n<li><p>id 在 Objective-C 中可以代指任意的对象类型, 他是一个指向 objc_object 结构体的指针(这个struct的定义本身就带了一个 <em>, 所以我们在使用其他NSObject类型的实例时需要在前面加上 </em>, 而使用 id 时却不用). </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">/// A pointer to an instance of a class.</div><div class=\"line\">typedef struct objc_object *id;</div></pre></td></tr></table></figure>\n</li>\n<li><p>那么什么是 objc_object 呢? Objective-C中的Object(objc_object)在最后会被转换成C的结构体, 而在这个struct中有一个 <a href=\"#isa_t\">isa_t</a> 类型的结构体isa, 通过查看 isa_t 我们发现它里面有一个指向它的类别 Class(定义了对象所属的类). <em>注意: isa 指针不总是指向实例对象所属的类, 不能依靠它来确定类型, 而是应该用 class 方法来确定实例对象的类.</em> </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">struct objc_object &#123;  </div><div class=\"line\">private:  </div><div class=\"line\">    isa_t isa;</div><div class=\"line\">public:</div><div class=\"line\">    // initIsa() should be used to init the isa of new objects only.</div><div class=\"line\">    // If this object already has an isa, use changeIsa() for correctness.</div><div class=\"line\">    // initInstanceIsa(): objects with no custom RR/AWZ</div><div class=\"line\">    void initIsa(Class cls /*indexed=false*/);</div><div class=\"line\">    void initInstanceIsa(Class cls, bool hasCxxDtor);</div><div class=\"line\">private:  </div><div class=\"line\">    void initIsa(Class newCls, bool indexed, bool hasCxxDtor);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>那么什么是 Class 呢? Class 其实是一个指向 objc_class 结构体的指针. </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">/// An opaque type that represents an Objective-C class.</div><div class=\"line\">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>\n</li>\n<li><p>那么什么是objc_class呢? 我们可以看到 objc_class 继承自 objc_object, 由此可以看出<em>Objective-C 中类也是一个对象</em>. 我们调用类方法的时候, 类对象的isa里面是什么呢? 这样就引出了原类的概念. </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">struct objc_class : objc_object &#123;  </div><div class=\"line\">    // Class ISA;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             // formerly cache pointer and vtable</div><div class=\"line\">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><em>总结: Class在设计中本身也是一个对象. 而这个Class对象的对应的类, 我们叫它 Meta Class, 它用来表述类对象本身所具备的元数据, 类方法就定义于此处, 因为这些方法可以理解成类对象的实例方法. 每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类. 即Class结构体中的 isa 指向的就是它的 Meta Class. 我们可以把Meta Class理解为一个Class对象的Class. 当我们给一个NSObject对象发送消息时(实例方法), 这条消息会在对象所属的类的方法列表里查找. 当我们发送一个消息给一个类时(类方法), 这条消息会在类的Meta Class的方法列表里查找.</em> </p>\n<p>下面这个图很好地说明了Object, Class, Meta Class之间的关系.<br><img src=\"http://7ni3rk.com1.z0.glb.clouddn.com/Runtime/class-diagram.jpg\" alt=\"Object, Class, Meta Class之间的关系\"><br>概括一下, 上图主要说了以下几点: </p>\n<ol>\n<li>每个实例(Object)的isa指针都指向该实例所属的类. </li>\n<li>每个类(Class)的isa指针都指向为一个该类所属的Meta Class(原类).</li>\n<li>每个Meta Class(原类)的isa指针都指向Root Class(Meta)(根原类), 大部分情况是都是NSObject.</li>\n<li>Root class(meta)的superclass指向Root class(Class), 也就是NSObject, 形成一个回路.</li>\n<li>Root class(Class)其实就是NSObject, NSObject是没有超类的, 所以Root class(Class)的superclass指向nil.</li>\n</ol>\n<p>下面是针对上面出现的一些结构体和对象的详细解析.</p>\n<h3 id=\"isa-t\"><a href=\"#isa-t\" class=\"headerlink\" title=\"isa_t\"></a><span id=\"isa_t\">isa_t</span></h3><p>objc_object 结构体包含一个 isa 指针, 类型为 isa_t 联合体. 因为 isa_t 使用 union 实现, 所以可能表示多种形态, 既可以当成是指针, 也可以存储标志位. 有关 isa_t 联合体的更多内容可以查看 <a href=\"http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/#isa-%E6%8C%87%E9%92%88%EF%BC%88NONPOINTER-ISA%EF%BC%89\" target=\"_blank\" rel=\"noopener\">Objective-C 引用计数原理</a>.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">union isa_t  </div><div class=\"line\">&#123;</div><div class=\"line\">    isa_t() &#123; &#125;</div><div class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class=\"line\">    Class cls;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"cache-t\"><a href=\"#cache-t\" class=\"headerlink\" title=\"cache_t\"></a>cache_t</h3><p>cache_t 出现在 objc_class 中, cache_t 中存储了一个 bucket_t 的结构体 _buckets ，和两个unsigned int 的变量 _mask 和 _occupied. _mask 分配用来缓存bucket的总数, _occupied 表明目前实际占用的缓存bucket的个数. bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP. IMP是一个函数指针, 指向了一个方法的具体实现. bucket_t *_buckets其实就是一个散列表, 用来存储Method的链表. </p>\n<p>Cache 的作用主要是为了优化方法调用的性能. 当对象receiver调用方法message时, 首先根据对象receiver 的 isa 指针查找到它对应的类, 然后在类的 methodLists 中搜索方法, 如果没有找到, 就使用 super_class 指针到父类中的 methodLists 查找, 一旦找到就调用方法. 如果没有找到, 有可能消息转发, 也可能忽略它. 但这样查找方式效率太低, 所以使用Cache来缓存经常调用的方法, 当调用方法时, 优先在Cache查找, 如果没有找到, 再到methodLists查找.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//cache_t结构</div><div class=\"line\">struct cache_t &#123;  </div><div class=\"line\">   struct bucket_t *_buckets;</div><div class=\"line\">   mask_t _mask;</div><div class=\"line\">   mask_t _occupied;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">typedef unsigned int uint32_t;  </div><div class=\"line\">typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits</div><div class=\"line\">    </div><div class=\"line\">typedef unsigned long  uintptr_t;  </div><div class=\"line\">typedef uintptr_t cache_key_t;</div><div class=\"line\">    </div><div class=\"line\">struct bucket_t &#123;  </div><div class=\"line\">private:  </div><div class=\"line\">   cache_key_t _key;</div><div class=\"line\">   IMP _imp;</div><div class=\"line\">public:</div><div class=\"line\">    inline cache_key_t key() const &#123; return _key; &#125;</div><div class=\"line\">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</div><div class=\"line\">    inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125;</div><div class=\"line\">    inline void setImp(IMP newImp) &#123; _imp = newImp; &#125;</div><div class=\"line\"></div><div class=\"line\">    void set(cache_key_t newKey, IMP newImp);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"class-data-bits-t\"><a href=\"#class-data-bits-t\" class=\"headerlink\" title=\"class_data_bits_t\"></a><span id=\"class_data_bits_t\">class_data_bits_t</span></h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//class_data_bits_t结构</div><div class=\"line\">struct class_data_bits_t &#123;</div><div class=\"line\">   // Values are the FAST_ flags above.</div><div class=\"line\">   uintptr_t bits;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">struct class_rw_t &#123;  </div><div class=\"line\">   uint32_t flags;</div><div class=\"line\">   uint32_t version;</div><div class=\"line\">    </div><div class=\"line\">   const class_ro_t *ro;</div><div class=\"line\">    </div><div class=\"line\">   method_array_t methods;</div><div class=\"line\">   property_array_t properties;</div><div class=\"line\">   protocol_array_t protocols;</div><div class=\"line\">    </div><div class=\"line\">   Class firstSubclass;</div><div class=\"line\">   Class nextSiblingClass;</div><div class=\"line\">    </div><div class=\"line\">   char *demangledName;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">struct class_ro_t &#123;  </div><div class=\"line\">   uint32_t flags;</div><div class=\"line\">   uint32_t instanceStart;</div><div class=\"line\">   uint32_t instanceSize;</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">   uint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\">    </div><div class=\"line\">   const uint8_t * ivarLayout;</div><div class=\"line\">   </div><div class=\"line\">   const char * name;</div><div class=\"line\">   method_list_t * baseMethodList;</div><div class=\"line\">   protocol_list_t * baseProtocols;</div><div class=\"line\">   const ivar_list_t * ivars;</div><div class=\"line\">    </div><div class=\"line\">   const uint8_t * weakIvarLayout;</div><div class=\"line\">   property_list_t *baseProperties;</div><div class=\"line\">    </div><div class=\"line\">   method_list_t *baseMethods() const &#123;</div><div class=\"line\">       return baseMethodList;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><img src=\"https://ob6mci30g.qnssl.com/Blog/ArticleImage/23_15.png\" alt=\"class_data_bits_t\"></p>\n<p>上面这张图很好地说明了 class_data_bits_t 的作用. 详见<a href=\"https://github.com/Draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-objc-%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"noopener\">深入解析 ObjC 中方法的结构</a>. 大致说明一下就是, Objc的类的属性, 方法, 以及遵循的协议在obj 2.0的版本之后都放在 class_rw_t 中. class_ro_t 是一个指向常量的指针, 存储来编译器决定了的属性、方法和遵守协议. 在运行时发消息时, 会从 class_data_bits_t 调用 data 方法, 将结果从 class_rw_t 强制转换为 class_ro_t 指针. 最后调用 methodizeClass 方法, 把类里面的属性, 协议, 方法都加载进来.</p>\n<h2 id=\"方法与消息\"><a href=\"#方法与消息\" class=\"headerlink\" title=\"方法与消息\"></a>方法与消息</h2><h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p>SEL 又叫做方法选择器, 是表示一个方法的 selector 的指针, 定义如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>\n<p>Objective-C在编译时, 会依据每一个方法的名字, 参数序列, 生成一个唯一的整型标识(Int类型的地址), 这个标识就是SEL. 不同类的不同方法, 只要方法名相同, 哪怕参数类型不同, 这两个方法的SEL就是一样的. 同一个类中就不能存在两个方法, 方法名一致, 参数不一致, 这样是会编译错误的. 但是不同的类就可以, 因为不同的类的实例对象执行方法时, 是从各自类的方法列表中根据selector去寻找自己对应的IMP. </p>\n<p>工程中所有的SEL组合成一个set集合, 因此SEL是唯一的. set中的元素都是唯一的, 所以SEL也是唯一的, 所以我们找一个selector, 通过他对应的SEL是最快的方法. SEL实际就是根据方法名Hash过的一个字符串(这也解释了上面相同方法名编译为什么报错的原因), 字符串的比较只需比较地址就可以了, 速度十分快. 本质上, SEL只是一个指向方法的指针(准确的说, 只是一个根据方法名hash化了的KEY值, 能唯一代表一个方法), 它的存在只是为了加快方法的查询速度.</p>\n<p>我们可以在运行时添加和获取selector, 也可以通过下面几种方式来获取SEL:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1. sel_registerName函数</div><div class=\"line\">2. Objective-C编译器提供的@selector()</div><div class=\"line\">3. NSSelectorFromString()方法</div></pre></td></tr></table></figure>\n<h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><p>IMP实际上是一个函数指针, 指向方法实现的地址. 定义如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">id (*IMP)(id, SEL,...)</div></pre></td></tr></table></figure>\n<p>该函数的第一个参数是self的指针, 如果是实例方法, 则是类实例的内存地址; 如果是类方法, 则是指向元类的指针. 第二个参数是方法选择器, 后面是方法的参数列表. </p>\n<p>每个方法对应唯一的SEL, 我们通过SEL就是为了查找方法的最终实现IMP, 而IMP这个函数指针指向了最终的这个方法的实现, 取得IMP后, 我们就获得了执行这个方法代码的入口点. 通过取得IMP, 我们可以跳过Runtime的消息传递机制, 直接执行IMP指向的函数实现, 这样省去了Runtime消息传递过程中所做的一系列查找操作, 会比直接向对象发送消息高效一些.</p>\n<p>通过一组id和SEL参数就能确定唯一的方法实现地址, 而一个确定的方法也只有唯一的一组id和SEL参数.</p>\n<h3 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h3><p>Method用于表示类定义中的方法, 定义如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">struct method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\"></div><div class=\"line\">    struct SortBySELAddress :</div><div class=\"line\">        public std::binary_function&lt;const method_t&amp;,</div><div class=\"line\">                                    const method_t&amp;, bool&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        bool operator() (const method_t&amp; lhs,</div><div class=\"line\">                         const method_t&amp; rhs)</div><div class=\"line\">        &#123; return lhs.name &lt; rhs.name; &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们可以看到, 该结构体包含有 name(方法名, 本质是IMP), types(方法类型, 本质是个char指针, 存储方法的参数类型和返回值), imp(方法指向, 本质是个IMP, 也可以说是函数指针). 该结构体实际上相当于在 SEL 和 IMP 之间做了一个映射, 让我们可以通过 SEL 快速的找到 IMP.</p>\n<h2 id=\"成员变量与属性\"><a href=\"#成员变量与属性\" class=\"headerlink\" title=\"成员变量与属性\"></a>成员变量与属性</h2><h3 id=\"Ivar\"><a href=\"#Ivar\" class=\"headerlink\" title=\"Ivar\"></a>Ivar</h3><p>Ivar用来表示实例变量, 其实际是一个指向 objc_ivar 结构体的指针, 定义如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef struct objc_ivar *Ivar;</div><div class=\"line\"></div><div class=\"line\">struct ivar_t &#123;</div><div class=\"line\">    int32_t *offset;//表示基地址偏移字节</div><div class=\"line\">    const char *name;</div><div class=\"line\">    const char *type;</div><div class=\"line\">    // alignment is sometimes -1; use alignment() instead</div><div class=\"line\">    uint32_t alignment_raw;</div><div class=\"line\">    uint32_t size;</div><div class=\"line\"></div><div class=\"line\">    uint32_t alignment() const &#123;</div><div class=\"line\">        if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT;</div><div class=\"line\">        return 1 &lt;&lt; alignment_raw;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>关于Ivar我们需要知道以下几点: </p>\n<ol>\n<li>我们对 ivar 的访问就可以通过 对象地址 ＋ Ivar偏移字节的方法来访问, 但是如果增加了父类的Ivar, 那怎么办, Objective-C使用Non Fragile Ivars机制, Runtime会进行检测来调整类中新增的ivar的偏移量, 这样我们就可以通过 对象地址 + 基类大小 + ivar偏移字节的方法来计算出ivar相应的地址, 并访问到相应的ivar, 而不用重新编译子类.</li>\n<li>我们无法通过-&gt;函数来修改私有属性, 但是我们可以通过对象地址 + Ivar偏移量来访问地址, 获取到指针后直接修改.</li>\n<li>属性实际就是Ivar加上系统自动为我们生成的get和set方法.</li>\n</ol>\n<h3 id=\"objc-property-t\"><a href=\"#objc-property-t\" class=\"headerlink\" title=\"objc_property_t\"></a>objc_property_t</h3><p>@property 标记了类中的属性, 他是一个指向 objc_property 结构体的指针:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef struct property_t *objc_property_t;</div></pre></td></tr></table></figure>\n<p>需要注意的是, 与 class_copyIvarList 函数不同, 使用 class_copyPropertyList 函数只能获取类的属性, 而不包含成员变量, 但此时获取的属性名是不带下划线的.</p>\n<p>更多姿势可以看<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h3 id=\"protocol-t\"><a href=\"#protocol-t\" class=\"headerlink\" title=\"protocol_t\"></a>protocol_t</h3><p>这个没啥好讲的, 直接看定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">struct protocol_t : objc_object &#123;</div><div class=\"line\">    const char *mangledName;</div><div class=\"line\">    struct protocol_list_t *protocols;</div><div class=\"line\">    method_list_t *instanceMethods;</div><div class=\"line\">    method_list_t *classMethods;</div><div class=\"line\">    method_list_t *optionalInstanceMethods;</div><div class=\"line\">    method_list_t *optionalClassMethods;</div><div class=\"line\">    property_list_t *instanceProperties;</div><div class=\"line\">    uint32_t size;   // sizeof(protocol_t)</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    // Fields below this point are not always present on disk.</div><div class=\"line\">    const char **_extendedMethodTypes;</div><div class=\"line\">    const char *_demangledName;</div><div class=\"line\">    property_list_t *_classProperties;</div><div class=\"line\">    ... 省略一些封装的便捷 get 方法</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Category\"><a href=\"#Category\" class=\"headerlink\" title=\"Category\"></a>Category</h2><p>美团的<a href=\"https://tech.meituan.com/DiveIntoCategory.html\" target=\"_blank\" rel=\"noopener\">这篇</a>讲的具详细, 这里我们就大概说一下.<br>Category(分类), 他为现有的类提供了扩展, 它是 category_t 结构体的指针.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef struct category_t *Category;</div><div class=\"line\"></div><div class=\"line\">typedef struct category_t &#123;</div><div class=\"line\">    const char *name;//类的名字</div><div class=\"line\">    classref_t cls;//类</div><div class=\"line\">    struct method_list_t *instanceMethods;//category中所有给类添加的实例方法的列表</div><div class=\"line\">    struct method_list_t *classMethods;//给所有类添加类方法的列表</div><div class=\"line\">    struct protocol_list_t *protocols;//所有协议的列表</div><div class=\"line\">    struct property_list_t *instanceProperties;//category中添加的所有属性的列表</div><div class=\"line\">&#125; category_t;</div></pre></td></tr></table></figure>\n<p><em>从category的定义也可以看出我们可以添加实例方法, 类方法, 甚至可以实现协议, 添加属性, 但是无法添加实例变量</em>.</p>\n<p>在APP的启动过程中, 会在 <code>_read_images</code> 函数间接调用到 attachCategories 函数, 完成向类中添加 Category 的工作. 向 class_rw_t(上面<a href=\"#class_data_bits_t\">class_data_bits_t</a>中有介绍) 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针. 把category的实例方法, 协议以及属性添加到类上, 把category的类方法和协议添加到类的metaclass上.</p>\n<p>我们需要注意的是: </p>\n<ol>\n<li>category不会覆盖原类中的方法, 而是两个都存在, 但是category的在前面, 按照方法列表来找, 找到category的之后, 就不再往下找了, 造成被覆盖的假象. </li>\n<li>附加category的类的工作会先于+load方法的执行. </li>\n<li>+load的执行顺序是先类, 后category, 而category的+load执行顺序是根据编译顺序(Compile Sources中的顺序)决定的.</li>\n</ol>\n<h2 id=\"消息查找与转发\"><a href=\"#消息查找与转发\" class=\"headerlink\" title=\"消息查找与转发\"></a>消息查找与转发</h2><p>Objective-C中任何方法的调用, 编译器都会将[receiver message]转化为一个消息函数的调用, 即objc_msgSend, 消息直到运行时才绑定到方法的实现上. objc_msgSend 的定义如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>\n<p>在<a href=\"http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html\" target=\"_blank\" rel=\"noopener\">Obj-C Optimization: The faster objc_msgSend</a>中有一段 objc_msgSend 方法实现思路的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">id  c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...)  </div><div class=\"line\">&#123;</div><div class=\"line\">   struct objc_class    *cls;</div><div class=\"line\">   struct objc_cache    *cache;</div><div class=\"line\">   unsigned int         hash;</div><div class=\"line\">   struct objc_method   *method;   </div><div class=\"line\">   unsigned int         index;</div><div class=\"line\"></div><div class=\"line\">   if( self)</div><div class=\"line\">   &#123;</div><div class=\"line\">      cls   = self-&gt;isa;</div><div class=\"line\">      cache = cls-&gt;cache;</div><div class=\"line\">      hash  = cache-&gt;mask;</div><div class=\"line\">      index = (unsigned int) _cmd &amp; hash;</div><div class=\"line\"></div><div class=\"line\">      do</div><div class=\"line\">      &#123;</div><div class=\"line\">         method = cache-&gt;buckets[ index];</div><div class=\"line\">         if( ! method)</div><div class=\"line\">            goto recache;</div><div class=\"line\">         index = (index + 1) &amp; cache-&gt;mask;</div><div class=\"line\">      &#125;</div><div class=\"line\">      while( method-&gt;method_name != _cmd);</div><div class=\"line\">      return( (*method-&gt;method_imp)( (id) self, _cmd));</div><div class=\"line\">   &#125;</div><div class=\"line\">   return( (id) self);</div><div class=\"line\"></div><div class=\"line\">recache:  </div><div class=\"line\">   /* ... */</div><div class=\"line\">   return( 0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>查了一堆资料, 总结一下消息的查找和转发的过程:</p>\n<h3 id=\"消息的查找和动态解析\"><a href=\"#消息的查找和动态解析\" class=\"headerlink\" title=\"消息的查找和动态解析\"></a>消息的查找和动态解析</h3><ol>\n<li>判断 selector 是不是需要被忽略的垃圾回收用到的方法, 是的话就忽略, 不是的话继续下一步操作.</li>\n<li>判断target是不是nil, 如果这里有相应的nil的处理函数, 就跳转到相应的函数中. 如果没有处理nil的函数, 就自动清理现场并返回. 这一点就是为何在OC中给nil发送消息不会崩溃的原因.</li>\n<li>查找当前类的缓存, 如果命中缓存获取到了IMP就将IMP返回, 如果没有继续下一步操作.</li>\n<li>在当前类的方法列表中查找(根据 selector 查找到 Method 后, 获取 Method 中的 IMP), 对已经排序的列表使用二分法查找, 未排序的列表则是线性遍历. 如果找到把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作.</li>\n<li>在继承层级中递归向父类(一直到 NSObject 为止)中查找, 情况跟上一步类似, 也是先查找缓存, 缓存没中就查找方法列表, 查到后就终止递归查询, 把方法加入 cache 并且把IMP返回, 如果没找到继续下一步操作.</li>\n<li><p>在消息查找阶段, 如果没找到IMP(也就是接收到未知的消息), 会进入动态方法解析阶段, 首先会调用所属类的<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)方法. 前提是我们必须自己实现该方法, 并且添加到类里面.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">void functionForMethod1(id self, SEL _cmd) &#123;</div><div class=\"line\">   NSLog(@&quot;%@, %p&quot;, self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\">\t</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class=\"line\">    NSString *selectorString = NSStringFromSelector(sel);</div><div class=\"line\">    if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123;</div><div class=\"line\">        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>此时如果既没有没查找到 IMP, 动态方法解析也不奏效, 那么就进入了下一个阶段-消息转发阶段.</p>\n</li>\n</ol>\n<h3 id=\"消息的转发\"><a href=\"#消息的转发\" class=\"headerlink\" title=\"消息的转发\"></a><span id=\"消息的转发\">消息的转发</span></h3><p>上面主要是消息的查找阶段主要完成的是通过select()快速查找IMP的过程, 接下来才是消息的转发阶段, 到了转发阶段, 会调用到了转发阶段, 会调用<code>id _objc_msgForward(id self, SEL _cmd,...)</code>方法. 在执行<code>_objc_msgForward</code>之后会调用 <code>__objc_forward_handler</code>函数. 它的实现大致如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Default forward handler halts the process.</div><div class=\"line\">__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)  </div><div class=\"line\">&#123;</div><div class=\"line\">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class=\"line\">                &quot;(no message forward handler is installed)&quot;, </div><div class=\"line\">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                object_getClassName(self), sel_getName(sel), self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当我们给一个对象发送一个没有实现的方法的时候, 如果其父类也没有这个方法, 则会崩溃, 报错信息类似于这样: unrecognized selector sent to instance, 然后接着会跳出一些堆栈信息. 这些信息就是从这里而来. </p>\n<ol>\n<li><p>如果上面的查找和解析都失败的话, 消息就会无法处理, 这是Runtime会调用以下方法:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>\n<p> 我们可以通过重写- (id)forwardingTargetForSelector:(SEL)aSelector方法来把消息的接受者换成一个可以处理该消息的实例对象或者类对象. 示例如下:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class=\"line\">&#123;</div><div class=\"line\">    if(aSelector == @selector(Method:))&#123;</div><div class=\"line\">        return otherObject;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class=\"line\">    if(aSelector == @selector(xxx)) &#123;</div><div class=\"line\">        return NSClassFromString(@&quot;Class name&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 如果一个对象实现了这个方法, 并返回一个非nil的结果, 则这个对象会作为消息的新接收者, 且消息会被分发到这个对象. 当然这个对象不能是self自身, 否则就是出现无限循环. 如果我们没有指定相应的对象来处理aSelector, 则应该调用父类的实现来返回结果. 这一步合适于我们只想将消息转发到另一个能处理该消息的对象上, 但这一步无法对消息进行处理, 如操作消息的参数和返回值.</p>\n</li>\n<li><p>如果在上一步还不能处理未知消息, 则唯一能做的就是启用完整的消息转发机制了. 运行时系统会给消息接收者最后一次机会将消息转发给其它对象. 我们首先要通过, 指定方法签名, 若返回nil, 则表示不处理. </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class=\"line\">   if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123;</div><div class=\"line\">     return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];</div><div class=\"line\">  &#125;  </div><div class=\"line\">return [super methodSignatureForSelector: aSelector];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 若返回方法签名, 则会进入下一步调用.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)forwardInvovation:(NSInvocation)anInvocation &#123;</div><div class=\"line\">    if ([someOtherObject respondsToSelector:</div><div class=\"line\">            [anInvocation selector]]) &#123;</div><div class=\"line\">        [anInvocation invokeWithTarget:someOtherObject];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        [super forwardInvocation:anInvocation];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 该方法对象会创建一个表示消息的NSInvocation对象, 把与尚未处理的消息有关的全部细节都封装在anInvocation中, 包括selector, 目标(target)和参数. 我们可以在forwardInvocation方法中选择将消息转发给其它对象. 我们可以通过anInvocation对象做很多处理, 比如修改实现方法, 修改响应对象等.</p>\n<p> 这个方法的主要作用是定位可以响应封装在anInvocation中的消息的对象(这个对象不需要能处理所有未知消息). 使用anInvocation作为参数, 将消息发送到选中的对象. anInvocation将会保留调用结果, 运行时系统会提取这一结果并将其发送到消息的原始发送者. 在这个方法中我们也可以实现一些更复杂的功能, 我们可以对消息的内容进行修改, 比如追回一个参数等, 然后再去触发消息. 另外, 若发现某个消息不应由本类处理, 则应调用父类的同名方法, 以便继承体系中的每个类都有机会处理此调用请求.</p>\n</li>\n<li><p>上面两个补救措施做完后, 若发现某调用不应由本类处理, 则会调用超类的同名方法. 如此, 继承体系中的每个类都有机会处理该方法调用的请求, 一直到NSObject根类. 如果到NSObject也不能处理该条消息, 那么就是再无挽救措施了, 只能抛出”doesNotRecognizeSelector”异常.</p>\n</li>\n</ol>\n<h2 id=\"Runtime经典问题分析\"><a href=\"#Runtime经典问题分析\" class=\"headerlink\" title=\"Runtime经典问题分析\"></a>Runtime经典问题分析</h2><p>这里有几个网络上常见的Runtime经典问题, 下面我会逐个分析.</p>\n<h3 id=\"self-class-与-super-class\"><a href=\"#self-class-与-super-class\" class=\"headerlink\" title=\"[self class]与[super class]\"></a>[self class]与[super class]</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"> @implementation Son : Father</div><div class=\"line\">- (id)init &#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self)</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</div><div class=\"line\">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如题, 先说结果: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2018-03-15 20:02:57.031501+0800 HCRuntime[8115:645357] Son</div><div class=\"line\">2018-03-15 20:02:57.034428+0800 HCRuntime[8115:645357] Son</div></pre></td></tr></table></figure>\n<p>首先我们有几个概念要理解: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//[self class]实际是调用objc_msgSend方法</div><div class=\"line\">id objc_msgSend(id self, SEL op, ...)</div><div class=\"line\">//[super class]实际是调用objc_msgSendSuper方法</div><div class=\"line\">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</div><div class=\"line\"></div><div class=\"line\">struct objc_super &#123;</div><div class=\"line\">   __unsafe_unretained id receiver;//类似于objc_msgSend中的self</div><div class=\"line\">   __unsafe_unretained Class super_class;//记录当前类的父类是什么</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">- (Class)class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>self 和 super 的唯一区别是, 当使用 self 调用方法时, 会从当前类的方法列表中开始找, 如果没有, 就从父类中再找; 而当使用 super 时, 则从父类的方法列表中开始找, 然后调用父类的这个方法. self 是类的隐藏参数, 指向当前调用方法的这个类的实例. 而 super 是一个 Magic Keyword, 它本质是一个编译器标示符, 和 self 是指向的同一个消息接受者.</p>\n<p>结合本题, 当调用<code>[self class]</code>时, 先调用的是 <code>objc_msgSend</code> 函数, 第一个参数是<code>Son</code>这个类的实例, 然后去示例的ISA(Son类)中找 <code>- (Class)class</code> 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 而 <code>- (Class)class</code> 的实现就是返回self的类别, 故上述输出结果为 Son.<br>当调用<code>[super class]</code>时, 先调用的是<code>class_getSuperclass</code>函数, 该函数第一个参数是结构体 <code>objc_super</code>(第一个参数是self, 第二个参数是当前实例变量的super_class, 就是Father类). 然后直接从实例变量所在类的父类(Father)去找<code>- (Class)class</code> 这个方法, 没找到, 然后去Son类的父类(Father类)中找, 没找到, 一直找到NSObject类中找到. 最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用, 此时已经和<code>[self class]</code>调用相同了, 故上述输出结果仍然返回 Son.</p>\n<h3 id=\"isKindOfClass与isMemberOfClass\"><a href=\"#isKindOfClass与isMemberOfClass\" class=\"headerlink\" title=\"isKindOfClass与isMemberOfClass\"></a>isKindOfClass与isMemberOfClass</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface Student : NSObject</div><div class=\"line\">@end</div><div class=\"line\">@implementation Student</div><div class=\"line\">@end</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];</div><div class=\"line\">        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];</div><div class=\"line\">        BOOL res3 = [(id)[Student class] isKindOfClass:[Student class]];</div><div class=\"line\">        BOOL res4 = [(id)[Student class] isMemberOfClass:[Student class]];</div><div class=\"line\">        NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如题, 先说结果: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2018-03-15 21:33:16.047955+0800 HCRuntime[8721:695376] 1 0 0 0</div></pre></td></tr></table></figure>\n<p>再来进行分析, 这里主要的知识点是类, 原类, 实例变量之间的关系, 以及三个函数的内部实现: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (Class)class &#123;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (Class)class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Class object_getClass(id obj) &#123;</div><div class=\"line\">    if (obj) return obj-&gt;getIsa();</div><div class=\"line\">    else return Nil;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isKindOf:(Class)cls &#123;</div><div class=\"line\">    Class cls;</div><div class=\"line\">    for (cls = isa; cls; cls = cls-&gt;superclass) </div><div class=\"line\">        if (cls == (Class)aClass)</div><div class=\"line\">            return YES;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class=\"line\">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class=\"line\">        if (tcls == cls) return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isMemberOf:(Class)cls &#123;</div><div class=\"line\">    return [self class] == cls;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class=\"line\">    return object_getClass((id)self) == cls;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来我们挨个分析: </p>\n<ol>\n<li><code>[(id)[NSObject class] isKindOfClass:[NSObject class]]</code>; <code>[NSObject class]</code>返回NSObject(Class), 所以走类方法. cls是NSObject(Class). 第一次比较, tcls是object_getClass((id)self)也就是NSObject(Class)的ISA也就是NSObject(Class)的Meta Class, 两者不相等, 第二次比较, cls是NSObject(Class), tcls是NSObject(Class)的Meta Class的superclass, 也就是NSObject(Class), 两者相等, 循环结束, 返回YES.</li>\n<li><code>[(id)[NSObject class] isMemberOfClass:[NSObject class]]</code>; 因为<code>[NSObject class]</code>返回NSObject(Class), 所以走类方法. 只比较一次, cls是NSObject(Class), object_getClass((id)self)也就是NSObject(Class)的ISA也就是NSObject(Class)的Meta Class, 两者不相等, 返回NO;</li>\n<li><p><code>[(id)[Student class] isKindOfClass:[Student class]]</code>; 类似于第一题, <code>[Student class]</code>返回Student(Class), 所以走类方法. cls是Student(Class). 第一次比较, tcls是Student(Class)的ISA, 也就是Student(Class)的Meta Class, 不相等. 第二次比较, tcls是Student(Class)的Meta Class的superclass, 也就是NSObject的Meta Class, 不相等. 第三次比较, tcls是NSObject的Meta Class的superclass也就是NSObject(Class), 不相等. 第四次比较. tcls是NSObject(Class)的superclass, 是nil, 不相等. 至此不满足循环条件, 退出循环, 返回NO;</p>\n<p> 这里需要注意的是如果是<code>[(id)[[[Student alloc] init] class] isKindOfClass:[Student class]]</code>的话, <code>[Student alloc] init]</code>返回一个实例变量, 所以走实例方法. cls是Student(Class). 第一次比较, tcls是Student(Object)的ISA, 也就是Student(Class), 相等, 循环结束, 返回YES;</p>\n</li>\n<li><code>[(id)[Student class] isMemberOfClass:[Student class]]</code>; 类似于第二题, <code>[Student class]</code>返回Student(Class), 所以走类方法, 只比较一次. cls是Student(Class), <code>object_getClass((id)self)</code>是Student(Class)的ISA, 也就是Student(Class)的Meta Class, 两者不相等, 返回NO;</li>\n</ol>\n<h3 id=\"Class与内存地址\"><a href=\"#Class与内存地址\" class=\"headerlink\" title=\"Class与内存地址\"></a>Class与内存地址</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface Student : NSObject</div><div class=\"line\">@property (nonatomic, copy) NSString *name;</div><div class=\"line\">- (void)speak;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Student</div><div class=\"line\">- (void)speak &#123;                            </div><div class=\"line\">   NSLog(@&quot;my name&apos;s %@&quot;, self.name);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;  </div><div class=\"line\">  [super viewDidLoad];</div><div class=\"line\">  id cls = [Student class];</div><div class=\"line\">  void *obj = &amp;cls;</div><div class=\"line\">  [(__bridge id)obj speak];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如题, 先说结果: 程序可以正常运行, 结果如下:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2018-03-15 22:45:52.486617+0800 HCRuntime[9838:786076] my name&apos;s &lt;ViewController: 0x7fc349d0a670&gt;</div></pre></td></tr></table></figure>\n<p>接下来我们分析一下都发生了什么. 首先, obj被转换成了一个指向<code>[Student class]</code>的指针, 然后使用<code>(__bridge id)</code>转换成了 objc_object 类型, 这时候实际上已经是一个Student类型的实例对象了, 所以可以正常调用speak方法. 那么调用speak方法会输出什么呢? 我们接下来分析.</p>\n<p>首先我们要知道, Objective-C中的对象是一个指向ClassObject地址的变量, 即 id obj = &amp;ClassObject, 而对象的实例变量 void *ivar = &amp;obj + offset(N). 在C中局部变量是存储到内存的栈区, 程序运行时栈的地址从高到低. C语言到头来讲是一个顺序运行的语言, 随着程序运行, 栈中的地址越来越低. 我们来看下程序运行到执行到speak方法时, 栈中都放了哪些变量. </p>\n<p>首先, 执行会有两个隐藏参数传进来 self() 和 _cmd这两个参数依次被压入栈中. 然后调用<code>[super viewDidload]</code>方法, 这个方法实际是调用的<code>OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...)</code>, <code>objc_msgSendSuper2</code>方法入参是一个<code>objc_super *super</code>, <code>objc_super</code>的结构如下.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">struct objc_super &#123;  </div><div class=\"line\">    /// Specifies an instance of a class.</div><div class=\"line\">    __unsafe_unretained id receiver;</div><div class=\"line\"></div><div class=\"line\">    /// Specifies the particular superclass of the instance to message. </div><div class=\"line\">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</div><div class=\"line\">    /* For compatibility with old objc-runtime.h header */</div><div class=\"line\">    __unsafe_unretained Class class;</div><div class=\"line\">#else</div><div class=\"line\">    __unsafe_unretained Class super_class;</div><div class=\"line\">#endif</div><div class=\"line\">    /* super_class is the first class to search */</div><div class=\"line\">&#125;;</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>在调用<code>[super viewDidload]</code>方法时, 又产生了几个局部变量, <code>super_class</code>(等同于self.class)和<code>receiver</code>(等同于self), 依次被压入栈. 调用完<code>[super viewDidload]</code>方法后, 又产生了一个局部变量obj, 被压入栈.</p>\n<p>这时候栈中一共有五个变量, 地址从高到低分别是: 第一个是self和第二个是隐藏参数_cmd, 第三个是self.class和第四个self是<code>[super viewDidLoad]</code>方法执行时候的参数, 第五个是obj. 当我们调用self.name的时候, 本质上就是self指针在内存向高位地址偏移一个指针. 如果我们打印对象地址就可以看出, obj就是cls的地址, obj就是Student(Object), 所以self.name也就是obj的地址向上偏移一个指针, 指向了第四个参数self, 也就是viewController的地址.</p>\n<h3 id=\"Category-1\"><a href=\"#Category-1\" class=\"headerlink\" title=\"Category\"></a>Category</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">下面的代码会？Compile Error / Runtime Crash / NSLog…?</div><div class=\"line\"></div><div class=\"line\"> @interface NSObject (Student)</div><div class=\"line\"> + (void)foo;</div><div class=\"line\"> - (void)foo;</div><div class=\"line\"> @end</div><div class=\"line\"></div><div class=\"line\"> @implementation NSObject (Student)</div><div class=\"line\"> - (void)foo &#123;</div><div class=\"line\">    NSLog(@&quot;IMP: -[NSObject(Student) foo]&quot;);</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#import &quot;NSObject+Student.h&quot;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        [NSObject foo];</div><div class=\"line\">        [[NSObject new] foo];</div><div class=\"line\"></div><div class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如题, 先说结果, 程序可以正常运行, 结果如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2018-03-17 22:47:42.695913+0800 HCRuntime[7043:463076] IMP: -[NSObject(Student) foo]</div><div class=\"line\">2018-03-17 22:47:42.700542+0800 HCRuntime[7043:463076] IMP: -[NSObject(Student) foo]</div></pre></td></tr></table></figure>\n<p>category中新增的方法, 如果是实例方法, 协议以及属性是直接添加到当前类上面, 如果是类方法和协议则会添加到当前类的原类上面去. </p>\n<p>所以调用<code>[NSObject foo]</code>时, 由于是类方法, 根据objc_msgSend的相关知识, 会先在NSObject(Class)的isa中也就是NSObject的meta-class中, 去查找foo方法的IMP, 没找到, 然后去NSObject的meta-class的superclass(NSObject)中找, 找到了, 执行foo方法. 调用<code>[[NSObject new] foo]</code>时, 会先在NSObject(Object)的isa中, 也就是NSObject(Class)中找, 找到了, 直接执行, 输出结果.</p>\n<h2 id=\"Runtime的常见用法\"><a href=\"#Runtime的常见用法\" class=\"headerlink\" title=\"Runtime的常见用法\"></a>Runtime的常见用法</h2><p>讲了那么多, 下面看下Runtime在实际应用中主要有用法. </p>\n<h3 id=\"实现多继承Multiple-Inheritance\"><a href=\"#实现多继承Multiple-Inheritance\" class=\"headerlink\" title=\"实现多继承Multiple Inheritance\"></a>实现多继承Multiple Inheritance</h3><p>转发和继承相似, 可以用于为Objc编程添加一些多继承的效果, 但是本身是不支持多继承的, 但是我们可以通过消息转发机制来实现多继承的功能. </p>\n<p>消息转发提供了许多类似于多继承的特性, 但是他们之间有一个很大的不同. 多继承合并了不同的行为特征在一个单独的对象中, 会得到一个重量级多层面的对象. 而消息转发则是将各个功能分散到不同的对象中, 得到的一些轻量级的对象, 这些对象通过消息转发联合起来.</p>\n<p>我们要重写消息转发函数, 并在其中, 把我们想要转发的类做一个判断, 类似与下面代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//我们在A类中重写他的消息转发方法, 把他转发给B类的对象</div><div class=\"line\">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector &#123;</div><div class=\"line\">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</div><div class=\"line\">    if (!signature) &#123;</div><div class=\"line\">        signature = [objectB methodSignatureForSelector:selector];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return signature;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样, 虽然我们可以正常运行这个方法, 但是如果我们调用<code>respondsToSelector:</code>, <code>isKindOfClass:</code>和 <code>instancesRespondToSelector:</code>方法, 还有如果我们使用了协议, 那么<code>conformsToProtocol:</code>和上面三个方法都是要被重写的, 因为这类方法只会考虑继承体系, 不会考虑转发链. </p>\n<h3 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h3><p>Method Swizzling本质上就是对IMP和SEL进行交换, 当Method Swilzzling代码执行完毕之后互换才起作用, Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式. 我们替换ViewController的<code>viewWillAppear:</code>方法为例, 使用方式如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@implementation ViewController (MethodSwizzling)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    static dispatch_once_t once;</div><div class=\"line\">    dispatch_once(&amp;once, ^&#123;</div><div class=\"line\">        Class class = [self class];</div><div class=\"line\">        //这里需要注意, 如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class, 但前者为元类, 后者为其本身.</div><div class=\"line\">        // Class class = object_getClass((id)self);</div><div class=\"line\">        SEL originalSelector = @selector(viewWillAppear:);</div><div class=\"line\">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class=\"line\">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class=\"line\">        //我们先把要替换的类添加到category中</div><div class=\"line\">        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class=\"line\">        if (didAddMethod) &#123;</div><div class=\"line\">            //class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现</div><div class=\"line\">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            //交换IMP, IMP是函数指针, 直接指向方法的内存地址</div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class=\"line\">    [self xxx_viewWillAppear:animated];</div><div class=\"line\">    NSLog(@&quot;%@ viewWillAppear&quot;, self);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这里有几点是要注意的: </p>\n<ol>\n<li>Objective-C在运行时会自动调用类的两个方法<code>+load</code>和<code>+initialize</code>. <code>+load</code>会在类初始加载时调用, <code>+initialize</code>方法是以懒加载的方式被调用的, 只有当你给某个类或它的子类发送消息, 那么这个类的<code>+initialize</code>方法才会被调用. 所以Swizzling要写在<code>+load</code>方法中, 因为写在<code>+initialize</code>方法中, 是有可能永远都不被执行. </li>\n<li>Swizzling应该只被执行一次, 如果Swizzling的方法被多次执行, 那么就有可能造成Swizzling失效, 所以我们要用dispatch_once来保证只被执行一次. </li>\n<li>Swizzling在<code>+load</code>中执行时, 不要调用<code>[super load]</code>. 如果是多继承, 并且对同一个方法都进行了Swizzling, 那么调用[super load]以后, 父类的Swizzling就失效了.</li>\n<li>在swizzling的过程中, 方法中的<code>[self xxx_viewWillAppear:animated]</code>已经被重新指定到UIViewController类的<code>-viewWillAppear:</code>中. 这时不会产生无限循环. 如果我们调用的是<code>[self viewWillAppear:animated]</code>, 因为<code>viewWillAppear:</code>被重定向到<code>xxx_viewWillAppear:</code>, 就会产生无限循环.</li>\n<li>如果要Swizzling类方法则要获取当前类的原类, 因为根据objc_msgSend, 实例方法我们从对象的isa也就是对象所在的类中开始找, 类方法则是从类的isa也就是类的原类中开始找. <code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 Class, 但前者为元类, 后者为其本身.</li>\n<li>我们也可以使用这个来做一些异常保护, 例如数组的越界问题, 我们可以Swizzling数组的<code>objectAtIndex:</code>方法, 在新方法中做一些异常处理, 来抛出一些异常信息, 方便我们定位问题.<h3 id=\"Isa-Swizzling\"><a href=\"#Isa-Swizzling\" class=\"headerlink\" title=\"Isa Swizzling\"></a>Isa Swizzling</h3>在Objective-C中, 所有的类自身也是一个对象, 这个对象的Class里面也有一个isa指针, 它指向metaClass(元类). 而消息的转发objc_msgSend也是从他的isa开始查找方法列表, 所以如果我们替换了isa, 实际也相当于替换了类. </li>\n</ol>\n<p>可以参考<a href=\"http://hchong.net/2018/01/24/KVO%E8%AF%A6%E8%A7%A3/\">KVO的实现</a>. KVO在调用addObserver方法之后, 苹果的做法是在执行完 <code>addObserver: forKeyPath: options: context:</code> 方法之后, 把isa指向到另外一个类去. </p>\n<h3 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h3><p>面向切面编程, 常用的第三方库有一个<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a>. 他的实现逻辑我们可以看<a href=\"\">这篇文章</a>. 下面我们来分析一下我们如何为自己实现一个AOP.</p>\n<p>AOP的多数操作就是在forwardInvocation(<a href=\"#消息的转发\">消息转发的第二阶段</a>)中完成的. 一般会分为2个阶段, 一个是Intercepter注册阶段, 一个是Intercepter执行阶段.</p>\n<p>首先会把类里面的某个要切片的方法的IMP加入到Aspect中, 类方法里面如果有forwardingTargetForSelector:的IMP, 也要加入到Aspect中. 然后对类的切片方法和forwardingTargetForSelector:的IMP进行替换, 两者的IMP相应的替换为objc_msgForward()方法和hook过的forwardingTargetForSelector:. 这样主要的Intercepter注册就完成了. </p>\n<p>当执行func()方法的时候, 会去查找它的IMP, 现在它的IMP已经被我们替换为了objc_msgForward()方法, 于是开始查找备援转发对象. 查找备援接受者调用forwardingTargetForSelector:这个方法, 由于这里是被我们hook过的, 所以IMP指向的是hook过的forwardingTargetForSelector:方法. 这里我们会返回Aspect的target, 即选取Aspect作为备援接受者. 有了备援接受者之后, 就会重新objc_msgSend. 从消息发送阶段重头开始. objc_msgSend找不到指定的IMP, 再进行_class_resolveMethod, 这里也没有找到, forwardingTargetForSelector:这里也不做处理, 接着就会methodSignatureForSelector. 在methodSignatureForSelector方法中创建一个NSInvocation对象, 传递给最终的forwardInvocation方法. </p>\n<p>Aspect里面的forwardInvocation方法会干所有切面的事情. 这里转发逻辑就完全由我们自定义了. Intercepter注册的时候我们也加入了原来方法中的method()和forwardingTargetForSelector:方法的IMP, 这里我们可以在forwardInvocation方法中去执行这些IMP. 在执行这些IMP的前后都可以任意的插入任何IMP以达到切面的目的.</p>\n<h3 id=\"动态的增加方法\"><a href=\"#动态的增加方法\" class=\"headerlink\" title=\"动态的增加方法\"></a>动态的增加方法</h3><p>在消息发送阶段, 如果在父类中也没有找到相应的IMP, 就会执行resolveInstanceMethod方法. 在这个方法里面, 我们可以动态的给类对象或者实例对象动态的增加方法. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class=\"line\">    </div><div class=\"line\">    NSString *selectorString = NSStringFromSelector(sel);</div><div class=\"line\">    if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123;</div><div class=\"line\">        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于方法操作的函数还有以下这些: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 调用指定方法的实现</div><div class=\"line\">id method_invoke ( id receiver, Method m, ... );  </div><div class=\"line\">// 调用返回一个数据结构的方法的实现</div><div class=\"line\">void method_invoke_stret ( id receiver, Method m, ... );  </div><div class=\"line\">// 获取方法名</div><div class=\"line\">SEL method_getName ( Method m );  </div><div class=\"line\">// 返回方法的实现</div><div class=\"line\">IMP method_getImplementation ( Method m );  </div><div class=\"line\">// 获取描述方法参数和返回值类型的字符串</div><div class=\"line\">const char * method_getTypeEncoding ( Method m );  </div><div class=\"line\">// 获取方法的返回值类型的字符串</div><div class=\"line\">char * method_copyReturnType ( Method m );  </div><div class=\"line\">// 获取方法的指定位置参数的类型字符串</div><div class=\"line\">char * method_copyArgumentType ( Method m, unsigned int index );  </div><div class=\"line\">// 通过引用返回方法的返回值类型字符串</div><div class=\"line\">void method_getReturnType ( Method m, char *dst, size_t dst_len );  </div><div class=\"line\">// 返回方法的参数的个数</div><div class=\"line\">unsigned int method_getNumberOfArguments ( Method m );  </div><div class=\"line\">// 通过引用返回方法指定位置参数的类型字符串</div><div class=\"line\">void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );  </div><div class=\"line\">// 返回指定方法的方法描述结构体</div><div class=\"line\">struct objc_method_description * method_getDescription ( Method m );  </div><div class=\"line\">// 设置方法的实现</div><div class=\"line\">IMP method_setImplementation ( Method m, IMP imp );  </div><div class=\"line\">// 交换两个方法的实现</div><div class=\"line\">void method_exchangeImplementations ( Method m1, Method m2 );</div></pre></td></tr></table></figure>\n<h3 id=\"动态关联对象\"><a href=\"#动态关联对象\" class=\"headerlink\" title=\"动态关联对象\"></a>动态关联对象</h3><p>实现原理<a href=\"http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/\" target=\"_blank\" rel=\"noopener\">看这里</a>, <a href=\"https://draveness.me/ao\" target=\"_blank\" rel=\"noopener\">看这里</a>. 这个也很常用, 主要涉及到三个函数: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)  </div><div class=\"line\">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div><div class=\"line\"></div><div class=\"line\">OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)  </div><div class=\"line\">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div><div class=\"line\"></div><div class=\"line\">OBJC_EXPORT void objc_removeAssociatedObjects(id object)  </div><div class=\"line\">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure>\n<p>上面需要传入的几个参数的含义:</p>\n<ol>\n<li><p>id object 设置关联对象的实例对象</p>\n</li>\n<li><p>const void *key 区分不同的关联对象的 key。这里会有3种写法。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//使用 &amp;AssociatedObjectKey 作为key值</div><div class=\"line\">static char AssociatedObjectKey = &quot;AssociatedKey&quot;;</div><div class=\"line\"></div><div class=\"line\">//使用AssociatedKey 作为key值</div><div class=\"line\">static const void *AssociatedKey = &quot;AssociatedKey&quot;;</div><div class=\"line\"></div><div class=\"line\">//使用@selector    </div><div class=\"line\">@selector(associatedKey)</div></pre></td></tr></table></figure>\n</li>\n<li><p>id value 关联的对象</p>\n</li>\n<li><p>objc_AssociationPolicy policy 关联对象的存储策略, 它是一个枚举, 与property的attribute 相对应</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class=\"line\">    //弱引用关联对象</div><div class=\"line\">    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</div><div class=\"line\">    //强引用关联对象且为非原子操作</div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </div><div class=\"line\">                                            *   The association is not made atomically. */</div><div class=\"line\">    //复制关联对象, 切位非原子操作</div><div class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </div><div class=\"line\">                                            *   The association is not made atomically. */</div><div class=\"line\">    //强引用关联对象, 且为原子操作</div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</div><div class=\"line\">                                            *   The association is made atomically. */</div><div class=\"line\">    //复制关联对象, 且为原子操作</div><div class=\"line\">    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</div><div class=\"line\">                                            *   The association is made atomically. */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>例如我们给NSobjet的category增加一个name属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface NSObject (Student)</div><div class=\"line\">- (NSString *)name;</div><div class=\"line\"></div><div class=\"line\">- (void)setName:(NSString *)name;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#import &quot;NSObject+Student.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation NSObject (Student)</div><div class=\"line\"></div><div class=\"line\">- (NSString *)name &#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setName:(NSString *)name &#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"NSCoding的自动归档和自动解档\"><a href=\"#NSCoding的自动归档和自动解档\" class=\"headerlink\" title=\"NSCoding的自动归档和自动解档\"></a>NSCoding的自动归档和自动解档</h3><p>这个太常用了, 主要思路是获取成员变量列表, 利用KVC读取和赋值来完成<code>encodeWithCoder</code>和<code>initWithCoder</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#import &quot;Student.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">#import &lt;objc/message.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation Student</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder&#123;</div><div class=\"line\">    unsigned int outCount = 0;</div><div class=\"line\">    Ivar *vars = class_copyIvarList([self class], &amp;outCount);</div><div class=\"line\">    for (int i = 0; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        Ivar var = vars[i];</div><div class=\"line\">        const char *name = ivar_getName(var);</div><div class=\"line\">        NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\"></div><div class=\"line\">        id value = [self valueForKey:key];</div><div class=\"line\">        [aCoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (nullable __kindof)initWithCoder:(NSCoder *)aDecoder&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        unsigned int outCount = 0;</div><div class=\"line\">        Ivar *vars = class_copyIvarList([self class], &amp;outCount);</div><div class=\"line\">        for (int i = 0; i &lt; outCount; i ++) &#123;</div><div class=\"line\">            Ivar var = vars[i];</div><div class=\"line\">            const char *name = ivar_getName(var);</div><div class=\"line\">            NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">            id value = [aDecoder decodeObjectForKey:key];</div><div class=\"line\">            [self setValue:value forKey:key];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"字典和模型互相转换\"><a href=\"#字典和模型互相转换\" class=\"headerlink\" title=\"字典和模型互相转换\"></a>字典和模型互相转换</h3><ol>\n<li><p>字典转模型</p>\n<ol>\n<li>调用 class_getProperty 方法获取当前 Model 的所有属性.</li>\n<li>调用 property_copyAttributeList 获取属性列表.</li>\n<li>根据属性名称生成 setter 方法.</li>\n<li><p>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC)<br>示例代码如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+(id)objectWithKeyValues:(NSDictionary *)aDictionary&#123;</div><div class=\"line\">    id objc = [[self alloc] init];</div><div class=\"line\">    for (NSString *key in aDictionary.allKeys) &#123;</div><div class=\"line\">        id value = aDictionary[key];</div><div class=\"line\">        </div><div class=\"line\">        /*判断当前属性是不是Model*/</div><div class=\"line\">        objc_property_t property = class_getProperty(self, key.UTF8String);</div><div class=\"line\">        unsigned int outCount = 0;</div><div class=\"line\">        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</div><div class=\"line\">        objc_property_attribute_t attribute = attributeList[0];</div><div class=\"line\">        NSString *typeString = [NSString stringWithUTF8String:attribute.value];</div><div class=\"line\">        </div><div class=\"line\">        //防止model嵌套, 比如说Student里面还有一层Student, 那么这里就需要再次转换一次, 当然这里有几层就需要转换几次.</div><div class=\"line\">        if ([typeString isEqualToString:@&quot;@\\&quot;Student\\&quot;&quot;]) &#123;</div><div class=\"line\">            value = [self objectWithKeyValues:value];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        //生成setter方法，并用objc_msgSend调用</div><div class=\"line\">        NSString *methodName = [NSString stringWithFormat:@&quot;set%@%@:&quot;,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];</div><div class=\"line\">        SEL setter = sel_registerName(methodName.UTF8String);</div><div class=\"line\">        if ([objc respondsToSelector:setter]) &#123;</div><div class=\"line\">            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(attributeList);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return objc;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>几个出名的开源库JSONModel, MJExtension等都是通过这种方式实现的. 利用runtime的class_copyIvarList获取属性数组, 遍历模型对象的所有成员属性, 根据属性名找到字典中key值进行赋值, 当然这种方法只能解决NSString, NSNumber等. 如果含有NSArray或NSDictionary, 还要进行第二步转换, 如果是字典数组, 需要遍历数组中的字典, 利用objectWithDict方法将字典转化为模型, 在将模型放到数组中, 最后把这个模型数组赋值给之前的字典数组.</p>\n</li>\n</ol>\n</li>\n<li><p>模型转字典</p>\n<ol>\n<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性. </li>\n<li>调用 property_getName 获取属性名称.</li>\n<li>根据属性名称生成 getter 方法.</li>\n<li><p>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.<br>示例代码如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//模型转字典</div><div class=\"line\">-(NSDictionary *)keyValuesWithObject&#123;</div><div class=\"line\">    unsigned int outCount = 0;</div><div class=\"line\">    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;outCount);</div><div class=\"line\">    NSMutableDictionary *dict = [NSMutableDictionary dictionary];</div><div class=\"line\">    for (int i = 0; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        objc_property_t property = propertyList[i];</div><div class=\"line\">        </div><div class=\"line\">        //生成getter方法，并用objc_msgSend调用</div><div class=\"line\">        const char *propertyName = property_getName(property);</div><div class=\"line\">        SEL getter = sel_registerName(propertyName);</div><div class=\"line\">        if ([self respondsToSelector:getter]) &#123;</div><div class=\"line\">            id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);</div><div class=\"line\">            </div><div class=\"line\">            /*判断当前属性是不是Model*/</div><div class=\"line\">            if ([value isKindOfClass:[self class]] &amp;&amp; value) &#123;</div><div class=\"line\">                value = [value keyValuesWithObject];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (value) &#123;</div><div class=\"line\">                NSString *key = [NSString stringWithUTF8String:propertyName];</div><div class=\"line\">                [dict setObject:value forKey:key];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    free(propertyList);</div><div class=\"line\">    return dict;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://halfrost.com/objc_runtime_isa_class/\" target=\"_blank\" rel=\"noopener\">神经病院 Objective-C Runtime 入院系列</a></p>\n<p>2.<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime</a></p>\n<p>3.<a href=\"http://southpeak.github.io/2014/10/25/objective-c-runtime-1/\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime 运行时系列</a></p>\n<p>4.<a href=\"https://halfrost.com/ios_aspect/\" target=\"_blank\" rel=\"noopener\">iOS 如何实现 Aspect Oriented Programming</a></p>\n<p>5.<a href=\"http://tech.glowing.com/cn/method-swizzling-aop/\" target=\"_blank\" rel=\"noopener\">Method Swizzling 和 AOP 实践</a></p>\n<p>6.<a href=\"http://www.cocoachina.com/ios/20141224/10740.html\" target=\"_blank\" rel=\"noopener\">刨根问底Objective－C Runtime</a></p>\n<p>7.<a href=\"https://tech.meituan.com/DiveIntoCategory.html\" target=\"_blank\" rel=\"noopener\">深入理解Objective-C：Category</a></p>\n<p>8.<a href=\"http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/\" target=\"_blank\" rel=\"noopener\">Objective-C 消息发送与转发机制原理</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"RN实践指南","url":"http://hchong.net/2017/12/01/RN实践指南/","content":"<h1 id=\"RN实践指南\"><a href=\"#RN实践指南\" class=\"headerlink\" title=\"RN实践指南\"></a>RN实践指南</h1><p>RN区别于传统项目三板斧(HTML, CSS, JS)我们可以在JS文件中写HTML的语法和CSS的布局, 这种语法称为JSX, 属于JS的语法拓展. RN使用的是虚拟DOM(存在于内存中的DOM), 他与DOM是一一对应的关系. 当界面发生变化时, 得益于DOM Diff算法, 我们就知道了虚拟DOM的变化, 从而高效的改动DOM, 避免了重新绘制DOM.</p>\n<p>RN的本质就是JS与OC通过JavaScript Core的相互调用, 源码分析参考<a href=\"http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">这里</a>, JS与OC的通信机制参考<a href=\"http://blog.cnbang.net/tech/2698/\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>RN的生命周期, 大致可以用下面这张图来概括:</p>\n<p><img src=\"http://7rf9ir.com1.z0.glb.clouddn.com/3-3-component-lifecycle.jpg\" alt=\"RN声明周期\"></p>\n<p>如图所示, RN的生命周期大致分为三个阶段:</p>\n<ul>\n<li><p>第一阶段: 是组件第一次绘制阶段, 如图中的上面虚线框内, 在这里完成了组件的加载和初始化;</p>\n<ul>\n<li><p><code>getDefaultProps</code>该函数用于初始化一些默认属性, 全局仅调用一次, 通常会将固定的内容放在这个函数中进行初始化和赋值. <em>注意</em>这是ES5的写法, 在ES6中我们使用static成员来实现. 更多ES5与ES6使用对照参考<a href=\"http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</li>\n<li><p><code>getInitialState</code>该函数用于对组件一些状态进行初始化, 可以将控制控件状态的一些变量放在这里初始化. 通过get取值, set写值. <em>注意</em>这是ES5的写法, 在ES6中我们常使用下面这种写法:</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">constructor(props)&#123;</div><div class=\"line\">    super(props);</div><div class=\"line\">    this.state = &#123;</div><div class=\"line\">        key: value,</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</code></pre></li>\n<li><p><code>componentWillMount</code>, 该方法表示组件将要加载到虚拟DOM中, 在render()方法之前执行, 整个生命周期只执行一次.</p>\n</li>\n<li><p><code>componentDidMount</code>, 该方法在组件第一次绘制之后调用, 通知组件已经加载完成, 这个函数整个生命周期只被调用一次, 这个函数被调用的时候就说虚拟DOM已经构建完成, 可以在这个函数中获取其中的元素和子组件. 这个函数之后, 就进入了稳定状态, 只有等到其他事件触发才会再次调用其他的函数.</p>\n</li>\n</ul>\n</li>\n<li><p>第二阶段: 是组件在运行和交互阶段, 如图中左下角虚线框, 这个阶段组件可以处理用户交互, 或者接收事件更新界面;</p>\n<ul>\n<li><p><code>componentWillReceiveProps</code>, 在组件接收到其父组件传递的props的时候执行, 参数为父组件传递的props. 在组件的整个生命周期可以多次执行, 通常在此方法接收新的props值, 重新设置state. </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">componentWillReceiveProps(nextProps) &#123;</div><div class=\"line\">     this.setState(&#123;</div><div class=\"line\">       //key : value</div><div class=\"line\">     &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>shouldComponentUpdate</code>, 当组件接收到新的props或者state改变时, 都会调用该方法, 该函数的返回值直接决定是否要更新组件. 该方法包含两个参数, 分别是props和state. 该方法在组件的整个生命周期可以多次执行. 如果该方法返回false, 则componentWillUpdate(nextProps, nextState)及其之后执行的方法都不会执行, 组件则不会进行重新渲染.</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class=\"line\">  return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>componentWillUpdate</code>, 如果组件状态或者属性改变, 并且<code>shouldComponentUpdate</code>的返回值为true, 就会更新组件, 在组件更新之前会先调用该方法, 该方法在整个声明周期中可以被多次执行. 在该方法中可以做一些更新界面之前要做的事情. <em>注意</em>, 在这个函数中不能使用set来修改state的值. 该函数调用之后, 就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中. 紧接着这个函数, 就会调用 <code>render()</code> 来更新界面.</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">componentWillUpdate(nextProps, nextState) &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>* `render`, 方法用于渲染组件, 在初始化阶段和运行期阶段都会执行.\n\n    <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">render() &#123;</div><div class=\"line\">  return(</div><div class=\"line\">    &lt;View/&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n\n\n* `componentDidUpdate`, 该方法在`render()`之后立刻调用, 包含两个参数, 分别是props和state. 该方法在组件的整个生命周期可以多次执行. 因为到这里已经完成了属性和状态的更新, 此时, 函数的参数就变成prevProps和prevState.\n\n    <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">componentDidUpdate(prevProps, prevState)(  </div><div class=\"line\">    </div><div class=\"line\">)</div></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><p>第三阶段: 是组件卸载消亡的阶段, 如图中右下角的虚线框中, 这里做一些组件的清理工作;</p>\n<ul>\n<li><code>componentWillUnmount</code>, 当组件将要从界面上移除的时候, 就会调用该方法.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>RN布局采用的是前端的flex布局, 关于这种布局方式, 网上的教程一大堆, 强烈推荐阮阮一峰<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>.</p>\n<h2 id=\"组件间通信\"><a href=\"#组件间通信\" class=\"headerlink\" title=\"组件间通信\"></a>组件间通信</h2><p>RN的组件间通信主要分为父子组件和跨级组件间通信.</p>\n<ul>\n<li>父子组件通信, 父组件设置属性参数, 子组件通过props取得参数.</li>\n<li><p>子父组件通信, 也通过props.</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//子组件</div><div class=\"line\">class Son extends Component &#123;</div><div class=\"line\">    constructor(props) &#123;</div><div class=\"line\">        super(props);</div><div class=\"line\">    &#125;</div><div class=\"line\">    componentDidMount() &#123;</div><div class=\"line\">        //子组件给父组件的方法传参</div><div class=\"line\">        this.props.onChange(&apos;newVal&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;View /&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//父组件</div><div class=\"line\">class Father extends Component &#123;</div><div class=\"line\">    constructor(props) &#123;</div><div class=\"line\">        super(props);</div><div class=\"line\">        this.state = &#123;</div><div class=\"line\">            key: &apos;defVal&apos;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //父组件接受子组件的参数，并改变 state</div><div class=\"line\">    handleChange(val) &#123;</div><div class=\"line\">        this.setState(&#123;</div><div class=\"line\">            key: val </div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    render() &#123;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;Son onChange=&#123;this.clickItem&#125;/&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    clickItem = (item) =&gt; &#123;</div><div class=\"line\">        this.handleChange(item);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>跨级组件间通信<br>  如果是兄弟组件可以先把值向上传递到父组件, 在向下传递到子组件. 如果是嵌套多层的传值可以使用context对象. 参考<a href=\"https://www.jianshu.com/p/fb915d9c99c4\" target=\"_blank\" rel=\"noopener\">React 中组件间通信的几种方式</a>.</p>\n</li>\n<li><p>观察者模式通信, 使用eventProxy对象. 该对象共有四个函数, 使用方法很简单.</p>\n<ul>\n<li>on, one: on 与 one 函数用于订阅者监听相应的事件, 并将事件响应时的函数作为参数, on 与 one 的唯一区别就是, 使用 one 进行订阅的函数, 只会触发一次, 而使用 on 进行订阅的函数, 每次事件发生相应时都会被触发.</li>\n<li>trigger: trigger 用于发布者发布事件, 将除第一参数(事件名)的其他参数, 作为新的参数, 触发使用 one 与 on 进行订阅的函数.</li>\n<li>off: 用于解除所有订阅了某个事件的所有函数.</li>\n</ul>\n</li>\n<li><p>使用Refs, Refs的关键在于保存组件的实例, 实例代码如下(子组件向父组件传递).</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//子组件</div><div class=\"line\">class Son extends Component &#123;</div><div class=\"line\">    constructor(props) &#123;</div><div class=\"line\">        super(props);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //开放的实例方法</div><div class=\"line\">    doIt() &#123;</div><div class=\"line\">        //...做点什么</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    render() &#123;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;View /&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//父组件</div><div class=\"line\">class Father extends Component &#123;</div><div class=\"line\">    constructor(props) &#123;</div><div class=\"line\">        super(props);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    render() &#123;</div><div class=\"line\">        //this.yyy 保存组件的实例</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;Son ref=&#123;(xxx) =&gt; &#123;this.yyy = xxx;&#125;&#125; /&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    componentDidMount() &#123;</div><div class=\"line\">        //调用组件的实例方法</div><div class=\"line\">        this.myCpt.doIt();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>使用global<br>  global 类似浏览器里的 window 对象, 它是全局的, 一处定义, 所有组件都可以访问, 一般用于存储一些全局的配置参数或方法. 使用场景: 全局参数不想通过 props 层层组件传递, 有些组件对此参数并不关心, 只有嵌套的某个组件使用.</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">global.isOnline = true;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"MobX与RN的结合使用\"><a href=\"#MobX与RN的结合使用\" class=\"headerlink\" title=\"MobX与RN的结合使用\"></a>MobX与RN的结合使用</h2><p>强烈推荐使用<a href=\"https://mobx.js.org/index.html\" target=\"_blank\" rel=\"noopener\">MobX</a>以数据驱动视图, 通过数据绑定, 我们只需修改数据本身, 便可自动更新视图. <a href=\"http://cn.mobx.js.org/\" target=\"_blank\" rel=\"noopener\">中文文档</a></p>\n<h2 id=\"MobX与RN的结合使用范式\"><a href=\"#MobX与RN的结合使用范式\" class=\"headerlink\" title=\"MobX与RN的结合使用范式\"></a>MobX与RN的结合使用范式</h2><p>我们尽量推荐一个模块由若干pages, 若干models和stores组成. 他们分别对应到iOS开发中的VC, M和VM三层. 如果使用store, 那么建议不要再使用state来控制UI状态, 建议都放进store里面.</p>\n<ul>\n<li>pages内就是一些组件, 业务逻辑</li>\n<li>store内可以定义一些跟数据相关的action, 对接口获取回来的数据做一层映射, 利用Mobx来实现数据变化自动分发渲染, 统一规划数据层.</li>\n<li>model类似于OC的瘦model, 也可以在里面做数据映射和数据校验</li>\n</ul>\n<h2 id=\"MobX使用注意\"><a href=\"#MobX使用注意\" class=\"headerlink\" title=\"MobX使用注意\"></a>MobX使用注意</h2><p>关于MobX的使用还要注意下面这些: </p>\n<blockquote>\n<p>MobX 会对在追踪函数执行过程中读取现存的可观察属性做出反应。<br>“读取” 是对象属性的间接引用，可以用<code>.</code>(例如 user.name) 或者 <code>[]</code>(例如 user[‘name’]) 的形式完成。<br>“追踪函数” 是 computed 表达式、observer 组件的 render() 方法和 when、reaction 和 autorun 的第一个入参函数。<br>“过程(during)” 意味着只追踪那些在函数执行时被读取的 observable 。这些值是否由追踪函数直接或间接使用并不重要。<br>MobX 追踪属性访问, 而不是值. 也可以理解为c/c++当中的指针的概念. 例如一个数组新增一个元素, 是不会触发MobX.</p>\n</blockquote>\n<h2 id=\"MobX与其他状态管理框架的对比\"><a href=\"#MobX与其他状态管理框架的对比\" class=\"headerlink\" title=\"MobX与其他状态管理框架的对比\"></a>MobX与其他状态管理框架的对比</h2><p>MobX与Redux, Flux总是要放在一起对比的, 他们的对比<a href=\"http://zhenhua-lee.github.io/react/state-manage.html\" target=\"_blank\" rel=\"noopener\">看这里</a>. </p>\n<hr>\n<p>参考资料:<br>1.<a href=\"https://www.jianshu.com/p/2a1571d23cf1\" target=\"_blank\" rel=\"noopener\">React Native组件的生命周期</a></p>\n<p>2.<a href=\"https://www.race604.com/react-native-component-lifecycle/\" target=\"_blank\" rel=\"noopener\">React Native 中组件的生命周期</a></p>\n<p>3.<a href=\"http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">React/React Native的ES5 ES6对照表</a></p>\n<p>4.<a href=\"http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">ReactNative iOS源码解析</a></p>\n<p>5.<a href=\"https://bestswifter.com/react-native/\" target=\"_blank\" rel=\"noopener\">React Native 从入门到原理</a></p>\n<p>6.<a href=\"http://blog.cnbang.net/tech/2698/\" target=\"_blank\" rel=\"noopener\">React Native通信机制详解</a></p>\n<p>7.<a href=\"https://reactnative.cn/docs/0.39/communication-ios.html\" target=\"_blank\" rel=\"noopener\">在原生和React Native间通信</a></p>\n","categories":["基础知识","RN"],"tags":["基础知识","RN"]},{"title":"iOS多线程","url":"http://hchong.net/2017/11/21/iOS多线程/","content":"<p>首先我们来搞清楚几个概念和他们之间的联系和区别: </p>\n<h2 id=\"多线程开发常用概念\"><a href=\"#多线程开发常用概念\" class=\"headerlink\" title=\"多线程开发常用概念\"></a>多线程开发常用概念</h2><ol>\n<li><p>进程和线程<br> 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.<br> 线程是进程的一个实体, 是CPU调度和分派(资源分配)的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数器, 一组寄存器和栈), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br> 一个线程可以创建和撤销另一个线程; 同一个进程中的多个线程之间可以并发执行.<br> 进程和线程的主要差别在于它们是不同的操作系统资源管理方式. 进程有独立的地址空间, 一个进程崩溃后, 在保护模式下不会对其它进程产生影响. 而线程只是一个进程中的不同执行路径. 线程有自己的堆栈和局部变量, 但线程之间没有单独的地址空间, 一个线程死掉就等于整个进程死掉, 所以多进程的程序要比多线程的程序健壮, 但在进程切换时, 耗费资源较大, 效率要差一些. 但对于一些要求同时进行并且又要共享某些变量的并发操作, 只能用线程, 不能用进程. </p>\n<ul>\n<li>简而言之, 一个程序至少有一个进程, 一个进程至少有一个线程.</li>\n<li>线程的划分尺度小于进程, 使得多线程程序的并发性高. </li>\n<li>另外, 进程在执行过程中拥有独立的内存单元, 而多个线程共享内存, 从而极大地提高了程序的运行效率. </li>\n<li>线程在执行过程中与进程还是有区别的. 每个独立的线程有一个程序运行的入口, 顺序执行序列和程序的出口. 但是线程不能够独立执行, 必须依存在应用程序中, 由应用程序提供多个线程执行控制. </li>\n<li><p>从逻辑角度来看, 多线程的意义在于一个应用程序中, 有多个执行部分可以同时执行. 但操作系统并没有将多个线程看做多个独立的应用, 来实现进程的调度和管理以及资源分配. 这就是进程和线程的重要区别.</p>\n<p>打个比方, 多进程就好比同时执行多个程序. 比如同时运行QQ, 音乐播放器, 以及浏览器. 多线程就是同一时刻执行多个线程, 用浏览器一边下载, 一边听歌, 一边看视频, 一边看网页. 浏览器这个进程下有多个线程, 这些线程共享系统分配给浏览器这个进程的资源, 所以各个线程之间可很方便的通信, 一个线程死了, 不会影响其他线程的运行. 如果浏览器这个进程死了, 那么他下面的所有线程就都用不了了. 我们可以通过浏览器打开QQ这里就是进程间通信, 由于不同的进程系统资源不同, 所以进程间的通信不是很容易实现. 并且切换进程会有性能问题.</p>\n</li>\n</ul>\n</li>\n<li><p>并发和并行<br> 并发指能够让多个任务在逻辑上交织执行的程序设计, 但并发事件之间不一定要同一时刻发生. 并行指的是程序运行时的状态是物理上同时执行, 是指同时发生的两个并发事件, 具有并发的含义, 而并发则不一定并行.<br> 并发是一种现象, 面对这一现象, 我们首先创建多个线程. 真正加快程序运行速度的, 是并行技术. 也就是让多个CPU同时工作. 而多线程, 是为了让多个CPU同时工作成为可能. 并发设计让并发执行成为可能, 而并行是并发执行的一种模式.<br> 并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头. 一个人同时吃三个馒头但是同一时间只能啃一个馒头, 三个人同时吃三个馒头, 三个馒头同一时间都会被啃.<br> 下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况. 假设每个核心有两个线程, 那么每个CPU中两个线程会交替并发, 两个CPU之间的操作会并行运算. 就CPU1而言虽然实现了并发但是同一时间只有一个任务在进行, CPU只是快速的在任务之间切换, CPU1和CPU2整体来看是并行元算, 同一时间是有多个任务在进行. 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题, 其本身运行效率并没有提高. 多CPU的并行运算才真正解决了运行效率问题, 这也正是并发和并行的区别. </p>\n<p>  <img src=\"http://img.souche.com/f2e/5d7717afde012bbfc557f26bc5eaffea.png\" alt=\"并发和并行\"></p>\n<p> 注意: 并行和串行是相对应的. 串行在物理层面上同一时刻只会有一个任务在进行.</p>\n</li>\n<li><p>同步和异步<br> 同步在发出一个同步调用时, 在没有得到结果之前, 该调用就不返回. 多个任务情况下, 一个任务A执行结束, 才可以执行另一个任务B. 只存在一个线程. 异步在发出一个异步调用后, 调用者不会立刻得到结果, 该调用就返回了. 多个任务情况下, 一个任务A正在执行, 同时可以执行另一个任务B. 任务B不用等待任务A结束才执行. 存在多条线程. </p>\n</li>\n</ol>\n<h2 id=\"多线程实现方案\"><a href=\"#多线程实现方案\" class=\"headerlink\" title=\"多线程实现方案\"></a>多线程实现方案</h2><p>在iOS开发中常见的多线程方案一共有4套, 分别是<code>Pthreads</code>, <code>NSThread</code>, <code>GCD</code>, <code>NSOperation &amp; NSOperationQueue</code>. 前两种不怎么常用, 这里就简单的介绍一下, 着重介绍后两种. </p>\n<h3 id=\"Pthresds\"><a href=\"#Pthresds\" class=\"headerlink\" title=\"Pthresds\"></a>Pthresds</h3><p>POSIX线程(POSIX threads), 简称Pthreads, 是线程的POSIX标准. 该标准定义了创建和操纵线程的一整套API, 在类Unix操作系统(Unix、Linux、Mac OSX等)中, 都使用Pthreads作为操作系统的线程. 那也就意味着可以跨平台使用, 但是使用起来特别酸爽. 🙂</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#import &lt;pthread.h&gt;</div><div class=\"line\"></div><div class=\"line\">- (void)pthreadsDoTask &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     pthread_t：线程指针</div><div class=\"line\">     pthread_attr_t：线程属性</div><div class=\"line\">     pthread_mutex_t：互斥对象</div><div class=\"line\">     pthread_mutexattr_t：互斥属性对象</div><div class=\"line\">     pthread_cond_t：条件变量</div><div class=\"line\">     pthread_condattr_t：条件属性对象</div><div class=\"line\">     pthread_key_t：线程数据键</div><div class=\"line\">     pthread_rwlock_t：读写锁</div><div class=\"line\">     //</div><div class=\"line\">     pthread_create()：创建一个线程</div><div class=\"line\">     pthread_exit()：终止当前线程</div><div class=\"line\">     pthread_cancel()：中断另外一个线程的运行</div><div class=\"line\">     pthread_join()：阻塞当前的线程, 直到另外一个线程运行结束</div><div class=\"line\">     pthread_attr_init()：初始化线程的属性</div><div class=\"line\">     pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）</div><div class=\"line\">     pthread_attr_getdetachstate()：获取脱离状态的属性</div><div class=\"line\">     pthread_attr_destroy()：删除线程的属性</div><div class=\"line\">     pthread_kill()：向线程发送一个信号</div><div class=\"line\">     pthread_equal(): 对两个线程的线程标识号进行比较</div><div class=\"line\">     pthread_detach(): 分离线程</div><div class=\"line\">     pthread_self(): 查询线程自身线程标识号</div><div class=\"line\">     //</div><div class=\"line\">     *创建线程</div><div class=\"line\">     int pthread_create(pthread_t _Nullable * _Nonnull __restrict, //指向新建线程标识符的指针</div><div class=\"line\">     const pthread_attr_t * _Nullable __restrict,  //设置线程属性. 默认值NULL. </div><div class=\"line\">     void * _Nullable (* _Nonnull)(void * _Nullable),  //该线程运行函数的地址</div><div class=\"line\">     void * _Nullable __restrict);  //运行函数所需的参数</div><div class=\"line\">     *返回值：</div><div class=\"line\">     *若线程创建成功, 则返回0</div><div class=\"line\">     *若线程创建失败, 则返回出错编号</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    //</div><div class=\"line\">    pthread_t thread = NULL;</div><div class=\"line\">    NSString *params = @&quot;Hello World&quot;;</div><div class=\"line\">    int result = pthread_create(&amp;thread, NULL, threadTask, (__bridge void *)(params));</div><div class=\"line\">    result == 0 ? NSLog(@&quot;creat thread success&quot;) : NSLog(@&quot;creat thread failure&quot;);</div><div class=\"line\">    //设置子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源</div><div class=\"line\">    pthread_detach(thread);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void *threadTask(void *params) &#123;</div><div class=\"line\">    NSLog(@&quot;%@ - %@&quot;, [NSThread currentThread], (__bridge NSString *)(params));</div><div class=\"line\">    return NULL;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看下这些API设计可以说是相当不友好, 并且需要手动管理线程的各个状态的转换和生命周期的管理.</p>\n<h3 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h3><p><code>NSThread</code>的API设计大致如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface NSThread : NSObject</div><div class=\"line\">//当前线程</div><div class=\"line\">@property (class, readonly, strong) NSThread *currentThread;</div><div class=\"line\">//使用类方法创建线程执行任务</div><div class=\"line\">+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</div><div class=\"line\">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</div><div class=\"line\">//判断当前是否为多线程</div><div class=\"line\">+ (BOOL)isMultiThreaded;</div><div class=\"line\">//指定线程的线程参数, 例如设置当前线程的断言处理器. </div><div class=\"line\">@property (readonly, retain) NSMutableDictionary *threadDictionary;</div><div class=\"line\">//当前线程暂停到某个时间</div><div class=\"line\">+ (void)sleepUntilDate:(NSDate *)date;</div><div class=\"line\">//当前线程暂停一段时间</div><div class=\"line\">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</div><div class=\"line\">//退出当前线程</div><div class=\"line\">+ (void)exit;</div><div class=\"line\">//当前线程优先级</div><div class=\"line\">+ (double)threadPriority;</div><div class=\"line\">//设置当前线程优先级</div><div class=\"line\">+ (BOOL)setThreadPriority:(double)p;</div><div class=\"line\">//指定线程对象优先级 0.0～1.0, 默认值为0.5</div><div class=\"line\">@property double threadPriority NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//服务质量</div><div class=\"line\">@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);</div><div class=\"line\">//线程名称</div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//栈区大小</div><div class=\"line\">@property NSUInteger stackSize NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//是否为主线程</div><div class=\"line\">@property (class, readonly) BOOL isMainThread NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//获取主线程</div><div class=\"line\">@property (class, readonly, strong) NSThread *mainThread NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//初始化</div><div class=\"line\">- (instancetype)init NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;</div><div class=\"line\">//实例方法初始化, 需要再调用start方法</div><div class=\"line\">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</div><div class=\"line\">//线程状态, 正在执行</div><div class=\"line\">@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//线程状态, 正在完成</div><div class=\"line\">@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//线程状态, 已经取消</div><div class=\"line\">@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//取消, 仅仅改变线程状态, 并不能像exist一样真正的终止线程</div><div class=\"line\">- (void)cancel NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//开始</div><div class=\"line\">- (void)start NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">//线程需要执行的代码, 一般写子类的时候会用到</div><div class=\"line\">- (void)main NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>还有一个NSObject的分类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface NSObject (NSThreadPerformAdditions)</div><div class=\"line\">//隐式的创建并启动线程, 并在指定的线程（主线程或子线程）上执行方法. </div><div class=\"line\">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</div><div class=\"line\">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class=\"line\">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>常见的用法有以下几种: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void) startThread &#123;</div><div class=\"line\"></div><div class=\"line\">    //创建并且手动启动</div><div class=\"line\">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class=\"line\">    [thread start];</div><div class=\"line\"></div><div class=\"line\">    //类方法创建并且自动启动</div><div class=\"line\">    [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</div><div class=\"line\"></div><div class=\"line\">    //通过NSObject的方法自动启动</div><div class=\"line\">    [self performSelectorInBackground:@selector(run) withObject:nil];</div><div class=\"line\">&#125;    </div><div class=\"line\"></div><div class=\"line\">- (void)run &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h3><p>Grand Central Dispatch, 它是苹果为多核的并行运算提出的解决方案, 会自动合理地利用更多的CPU内核(比如双核、四核), 最重要的是它会自动管理线程的生命周期(创建线程、调度任务、销毁线程), 完全不需要我们管理, 我们只需要告诉干什么就行. 同时它使用的也是C语言, 不过由于使用了Block(Swift里叫做闭包), 使得使用起来更加方便, 而且灵活.</p>\n<p>了解GCD我们需要先了解两个概念, <strong><code>队列</code></strong>和<strong><code>任务</code></strong>.</p>\n<ol>\n<li><p>任务<br>要执行的操作或方法函数. 在GCD中指的就是block块, 在NSThread中指的是<code>performSelector:</code>中的方法. 加入任务时有两种形式: <code>同步任务(dispatch_sync)</code>和<code>异步任务(dispatch_async)</code>.</p>\n<ul>\n<li><p>同步任务: 不会开启新的线程, 会阻塞当前线程. 完成需要做的任务后才会返回, 进行下一任务. 创建方式为:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//把右边的参数(任务)提交给左边的参数(队列)进行执行</div><div class=\"line\">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>\n</li>\n<li><p>异步任务: 不会等待任务完成才返回, 会立即返回. 异步是多线程的代名词, 因为必定会开启新的线程, 线程的申请是由异步负责, 起到开分支的作用. 创建方式为:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//把右边的参数(任务)提交给左边的参数(队列)进行执行</div><div class=\"line\">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>队列<br>存放任务的集合, 我们要做的就是将任务添加到队列然后执行, GCD会自动将队列中的任务按先进先出的方式取出. 队列主要有的有<code>串行队列(Serial Dispatch Queue)</code>, <code>并行队列(Concurrent Dispatch Queue)</code>, <code>全局队列(Global Queue)</code>和<code>主队列(Main Queue)</code>.</p>\n<ul>\n<li><p>串行队列: 任务依次执行, 同一时间队列中只有一个任务在执行, 每个任务只有在前一个任务执行完成后才能开始执行. 你不知道在一个Block(任务)执行结束到下一个Block(任务)开始执行之间的这段时间时间是多长, 这部分是由GCD控制. 创建方式为:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//创建一个名为queue的串行队列</div><div class=\"line\">//第一个参数为队列名称</div><div class=\"line\">//第二个参数为队列类型, DISPATCH_QUEUE_SERIAL和NULL表示串行队列</div><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.SerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>* 并行队列: 任务并发执行, 唯一能保证的是, 这些任务会按照被添加的顺序开始执行. 但是任务可以以任何顺序完成, 你不知道在执行下一个任务是从什么时候开始, 或者说任意时刻有多个Block(任务)运行, 这个完全是取决于GCD. GCD默认已经提供了全局的并发队列, 供整个应用使用, 一般不需要手动创建创建方式为:\n\n    <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//创建一个名为queue的并行队列</div><div class=\"line\">//第一个参数为队列名称</div><div class=\"line\">//第二个参数为队列类型, DISPATCH_QUEUE_CONCURRENT表示并行队列</div><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.ConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>\n\n\n* 全局队列: **隶属于并行队列**, 不要与 barrier 栅栏方法搭配使用, barrier 只有与自定义的并行队列一起使用, 才能让 barrier 达到我们所期望的栅栏功能. 与串行队列或者global队列 一起使用, barrier的表现会和dispatch_sync方法一样. 创建方式为:\n\n    <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//获取系统全局队列, 并赋值给队列queue</div><div class=\"line\">//第一个参数表示优先级, 这里是新老优先级的对照Map</div><div class=\"line\">*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED//高</div><div class=\"line\">*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT//默认</div><div class=\"line\">*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY//低</div><div class=\"line\">*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND//后台</div><div class=\"line\">    </div><div class=\"line\">//第二个参数是预留参数, 传0就好</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>\n\n* 主队列: **隶属于串行队列**, 不能与sync同步方法搭配使用, 会造成死循环. 主队列是GCD自带的一种特殊的串行队列, 放在主队列中的任务, 都会放到主线程中执行. 创建方式为:\n\n    <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//获取系统主队列, 并赋值给队列queue</div><div class=\"line\">  dispatch_queue_t queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>\n</code></pre><p>不管是串行队列(SerialQueue)还是并行队列(ConcurrencyQueue), 都是FIFO队列. 也就意味着, 任务一定是一个一个地, 按照先进先出的顺序来执行.</p>\n<h3 id=\"NSOperation-amp-NSOperationQueue\"><a href=\"#NSOperation-amp-NSOperationQueue\" class=\"headerlink\" title=\"NSOperation &amp; NSOperationQueue\"></a>NSOperation &amp; NSOperationQueue</h3><p><code>NSOperation</code> 是苹果公司对<code>GCD</code>的封装, 完全面向对象, 所以使用起来更好理解. 大家可以看到 <code>NSOperation</code>和<code>NSOperationQueue</code>分别对应<code>GCD</code>的<strong>任务</strong>和<strong>队列</strong>. 所以他的操作步骤和<code>GCD</code>类似: 首先将要执行的任务封装到一个<code>NSOperation</code>对象中. 然后将此任务添加到一个<code>NSOperationQueue</code>对象中, 然后系统就会自动在执行任务.</p>\n<h4 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h4><p>NSOperation主要有一下这些属性和方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface NSOperation : NSObject &#123;</div><div class=\"line\">@private</div><div class=\"line\"> id _private;</div><div class=\"line\"> int32_t _private1;</div><div class=\"line\">#if __LP64__</div><div class=\"line\"> int32_t _private1b;</div><div class=\"line\">#endif</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">- (void)start;//启动任务 默认在当前线程执行</div><div class=\"line\">- (void)main;//自定义NSOperation，写一个子类，重写这个方法，在这个方法里面添加需要执行的操作。</div><div class=\"line\">  </div><div class=\"line\">@property (readonly, getter=isCancelled) BOOL cancelled;//是否已经取消，只读</div><div class=\"line\">- (void)cancel;//取消任务</div><div class=\"line\">  </div><div class=\"line\">@property (readonly, getter=isExecuting) BOOL executing;//正在执行，只读</div><div class=\"line\">@property (readonly, getter=isFinished) BOOL finished;//执行结束，只读</div><div class=\"line\">@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &apos;asynchronous&apos; below</div><div class=\"line\">@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);//是否并发，只读</div><div class=\"line\">@property (readonly, getter=isReady) BOOL ready;//准备执行</div><div class=\"line\">  </div><div class=\"line\">- (void)addDependency:(NSOperation *)op;//添加依赖</div><div class=\"line\">- (void)removeDependency:(NSOperation *)op;//移除依赖</div><div class=\"line\">  </div><div class=\"line\">@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;//所有依赖关系，只读</div><div class=\"line\">  </div><div class=\"line\">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</div><div class=\"line\"> NSOperationQueuePriorityVeryLow = -8L,</div><div class=\"line\"> NSOperationQueuePriorityLow = -4L,</div><div class=\"line\"> NSOperationQueuePriorityNormal = 0,</div><div class=\"line\"> NSOperationQueuePriorityHigh = 4,</div><div class=\"line\"> NSOperationQueuePriorityVeryHigh = 8</div><div class=\"line\">&#125;;//系统提供的优先级关系枚举</div><div class=\"line\">  </div><div class=\"line\">@property NSOperationQueuePriority queuePriority;//执行优先级</div><div class=\"line\">  </div><div class=\"line\">@property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);//任务执行完成之后的回调</div><div class=\"line\">  </div><div class=\"line\">- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);//阻塞当前线程，等到某个operation执行完毕。</div><div class=\"line\">  </div><div class=\"line\">@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);//已废弃，用qualityOfService替代。</div><div class=\"line\">  </div><div class=\"line\">@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);//服务质量，一个高质量的服务就意味着更多的资源得以提供来更快的完成操作。</div><div class=\"line\">  </div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);//任务名称</div><div class=\"line\">   </div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>由于<code>NSOperation</code>是一个抽象基类, 不能直接使用, 在这里我么你一般使用<code>NSOperation</code>的两个子类<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>, 或者<code>NSOperation的自定义子类</code>:</p>\n<ul>\n<li><p><code>NSInvocationOperation</code>基于应用的一个target对象和selector来创建operation object. 如果你已经有现有的方法来执行需要的任务, 就可以使用这个类. 使用方式大致如下: </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)NSInvocationOperationRun &#123;</div><div class=\"line\">  NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];</div><div class=\"line\">  [invocationOper start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)invocationOperSel &#123;</div><div class=\"line\">  NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  从打印结果可以看出, 该实现方式是同步顺序执行.</p>\n</li>\n<li><p><code>NSBlockOperation</code>用来并发地执行一个或多个block对象. operation object使用<strong>组</strong>的语义来执行多个block对象，所有相关的 block 都执行完成之后, operation object才算完成. 使用方法如下:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//系统提供的API</div><div class=\"line\">@interface NSBlockOperation : NSOperation &#123;</div><div class=\"line\">@private</div><div class=\"line\">id _private2;</div><div class=\"line\">void *_reserved2;</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">+ (instancetype)blockOperationWithBlock:(void (^)(void))block;//在当前线程执行</div><div class=\"line\">  </div><div class=\"line\">- (void)addExecutionBlock:(void (^)(void))block;//新开线程执行</div><div class=\"line\">@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;</div><div class=\"line\">  </div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p> 使用<code>NSBlockOperation</code>类方法创建任务, 从打印结果可以看出来该任务是在主线程执行的</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)NSBlockOperationRun &#123;</div><div class=\"line\">NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">   NSLog(@&quot;NSBlockOperationRun_%@_%@&quot;, [NSOperationQueue currentQueue], [NSThread currentThread]);</div><div class=\"line\">&#125;];</div><div class=\"line\">[blockOper start];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 使用<code>NBlockOperation</code>的实例方法创建任务, 从打印结果可以看出来, 第一个任务是在主线程执行, 其他任务均是新开的线程, 所有的任务是以异步并发的形式执行. </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)NSBlockOperationRun &#123;</div><div class=\"line\">NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">    NSLog(@&quot;NSBlockOperationRun_1_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;];</div><div class=\"line\">[blockOper addExecutionBlock:^&#123;</div><div class=\"line\">    NSLog(@&quot;NSBlockOperationRun_2_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;];</div><div class=\"line\">[blockOper addExecutionBlock:^&#123;</div><div class=\"line\">    NSLog(@&quot;NSBlockOperationRun_3_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;];</div><div class=\"line\">[blockOper addExecutionBlock:^&#123;</div><div class=\"line\">    NSLog(@&quot;NSBlockOperationRun_4_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;];</div><div class=\"line\">[blockOper start];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>NSOperation的自定义子类. 在子类中重写父类的<code>-(void)main</code>函数, 在里面实现主要逻辑. <code>NSBlockOperation</code>, <code>NSBlockOperationRun</code>或者<code>NSOperation的自定义子类</code>创建的operation object都可以使用<code>NSOperation</code>的所有属性, 意味着他们具有以下主要特性: </p>\n<ul>\n<li>多个任务之间可以使用有依赖关系</li>\n<li>可以获得Operation object任务执行完成之后的回调</li>\n<li>支持应用使用 KVO 通知来监控 operation 的执行状态</li>\n<li>可以通过operation优先级, 从而影响相对的执行顺序</li>\n<li>可以终止正在执行的任务</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"NSOperationQueue\"><a href=\"#NSOperationQueue\" class=\"headerlink\" title=\"NSOperationQueue\"></a>NSOperationQueue</h4><p><code>NSOperationQueue</code>类似于GCD中的队列, 只需要吧任务加入到<code>NSOperationQueue</code>中, 就会自动运行, 由系统通过最大并发数来控制是并行还是串行, 官方提供的API如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">static const NSInteger NSOperationQueueDefaultMaxConcurrentOperationCount = -1;</div><div class=\"line\">    </div><div class=\"line\">NS_CLASS_AVAILABLE(10_5, 2_0)</div><div class=\"line\">@interface NSOperationQueue : NSObject &#123;</div><div class=\"line\">@private</div><div class=\"line\">   id _private;</div><div class=\"line\">   void *_reserved;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (void)addOperation:(NSOperation *)op;//向队列中添加任务</div><div class=\"line\">- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一组任务</div><div class=\"line\">    </div><div class=\"line\">- (void)addOperationWithBlock:(void (^)(void))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//添加一个block形式的任务</div><div class=\"line\">    </div><div class=\"line\">@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;//队列中所有任务的数组</div><div class=\"line\">@property (readonly) NSUInteger operationCount API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//队列中所有任务数</div><div class=\"line\">    </div><div class=\"line\">@property NSInteger maxConcurrentOperationCount;//最大并发数</div><div class=\"line\">    </div><div class=\"line\">@property (getter=isSuspended) BOOL suspended;//暂停</div><div class=\"line\">    </div><div class=\"line\">@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//名称</div><div class=\"line\">    </div><div class=\"line\">@property NSQualityOfService qualityOfService API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));//服务质量, 系统会为权重高的服务分配更多的资源</div><div class=\"line\">    </div><div class=\"line\">@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));</div><div class=\"line\">    </div><div class=\"line\">- (void)cancelAllOperations;//取消队列中所有的任务</div><div class=\"line\">    </div><div class=\"line\">- (void)waitUntilAllOperationsAreFinished;//阻塞当前线程, 等到队列中的全部任务全部执行完毕</div><div class=\"line\">    </div><div class=\"line\">@property (class, readonly, strong, nullable) NSOperationQueue *currentQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取当前队列</div><div class=\"line\">@property (class, readonly, strong) NSOperationQueue *mainQueue API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//获取主队列</div><div class=\"line\">    </div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>使用方式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//以三种方式为队列添加了三个任务, </div><div class=\"line\">- (void)NSOperationQueueRun &#123;</div><div class=\"line\">   NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class=\"line\">   NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];</div><div class=\"line\">   [queue addOperation:invocationOper];</div><div class=\"line\">   NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">       NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">   &#125;];</div><div class=\"line\">   [queue addOperation:blockOper];</div><div class=\"line\">   [queue addOperationWithBlock:^&#123;</div><div class=\"line\">       NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">   &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">- (void)invocationOperSel &#123;</div><div class=\"line\">   NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一般情况下, <code>NSOperationQueue</code>会按照任务添加的顺序来执行任务, 但是我们可以通过使用优先级和依赖关系来改变执行顺序. 并发数大于任务数, 没有设置依赖关系, 并且在同一队列.</p>\n<h2 id=\"常见的使用方式\"><a href=\"#常见的使用方式\" class=\"headerlink\" title=\"常见的使用方式\"></a>常见的使用方式</h2><h3 id=\"GCD向并行队列中添加异步任务\"><a href=\"#GCD向并行队列中添加异步任务\" class=\"headerlink\" title=\"GCD向并行队列中添加异步任务\"></a>GCD向并行队列中添加异步任务</h3><p>该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加异步任务. 任务会遵守FIFO原则来执行, 但是每个任务何时执行完我们却并不知道. 但是系统会新开线程来执行异步任务, 三个异步任务会分别在三个线程中执行, 各个任务的执行顺序无法确定.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)test1 &#123;</div><div class=\"line\">    //获取系统提供的全局队列</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">        sleep(5);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD向串行队列中添加异步任务\"><a href=\"#GCD向串行队列中添加异步任务\" class=\"headerlink\" title=\"GCD向串行队列中添加异步任务\"></a>GCD向串行队列中添加异步任务</h3><p>该过程一共分为两步, 第一步创建串行队列, 第二步向并行队列中添加异步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 但是由于我们是在串行队列中添加的任务, 不会新开线程, 所有的异步任务会按照顺序前一个执行完毕再执行后一个.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"> - (void)test2 &#123;</div><div class=\"line\">    //创建串行队列, 第一个参数为串行队列的名称, 第二个参数为队列的属性, NULL或者DISPATCH_QUEUE_SERIAL表示是串行队列</div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;test2&quot;, NULL);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">        sleep(5);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD向并行队列添加同步任务\"><a href=\"#GCD向并行队列添加同步任务\" class=\"headerlink\" title=\"GCD向并行队列添加同步任务\"></a>GCD向并行队列添加同步任务</h3><p>该过程一共分为两步, 第一步获取系统提供的全局并行队列, 第二步向并行队列中添加同步任务. 任务会遵守FIFO原则来执行, 每个任务何时执行完我们却并不知道. 虽然是并行队列, 单由于添加的是同步任务, 不会新开线程, 全都在当前线程中执行, 所以三个任务会顺序执行, 并行队列失去了并行的能力. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//并行队列中添加同步任务</div><div class=\"line\">- (void)test3 &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_sync(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">        sleep(5);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_sync(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_sync(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD-向串行队列添加异步任务\"><a href=\"#GCD-向串行队列添加异步任务\" class=\"headerlink\" title=\"GCD 向串行队列添加异步任务\"></a>GCD 向串行队列添加异步任务</h3><p>该过程一共分为两步, 第一步创建自定义串行队列, 第二步向并行队列中添加异步任务. 虽然异步任务会新开线程, 但是由于是在串行队列中执行, 所以不新开线程, 所有任务前一个执行完毕再执行下一个.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)test4 &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;test4&quot;, NULL);</div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">       NSLog(@&quot;下载图片1----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">       sleep(5);</div><div class=\"line\">    &#125;);</div><div class=\"line\">        </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">       NSLog(@&quot;下载图片2----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">        </div><div class=\"line\">    //向队列中添加异步任务</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">       NSLog(@&quot;下载图片3----%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h3><p>分组模式 <code>dispatch_group_notify</code>. 可以异步执行多个耗时操作. 等耗时操作都执行完毕之后会回到主线程执行操作, 主要用于监听任务是否完成. 主要有两种用法: </p>\n<p>第一种用法是通过<code>dispatch_group_async</code>, 首先创建一个全局并行队列和一个group队列组, 再次创建异步group任务加入到前面创建的group队列中去. 当所有异步任务完成后, 会通过<code>dispatch_group_notify</code>回到主线程.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)groupTest1 &#123;</div><div class=\"line\">    //获取全局队列</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    //创建一个队列组</div><div class=\"line\">    dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;--- 1 开始--- %@&quot;, [NSThread currentThread]);</div><div class=\"line\">        //延时5秒 模仿堵塞子线程</div><div class=\"line\">        [NSThread sleepForTimeInterval:5];</div><div class=\"line\">        NSLog(@&quot;--- 1 --- 完成 %@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;--- 2 开始--- %@&quot;, [NSThread currentThread]);</div><div class=\"line\">        //延时5秒 模仿堵塞子线程</div><div class=\"line\">        [NSThread sleepForTimeInterval:5];</div><div class=\"line\">        NSLog(@&quot;--- 2 --- 完成 %@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //在这个队列组里面，会等group中的全部代码执行完毕再去执行其它的操作</div><div class=\"line\">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        // 等前面的异步操作都执行完毕后，回到主线程...</div><div class=\"line\">        NSLog(@&quot;全部完成&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二种用法是通过信号量<code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code>. 创建一个并行线程和多个异步任务, 将异步任务添加到并行线程中区. 通过<code>dispatch_group_enter</code>来告知<code>group</code>一个异步任务开始,  未执行完毕任务数加1. 在异步线程任务执行完毕时, 通过<code>dispatch_group_leave</code>告知group, 一个任务结束, 未执行完毕任务数减1. 当未执行完毕任务数为0的时候, 这时group才认为组内任务都执行完毕了(这个和GCD的信号量的机制有些相似), 这时候才会回调<code>dispatch_group_notify</code>中的block. 此处需要注意, <code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的数量一定要一致. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)groupTest2 &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_enter(group);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        sleep(2); //这里线程睡眠1秒钟，模拟异步请求</div><div class=\"line\">        NSLog(@&quot;%@ one finish&quot;, [NSThread currentThread]);</div><div class=\"line\">        dispatch_group_leave(group);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_enter(group);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        sleep(2); //这里线程睡眠1秒钟，模拟异步请求</div><div class=\"line\">        NSLog(@&quot;%@ two finish&quot;, [NSThread currentThread]);</div><div class=\"line\">        dispatch_group_leave(group);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;group finished&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD延时操作-dispatch-after\"><a href=\"#GCD延时操作-dispatch-after\" class=\"headerlink\" title=\"GCD延时操作(dispatch_after)\"></a>GCD延时操作(dispatch_after)</h3><p>使用很简单, 两个核心的对象<code>dispatch_time_t</code>和<code>dispatch_after</code>. 大家都经常使用, 不用多说. 下面的代码和在3妙手用<code>dispatch_async</code>函数追加block到主线程的操作是相同的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)afterTest &#123;</div><div class=\"line\">    double delayInSeconds = 2.0;</div><div class=\"line\">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));</div><div class=\"line\">    //第一个参数代表时间, 第二各参数代表要在哪个线程执行接下来的任务, 第三个参数就是任务block</div><div class=\"line\">    dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD单例-dispatch-once\"><a href=\"#GCD单例-dispatch-once\" class=\"headerlink\" title=\"GCD单例(dispatch_once)\"></a>GCD单例(dispatch_once)</h3><p>这个更是不用多说, 直接贴上代码.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface Tool : NSObject</div><div class=\"line\">+ (instancetype)sharedTool;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation Tool</div><div class=\"line\">static id _instance;</div><div class=\"line\">+ (instancetype)sharedTool &#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        _instance = [[Tool alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return _instance;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"GCD-线程间的通讯\"><a href=\"#GCD-线程间的通讯\" class=\"headerlink\" title=\"GCD 线程间的通讯\"></a>GCD 线程间的通讯</h3><p>常用的方式就是在后台线程中执行长时间任务, 处理结束时, 主线程使用该处理结果. 代码如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)threadTest &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        //在这里执行耗时的操作</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            //在主线程使用上面操作的结果</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD重复执行同一个任务-dispatch-apply\"><a href=\"#GCD重复执行同一个任务-dispatch-apply\" class=\"headerlink\" title=\"GCD重复执行同一个任务(dispatch_apply)\"></a>GCD重复执行同一个任务(dispatch_apply)</h3><p><code>disaptch_apply</code>函数是<code>dispatch_sync</code>函数和<code>Dispatch Group</code>的关联API, 该函数按照指定的次数将指定的Block追加到指定的Dispatch Queue中, 并等待处理执行结束. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)applyTest &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_apply(10, queue, ^(size_t index) &#123;</div><div class=\"line\">        //并行处理10次任务</div><div class=\"line\">        NSLog(@&quot;%zu&quot;, index);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是由于<code>dispatch_apply</code>函数与<code>dispatch_sync</code>函数相同, 会等待任务执行结束, 所以我们强烈推荐在<code>dispatch_async</code>函数中异步执行. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)applyTest &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    </div><div class=\"line\">    //在全局并行队列中异步执行</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        //等待函数中操作全部执行完毕</div><div class=\"line\">        dispatch_apply(10, queue, ^(size_t index) &#123;</div><div class=\"line\">            //并行处理10次任务</div><div class=\"line\">            sleep(2);</div><div class=\"line\">            NSLog(@&quot;%zu&quot;, index);</div><div class=\"line\">        &#125;);</div><div class=\"line\">        </div><div class=\"line\">        //dispatch_apply中的处理全部结束, 在主线程异步执行</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            NSLog(@&quot;Done&quot;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD设置优先级-dispatch-set-target-queue\"><a href=\"#GCD设置优先级-dispatch-set-target-queue\" class=\"headerlink\" title=\"GCD设置优先级(dispatch_set_target_queue)\"></a>GCD设置优先级(dispatch_set_target_queue)</h3><p>将queue的优先级通过<code>dispatch_set_target_queue</code>变更的和queue1的优先级一致, 代码如下. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)targetQueeuTest &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, NULL);</div><div class=\"line\">    dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    //把第一个参数的执行优先级设置的和第二个参数的优先级一致.</div><div class=\"line\">    dispatch_set_target_queue(queue, queue1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD栅栏-dispatch-barrier-async\"><a href=\"#GCD栅栏-dispatch-barrier-async\" class=\"headerlink\" title=\"GCD栅栏(dispatch_barrier_async)\"></a>GCD栅栏(dispatch_barrier_async)</h3><p>以下面的代码为例, 假设一个并行队列中添加了五个异步任务, 虽然遵循FIFO的原则, 这五个任务的执行必定是无序的. 当我们在第三个任务之后加入<code>dispatch_barrier_async</code>任务, 那么这五个任务就被分割成两部分, 前三次无序执行, 然后执行<code>dispatch_barrier_async</code>任务, 然后再无序执行后两次任务. 注意<strong>此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)barrierTest &#123;</div><div class=\"line\">    </div><div class=\"line\">    //此处的队列只能使用自定义的并行队列, 系统提供的全局队列不行</div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;barrierTest&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;2&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;3&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">        sleep(3);</div><div class=\"line\">        NSLog(@&quot;插入执行&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;4&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;5&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD信号量-dispatch-semaphore-t\"><a href=\"#GCD信号量-dispatch-semaphore-t\" class=\"headerlink\" title=\"GCD信号量(dispatch_semaphore_t)\"></a>GCD信号量(dispatch_semaphore_t)</h3><p>我们以这个使用场景为例, 来说明一下, 不考虑顺序 将所有的数据添加到空数组中去, 我们可能会这么实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)dispatchSemaphoreDemo &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    NSMutableArray *array = [NSMutableArray array];</div><div class=\"line\">    for (int i = 0; i &lt; 100000; i++) &#123;</div><div class=\"line\">        dispatch_async(queue, ^&#123;</div><div class=\"line\">            NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class=\"line\">            [array addObject:@(i)];</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为是并行队列, 异步任务, 所以会开大量的线程, 并且这些线程会保存在内存中,相当耗费资源, 最终运行的结果就是崩溃. 那么我们就需要通过信号量来控制任务的执行. <code>dispatch_semaphore_t</code>类似于单个队列的最大并发数控制机制, 提高并行效率的同时, 也可以防止太多线程的开辟对系统造成太大的负担. 改造后应该是这样的: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)dispatchSemaphoreDemo &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    NSMutableArray *array = [NSMutableArray array];</div><div class=\"line\">    </div><div class=\"line\">    //设置信号量初始值, 当信号量为0时, 所有任务等待, 信号量越大, 允许可并行执行的任务数量越多. 并发的线程由系统调配, 不一定一直是同样的两条, 但是最多只能同时存在两条.</div><div class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);</div><div class=\"line\">    for (int i = 0; i &lt; 100; i++) &#123;</div><div class=\"line\">        </div><div class=\"line\">        //当信号量大于等于设定的初始值时就继续执行, 否则一直等待</div><div class=\"line\">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">        dispatch_async(queue, ^&#123;</div><div class=\"line\">            //执行到这里就代表信号量大于等于设定的初始值, 所以在这里信号量要减1</div><div class=\"line\">            NSLog(@&quot;%d+++++%@&quot;, i, [NSThread currentThread]);</div><div class=\"line\">            [array addObject:@(i)];</div><div class=\"line\">            //到这里的时候, 因为异步任务已经将要结束, 要将信号量加1. 如果前面有等待的线程, 最先等待的线程先执行</div><div class=\"line\">            dispatch_semaphore_signal(semaphore);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GCD定时器\"><a href=\"#GCD定时器\" class=\"headerlink\" title=\"GCD定时器\"></a>GCD定时器</h3><p>GCD实现定时器主要用到<code>dispatch_source_t</code>函数, 该函数实际有多种Type, <code>DISPATCH_SOURCE_TYPE_TIMER</code>是定时器相关的任务, 还有其他类型的处理事件类型. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)timerDemo &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    //指定DISPATCH_SOURCE_TYPE_TIMER类型, 作成Dispatch Source</div><div class=\"line\">    </div><div class=\"line\">    //在定时器经过指定时间, 把任务追加到main queue</div><div class=\"line\">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">    </div><div class=\"line\">    //定时器的相关设置, 将定时器设置为5s后, 不指定为重复, 允许延迟1s</div><div class=\"line\">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 1ull * NSEC_PER_SEC);</div><div class=\"line\">    </div><div class=\"line\">    //指定定时器指定时间内执行的处理</div><div class=\"line\">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">        NSLog(@&quot;wake up&quot;);</div><div class=\"line\">        dispatch_source_cancel(timer);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //取消定时器时的处理</div><div class=\"line\">    dispatch_source_set_cancel_handler(timer, ^&#123;</div><div class=\"line\">        NSLog(@&quot;canceled&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //定时器启动</div><div class=\"line\">    dispatch_resume(timer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"NSOperation的优先级\"><a href=\"#NSOperation的优先级\" class=\"headerlink\" title=\"NSOperation的优先级\"></a>NSOperation的优先级</h3><p>NSOperationQueue中NSOperation对象的执行方式是按照FIFO的原则顺序执行, 但是如果我们设置了任务的优先级, 那么系统就会给优先级高的优先分配资源. </p>\n<p>优先级一共有这几种, 从高到低依次排列.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</div><div class=\"line\">\tNSOperationQueuePriorityVeryLow = -8L,</div><div class=\"line\">\tNSOperationQueuePriorityLow = -4L,</div><div class=\"line\">\tNSOperationQueuePriorityNormal = 0,</div><div class=\"line\">\tNSOperationQueuePriorityHigh = 4,</div><div class=\"line\">\tNSOperationQueuePriorityVeryHigh = 8</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>示例代码如下, 三个任务被添加到队列中去, 这三个任务分别在三个线程, 互不干扰, 类似于GCD的异步并行模式, 如果我们设置<code>invocationOper.queuePriority = NSOperationQueuePriorityVeryLow</code>理论上, <code>invocationOper</code>任务会在最后执行, 但是我们发现并没有, 那是因为我们没有设置最大并发数的原因, 我猜测系统可能是做了某些限制, 虽然是新开了线程, 但是由于最大并发数小于等于1实际还是按照FIFO顺序执行, <strong>所以注意一定要设置最大并发数</strong>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//把注释打开就可以看到想要的效果</div><div class=\"line\">- (void)NSOperationQueueRun &#123;</div><div class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class=\"line\">    //queue.maxConcurrentOperationCount = 3;</div><div class=\"line\">    NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];</div><div class=\"line\">    //invocationOper.queuePriority = NSOperationQueuePriorityVeryLow;</div><div class=\"line\">    [queue addOperation:invocationOper];</div><div class=\"line\">    NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;NSBlockOperationRun_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [queue addOperation:blockOper];</div><div class=\"line\">    [queue addOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;QUEUEBlockOperationRun_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)invocationOperSel &#123;</div><div class=\"line\">    NSLog(@&quot;NSInvocationOperationRun_%@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"NSOperation的依赖关系\"><a href=\"#NSOperation的依赖关系\" class=\"headerlink\" title=\"NSOperation的依赖关系\"></a>NSOperation的依赖关系</h3><p>首先我们创建一个队列, 分别创建要执行的任务, <strong>在把要执行的任务添加到队列中去之前, 通过<code>addDependency</code>来建立任务间的依赖关系</strong>. 如果我们没有设置依赖的话, 如果设置的并发数大于1,  那么<code>blockOper_1</code>和<code>`blockOper_2</code>的执行顺序是随机的. 可是当我们执行<code>[blockOper_1 addDependency:blockOper_2]</code>时, 就给两个任务添加了依赖关系, <code>blockOper_1</code>永远只会在<code>blockOper_2</code>后执行. 即使我们给<code>blockOper_1</code>设置了最高的优先级, 因为<strong>依赖的优先级要高于<code>queuePriority</code></strong>. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)NSOperationQueueRun2 &#123;</div><div class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class=\"line\">//    queue.maxConcurrentOperationCount = 2;</div><div class=\"line\">    NSBlockOperation *blockOper_1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blockOper_1_%@_%@&quot;,@(1),[NSThread currentThread]);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    NSBlockOperation *blockOper_2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blockOper_2_%@_%@&quot;,@(2),[NSThread currentThread]);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">//    blockOper_1.queuePriority = NSOperationQueuePriorityVeryHigh;</div><div class=\"line\">    [blockOper_1 addDependency:blockOper_2];</div><div class=\"line\">    [queue addOperation:blockOper_1];</div><div class=\"line\">    [queue addOperation:blockOper_2];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"常见使用案列分析\"><a href=\"#常见使用案列分析\" class=\"headerlink\" title=\"常见使用案列分析\"></a>常见使用案列分析</h2><h3 id=\"案例一\"><a href=\"#案例一\" class=\"headerlink\" title=\"案例一\"></a>案例一</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)case1 &#123;</div><div class=\"line\">    NSLog(@&quot;任务一 - %@&quot;, [NSThread currentThread]);</div><div class=\"line\">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        NSLog(@&quot;同步任务 - %@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    NSLog(@&quot;任务二 - %@&quot;, [NSThread currentThread]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上<code>- (void)case1</code>默认在当前线程(主线程)执行,  首先执行”任务一”. 然后<code>dispatch_sync</code>阻塞当前线程(主线程), 由于主队列是串行队列, 任务不能并发执行, 同时只能有一个任务在执行. 又因为<strong>“同步任务”后入列, 按照FIFO原则, 必须等到<code>- (void)case1</code>执行完毕才能执行</strong>, 但是<code>- (void)case1</code>中的”任务二”又在等着”同步任务”执行完毕才能执行, 这样就造成同一队列中的两个任务相互等待, 造成死锁. </p>\n<p><img src=\"http://img.souche.com/f2e/5b1729532683ad164c061958d5248a66.png\" alt=\"案例1\"></p>\n<p>有两种解决思路, 一是为当前队列扩容, 让它变成并行队列, 就不会造成阻塞. 第二种解决思路是把同步任务添加到一个新的自定义串行队列中去, 两个队列之间不存在阻塞就避免了死锁问题. </p>\n<h3 id=\"案例二\"><a href=\"#案例二\" class=\"headerlink\" title=\"案例二\"></a>案例二</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)case2 &#123;</div><div class=\"line\">    NSLog(@&quot;1&quot;);</div><div class=\"line\">    //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</div><div class=\"line\">    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class=\"line\">        NSLog(@&quot;2&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    NSLog(@&quot;3&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印顺序一定为1, 2, 3. 2新开队列, 不会造成死锁. <code>case2</code>和新开的block任务之间没有队列的约束, 但是由于是同步任务,阻塞线程, 所以block先执行, 执行完毕后再回到<code>case2</code>, 接着执行.</p>\n<p><img src=\"http://img.souche.com/f2e/27086c860f921209238d3f60c2f8722c.png\" alt=\"案例2\"></p>\n<h3 id=\"案例三\"><a href=\"#案例三\" class=\"headerlink\" title=\"案例三\"></a>案例三</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)case3 &#123;</div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">    NSLog(@&quot;1&quot;); // 任务1</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;2&quot;); // 任务2</div><div class=\"line\">        dispatch_sync(queue, ^&#123;</div><div class=\"line\">            NSLog(@&quot;3&quot;); // 任务3</div><div class=\"line\">        &#125;);</div><div class=\"line\">        NSLog(@&quot;4&quot;); // 任务4</div><div class=\"line\">    &#125;);</div><div class=\"line\">    NSLog(@&quot;5&quot;); // 任务5</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>控制台输出1, 5, 2. (5, 2的顺序不一定). 可以肯定, 使用的是自定义串行队列. 首先执行任务1, 接下来有一个异步任务, 新开辟线程(将任务2, 同步线程, 任务4加入新线程). 因为是异步线程, 主线程中的任务5不用等待, 所以 2 和 5 的输出顺序不定. 任务2执行完后, 遇到同步任务, 因为是在串行队列, 所以会阻塞当前线程, 任务3执行完后才能执行任务4. 但是任务4比任务3早加入队列, 根据FIFO原则, 任务3要等待任务4执行完后才能执行. 任务3和任务4相互等待造成死锁. </p>\n<p><img src=\"http://img.souche.com/f2e/9c13eaeac28f7fe7105af2feb878d5ef.png\" alt=\"案例三图片\"></p>\n<h3 id=\"案例四\"><a href=\"#案例四\" class=\"headerlink\" title=\"案例四\"></a>案例四</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)case4 &#123;</div><div class=\"line\">    NSLog(@&quot;1&quot;); // 任务1</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        NSLog(@&quot;2&quot;); // 任务2</div><div class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            NSLog(@&quot;3&quot;); // 任务3</div><div class=\"line\">        &#125;);</div><div class=\"line\">        NSLog(@&quot;4&quot;); // 任务4</div><div class=\"line\">    &#125;);</div><div class=\"line\">    NSLog(@&quot;5&quot;); // 任务5</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果是: 1, 5, 2, 3, 4.(2, 5的顺序不定). 首先在主线程中有三个任务, 分别是任务1, 并行队列的异步任务, 任务5. 并行队列的异步任务中又有三个任务, 分别是任务2, 异步任务, 任务4.  </p>\n<p>所以先打印1, 然后把异步任务加入全部并行队列, 由于是异步任务新开辟线程, 不阻塞主线程, 5不用等待. 所以2, 5顺序不定. 然后再分析并行队列中的异步任务, 任务2执行后遇到同步任务, 同步任务被加入到主线程(因为前面已经被加过3个任务, 所以该任务在任务5后面). 因为是同步, 阻塞主线程, 所以4一定在3后面. </p>\n<p><img src=\"http://img.souche.com/f2e/43a48f9de1c0bb336215543157ad875b.png\" alt=\"案例四\"></p>\n<h3 id=\"案例五\"><a href=\"#案例五\" class=\"headerlink\" title=\"案例五\"></a>案例五</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)case5 &#123;</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;); // 任务1</div><div class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            NSLog(@&quot;2&quot;); // 任务2</div><div class=\"line\">        &#125;);</div><div class=\"line\">        NSLog(@&quot;3&quot;); // 任务3</div><div class=\"line\">    &#125;);</div><div class=\"line\">    NSLog(@&quot;4&quot;); // 任务4</div><div class=\"line\">    while (1) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;5&quot;); // 任务5</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果是: 1, 4(顺序不定). 首先主线程中有四个任务, 分别是全局并行队列的异步任务, 任务4, 死循环, 任务5. 全局并行队列的异步任务中又有三个任务, 分别是任务1, 主线程的同步任务(任务2), 任务3. </p>\n<p>由于是异步任务, 不阻塞主线程, 所以全局并行队列的异步任务执行顺序和任务4不定, 全局并行队列的异步任务又是先执行任务1, 所以任务1和任务4的顺序不定. 当任务4执行完后, 进入死循环, 主线程被阻塞. 由于同步任务(任务2)是被加在主线程中, 但是此时主线程已被阻塞, 所以2不会被执行. 任务3又是在任务2后被加入队列, 任务2是同步任务, 所以任务3要等待任务2完成才执行. 所以任务2, 任务3都不会执行. 任务5在死循环后执行, 所以任务5永远不会被执行. 如果没有死循环, 任务2肯定在任务后后面, 任务3肯定在任务2后面. </p>\n<p><img src=\"http://img.souche.com/f2e/0d108cba7a737b62e2f5e1be402bc5d0.png\" alt=\"案例五\"></p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.cocoachina.com/ios/20150731/12819.html\" target=\"_blank\" rel=\"noopener\">关于iOS多线程, 你看我就够了</a></p>\n<p>2.<a href=\"https://bestswifter.com/multithreadconclusion/\" target=\"_blank\" rel=\"noopener\">iOS多线程编程总结</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/51fd1362249e\" target=\"_blank\" rel=\"noopener\">关于iOS多线程, 我说, 你听, 没准你就懂了</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/06a18323d9d2\" target=\"_blank\" rel=\"noopener\">深入理解 GCD</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/6a6722f12fe3\" target=\"_blank\" rel=\"noopener\">关于 iOS 多线程, 都在这里了</a></p>\n<p>6.<a href=\"http://blog.csdn.net/mxsgoden/article/details/8821936\" target=\"_blank\" rel=\"noopener\">进程与线程的区别</a></p>\n<p>7.<a href=\"https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/\" target=\"_blank\" rel=\"noopener\">并发和并行</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"JavaScript第二弹","url":"http://hchong.net/2017/08/22/JavaScript第二弹/","content":"<h1 id=\"JavaScript第二弹\"><a href=\"#JavaScript第二弹\" class=\"headerlink\" title=\"JavaScript第二弹\"></a>JavaScript第二弹</h1><p>第一弹主要是一些基本语法, 数据类型和变量. 这一弹来说一下字符串, 数组和对象. </p>\n<blockquote>\n<p>在 <code>JavaScript</code>中，对象的定义是拥有属性和方法的数据.<br>严格来讲, <code>JavaScript</code>中的所有事物都是对象：字符串, 数字, 数组, 日期，等等.</p>\n</blockquote>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>和OC的没什么太大的区别, 这里只说几点比较特殊的.</p>\n<ul>\n<li>可以使用反引号` <code>...</code> `来标记一串带符号的文本, 例如</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">alert(`你好, </div><div class=\"line\">哈哈`);</div></pre></td></tr></table></figure>\n<p>中间的所有符号都会被保留下来, </p>\n<ul>\n<li>还可以在在` <code>你好 + ${string}</code> `来拼接字符串, 其中<code>${String}</code>代表一个叫做<code>String</code>的变量</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>区别于OC的数组, <code>JavaScript</code>的<code>Array</code>可以包含任意的数据类型, 通过索引来访问每个元素.</p>\n<p>Array属性:</p>\n<blockquote>\n<p>constructor 返回对创建此对象的数组函数的引用.<br>length 设置或返回数组中元素的数目.<br>prototype 使您有能力向对象添加属性和方法.</p>\n</blockquote>\n<p>Array 对象方法:</p>\n<blockquote>\n<p>indexOf() 搜索一个指定的元素的位置.<br>concat() 连接两个或更多的数组，并返回结果.<br>join() 把数组的所有元素放入一个字符串.元素通过指定的分隔符进行分隔.<br>pop() 删除并返回数组的最后一个元素<br>push() 向数组的末尾添加一个或更多元素，并返回新的长度.<br>shift() 删除并返回数组的第一个元素.<br>unshift() 向数组的开头添加一个或更多元素，并返回新的长度.<br>reverse() 颠倒数组中元素的顺序.<br>slice() 从某个已有的数组返回选定的元素.<br>sort() 对数组的元素进行排序.<br>splice(loc, len, newElement, …) 删除元素，并向数组添加新元素.<br>toSource() 返回该对象的源代码.<br>toString() 把数组转换为字符串，并返回结果.<br>toLocaleString() 把数组转换为本地数组，并返回结果.<br>valueOf() 返回数组对象的原始值.</p>\n</blockquote>\n<p>在这里需要注意, 直接使用<code>arr.length</code>是会改变原<code>arr</code>的长度的, 没有被赋值的元素就会变为<code>undefined</code>, 直接通过索引赋值, 也会出现这个问题. 例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var arr1 = [1, 2, 3];</div><div class=\"line\">arr1.length; // 3</div><div class=\"line\">arr1.length = 6;</div><div class=\"line\">arr1; // arr1变为[1, 2, 3, undefined, undefined, undefined]</div><div class=\"line\">arr1.length = 2;</div><div class=\"line\">arr1; // arr1变为[1, 2]</div><div class=\"line\"></div><div class=\"line\">var arr2 = [1, 2, 3];</div><div class=\"line\">arr2[5] = &apos;x&apos;;</div><div class=\"line\">arr2; // arr2变为[1, 2, 3, undefined, undefined, &apos;x&apos;]</div></pre></td></tr></table></figure>\n<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界.</p>\n","categories":["JavaScript"],"tags":["基础知识","JavaScript"]},{"title":"JavaScript第一弹","url":"http://hchong.net/2017/08/18/JavaScript第一弹/","content":"<h1 id=\"JavaScript第一弹\"><a href=\"#JavaScript第一弹\" class=\"headerlink\" title=\"JavaScript第一弹\"></a>JavaScript第一弹</h1><p>主要是一些JavaScript的一些基础知识, 和OC的一些区别</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>JavaScript可以嵌在网页的任意地方, 不过通常有两种写法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">  &lt;script&gt;</div><div class=\"line\">\t\tJavaScript代码</div><div class=\"line\">  &lt;/script&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  ...</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>或者把JavaScript代码放到一个单独的<code>.js</code>文件中, 然后在HTML中引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">  &lt;script src=&quot;.js文件的路径&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  ...</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>把JavaScript代码放入一个单独的<code>.js</code>文件中更利于维护代码，并且多个页面可以各自引用同一份<code>.js</code>文件。</p>\n<p>可以在同一个页面中引入多个<code>.js</code>文件，还可以在页面中多次编写<code>&lt;script&gt; js代码... &lt;/script&gt;</code>，浏览器按照顺序依次执行。</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型, 这一点和OC是有区别的.</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串是以<code>单引号&#39;</code>或<code>双引号&quot;</code>括起来的任意文本, 这和OC的略有不同. 和OC的字符串初始化不同的是, JS只需用引号括起来就代表一个字符串了.</p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>JavaScript允许对任意数据类型做比较. 要特别注意相等运算符<code>==</code>。JavaScript在设计时，有两种比较运算符：</p>\n<ul>\n<li>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</li>\n<li>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</li>\n</ul>\n<p>由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用<code>===</code>比较。</p>\n<p>这个和<code>OC</code>类似, 如果使用<code>===</code>比较的是两个基本数据类型, 只要值相等就位<code>true</code>. 但是如果是数组, 字典, 对象等其他类型, 那比较的就是内存地址, 而不是元素.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var arr1 = [1,2,3];</div><div class=\"line\">var arr2 = [1,2,3];</div><div class=\"line\">alert(arr1 === arr2)//false</div><div class=\"line\"></div><div class=\"line\">var str1 = &apos;123&apos;;</div><div class=\"line\">var str2 = &apos;123&apos;;</div><div class=\"line\">alert(str1 === str2);//true</div></pre></td></tr></table></figure>\n<p>关于数组元素的比较, 如果是OC的话, 可以使用<code>-(BOOL)isEquleToArray:(NSArray *)array;</code>来比较数组中的元素, 然而JS没有这种方法, 常见的做法是先排序, 再转成String, 再比较String是否相等. 参考<a href=\"https://gist.github.com/smallnewer/6535788\" target=\"_blank\" rel=\"noopener\">equalArray.js</a></p>\n<p><code>NaN</code>这个值通过<code>===</code>来比较大小永远为<code>false</code>, 包括与自身比较. 唯一的判断方法就是通过<code>isNaN()</code>函数.</p>\n<h3 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h3><p><code>null</code>表示一个“空”的值类似于OC的<code>nil</code>，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”.</p>\n<p>还有一个和null类似的undefined，它表示“未定义”. JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义.</p>\n<ul>\n<li>大多数情况下，我们都应该用null.</li>\n<li>undefined仅仅在判断函数参数是否传递的情况下有用, 未使用值来声明的变量，其值实际上是 undefined.</li>\n</ul>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量和OC的变量是一样的, 但是命名规则有所不同. 变量名是大小写, 数字, <code>$</code>, 和<code>_</code>组合, 且不能用数字开头. </p>\n<p>和OC一样, 使用<code>=</code>对变量进行赋值, 由于JS是一门动态语言, 在初始化变量时可以不指定变量类型, 这与OC略有不同.</p>\n<p>仅仅声明但是没有赋值的变量, 其值实际上是<code>undefined</code>.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var carname;</div><div class=\"line\">console.log(carname);</div></pre></td></tr></table></figure></p>\n<hr>\n<p>1.<a href=\"http://www.bootcss.com/p/underscore/\" target=\"_blank\" rel=\"noopener\">Underscore - 一个JavaScript 工具库</a>.<br>2.<a href=\"https://halfrost.com/lost_in_javascript/\" target=\"_blank\" rel=\"noopener\">JavaScript 新手的踩坑日记</a>.</p>\n","categories":["JavaScript"],"tags":["基础知识","JavaScript"]},{"title":"UIView系列之---iOS的动态高度","url":"http://hchong.net/2017/07/24/UIView系列之---iOS的动态高度/","content":"<h1 id=\"UIView系列之—iOS的动态高度\"><a href=\"#UIView系列之—iOS的动态高度\" class=\"headerlink\" title=\"UIView系列之—iOS的动态高度\"></a>UIView系列之—iOS的动态高度</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<p>不论是UITableViewCell的高度也好, 或者是一个输入框也好, 都会用到动态布局. 实际上就是对一些显示文本内容的控件进行高度计算, 然后根据子视图的约束, 布局来得到父视图的高度并且改变他. </p>\n<h2 id=\"iOS布局机制大概分这么几种常见的方式\"><a href=\"#iOS布局机制大概分这么几种常见的方式\" class=\"headerlink\" title=\"iOS布局机制大概分这么几种常见的方式:\"></a>iOS布局机制大概分这么几种常见的方式:</h2><ul>\n<li><p>frame layout. frame layout最简单直接, 即通过设置view的frame属性值进而控制view的位置(相对于superview的位置)和大小. </p>\n</li>\n<li><p>autoresizing. autoresizing和frame layout一样, 从一开始存在, 它算是对frame layout的的补充,, 基于autoresizing机制, 能够让subview和superview维持一定的布局关系, 譬如让subview的大小适应superview的大小,, 随着后者的改变而改变. </p>\n<p>  站在代码接口的角度来看, autoresizing主要体现在几个属性上, 包括(但不限于):</p>\n<ul>\n<li><p><code>translatesAutoresizingMaskIntoConstraints</code>. 标识view是否愿意被autoresize;</p>\n</li>\n<li><p><code>autoresizingMask</code>. 是一个枚举值, 决定了当superview的size改变时, subview应该做出什么样的调整;</p>\n<p>autoresizing存在的不足是非常显著的, 通过autoresizingMask的可选枚举值可以看出: 基于autoresizing机制, 我们只能让view在superview的大小改变时做些调整; 而无法处理兄弟view之间的关系, 譬如处理与兄弟view的间隔; 更无法反向处理, 譬如让superview依据subview的大小进行调整. </p>\n</li>\n</ul>\n</li>\n<li><p>Auto layout. Auto Layout是随着iOS 6推出来的, 它是一种基于约束的布局系统, 可以根据你在元素(对象)上设置的约束自动调整元素(对象)的位置和大小对于某个view的布局方式. </p>\n<blockquote>\n<p>Auto Layout is a system that lets you lay out your app’s user interface by creating a mathematical description of the relationships between the elements. You define these relationships in terms of constraints either on individual elements, or between sets of elements. Using Auto Layout, you can create a dynamic and versatile interface that responds appropriately to changes in screen size, device orientation, and localization.</p>\n</blockquote>\n</li>\n</ul>\n<p>autoresizing和auto layout只能二选一, 简单来说, 若要对某个view采用auto layout布局, 则需要设置其<code>translatesAutoresizingMaskIntoConstraints</code>属性值为NO.</p>\n<h2 id=\"常见Auto-Layout场景下的运用\"><a href=\"#常见Auto-Layout场景下的运用\" class=\"headerlink\" title=\"常见Auto Layout场景下的运用\"></a>常见Auto Layout场景下的运用</h2><p>下面主要就几种常见场景下, Auto Layout的运用来说明一下用法. 在这里先说明一个概念 <em>Leaf-level views</em>, Leaf-level views指的是不包含任何subview的view, 譬如UILabel, UIButton等. 但是有些view不包含content, 譬如UIView, 这种view被认为「has no intrinsic size」, 它们的intrinsicContentSize返回的值是(-1, -1). </p>\n<h3 id=\"Leaf-level-views高度计算\"><a href=\"#Leaf-level-views高度计算\" class=\"headerlink\" title=\"Leaf-level views高度计算\"></a>Leaf-level views高度计算</h3><p>这类的view往往能够直接计算出content(譬如UILabel的text, UIButton的title, UIImageView的image)的大小. 以UILabel为例:</p>\n<p>假设我们已经设置了UILabel的x, y值约束, 没有设置与size有关的约束. 如果我们要根据UILabel的文本内容来计算最合适的size, 我们可以自定义一个Custom Label, 继承于UILabel, 在Custom Label中重写<code>- (CGSize)intrinsicContentSize</code>方法. 返回我们希望返回的size. 在需要使用UILabel的地方我们就可以通过使用Custom Label来实现搞得的正确计算. </p>\n<p>关于<code>intrinsicContentSize</code>方法的理解是, Auto Layout System在layout时, 不知道该为view分配多大的size, 因此回调view的<code>intrinsicContentSize</code>方法, 该方法会给auto layout system一个合适的size, system根据此size对view的大小进行设置; </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface CustomLabel : UILabel</div><div class=\"line\">    </div><div class=\"line\">@end</div><div class=\"line\">    </div><div class=\"line\">@implementation CustomLabel</div><div class=\"line\">    </div><div class=\"line\">- (CGSize)intrinsicContentSize &#123;</div><div class=\"line\">    CGSize size = [super intrinsicContentSize];</div><div class=\"line\">    size.width  += 20;</div><div class=\"line\">    size.height += 20;</div><div class=\"line\">    return size;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>以上如果是单行label的话, 实现起来没问题. 但是如果label一行显示不下需要换行的话, 那事情就没这么简单了. 但是怎么计算多行label的高度呢? 有以下几种方法: </p>\n<p>下面几种方法都需要我们首先设置<code>preferredMaxLayoutWidth</code>, 也就是UILabel的Width最大值, label会根据这个最大值来换行. 再设置<code>numberOfLines = 0</code>, 来实现换行. ==注意:== <code>preferredMaxLayoutWidth</code>适用于没有指定UILabel的Width的情况, 如果设置了Width的约束, 又设置了<code>preferredMaxLayoutWidth</code>. 那么计算size会以<code>preferredMaxLayoutWidth</code>为准, 显示则以Width的约束为准.</p>\n<ol>\n<li><p><code>boundingRectWithSize:options:attributes:context:</code></p>\n<p> <code>boundingRectWithSize:options:attributes:context:</code>是NSString的方法. 理解起来也非常简单, 根据一些绘制字符的选项和字符属性(字体, 字号, 字体颜色)等信息返回一个可以容纳字符串内容的CGRect. 它同样也需要一个CGSize来确定绘制区域.<br> size: 通常你可以传一个任意的Size, 它会返回一个它认为最合适的CGSize给你. 不过如果要想把视图的内容显示完全(纵向), 最好是将视图的实际宽度和最大高度<code>CGFLOAT_MAX</code>作为参数传递. 这样返回的才是完全显示内容的Size.<br> options: 默认情况下这个方法不会绘制多行, 如果要绘制多行字符, 那么options参数必须为: <code>NSStringDrawingUsesLineFragmentOrigin</code>.<br> attributes: 字符属性信息也非常重要. 如果要显示UILabel的全部内容, 必须传递这个参数. 以确保绘制的字体大小和UILabel的字体大小一致, </p>\n<p> 最后一个关键点是，这个方法返回的CGRect中Size的width和height都是小数，所以必须使用ceil函数才能确保结果的准确性。</p>\n</li>\n<li><p><span id=\"sizeThatFits\">sizeThatFits:</span></p>\n<blockquote>\n<p>Asks the view to calculate and return the size that best fits the specified size.</p>\n<p>Return Value<br>A new size that fits the receiver’s subviews.</p>\n<p>Discussion<br>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.</p>\n</blockquote>\n<p> sizeThatFits: 方法意味着「根据文本计算最适合的size」, 但是并不改变调用者的size. 它需要传入一个CGSize参数这个参数和<code>boundingRectWithSize:options:attributes:context:</code>中size的作用和意义是一样的. </p>\n</li>\n<li><p><span id=\"sizeToFit\">sizeToFit:</span></p>\n<blockquote>\n<p>calls sizeThatFits: with current view bounds and changes bounds size. </p>\n</blockquote>\n<p> <code>sizeToFit</code>内部会调用<code>sizeThatFits:</code>方法, 然后改变调用者的size. sizeToFit的伪代码大致如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// calls sizeThatFits</div><div class=\"line\">CGSize size = [self sizeThatFits:self.bounds.size];</div><div class=\"line\">// change bounds size</div><div class=\"line\">CGRect bounds = self.bounds;</div><div class=\"line\">bounds.size.width = size.width;</div><div class=\"line\">bounds.size.height = size.width;</div><div class=\"line\">self.bounds = bounds;</div></pre></td></tr></table></figure>\n</li>\n<li><p><span id=\"systemLayoutSizeFittingSize\">systemLayoutSizeFittingSize</span> </p>\n<p> <code>systemLayoutSizeFittingSize</code>, 它也是UIView的方法, 是AutoLayout诞生后的产物. 所以使用它的前提是需要展示内容的控件(这里指的就是UILabel)必须约束完美. 不然就不会起作用。而且必须要设置UILabel的<code>preferredMaxLayoutWidth</code>属性.<br> 这个属性非常重要, 它影响着layout. 如果设置了<code>preferredMaxLayoutWidth</code>, 当内容超过约束区域, 就会自动换行并且更新约束. 在良好约束的前提下, <code>systemLayoutSizeFittingSize</code>同样接受一个CGSize, 不同的是这次不用计算了, 直接使用系统提供的Fitting Size即可:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">const CGSize UILayoutFittingCompressedSize; //在保证适当尺寸的前提下尽量压缩CGSize的大小</div><div class=\"line\">const CGSize UILayoutFittingExpandedSize; //在保证适当尺寸的前提下尽量扩充CGSize的大小</div></pre></td></tr></table></figure>\n<p> 所以为了刚好将UILabel的内容显示完全，应该使用UILayoutFittingCompressedSize。代码如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)layoutSubviews &#123;</div><div class=\"line\">    [super layoutSubviews];</div><div class=\"line\">    self.label.preferredMaxLayoutWidth = CGRectGetWidth(self.label.bounds);</div><div class=\"line\">    CGSize size = [self.label systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];</div><div class=\"line\">    self.labelConstraintHeight.constant = size.height + (2 * MARGIN);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 需要注意的是: 约束的上下左右一定要写好, 但是不能约束UILabel的高度. 否则可能会导致返回的CGRect不准确. <code>numberOfLines = 0</code> 让Label可以显示多行内容. 设置<code>preferredMaxLayoutWidth</code>属性, 使UILabel能自适应多行内容. <code>UILayoutFittingCompressedSize</code> 使用这个参数会返回符合条件最合适的Size. 最后也要加上边距, 主要是因为这里我们在内部计算UILabel的Size, 而如果在外部对View调用<code>systemLayoutSizeFittingSize</code>方法, 就会得到整个View视图的Size. </p>\n</li>\n</ol>\n<p><code>sizeThatFits:</code>和<code>boundingRectWithSize:options:attributes:context:</code>这两个API也可以在传统布局(基于Frame)的情况下使用. </p>\n<h3 id=\"非Leaf-level-views高度计算\"><a href=\"#非Leaf-level-views高度计算\" class=\"headerlink\" title=\"非Leaf-level views高度计算\"></a>非Leaf-level views高度计算</h3><p>以UITextView显示文本为例, 让其能够自适应文本, 即根据文本自动调整其大小; 由于<code>intrinsicContentSize</code>的特性, 当其内部含有subView时返回值是(-1, -1), 无法向auto layout system传递我们想要传达的值, 我们可以使用<a href=\"#sizeThatFits\">sizeThatFits</a>或者<a href=\"#sizeToFit\">sizeToFit</a>来计算或者改变UITextView的大小. </p>\n<p>==这里需要注意的是:== 当调用<code>sizeThatFits:</code>的size=(width, height)，当width/height的值为0时，width/height就被认为是无穷大, size就不能被正常的显示. 所以区别于UILabel, 我们的约束一定要设置好Width和height, 否则使用<code>sizeToFit</code>也不能正确计算出. </p>\n<h3 id=\"Leaf-level-views和非Leaf-level-views混合使用下高度计算\"><a href=\"#Leaf-level-views和非Leaf-level-views混合使用下高度计算\" class=\"headerlink\" title=\"Leaf-level views和非Leaf-level views混合使用下高度计算\"></a>Leaf-level views和非Leaf-level views混合使用下高度计算</h3><p>这里我们需要计算的是根据subView来确定superView的frame, 大致分为一下几种情况: </p>\n<ol>\n<li><p>多个纯Leaf-level views的组合使用</p>\n<p> 这个计算起来比较简单, 我们以一个UIView里面添加两个UILabel为例. 我们只需要从上到下, 把subViews的子约束撑满superView. 需要注意, 如果UILabel需要换行, 那么高度约束就不能写, 并且要设置<code>numberOfLines = 0</code>. 虽然我们什么也没做, 但是子控件会通过<code>intrinsicContentSize</code>方法将最合适的size告诉superView. 但是对于superView, 因为它本身是UIVIew, 他的<code>intrinsicContentSize</code>返回是(-1, -1), 那么它是怎么得出正确的结果呢. auto layout system在处理某个view的size时，<span id=\"size\">参考值</span>包括:</p>\n<ul>\n<li>自身的<code>intrinsicContentSize</code>方法返回值;</li>\n<li>subviews的<code>intrinsicContentSize</code>方法返回值;</li>\n<li><p>自身和subviews的constraints;</p>\n<p>系统会将superView的size和subViews的约束以及<code>intrinsicContentSize</code>返回的正确size相加, 然后比较两个值的大小, 然后取最大的一个.<br><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fjvnn0tr2lj30ok0ru0st.jpg\" alt=\"约束\"></p>\n<p>size1, size2, size3, 分别是label1, label2, superView的<code>intrinsicContentSize</code>方法返回的size.<br>width = max{91 + size1.width + 91 + size2.width, size3.width}<br>height = max{60 + size1.height + 36 + size2.height + 58, size3.height}</p>\n</li>\n</ul>\n</li>\n<li><p>多个纯非Leaf-level views的组合使用</p>\n<p> 仍旧以UITextView为例, 如果没有设定UItextView的height属性的话, 由于非Leaf-level views的<code>intrinsicContentSize</code>返回值值为(-1, -1). 设置某个View的size有三个<a href=\"#size\">参考值</a>, 在<code>intrinsicContentSize</code>方法返回值和constraints中取最大值为0, 导致height=0不能正常显示. 解决方案参考<a href=\"#next\">下一个</a>;</p>\n</li>\n<li><p><span id=\"next\">Leaf-level views和非Leaf-level views混合使用</span></p>\n<p> 因为有UItextView这种非Leaf-level views的存在, 会导致superView的size不能得到正常值. 解决方案有两种:</p>\n<ol>\n<li><p>设置非Leaf-level views的height, width约束, 因为<code>intrinsicContentSize</code>方法不能正常的返回size, 但是如果我们设置了width和height约束, constraints就不为0, 那么就可以正常显示了. </p>\n</li>\n<li><p>使用<code>systemLayoutSizeFittingSize:</code>, 具体使用方式可以参考<a href=\"#systemLayoutSizeFittingSize\">systemLayoutSizeFittingSize:</a>.</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Cell的动态高度计算\"><a href=\"#Cell的动态高度计算\" class=\"headerlink\" title=\"Cell的动态高度计算\"></a>Cell的动态高度计算</h3><p>对于使用auto layout机制布局的view, auto layout system会在布局过程中综合各种约束的考虑为之设置一个size, 在布局完成后, 该size的值即为view.frame.size的值; 这包含的另外一层意思, 即在布局完成前, 我们是不能通过view.frame.size准确获取view的size的. 但有时候, 我们需要在auto layout system对view完成布局前就知道它的size, <code>systemLayoutSizeFittingSize:</code>方法正是能够满足这种要求的API. <code>systemLayoutSizeFittingSize:</code>方法会根据其constraints返回一个合适的size值. </p>\n<p>在这里看一下比较知名的cell高度计算库<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\" target=\"_blank\" rel=\"noopener\">UITableView-FDTemplateLayoutCell</a>的核心高度计算方法, 大体上和我们所使用的方法差不多. Auto layout mode using <code>-systemLayoutSizeFittingSize:</code>, Frame layout mode using <code>-sizeThatFits:</code>. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123;</div><div class=\"line\">    CGFloat contentViewWidth = CGRectGetWidth(self.frame);</div><div class=\"line\">    </div><div class=\"line\">    // If a cell has accessory view or system accessory type, its content view&apos;s width is smaller</div><div class=\"line\">    // than cell&apos;s by some fixed values.</div><div class=\"line\">    if (cell.accessoryView) &#123;</div><div class=\"line\">        contentViewWidth -= 16 + CGRectGetWidth(cell.accessoryView.frame);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        static const CGFloat systemAccessoryWidths[] = &#123;</div><div class=\"line\">            [UITableViewCellAccessoryNone] = 0,</div><div class=\"line\">            [UITableViewCellAccessoryDisclosureIndicator] = 34,</div><div class=\"line\">            [UITableViewCellAccessoryDetailDisclosureButton] = 68,</div><div class=\"line\">            [UITableViewCellAccessoryCheckmark] = 40,</div><div class=\"line\">            [UITableViewCellAccessoryDetailButton] = 48</div><div class=\"line\">        &#125;;</div><div class=\"line\">        contentViewWidth -= systemAccessoryWidths[cell.accessoryType];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // If not using auto layout, you have to override &quot;-sizeThatFits:&quot; to provide a fitting size by yourself.</div><div class=\"line\">    // This is the same height calculation passes used in iOS8 self-sizing cell&apos;s implementation.</div><div class=\"line\">    //</div><div class=\"line\">    // 1. Try &quot;- systemLayoutSizeFittingSize:&quot; first. (skip this step if &apos;fd_enforceFrameLayout&apos; set to YES.)</div><div class=\"line\">    // 2. Warning once if step 1 still returns 0 when using AutoLayout</div><div class=\"line\">    // 3. Try &quot;- sizeThatFits:&quot; if step 1 returns 0</div><div class=\"line\">    // 4. Use a valid height or default row height (44) if not exist one</div><div class=\"line\">    </div><div class=\"line\">    CGFloat fittingHeight = 0;</div><div class=\"line\">    </div><div class=\"line\">    if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) &#123;</div><div class=\"line\">        // Add a hard width constraint to make dynamic content views (like labels) expand vertically instead</div><div class=\"line\">        // of growing horizontally, in a flow-layout manner.</div><div class=\"line\">        NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth];</div><div class=\"line\">        [cell.contentView addConstraint:widthFenceConstraint];</div><div class=\"line\">        </div><div class=\"line\">        // Auto layout engine does its math</div><div class=\"line\">        fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;</div><div class=\"line\">        [cell.contentView removeConstraint:widthFenceConstraint];</div><div class=\"line\">        </div><div class=\"line\">        [self fd_debugLog:[NSString stringWithFormat:@&quot;calculate using system fitting size (AutoLayout) - %@&quot;, @(fittingHeight)]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (fittingHeight == 0) &#123;</div><div class=\"line\">#if DEBUG</div><div class=\"line\">        // Warn if using AutoLayout but get zero height.</div><div class=\"line\">        if (cell.contentView.constraints.count &gt; 0) &#123;</div><div class=\"line\">            if (!objc_getAssociatedObject(self, _cmd)) &#123;</div><div class=\"line\">                NSLog(@&quot;[FDTemplateLayoutCell] Warning once only: Cannot get a proper cell height (now 0) from &apos;- systemFittingSize:&apos;(AutoLayout). You should check how constraints are built in cell, making it into &apos;self-sizing&apos; cell.&quot;);</div><div class=\"line\">                objc_setAssociatedObject(self, _cmd, @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">        // Try &apos;- sizeThatFits:&apos; for frame layout.</div><div class=\"line\">        // Note: fitting height should not include separator view.</div><div class=\"line\">        fittingHeight = [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height;</div><div class=\"line\">        </div><div class=\"line\">        [self fd_debugLog:[NSString stringWithFormat:@&quot;calculate using sizeThatFits - %@&quot;, @(fittingHeight)]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // Still zero height after all above.</div><div class=\"line\">    if (fittingHeight == 0) &#123;</div><div class=\"line\">        // Use default row height.</div><div class=\"line\">        fittingHeight = 44;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // Add 1px extra space for separator line if needed, simulating default UITableViewCell.</div><div class=\"line\">    if (self.separatorStyle != UITableViewCellSeparatorStyleNone) &#123;</div><div class=\"line\">        fittingHeight += 1.0 / [UIScreen mainScreen].scale;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return fittingHeight;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.cocoachina.com/industry/20140604/8668.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>也有一些常见cell布局的高度计算方法, 可以参考下.</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://zhangbuhuai.com/beginning-auto-layout-part-1/\" target=\"_blank\" rel=\"noopener\">深入理解Auto Layout</a>.</p>\n<p>2.<a href=\"http://www.cocoachina.com/industry/20140604/8668.html\" target=\"_blank\" rel=\"noopener\">动态计算UITableViewCell高度</a></p>\n<p>3.<a href=\"http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/\" target=\"_blank\" rel=\"noopener\">优化UITableViewCell高度计算的那些事</a></p>\n<p>4.<a href=\"http://sylenthwave.github.io/2016/01/02/iOS%E5%8A%A8%E6%80%81%E5%8F%98%E9%AB%98%E6%80%BB%E7%BB%93/\" target=\"_blank\" rel=\"noopener\">iOS动态变高总结</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---如何写一个自定义View","url":"http://hchong.net/2017/07/15/UIView系列之---如何写一个自定义View/","content":"<h1 id=\"UIView系列之—如何写一个自定义View\"><a href=\"#UIView系列之—如何写一个自定义View\" class=\"headerlink\" title=\"UIView系列之—如何写一个自定义View\"></a>UIView系列之—如何写一个自定义View</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<p>这一篇和前面的实际是一个系列, 但是有不太一样, 也稍微偏架构和规范一些. 说一下在实际编程中的写法. </p>\n<h2 id=\"通用的自定义类的function归纳\"><a href=\"#通用的自定义类的function归纳\" class=\"headerlink\" title=\"通用的自定义类的function归纳\"></a>通用的自定义类的function归纳</h2><p>一个自定义类中的代码首先是有序的, 不管是<code>UIVIewControl</code>, <code>UIVIew</code>, 或者<code>NSObject</code>, 都应该把具有相同作用的function归纳为一个类, 我一般按照下面这样来分割代码, 这样看上去会比较有条理: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#pragma mark - LifeCycle</div><div class=\"line\">这里面是一些类的生命周期的方法, 以及overWrite的父类的方法</div><div class=\"line\">#pragma mark - UIConfig</div><div class=\"line\">这里面是和当前类的UI相关的设置信息</div><div class=\"line\">#pragma mark - HttpRequest</div><div class=\"line\">当前类的网络请求部分</div><div class=\"line\">#pragma mark - XXXDelegate</div><div class=\"line\">当前类响应的代理事件</div><div class=\"line\">#pragma mark - Action</div><div class=\"line\">当前类的EventResponse事件</div><div class=\"line\">#pragma mark - Private</div><div class=\"line\">当前类中所用到的一些工具function, 不过一般不建议写在这里面, 我们应该按照模块新建一个专门的工具类来管理这些function</div><div class=\"line\">#pragma mark - Getter, Setter</div><div class=\"line\">当前类中用到的所有属性的Getter和Setter, 强烈推荐这么些, 这样可以把当前类的子控件的初始化放到Getter中去, 维护了代码的整洁度.</div></pre></td></tr></table></figure>\n<p>除此之外, 上面这个顺序一般是按照使用者对这个类中所有function的关心程度来排序的, 例如对Lifecycle和UIConfig的关心程度就比Getter和Setter的程度高. 如果这个类还是特别长的话, 那就建议把代码在拆分为各个独立功能的category, 或者把尽量多的Private方法拆分为独立的工具类, 这样不管是对当前类的代码量, 或者后面可能会使用到这些PrivateFunction的人来说都是比较合理的做法. </p>\n<h2 id=\"组合代替继承\"><a href=\"#组合代替继承\" class=\"headerlink\" title=\"组合代替继承\"></a>组合代替继承</h2><p>除此之外, 对于复杂类来说我们要尽量<em>使用组合来代替继承</em>. 例如当前有一个类实现了A功能, 业务发展我们要使用A+B功能, 我们可能会想到写一个A的子类A’, 在里面再加上B功能, 完美解决. 那么后面我们要再使用A+B+C功能, 那么我们可能会写一个A’的子类A’’, 在里面实现C的功能, 又完美实现. 那如果突然有一天, 产品经理突然说要实现A+C功能呢, 傻眼了, 一大坨代码怎么拆分. 所以正确的做法应该是, 我们新建三个类, 分别独立实现A, B, C的功能, 业务方要用哪个就自由组合, 假设后面再来了D, E, F我们也不怕, 我们只用像插件一样, 用到哪个组合哪个就好. </p>\n<h2 id=\"UIView的写法\"><a href=\"#UIView的写法\" class=\"headerlink\" title=\"UIView的写法\"></a>UIView的写法</h2><p>UIView作为直接展示给用户看的层面, 是最重要的部分. 我强烈推荐使用纯代码布局, 使用Frame或者Autolayout都可以. 使用Frame的话, 推荐使用<a href=\"https://github.com/casatwy/HandyAutoLayout\" target=\"_blank\" rel=\"noopener\">这个项目</a>. 如果使用AutoLayout的话, <code>masonry</code>则是很不错的选择. </p>\n<p>objc构建一个对象使用的是两段式, 首先分配内存<code>alloc</code>然后<code>init</code>, 这样的好处就是将内存操作和初始化操作解耦合, 让我们能够在初始化的时候对对象做一些必要的操作. 这是个很好的思路, 我们在做很多事情的时候都可以使用这种两段式的思路. 比如布局一个UIView, 我们可以分成两部, <a href=\"#alloc\">初始化必要的子view和变量</a>, <a href=\"#init\">然后在合适的时机进行布局</a>. 一般来说我们的自定义类继承自UIView, 首先在initWithFrame:方法中将需要的子控件加入view中. 注意, 这里只是加入到view中, 并没有设置各个子控件的尺寸.</p>\n<h3 id=\"初始化必要的子view和变量\"><a href=\"#初始化必要的子view和变量\" class=\"headerlink\" title=\"初始化必要的子view和变量\"></a><span id=\"alloc\">初始化必要的子view和变量</span></h3><p>所以第一步应该是: <code>- (id)initWithFrame:(CGRect)aRect</code>, 那我们为什么不适用<code>- (id)init</code>来完成初始化呢? 如果是这种情况, 那么在init方法中frame是不确定的, 此时如果在initWithFrame:方法中设置尺寸, 那么各个子控件的尺寸都会是0, 因为这个view的frame还没有设置.所以我们应该保证view的frame设置完才会设置它的子控件的尺寸. </p>\n<p>还有就是这个函数是无论你用什么初始化函数都会被调用的一个, 比如你用<code>[UIView new]</code>或者<code>[[UIView alloc] init]</code>都会调用initWithFrame这个函数(有些UIView的子类有特殊情况，比如UITableViewCell), 所以你要是对一个view的变量有初始化的操作尽量往initWithFrame里面放还是非常合适的.  并且这样也能够保证, 以后在使用的时候所有的变量都被正确的初始化过. 而我们一般会在initWithFrame中做些什么呢.</p>\n<ul>\n<li>添加子View</li>\n<li>初始化属性变量</li>\n<li>其他一些共用操作</li>\n</ul>\n<h3 id=\"在合适的时机进行布局\"><a href=\"#在合适的时机进行布局\" class=\"headerlink\" title=\"在合适的时机进行布局\"></a><span id=\"init\">在合适的时机进行布局</span></h3><p>初始化函数中有一个名称withFrame, 大家可能就会以为这个函数使用布局用的. 然而在代码逻辑比较清晰的工程中，几乎很少看到在这个函数中进行界面布局的工作, 因为UIKit给你提供了一个专门的函数<code>layoutSubViews</code>来干这个事情. 而且, 在这个函数中做的界面布局的工作, 是一次性编码, 界面布局没有任何复用性, 如果父View的大小变了之后, 这个View还是傻傻的保持原来的模样. 同时也会造成, 初始化函数臃肿, 导致维护上的困难. 所以在<code>layoutSubViews</code>中对子视图进行布局才是最合理的地方. </p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>一个控件有2种创建方式: </p>\n<ul>\n<li>通过代码创建</li>\n</ul>\n<p>初始化时一定会调用<code>initWithFrame:</code>方法. </p>\n<ul>\n<li>通过xib\\storyboard创建</li>\n</ul>\n<p>初始化时不会调用<code>initWithFrame:</code>方法, 只会调用<code>initWithCoder:</code>方法, 初始化完毕后会调用<code>awakeFromNib</code>方法注意要在在awakeFromNib中初始化子控件</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈</a></p>\n<p>2.<a href=\"https://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1124.html\" target=\"_blank\" rel=\"noopener\">视图类, 如何布局</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---UIView的常见layout方法","url":"http://hchong.net/2017/07/10/UIView系列之---UIView的常见layout方法/","content":"<h2 id=\"UIView系列之—UIView的常见layout方法\"><a href=\"#UIView系列之—UIView的常见layout方法\" class=\"headerlink\" title=\"UIView系列之—UIView的常见layout方法\"></a>UIView系列之—UIView的常见layout方法</h2><ul>\n<li><p><code>init</code> &amp; <code>initWithFrame</code></p>\n<p>  <code>init</code> 和 <code>initWithFrame</code>方法, 实际上都会调用<code>initWithFrame</code>方法来完成初始化, 不同的是在<code>init</code>方法内部获取到的<code>self.frame</code>是<code>CGRectZero</code>, 在<code>initWithFrame</code>中获取到的<code>self.frame</code>就是初始化时, 传入的<code>frame</code>的大小. 不过一般不建议在初始化方法中设置子控件的<code>frame</code>, 因为这时<code>self.frame</code>时机还不是固定的.</p>\n</li>\n<li><p>layoutSubviews</p>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Lays out subviews.<br>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>\n<p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p>\n<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>\n</blockquote>\n<p>翻译成人话大概就是: <code>layoutSubviews</code>方法用来布局子视图. 在<code>layoutSubviews</code>方法内部直接给需要改变布局的子视图赋值新frame来改变其<code>frame</code>. 该方法主要应用在封装的自定义<code>view</code>中, 我们通过重写这个方法完成自定义<code>view</code>中子视图的布局. 但是我们不能直接调用他来更新子视图的<code>frame</code>. 只能通过<a href=\"#layoutIfNeeded\">layoutIfNeeded</a>或者<a href=\"#setNeedsLayout\">setNeedsLayout</a>来调用, 或者等待系统触发. 系统触发<code>layoutSubviews</code>的<a href=\"#layoutSubviews\">条件</a>.</p>\n<ul>\n<li><span id=\"setNeedsLayout\">setNeedsLayout</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.</p>\n<p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.</p>\n</blockquote>\n<p>翻译成人话大概就是: 如果一个layer的sublayer布局发生了改变需要更新布局, 我们通过调用<code>setNeedsLayout</code>方法来标记这个layer. 或者当layer的bounds发生变化或者layer上进行了add或者remove sublayer操作, 系统会自动调用<code>setNeedsLayout</code>方法. 这些被标记需要更新布局的layer会在下一个视图绘制周期(iOS屏幕刷新频率为60HZ, 因此下一个视图绘制周期是1/60s后)触发layoutSubviews完成子视图布局更新.</p>\n<p>如果你想要更新一个视图的子视图布局, 那么可以在主线程中调用这个方法来标记当前视图为需要更新子视图布局的视图. 可以使用这个方法给多个不同的view标记需要更新子视图布局, 然后在下一个视图绘制周期中这些view的subviews就会被一块更新布局, 这样做是可以很大地提高性能和效率的. </p>\n<ul>\n<li><span id=\"layoutIfNeeded\">layoutIfNeeded</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Lays out the subviews immediately.<br>Use this method to force the layout of subviews before drawing. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root.</p>\n</blockquote>\n<p>翻译成人话大概就是: 在下一次绘图周期开始之前使用此方法强制进行子视图的布局更新. 此方法会将receiver作为根视图, 然后从根视图开始遍历根视图的subview链, 判断super layer是否被标记需要更新布局, 直到找到一个super layer没有标记更新布局为止, 然后系统会向所有这些被标记需要更新布局的layer发送<code>layoutSublayers</code>消息. <code>layoutSublayers</code>是<code>setNeedsLayout</code>的一个辅助方法, 调用该方法就意味着不会等到下个绘制周期, 而是立马触发<code>layoutSubviews</code>方法, 完成子视图的布局. </p>\n<p>但是需要注意只有当系统检测到某个view被<code>setNeedsLayout</code>标记之后才会立即触发<code>layoutSubviews</code>, 如果没有检测到<code>setNeedsLayout</code>标记就不会触发<code>layoutSubviews</code>, 所以如果想要立即刷新某个视图的子视图布局, 需要先让该视图调用<code>setNeedsLayout</code>方法标记一下, 然后再调用<code>layoutIfNeeded</code>. 另外所有的视图在第一次显示之前都是默认有<code>setNeedsLayout</code>标记的, 所以视图第一次显示的时候就可以直接调用<code>layoutIfNeeded</code>. 但是当第一次显示完成后, 如果还想要调用<code>layoutIfNeeded</code>就必须先使用<code>setNeedsLayout</code>标记一下. </p>\n<ul>\n<li>setNeedsDisplay</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Marks the receiver’s entire bounds rectangle as needing to be redrawn.<br>You can use this method or the <code>setNeedsDisplayInRect:</code> to notify the system that your view’s contents need to be redrawn. This method makes a note of the request and returns immediately. The view is not actually redrawn until the next drawing cycle, at which point all invalidated views are updated.</p>\n<p>其他说明:<br>You should only be calling setNeedsDisplay if you override drawRect in a subclass of UIView which is basically a custom view drawing something on the screen, like lines, images, or shapes like a rectangle.</p>\n</blockquote>\n<p>如果我们在自定义的UIView中, 重写了<code>drawRect:</code>方法在屏幕上绘制一些东西, 那就需要在合适的地方调用<code>setNeedsDisplay</code>来标记当前视图, 系统会在下一个绘制周期时触发<code>drawRect:</code>方法. <a href=\"#drawRect\">系统触发drawRect:的条件</a>.</p>\n<p>也可以使用<code>setNeedsDisplayInRect:</code>方法来标记视图的某个区域需要重新绘制.</p>\n<ul>\n<li>drawRect</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Draws the receiver’s image within the passed-in rectangle</p>\n<p>The default implementation of this method does nothing. Subclasses that use technologies such as Core Graphics and UIKit to draw their view’s content should override this method and implement their drawing code there. You do not need to override this method if your view sets its content in other ways. For example, you do not need to override this method if your view just displays a background color or if your view sets its content directly using the underlying layer object.</p>\n<p>This method is called when a view is first displayed or when an event occurs that invalidates a visible part of the view. You should never call this method directly yourself. To invalidate part of your view, and thus cause that portion to be redrawn, call the <code>setNeedsDisplay</code> or <code>setNeedsDisplayInRect:</code> method instead.</p>\n</blockquote>\n<p>drawRect使用:</p>\n<p>该方法默认没有做任何操作, 如果视图中包含我们用<code>UIKit</code>或者<code>Core Graphics</code>绘制的内容, 我们需要重写该方法. 当视图第一次出现, 或者是改变约束条件让视图的全部或者一部分在屏幕上发生变化时, 系统都会调用<code>UIView</code>类的<code>drawRect</code>方法. 然后我们在此方法中能过获取到当前图形上下文, 实现我们的绘制内容, 最后系统会在合适的时机自动调用此方法. </p>\n<p><code>drawRect</code>一般调用是在<code>UIView</code>的<code>layoutSubviews</code>方法执行后. 但是, 在我们的视图全部初始化后,如果视图又发生了改变, 此时视图就需要重绘, 但是系统不会再帮我们自动调用<code>drewRect</code>方法. 这个时候就需要我们手动调用<code>UIView</code>类的 <code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect</code>方法. 这两个方法是用来告诉系统, 我们的视图有了更新需要去重绘. 相当于是给系统做了标记, 在系统 runloop 的下一个周期自动调用<code>drawRect</code>方法.</p>\n<p>使用中要注意的地方:</p>\n<ol>\n<li><p>不要直接调用 drawRect 方法,如果强行调用此方法也是无效果的.苹果要求我们调用 UIView 类的 setNeedsDisplay 方法,则程序会自动调用 drawRect 方法进行重绘.</p>\n</li>\n<li><p>因为在绘制时要拿到图形上下文,如果在 UIView 初始化时没有设置 rect 大小, drawRect 方法不会被调用.</p>\n</li>\n<li><p>调用 sizeThatFits 后, 控件 frame 改变, UIView 的 layoutSubviews 被调用, 然后再调用 drawRect 方法. 所以可以先调用 sizeToFit 计算出size. 然后系统自动调用 drawRect 方法.</p>\n</li>\n<li><p>通过设置 contentMode 属性值为 UIViewContentModeRedraw.那么将在每次设置或更改 bounds 的时候自动调用 drawRect.</p>\n</li>\n<li><p>若要实时画图, 如果使用 gestureRecognizer 来刷新屏幕, 需要判断并转化 point 的坐标; 使用 touchbegan 等方法, 只需调用 setNeedsDisplay 实时刷新屏幕.</p>\n</li>\n</ol>\n<p>这里有一篇<a href=\"http://bihongbo.com/2016/01/03/memoryGhostdrawRect/\" target=\"_blank\" rel=\"noopener\">使用drawRect:实现绘制画板功能的内存优化</a>的文章.</p>\n<ul>\n<li>sizeToFit</li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622630-sizetofit?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Resizes and moves the receiver view so it just encloses its subviews.</p>\n<p>Call this method when you want to resize the current view so that it uses the most appropriate amount of space. Specific UIKit views resize themselves according to their own internal needs. In some cases, if a view does not have a superview, it may size itself to the screen bounds. Thus, if you want a given view to size itself to its parent view, you should add it to the parent view before calling this method.<br>You should not override this method. If you want to change the default sizing information for your view, override the sizeThatFits: instead. That method performs any needed calculations and returns them to this method, which then makes the change.</p>\n</blockquote>\n<p>当我们想要resize当前View以便获取他合适的大小时, 我们需要调用该方法. 尤其是<code>UIKit</code>的<code>View</code>视图是根据内部需要进行尺寸调整时. 在某些情况下, 如果当前View没有父视图, 他会根据屏幕的bounds来resize自身大小. 如果你想让一个View根据父视图来调整大小, 必须将该View添加到父视图中.</p>\n<p>一般情况下, 我们不需要重写该方法, 如果你想改变当前View的default size, 我们通过重写<a href=\"#sizeThatFits\">sizeThatFits:</a>来实现. 在<code>sizeThatFits:</code>方法中进行必要的计算, 返回结果, 然后改变他的大小.</p>\n<ul>\n<li><span id=\"sizeThatFits\">sizeThatFits</span></li>\n</ul>\n<blockquote>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits?language=objc\" target=\"_blank\" rel=\"noopener\">官方文档</a><br>Asks the view to calculate and return the size that best fits the specified size.</p>\n<p>Parameters<br>size<br>The size for which the view should calculate its best-fitting size.</p>\n<p>Return Value<br>A new size that fits the receiver’s subviews.</p>\n<p>Discussion<br>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.<br>This method does not resize the receiver.</p>\n</blockquote>\n<p>该方法要求View计算并返回最适合指定大小的大小. 传入的参数就是View需要最合适的大小, 返回值是根据传入的大小, 计算得到的一个最适合receiver子视图的尺寸. </p>\n<p>该方法默认返回视图的现有大小, 子类能够通过重写该方法获得一个基于该子类所有子视图的期望布局的自定义大小. 调用<code>sizeThatFits:</code>并不改变view的size, 它只是让view根据已有content和给定size计算出最合适的view.size. </p>\n<h2 id=\"sizeToFit-vs-sizeThatFits\"><a href=\"#sizeToFit-vs-sizeThatFits\" class=\"headerlink\" title=\"sizeToFit vs sizeThatFits:\"></a>sizeToFit vs sizeThatFits:</h2><ol>\n<li>sizeToFit会自动调用sizeThatFits方法；</li>\n<li>sizeToFit不应该在子类中被重写, 应该重写sizeThatFits</li>\n<li>sizeThatFits传入的参数是receiver当前的size, 返回一个适合subviews的size</li>\n<li>sizeToFit可以被手动直接调用, </li>\n<li>sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己</li>\n<li>调用 sizeToFit() 会去自动调用 sizeThatFits(_ size: CGSize) 方法。</li>\n<li>sizeThatFits 不会改变 receiver 的 size, 调用 sizeToFit() 会改变 receiver 的 size. 此处的receiver一般是方法的调用者. </li>\n</ol>\n<h2 id=\"系统触发layoutSubviews的条件\"><a href=\"#系统触发layoutSubviews的条件\" class=\"headerlink\" title=\"系统触发layoutSubviews的条件\"></a><span id=\"layoutSubviews\">系统触发layoutSubviews的条件</span></h2><ol>\n<li>父视图使用<code>init</code>方法完成初始化时不会触发<code>layoutSubviews</code>. </li>\n<li>父视图用<code>initWithFrame</code>完成初始化并且当frame参数为<code>CGRectZero</code>时不会触发<code>layoutSubviews</code>. 当frame参数不为<code>CGRectZero</code>时则会触发<code>layoutSubviews</code>.</li>\n<li>父视图<code>setFrame</code>的时候会触发<code>layoutSubviews</code>, 当然frame前后值得发生变化.</li>\n<li>父视图<code>addSubview</code>添加子视图时会触发其内部的<code>layoutSubviews</code>.</li>\n<li>子视图从父视图上<code>removeFromSuperView</code>的时候会触发其内部的<code>layoutSubviews</code>. </li>\n<li>滚动ScrollView的时候会触发<code>layoutSubviews</code>. </li>\n<li>旋转屏幕的时候会触发<code>layoutSubviews</code>. </li>\n</ol>\n<h2 id=\"系统出发drawRect-的条件\"><a href=\"#系统出发drawRect-的条件\" class=\"headerlink\" title=\"系统出发drawRect:的条件\"></a><span id=\"drawRect\">系统出发drawRect:的条件</span></h2><ol>\n<li>如果在<code>UIView</code>初始化时没有设置rect大小, 将直接导致<code>drawRect</code>不被自动调用. <code>drawRect</code>调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的. 所以不用担心一进入到控制器中, 这些View的drawRect就开始画了. 这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).</li>\n<li>该方法在调用<code>sizeToFit</code>后被调用, 所以可以先调用<code>sizeToFit</code>计算出size, 然后系统自动调用drawRect:方法. </li>\n<li>通过设置<code>contentMode</code>属性值为<code>UIViewContentModeRedraw</code>. 那么将在每次设置或更改frame的时候自动调用<code>drawRect:</code>.</li>\n<li>直接调用<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>触发<code>drawRect:</code>. 但是有个前提条件是rect不能为<code>CGRectZero</code>.<br>以上1, 2推荐; 而3, 4不提倡. </li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/087529c83747\" target=\"_blank\" rel=\"noopener\">Core Animation 之 CALayer</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/3282c93c1a61\" target=\"_blank\" rel=\"noopener\">UIView几个layout方法的理解</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/b3bb9b08e3da\" target=\"_blank\" rel=\"noopener\">UIView布局深入理解</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/eb2c4bb4e3f1\" target=\"_blank\" rel=\"noopener\">UIViewLayout的几个方法</a></p>\n<p>5.<a href=\"http://zhangbuhuai.com/beginning-auto-layout-part-1/\" target=\"_blank\" rel=\"noopener\">深入理解Auto Layout 第一弹</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"UIView系列之---UIView和CALayer","url":"http://hchong.net/2017/07/07/UIView系列之---UIView和CALayer/","content":"<h1 id=\"UIView系列之—UIView和CALayer\"><a href=\"#UIView系列之—UIView和CALayer\" class=\"headerlink\" title=\"UIView系列之—UIView和CALayer\"></a>UIView系列之—UIView和CALayer</h1><p><a href=\"http://hchong.net/2017/08/30/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E5%92%8CCALayer/\">UIView系列之—UIView和CALayer</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---UIView%E7%9A%84%E5%B8%B8%E8%A7%81layout%E6%96%B9%E6%B3%95/\">UIView系列之—UIView的常见layout方法</a><br><a href=\"http://hchong.net/2017/09/24/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---iOS%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/\">UIView系列之—iOS的动态高度</a><br><a href=\"http://hchong.net/2017/09/21/UIView%E7%B3%BB%E5%88%97%E4%B9%8B---%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89View/\">UIView系列之—如何写一个自定义View</a></p>\n<h2 id=\"UIView和CALayer\"><a href=\"#UIView和CALayer\" class=\"headerlink\" title=\"UIView和CALayer\"></a>UIView和CALayer</h2><ol>\n<li><p><code>UIView</code>继承自<code>UIResponder</code>, 可以相应触摸事件. 而<code>CALayer</code>继承自<code>NSObject</code>, 不能响应触摸.</p>\n</li>\n<li><p><code>UIView</code>主要是对显示内容的管理, 而<code>CALayer</code>则主要侧重显示内容的绘制. 访问<code>UIVIew</code>的与绘图和跟坐标有关的属性, 例如<code>frame</code>, <code>bounds</code>等, 实际上内部都是在访问它所包含的CALayer的相关属性. <code>UIView</code>的<code>frame</code>实际是<code>layer</code>的<code>frame</code>, <code>center</code>, <code>bounds</code>实际也是只是内部<code>layer</code>相对应属性的<code>get</code>和<code>set</code>方法, 当你改变一个<code>view</code>的<code>frame</code>的时候, 你其实改变的是内部<code>layer</code>的<code>frame</code>. CALayer的frame由<code>anchorPoint</code>, <code>position</code>, <code>bounds</code>, <code>transform</code>共同决定. <code>UIView</code>的创建, 实际上是一系列<code>UILayer</code>创建的过程.</p>\n</li>\n<li><p><code>UIView</code>有个重要属性<code>layer</code>. 可以返回它的主<code>CALayer</code>实例. 所有从UIView继承来的对象都继承了这个属性. 这意味着你可以在所有的<code>UIVIew</code>子类上增加动画, 旋转, 缩放等<code>CALayer</code>支持的操作. <code>UIView</code>的<code>layerClass</code>方法, 可以返回主<code>layer</code>所使用的类, <code>UIView</code>的子类可以通过重载这个方法, 来让<code>UIView</code>使用不同的CALayer来显示. 代码示例：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (class)layerClass &#123;</div><div class=\"line\">    return ([CAEAGLLayer class]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>UIView</code>的主<code>CALayer</code>是类似于<code>subviews</code>的树形结构, 我们可以通过给主<code>layer</code>添加子<code>layer</code>来完成特殊的绘制效果.</p>\n<p> 在<code>view</code>上添加一个黑色透明<code>layer</code>层的示例代码:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">grayCover = [[CALayer alloc] init];</div><div class=\"line\">grayCover.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];</div><div class=\"line\">[self.layer addSubLayer:grayCover];</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>UIView</code>的内部, 有三个<code>layer tree</code>: 1.逻辑树, 这里是代码可以操纵的. 2.动画树, 是一个中间层, 系统就在这一层上通过逻辑树来更改属性, 进行各种渲染操作. 3.显示树, 其内容就是当前正被显示在屏幕上得内容. </p>\n</li>\n<li><p><code>UIView</code>实际上是<code>CALayer</code>的<code>CALayerDelegate</code>, 通过实现一系列的代理方法来显示<code>CALayer</code>绘制的内容.</p>\n</li>\n<li><p>在做 iOS 动画的时候, 修改非<code>RootLayer</code>的属性(譬如位置, 背景色等)会默认产生隐式动画, 而修改<code>UIView</code>则不会.</p>\n</li>\n<li><p><code>layer</code>可以设置圆角显示(cornerRadius), 也可以设置阴影(shadowColor). 但是如果<code>layer</code>树中某个<code>layer</code>设置了圆角, 树种所有<code>layer</code>的阴影效果都将不显示了. 因此若是要有圆角又要阴影, 变通方法只能做两个重叠的<code>UIView</code>, 一个的<code>layer</code>显示圆角, 一个<code>layer</code>显示阴影.</p>\n</li>\n<li><p><code>UIView</code> 是<code>UIKit</code>框架下的(只能iOS使用). <code>CALayer</code> 是<code>QuartzCore</code>的(iOS 和macOS通用).</p>\n</li>\n<li><p><code>QuartzCore</code>的渲染能力. 使二维图像可以被自由操纵, 就好像是三维的. 图像可以在一个三维坐标系中以任意角度被旋转, 缩放和倾斜. <code>CATransform3D</code>的一套方法提供了一些魔术般的变换效果. </p>\n</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/079e5cf0f014\" target=\"_blank\" rel=\"noopener\">详解CALayer 和 UIView的区别和联系</a></p>\n<p>2.<a href=\"http://blog.csdn.net/weiwangchao_/article/details/7771538\" target=\"_blank\" rel=\"noopener\">UIView和CALayer的区别</a></p>\n","categories":["面试题"],"tags":["基础知识","面试题","UIView"]},{"title":"Block用法与原理分析","url":"http://hchong.net/2017/07/04/Block用法与原理分析/","content":"<h1 id=\"Block用法及分析\"><a href=\"#Block用法及分析\" class=\"headerlink\" title=\"Block用法及分析\"></a>Block用法及分析</h1><p>Block的默认格式是这样的: <strong><code>返回值类型 (^Block变量名)(形参列表) = ^返回值类型 (形参列表){ 内容 }</code></strong>. 后面的返回值类型和形参列表可以省略. </p>\n<p>Block用一句话来形容就是带有自动变量(局部变量)的匿名函数. 他可以嵌套定义, 定义Block方法和定义函数方法类似, Block可以定义在方法内部和外部, 必须调用Block, 才会执行<code>{}</code>内部的方法. 本质是对象, 使代码高聚合. 结合<code>clang</code>分析可以发现Block的真实面目.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">struct Block_layout &#123;  </div><div class=\"line\">    void *isa;</div><div class=\"line\">    int flags;</div><div class=\"line\">    int reserved;</div><div class=\"line\">    void (*invoke)(void *, ...);</div><div class=\"line\">    struct Block_descriptor *descriptor;</div><div class=\"line\">    /* Imported variables. */</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct Block_descriptor &#123;  </div><div class=\"line\">    unsigned long int reserved;</div><div class=\"line\">    unsigned long int size;</div><div class=\"line\">    void (*copy)(void *dst, void *src);</div><div class=\"line\">    void (*dispose)(void *);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><img src=\"http://img.souche.com/f2e/d71a93dbbbf11a6055810df74fdf309d.png\" alt=\"block的数据结构\"></p>\n<p>可以看到有<code>isa</code>的存在, 由此可以说明, OC处理Block是按照对象来处理的. 在iOS中, isa常见的就是_NSConcreteStackBlock, _NSConcreteMallocBlock, _NSConcreteGlobalBlock这三种类型. </p>\n<h2 id=\"常见的使用方法\"><a href=\"#常见的使用方法\" class=\"headerlink\" title=\"常见的使用方法\"></a>常见的使用方法</h2><p>常见的Block的使用方式有以下几种:</p>\n<h3 id=\"作为变量的用法\"><a href=\"#作为变量的用法\" class=\"headerlink\" title=\"作为变量的用法\"></a>作为变量的用法</h3><p>官方提供的快捷写法(inlineBlock)的示例是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;#returnType#&gt;(^&lt;#blockName#&gt;)(&lt;#parameterTypes#&gt;) = ^(&lt;#parameters#&gt;) &#123;</div><div class=\"line\">   &lt;#statements#&gt;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们举个🌰</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//定义一个block变量sum, 并且赋值(此处省略返回值类型int)</div><div class=\"line\">int(^sum)(int, int) = ^(int a, int b) &#123;</div><div class=\"line\">   return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\">//调用block变量</div><div class=\"line\">int count = sum(2, 3);</div><div class=\"line\">NSLog(@&quot;%d&quot;, count);</div><div class=\"line\">    </div><div class=\"line\">也可以吧定义和赋值分开来写, 类似于这样</div><div class=\"line\"></div><div class=\"line\">//定义一个block变量</div><div class=\"line\">int (^sum)(int, int);</div><div class=\"line\">//给block变量赋值(此处没有省略返回值类型)</div><div class=\"line\">sum = ^int(int a, int b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\">int count = sum(2, 3);</div><div class=\"line\">    NSLog(@&quot;%d&quot;, count);</div></pre></td></tr></table></figure>\n<h3 id=\"作为属性的用法\"><a href=\"#作为属性的用法\" class=\"headerlink\" title=\"作为属性的用法\"></a>作为属性的用法</h3><p>block作为属性, 可以存在在找那个类的声明周期中, 这样就可以全局的使用, 也比较常用.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1. 定义一个block属性</div><div class=\"line\">@property (nonatomic, copy) int (^sum)(int a, int b);</div><div class=\"line\"></div><div class=\"line\">也可以使用`typedefBlock`的方式来定义(推荐)</div><div class=\"line\">typedef int(^Sum)(int, int);</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) Sum sum;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">2. 然后在合适的地方写该属性(block)的实现, </div><div class=\"line\">self.sum = ^int(int a, int b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">3. 最后是block的调用</div><div class=\"line\">int count = self.sum(3, 4);</div><div class=\"line\">NSLog(@&quot;%d&quot;, count);</div></pre></td></tr></table></figure>\n<h3 id=\"作为函数-方法-参数的用法\"><a href=\"#作为函数-方法-参数的用法\" class=\"headerlink\" title=\"作为函数(方法)参数的用法\"></a>作为函数(方法)参数的用法</h3><p>在这里C和OC的还略有不同. </p>\n<p>block作为函数参数的用法也是较常见的, 例如网络请求方法中, 会把网络请求结果处理的代码在block中, 等请求到数据的时候直接调用.</p>\n<p>block的定义也可以分为两种情况, 一种是使用了<code>typedefBlock</code>来定义, 一种是直接定义, 下面例子会给出代码示例. 假设有个下载的网络请求, 会有成功和失败的代码处理被我们封装在block里面, 作为参数在外面被调用.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//.h文件</div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">typedef void(^SuccessBlock)(id obj);</div><div class=\"line\">typedef void(^FailBlock)(id obj);</div><div class=\"line\"></div><div class=\"line\">@interface DownLoadManager : NSObject</div><div class=\"line\"></div><div class=\"line\">+ (void)downLoadedSuccess:(SuccessBlock)success fail:(FailBlock)fail;</div><div class=\"line\"></div><div class=\"line\">+ (void)uploadSuccess:(void(^)(id obj))success fail:(void(^)(id obj))fail;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//.m文件</div><div class=\"line\">#import &quot;DownLoadManager.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation DownLoadManager</div><div class=\"line\"></div><div class=\"line\">+ (void)downLoadedSuccess:(SuccessBlock)success fail:(FailBlock)fail &#123;</div><div class=\"line\">    //使用延迟来模拟异步数据请求</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        success(@&quot;我是数据&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (void)uploadSuccess:(void(^)(id obj))success fail:(void(^)(id obj))fail &#123;</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        success(@&quot;我是数据&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//在外面调用: </div><div class=\"line\">[DownLoadManager downLoadedSuccess:^(id obj) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, obj);</div><div class=\"line\">&#125; fail:^(id obj) &#123;</div><div class=\"line\">        </div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[DownLoadManager uploadSuccess:^(id obj) &#123;</div><div class=\"line\">   </div><div class=\"line\">&#125; fail:^(id obj) &#123;</div><div class=\"line\">   </div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>可以看到, 这里的作为参数有两种方式, 一种是使用<code>typedef</code>定义, 一种是直接定义, 这两种方式和作为属性的两种用法基本类似.</p>\n<p>下面是在C中的使用方法. 对比一下可以发现还是有一些差别的, 在OC中直接使用的话, block的name是没有定义的, C中是有的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 实现，不使用 typedef</div><div class=\"line\">// void (^iblock)()作为函数参数类型，iblock函数形参名</div><div class=\"line\">void iprint( void (^iblock)() )&#123; </div><div class=\"line\">    iblock(); // 调用 block参数&#125;</div><div class=\"line\"></div><div class=\"line\">// 实现，使用 typedef</div><div class=\"line\">typedef void (^IBlock)();</div><div class=\"line\">void iprint(IBlock iblock)&#123;</div><div class=\"line\">    iblock(); // 调用 block参数</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 调用「不管使用不使用 typedef 调用方式一致」</div><div class=\"line\">iprint(^&#123;</div><div class=\"line\">    NSLog(@&quot;传入的实参代码块区域&quot;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"作为返回值的用法\"><a href=\"#作为返回值的用法\" class=\"headerlink\" title=\"作为返回值的用法\"></a>作为返回值的用法</h3><p>block作为返回值的用法主要使用场景是函数的链式编程中, 可以参考<a href=\"http://hchong.net/2017/12/17/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/\">这篇文章</a>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef NSString *(^NameBlock)(NSString *inputalue);//定义一个返回值是String, 参数是String类型的block, 名字为NameBlock</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) NameBlock nameBlock;</div><div class=\"line\"></div><div class=\"line\">//实现属性的get方法</div><div class=\"line\">- (NSString *(^)(NSString *))nameBlock &#123;</div><div class=\"line\">    return ^NSString *(NSString *inputValue) &#123;</div><div class=\"line\">        return [inputValue stringByAppendingString:@&quot;test&quot;];</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//调用方式如下</div><div class=\"line\">NSLog(@&quot;%@&quot;, self.nameBlock(@&quot;block作为返回值&quot;));</div></pre></td></tr></table></figure>\n<h3 id=\"常见的使用场景\"><a href=\"#常见的使用场景\" class=\"headerlink\" title=\"常见的使用场景\"></a>常见的使用场景</h3><ul>\n<li><p>Enumeration (像我们上面看到的 NSArray 的枚举接口)</p>\n</li>\n<li><p>View Animations (animations)</p>\n</li>\n<li><p>Sorting (在排序时在 Block 中实现比较逻辑)</p>\n</li>\n<li><p>Notification (当某些事件被触发时，执行对应的 Block)</p>\n</li>\n<li><p>Error handlers (作为错误事件的 Handler)</p>\n</li>\n<li><p>Completion handlers (作为某个任务完成时的 Handler)</p>\n</li>\n<li><p>Multithreading (在 Grand Central Dispatch (GCD) API 中使用)</p>\n</li>\n</ul>\n<h2 id=\"捕获外部变量\"><a href=\"#捕获外部变量\" class=\"headerlink\" title=\"捕获外部变量\"></a>捕获外部变量</h2><p>C语言中的变量一共有五种: 自动变量, 函数参数, 静态局部变量, 静态全局变量, 全局变量. 要研究外部变量的捕获就去除掉函数参数这一项. 下面逐一分析.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">static int staticGlobalInt = 0;//静态全局变量</div><div class=\"line\">int globalInt;//全局变量</div><div class=\"line\"></div><div class=\"line\">//测试Block的变量捕获</div><div class=\"line\">- (void)variableTest &#123;</div><div class=\"line\">    static int staticInt = 0;//静态局部变量</div><div class=\"line\">    __block int intNumber = 0;//局部变量</div><div class=\"line\">    globalInt = 0;//全局变量</div><div class=\"line\">    staticGlobalInt = 0;//静态全局变量</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;初始化时---静态全局变量:%d, 全局变量:%d, 静态局部变量:%d, 局部变量:%d&quot;, staticGlobalInt, globalInt, staticInt, intNumber);</div><div class=\"line\">    </div><div class=\"line\">    void(^addTest)() = ^()&#123;</div><div class=\"line\">        staticGlobalInt++;</div><div class=\"line\">        globalInt++;</div><div class=\"line\">        staticInt++;</div><div class=\"line\">        intNumber++;</div><div class=\"line\">        NSLog(@&quot;在block中---静态全局变量:%d, 全局变量:%d, 静态局部变量:%d, 局部变量:%d&quot;, staticGlobalInt, globalInt, staticInt, intNumber);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    NSLog(@&quot;在block调用结束后---静态全局变量:%d, 全局变量:%d, 静态局部变量:%d, 局部变量:%d&quot;, staticGlobalInt, globalInt, staticInt, intNumber);</div><div class=\"line\">    addTest();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这里, 如果不加<code>__block</code>的话, 局部变量在block内部使用是会报错的, 原因后面讲. 这里先来说一下结果, 打印的结果是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">初始化时---静态全局变量:0, 全局变量:0, 静态局部变量:0, 局部变量:0</div><div class=\"line\">在block调用结束后---静态全局变量:0, 全局变量:0, 静态局部变量:0, 局部变量:0</div><div class=\"line\">在block中---静态全局变量:1, 全局变量:1, 静态局部变量:1, 局部变量:1</div></pre></td></tr></table></figure>\n<p>可以发现结果都变了, 但是内部实现实际上不同的.</p>\n<ul>\n<li><p>静态全局变量和静态局部变量, 由于他们是存储在全局区(数据区), 作用域的范围是整个程序的生命周期, 只要程序在运行, 就可以访问到. 所以block直接访问了对应的变量, 而没有把他们copy到block中去</p>\n</li>\n<li><p>静态局部变量也是存储在全局区(数据区), 程序在运行就可以访问的到, 但是他的作用范围仅限于定义他的函数中. 系统是把内存地址传递给block, 所以在block也可以直接修改他的的值.</p>\n</li>\n<li><p>局部变量, 必须使用<code>__block</code>(存储域类说明符)来修饰, 否则在block内部使用会报错. 对于非对象的变量来说, 自动变量的值, 被copy进了Block, 不带<code>__block</code>的自动变量只能在里面被访问, 并不能改变值. 对于对象来说, 在MRC环境下, <code>__block</code>根本不会对指针所指向的对象执行copy操作, 而只是把指针进行的复制. 而在ARC环境下, 对于声明为<code>__block</code>的外部对象, 在block内部会进行retain, 以至于在block环境内能安全的引用外部对象. 对于没有声明<code>__block</code>的外部对象, 在block中也会被retain</p>\n</li>\n</ul>\n<p><em>注意</em>: Block捕获外部变量仅仅只捕获Block闭包里面会用到的值，其他用不到的值，它并不会去捕获.</p>\n<h2 id=\"Block的存储域相关\"><a href=\"#Block的存储域相关\" class=\"headerlink\" title=\"Block的存储域相关\"></a>Block的存储域相关</h2><p>通过之前的源码分析可以看出, Block结构体中是有一个isa指针的, 这也就说明Block实际也是一个OC的对象. 在OC中一般Block分为三种: </p>\n<h3 id=\"NSConcreteStackBlock\"><a href=\"#NSConcreteStackBlock\" class=\"headerlink\" title=\"_NSConcreteStackBlock\"></a>_NSConcreteStackBlock</h3><p>该类对象的存储域在栈上面. 只用到外部局部变量, 成员属性变量, 且没有强指针引用的block都是StackBlock. StackBlock的生命周期由系统控制的. 由于存储在栈上面, 一旦返回之后所属的变量域一旦结束, 就被系统销毁了. 所以他是不安全的 <em>该类型的block不持有对象</em>.</p>\n<p>需要注意, 由于<code>_NSConcreteStackBlock</code>所属的变量域一旦结束, 那么该Block就会被销毁. 在ARC环境下, 编译器会自动的判断, 把Block自动的从栈copy到堆上. </p>\n<h3 id=\"NSConcreteGlobalBlock\"><a href=\"#NSConcreteGlobalBlock\" class=\"headerlink\" title=\"_NSConcreteGlobalBlock\"></a>_NSConcreteGlobalBlock</h3><p>与global变量一样, 该类对象的存储域在数据区(全局区). 一般情况下, 没有用到外界变量或只用到全局变量, 静态变量的block为_NSConcreteGlobalBlock. 由于存储在数据区(全局区), 所以生命周期从创建到应用程序结束. <em>该类型的block不持有对象</em>, 因为要么不引用外部变量, 要么使用的是全局变量或者静态变量.</p>\n<h3 id=\"NSConcreteMallocBlock\"><a href=\"#NSConcreteMallocBlock\" class=\"headerlink\" title=\"_NSConcreteMallocBlock\"></a>_NSConcreteMallocBlock</h3><p>该类对象设置在由malloc函数分配的内存块(堆)中. 有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock, 没有强指针引用即销毁, 生命周期由程序员控制. <em>该类型的block会持有外部对象</em>.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Block本身也是一个对象, 那么他自身的存储域, 生命周期和作用域也是我们要了解的.由于<code>_NSConcreteStackBlock</code>是在栈上面的, 容易被销毁, 所以我们需要把它copy到堆上面进行操作, 在ARC下, 如果有下面几种方式系统会自动把<code>block</code>copy到堆上面去:</p>\n<pre><code>* 手动调用copy \n* Block 作为函数返回值返回时\n* 将 Block 赋值给类的`__strong` 修饰的 id 类型的成员变量时\n* 将 Block 赋值给类 Block 类型成员变量时\n* 向 GCD 的 API 中或方法名中含有 usingBlock 的 Cocoa 框架方法传递 Block 作为参数时\n</code></pre><p>下面两种情况需要我们自己调用copy方法:</p>\n<pre><code>* 在向一般方法或函数传递 Block 作为参数时，传的时候要调用一下 Block 的 copy 方法。除非在方法或函数体中，对传进来的 Block 参数做了 copy 处理\n* 如果不明确情况, 也推荐手动调用 copy.\n</code></pre><p>Block对象如果内部使用了<code>__block</code>修饰的局部变量, 那么当Block从栈上复制到堆上时, <code>__block</code>变量也会被copy到堆上面, 并且Block会持有这个变量. 当堆上的 Block 被废弃时, 那么它所使用的 <code>__block</code> 变量也会被释放.</p>\n<h2 id=\"block几种关键字的用法\"><a href=\"#block几种关键字的用法\" class=\"headerlink\" title=\"block几种关键字的用法\"></a>block几种关键字的用法</h2><h3 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"__block\"></a>__block</h3><p>如果想在 Block 中读写局部变量, 那么需要在局部变量前加 <code>__block</code>. <code>__block</code>实际上是提升了变量的作用域. 如果获得对象（在堆上）, 调用变更该对象的方法是没问题的（存储对象的空间在堆上）, 而直接向截获的变量赋值则会产生编译错误（这个对象的指针是在栈上的）.</p>\n<ol>\n<li><p><code>__block</code>修饰变量<br> ARC环境下, 一旦Block赋值就会触发copy, <code>__block</code>就会copy到堆上, Block也是<code>__NSMallocBlock</code>. ARC环境下也是存在<code>__NSStackBlock</code>的时候, 这种情况下, <code>__block</code>就在栈上.</p>\n<p> MRC环境下, 只有copy, <code>__block</code>才会被复制到堆上, 否则, <code>__block</code>一直都在栈上, block也只是<strong>NSStackBlock, 这个时候`</strong>forwarding`指针就只指向自己了.</p>\n</li>\n<li><p><code>__block</code>修饰对象<br> 对象在OC中, 默认声明自带<code>__strong</code>所有权修饰符的</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">__block id block_obj = [[NSObject alloc]init];  </div><div class=\"line\">id obj = [[NSObject alloc]init];</div><div class=\"line\">等价于</div><div class=\"line\">Objective-C</div><div class=\"line\">__block id __strong block_obj = [[NSObject alloc]init];  </div><div class=\"line\">id __strong obj = [[NSObject alloc]init];</div></pre></td></tr></table></figure>\n<p> 在ARC环境下, 不仅仅是声明了<code>__block</code>的外部对象, 没有声明<code>__block</code>的对象, 在block内部也会被retain. 因为加了<code>__block</code>, 只是对一个自动变量有影响, 它们是指针, 相当于延长了指针变量的声明周期, 只要访问对象的话还是会retain.</p>\n<p> 在MRC环境下, <code>__block</code>根本不会对指针所指向的对象执行copy操作, 而只是把指针进行的复制. </p>\n</li>\n</ol>\n<h3 id=\"weak\"><a href=\"#weak\" class=\"headerlink\" title=\"__weak\"></a>__weak</h3><p><code>__weak</code>修饰的对象被Block捕获时是对其进行弱引用持有的, 因为<code>__NSConcreteMallocBlock</code>捕获外部对象会在内部持有他, 引用计数会+1. 如果使用<code>__weak</code>修饰外部变量, Block捕获的变量就会是弱引用持有. 当Block所有者的作用域结束时, 他指向的对象没有被其他强引用持有, 所以立即被释放, 这是Block内部持有的弱引用也被置为nil.</p>\n<p><em>注意</em>: block并不会捕获形参到block内部进行持有. 例如下面这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Student *student = [[Student alloc]init];</div><div class=\"line\">student.name = @&quot;Hello World&quot;;</div><div class=\"line\"></div><div class=\"line\">student.study = ^(NSString * name)&#123;</div><div class=\"line\">    NSLog(@&quot;my name is = %@&quot;,name);</div><div class=\"line\">&#125;;</div><div class=\"line\">student.study(student.name);</div></pre></td></tr></table></figure>\n<h3 id=\"strong\"><a href=\"#strong\" class=\"headerlink\" title=\"__strong\"></a>__strong</h3><p><code>__strong</code>修饰的对象被Block捕获时是对其进行强引用持有的. 当Block的所有者的作用域结束时, <code>__strong</code>修饰的对象依然被Block强引用持有, 所以不会立即释放.</p>\n<h3 id=\"weakSelf-amp-strongSelf\"><a href=\"#weakSelf-amp-strongSelf\" class=\"headerlink\" title=\"weakSelf &amp; strongSelf\"></a>weakSelf &amp; strongSelf</h3><p>weakSelf 是为了block不持有self，避免Retain Circle循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf. weakSelf有下面两种写法.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">__weak __typeof(self)weakSelf = self;</div><div class=\"line\">#define WEAKSELF typeof(self) __weak weakSelf = self;</div></pre></td></tr></table></figure>\n<p>strongSelf的目的是因为一旦进入block执行, 假设不允许self在这个执行过程中释放, 就需要加入strongSelf. block执行完后这个strongSelf 会自动释放, 不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf. strongSelf的写法如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">__weak __typeof(self)weakSelf = self;</div><div class=\"line\">__strong __typeof(weakSelf)strongSelf = weakSelf</div></pre></td></tr></table></figure>\n<h3 id=\"避免Block使用的对象被提前释放\"><a href=\"#避免Block使用的对象被提前释放\" class=\"headerlink\" title=\"避免Block使用的对象被提前释放\"></a>避免Block使用的对象被提前释放</h3><p>在 Block 中用异步的方式使用了外部对象, 当对象被释放后, 异步方法回调时访问该对象则会为空, 这时就可能造成程序崩溃了. 解决这个问题的方式则是 <code>__weak</code>/<code>__strong</code>. 例如下面这种样式的: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@implementation TestBlockViewController</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    // Init properties.</div><div class=\"line\">    self.tag = @&quot;tag is OK.&quot;;</div><div class=\"line\">    </div><div class=\"line\">    // Init TestService&apos;s block.</div><div class=\"line\">    typeof(self) __weak weakSelf = self;</div><div class=\"line\">    self.myBlock = ^&#123;</div><div class=\"line\">        typeof(weakSelf) __strong strongSelf = weakSelf;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            NSLog(@&quot;strongSelf is OK.&quot;);</div><div class=\"line\">            NSLog(@&quot;%@&quot;, strongSelf.tag);</div><div class=\"line\">            //NSLog(@&quot;%@&quot;, self.tag); // Retain cycle.</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">- (void)backButtonAction &#123;    </div><div class=\"line\">    self.myBlock();</div><div class=\"line\">    [self.navigationController popViewControllerAnimated:YES];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc &#123;</div><div class=\"line\">    NSLog(@&quot;TestBlockViewController dealloc.&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<p>参考资料: </p>\n<p>1.<a href=\"https://halfrost.com/ios_block/\" target=\"_blank\" rel=\"noopener\">深入研究 Block 捕获外部变量和 __block 实现原理</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/51d04b7639f1\" target=\"_blank\" rel=\"noopener\">Block技巧与底层解析</a></p>\n<p>3.<a href=\"https://halfrost.com/ios_block_retain_circle/\" target=\"_blank\" rel=\"noopener\">深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/581151493340\" target=\"_blank\" rel=\"noopener\">浅析iOS中Block的用法</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/e03292674e60\" target=\"_blank\" rel=\"noopener\">深入浅出Block</a></p>\n<p>6.<a href=\"http://www.samirchen.com/block-in-objc/\" target=\"_blank\" rel=\"noopener\">Block总结</a></p>\n","categories":["基础知识"],"tags":["Block","基础知识"]},{"title":"自己动手制作Xcode插件","url":"http://hchong.net/2017/06/25/自己动手制作Xcode插件/","content":"<h1 id=\"自己动手制作Xcode插件\"><a href=\"#自己动手制作Xcode插件\" class=\"headerlink\" title=\"自己动手制作Xcode插件\"></a>自己动手制作Xcode插件</h1><p>Xcode8以后, 以前的插件都不能用了. 网上虽然也有方法来解决这个问题, 但是稍显复杂, 这里我们采用曲线救国的方式, 使用Apple官方推荐的方式<em>Xcode Source Editor Extension</em>来自己制作插件. Extension的方式开发的插件, 可以独立上架AppStore, 并且是独立于Xcode工程独立运行的. 但是没有UI交互, 不能在后台运行并且只能在开发者调用的时候直接修改代码.</p>\n<p>在平常的开发过程中, 有些操作是经常遇到的. 下面我们以<em>根据属性自动生成Getter方法</em>和<em>根据选中内容导入头文件</em>两种经常碰到的场景来制作Xcode插件.</p>\n<h2 id=\"新建插件制作工程\"><a href=\"#新建插件制作工程\" class=\"headerlink\" title=\"新建插件制作工程\"></a>新建插件制作工程</h2><ol>\n<li><p>打开Xcode, <code>command + shift + N</code> 选择macOS -&gt; Cocoa Application, 点击Next新建一个工程. 此处我新建的工程名为<em>AutoImportPlugin</em>.</p>\n</li>\n<li><p>在Xcode工具栏中选择Editor -&gt; Add Target -&gt; MacOS -&gt; Xcode Source Editor Extension来新建一个Extension来编写插件的主要代码. 新建的Target名称不能与工程的名字一样. 接下来会有一个弹窗, 提示你是否<em>Activate xxx Scheme</em>, 选择<em>Activate</em>即可, 这一步骤会帮你创建一个和你新建Target对应的Scheme. 完成后你的页面应该是这个样子的.</p>\n</li>\n</ol>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fgyotdiqdbj312w0q03zl.jpg\" alt=\"主工程页面\"></p>\n<h2 id=\"工程环境和参数介绍\"><a href=\"#工程环境和参数介绍\" class=\"headerlink\" title=\"工程环境和参数介绍\"></a>工程环境和参数介绍</h2><p>这里我们会主要用到AutoImport文件夹下面的两个类<code>SourceEditorExtension</code> 和 <code>SourceEditorCommand</code>. </p>\n<p><code>SourceEditorExtension.m</code>中我们可以看到两个方法:</p>\n<ul>\n<li><code>-(void)extensionDidFinishLaunching{}</code>, 注释内容为<code>If your extension needs to do any work at launch, implement this optional method.</code>   指的是指刚刚加载好插件但还未点击插件按钮时，可以执行某些准备工作.</li>\n<li><code>- (NSArray &lt;NSDictionary &lt;XCSourceEditorCommandDefinitionKey, id&gt; *&gt; *)commandDefinitions{}</code>. 返回字典类型的数组, 可以为每个插件重写名字、标识符和自定义类名等信息，和<code>Info.plist</code>文件中对应的<code>XCSourceEditorCommandName</code>、<code>XCSourceEditorCommandIdentifier</code>和<code>XCSourceEditorCommandClassName</code>等信息一致.</li>\n</ul>\n<p><code>SourceEditorCommand.m</code>中只有一个方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler</div><div class=\"line\">&#123;</div><div class=\"line\">    // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.</div><div class=\"line\">    </div><div class=\"line\">    completionHandler(nil);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于插件的核心逻辑代码, 就是在这个方法里面实现. <code>XCSourceEditorCommandInvocation</code>类包含了所有的信息.可以通过他的各种属性来拿到原工程中的各种数据, 主要用到的有:</p>\n<ul>\n<li><code>invocation.buffer.lines</code>是一个数组, 包含了使用插件的工程的页面的每一行代码, 艺术组的形式存在. </li>\n<li><code>invocation.buffer.selections</code>是一个数组, 数组的内容是<code>XCSourceTextRange</code>. <code>XCSourceTextRange</code>包含了两个结构体, 用于标记原工程中选中部分的代码的位置信息.<h2 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h2></li>\n</ul>\n<p>此处以自动导入头文件的插件为例. 主要思路是遍历类的所有行, 拿到选中的内容, 判断是否被import过, 没有的话, 在合适位置插入<code>#import</code>;<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)performCommandWithInvocation:(XCSourceEditorCommandInvocation *)invocation completionHandler:(void (^)(NSError * _Nullable nilOrError))completionHandler</div><div class=\"line\">&#123;</div><div class=\"line\">    XCSourceTextRange *range = [invocation.buffer.selections firstObject];</div><div class=\"line\">    </div><div class=\"line\">    NSString *selectedLines = [invocation.buffer.lines objectAtIndex:range.start.line];</div><div class=\"line\">    NSString *selection = [selectedLines substringWithRange:NSMakeRange(range.start.column, range.end.column - range.start.column)];</div><div class=\"line\">    </div><div class=\"line\">    for (NSInteger i = 0; i &lt; invocation.buffer.lines.count - 1; i++) &#123;</div><div class=\"line\">        NSString *importString = [invocation.buffer.lines objectAtIndex:i];</div><div class=\"line\">        if ([importString containsString:@&quot;@interface&quot;]) &#123;</div><div class=\"line\">            self.startLineNumber = i;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    BOOL isImported = NO;</div><div class=\"line\">    for (NSInteger i = 0; i &lt;= self.startLineNumber ; i++) &#123;</div><div class=\"line\">        NSString *importString = [invocation.buffer.lines objectAtIndex:i];</div><div class=\"line\">        if ([importString containsString:[NSString stringWithFormat:@&quot;%@.h&quot;, selection]]) &#123;</div><div class=\"line\">            isImported = YES;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (isImported == NO) &#123;</div><div class=\"line\">        [invocation.buffer.lines insertObject:[NSString stringWithFormat:@&quot;#import \\&quot;%@.h\\&quot;&quot;, selection] atIndex:self.startLineNumber - 1];</div><div class=\"line\">    &#125;</div><div class=\"line\">    completionHandler(nil);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"插件使用\"><a href=\"#插件使用\" class=\"headerlink\" title=\"插件使用\"></a>插件使用</h2><h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>我们在插件工程中选中AutoImport的Scheme(新建的那个), <code>command + R</code>运行,这时会出现一个弹窗, 让你选择要运行的工程. 选中要运行的工程后, 正常打开. 在Editor的最下面可以看到我们运行的插件工程, 点击就可以运行插件了. 打断点和调试什么的和正常的Xcode项目一样.</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fgz0hh71w6j30ht0ccdgm.jpg\" alt=\"插件运行调试\"></p>\n<p>需要注意的是, 我们在插件工程中两个Target的Singing一定要保持一致, 并且不能为空. 否则在Xcode中看不到插件.</p>\n<h3 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h3><p>以上我们已经可以在自己电脑上调试和使用Xcode插件了, 那么怎么才能在其他电脑上也使用我们开发的插件呢?</p>\n<ol>\n<li><p>我们可以在插件工程中, 找到Products文件夹下生成的的.app文件</p>\n</li>\n<li><p>右键点击此文件 -&gt; “在Finder中显示” -&gt; 将这个.app文件拷贝到你或者小伙伴电脑上的”应用程序”里</p>\n</li>\n<li><p>在“应用程序”中双击.app文件运行。然后，打开“系统偏好设置” -&gt; “扩展” -&gt; “Xcode Source Editor” -&gt; 确认插件名字前已打钩 -&gt; 此时Xcode中菜单栏Editor下的插件虽然显示，但是为灰色，无法点按，所以要 -&gt; 重启Xcode -&gt; 大功告成！</p>\n</li>\n<li><p>添加快捷键: Xcode -&gt; “Preferences” -&gt; “Key Bindings” -&gt; 搜索插件名字 -&gt; 添加对应的快捷键.</p>\n</li>\n</ol>\n<hr>\n<p>下载地址: <a href=\"https://github.com/HChong3210/AutoGetterPlugin\" target=\"_blank\" rel=\"noopener\">AutoPlugin</a></p>\n<hr>\n<p>参考文章:<br>1.<a href=\"http://www.jianshu.com/p/9c9d0fcc62cc\" target=\"_blank\" rel=\"noopener\">详解一步步实现Xcode 8 插件——Source Editor Extensions</a></p>\n<p>2.<a href=\"http://www.code4app.com/blog-822721-394.html\" target=\"_blank\" rel=\"noopener\">使用 Xcode Source Editor Extension开发Xcode 8 插件</a></p>\n","categories":["插件"],"tags":["基础知识","Xcode"]},{"title":"车","url":"http://hchong.net/2017/06/20/车/","content":"<h1 id=\"十万左右落地\"><a href=\"#十万左右落地\" class=\"headerlink\" title=\"十万左右落地\"></a>十万左右落地</h1><p>数据来自汽车之家, 车主成交价是各地车主成交的真实价格, 和去4S店咨询的价格差不多</p>\n<table><br>   <tr><br>      <td>车系</td><br>      <td>车型</td><br>      <td>车型详情</td><br>      <td>车主成交价</td><br>   </tr><br>   <tr><br>      <td>别克-英朗</td><br>      <td>2017款 15N 自动精英型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28698/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28698/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28698#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28698#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>雪佛兰-科沃兹</td><br>      <td>2016款 1.5L 自动欣悦版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/27573/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/27573/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-27573#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-27573#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>现代-悦动</td><br>      <td>2017款 1.6L 自动悦值版GLS</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29502/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29502/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29502#pvareaid=103597\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29502#pvareaid=103597</a></td><br>   </tr><br>   <tr><br>      <td>东风-标致</td><br>      <td>2017款 1.6L 自动豪华版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29620/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29620/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29620#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29620#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>大众-朗逸</td><br>      <td>2017款 1.6L 自动风尚版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29362/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29362/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-29362#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-29362#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>大众-捷达</td><br>      <td>2017款 1.5L 自动舒适型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28451/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28451/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28451#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28451#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>东风雪铁龙-爱丽舍</td><br>      <td>2017款 1.6L 自动舒适型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/29341/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/29341/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/s-98#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/s-98#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪GS</td><br>      <td>2016款 运动版 1.3T 自动领尚型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/26402/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/26402/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-26402#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-26402#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪GL</td><br>      <td>2017款 1.3T 自动尊贵型</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/26596/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/26596/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-26596#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-26596#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪</td><br>      <td>2017款 三厢百万款 1.5L CVT向上版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28104/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28104/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28104#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28104#pvareaid=103596</a></td><br>   </tr><br>   <tr><br>      <td>吉利-帝豪</td><br>      <td>2017款 两厢RS百万款 1.5L CVT向上版</td><br>      <td><a href=\"http://www.autohome.com.cn/spec/28133/\" target=\"_blank\" rel=\"noopener\">http://www.autohome.com.cn/spec/28133/</a></td><br>      <td><a href=\"http://jiage.autohome.com.cn/price/carlist/p-28133#pvareaid=103596\" target=\"_blank\" rel=\"noopener\">http://jiage.autohome.com.cn/price/carlist/p-28133#pvareaid=103596</a></td><br>   </tr><br></table>\n\n\n","categories":[],"tags":["生活"]},{"title":"基于OpenCV的人脸识别","url":"http://hchong.net/2017/06/16/基于OpenCV的人脸识别/","content":"","categories":[],"tags":[]},{"title":"Python爬虫入门","url":"http://hchong.net/2017/06/14/Python爬虫入门/","content":"<h1 id=\"HCModule\"><a href=\"#HCModule\" class=\"headerlink\" title=\"HCModule\"></a>HCModule</h1><p><a href=\"https://travis-ci.org/HChong3210/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"http://img.shields.io/travis/HChong3210/HCModule.svg?style=flat\" alt=\"CI Status\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/v/HCModule.svg?style=flat\" alt=\"Version\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/l/HCModule.svg?style=flat\" alt=\"License\"></a><br><a href=\"http://cocoapods.org/pods/HCModule\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/cocoapods/p/HCModule.svg?style=flat\" alt=\"Platform\"></a></p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>To run the example project, clone the repo, and run <code>pod install</code> from the Example directory first.</p>\n<h2 id=\"Requirements\"><a href=\"#Requirements\" class=\"headerlink\" title=\"Requirements\"></a>Requirements</h2><h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>HCModule is available through <a href=\"http://cocoapods.org\" target=\"_blank\" rel=\"noopener\">CocoaPods</a>. To install<br>it, simply add the following line to your Podfile:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod <span class=\"string\">'HCModule'</span></div></pre></td></tr></table></figure>\n<h2 id=\"Author\"><a href=\"#Author\" class=\"headerlink\" title=\"Author\"></a>Author</h2><p>HChong3210, hchong7557@gmail.com</p>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p>HCModule is available under the MIT license. See the LICENSE file for more info.</p>\n","categories":["Python"],"tags":["爬虫","Python"]},{"title":"Cocoapods实践","url":"http://hchong.net/2017/05/24/Cocoapods实践/","content":"<h1 id=\"Cocoapods实践\"><a href=\"#Cocoapods实践\" class=\"headerlink\" title=\"Cocoapods实践\"></a>Cocoapods实践</h1><p>Cocoapods是一个基于Ruby的包管理工具, 类似的还有Carthage. Cocoapods的安装在这里不在详述, 请自行百度, 在这里着重讲一下如何使用Cocoapods制作私有包, 以及Cocoapods的实现原理. </p>\n<h2 id=\"Cocoapods的实现原理\"><a href=\"#Cocoapods的实现原理\" class=\"headerlink\" title=\"Cocoapods的实现原理\"></a>Cocoapods的实现原理</h2><p>cocoapods安装成功后, 我们怎么来使用它呢. 这里就要用到cocoapods的核心文件之一<code>Podfile</code>. Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度自定义，你可以根据个人喜好对其做出定制。<a href=\"https://guides.cocoapods.org/syntax/Podfile.html\" target=\"_blank\" rel=\"noopener\">查看更多官方介绍</a>. </p>\n<h3 id=\"Podfile\"><a href=\"#Podfile\" class=\"headerlink\" title=\"Podfile\"></a>Podfile</h3><p>下面是一个🌰, 我们来挨个分析下他们背后都代表着什么.</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><div class=\"line\">source <span class=\"string\">'http://source.git'</span></div><div class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'8.0'</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'Demo'</span> <span class=\"keyword\">do</span></div><div class=\"line\">    pod <span class=\"string\">'AFNetworking'</span></div><div class=\"line\">    pod <span class=\"string\">'SDWebImage'</span></div><div class=\"line\">    pod <span class=\"string\">'Masonry'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"></div><div class=\"line\">`source<span class=\"string\">`: Specifies the location of specs. spec的地址.</span></div><div class=\"line\"></div><div class=\"line\">`platform<span class=\"string\">`: Specifies the platform for which a static library should be built. 指定构建静态库的平台.</span></div><div class=\"line\"></div><div class=\"line\">`target<span class=\"string\">`: Defines a CocoaPods target and scopes dependencies defined within the given block. A target should correspond to an Xcode target. By default the target includes the dependencies defined outside of the block, unless instructed not to inherit them. 定义了CocoaPods在指定target的依赖, 此处的Target应该与Xcode目标相对应。默认情况下，除非表明不继承它们, 否则Target包括在块外部定义的依赖项.</span></div><div class=\"line\"></div><div class=\"line\">`pod<span class=\"string\">`: A dependency requirement is defined by the name of the Pod and optionally a list of version requirements. 一个依赖项需求是由Pod的名称和可选的版本需求列表所定义的.</span></div><div class=\"line\"></div><div class=\"line\">当你写完`Podfile<span class=\"string\">`之后, 就需要执行Pod的命令`</span>pod install<span class=\"string\">`, 来按照`</span>Podfile<span class=\"string\">`中的配置来配置我么你的工程</span></div><div class=\"line\"></div><div class=\"line\">### pod install</div><div class=\"line\"></div><div class=\"line\">当运行 `pod install<span class=\"string\">` 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 `</span>--verbose<span class=\"string\">`来查看详细内容。现在运行这个命令 `</span>pod install --verbose<span class=\"string\">`，可以看到类似如下的内容:</span></div></pre></td></tr></table></figure>\n<p>  Preparing</p>\n<p>Analyzing dependencies</p>\n<p>Inspecting targets to integrate<br>  Using <code>ARCHS</code> setting to build architectures of target <code>Pods-XXX</code>: (``)</p>\n<p>Resolving dependencies of <code>Podfile</code></p>\n<p>Comparing resolved specification to the sandbox manifest<br>  A AFNetworking<br>  A Masonry<br>  A SDWebImage</p>\n<p>Downloading dependencies</p>\n<p>-&gt; Installing AFNetworking (3.1.0)</p>\n<blockquote>\n<p>Git download<br>Git download<br>     $ /usr/bin/git clone <a href=\"https://github.com/AFNetworking/AFNetworking.git\" target=\"_blank\" rel=\"noopener\">https://github.com/AFNetworking/AFNetworking.git</a><br>     /var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8<br>     –template= –single-branch –depth 1 –branch 3.1.0<br>     Cloning into ‘/var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8’…<br>     Note: checking out ‘88f13053b1d1f20bf657f5c36459b87a5d317ad7’.</p>\n</blockquote>\n<pre><code>You are in &apos;detached HEAD&apos; state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b &lt;new-branch-name&gt;\n\n$ /usr/bin/git -C\n/var/folders/qy/tmvltypx4w954cx9hsfz0vn40000gn/T/d20170813-81556-1sx4ds8\nsubmodule update --init --recursive\n</code></pre><blockquote>\n<p>Copying AFNetworking from<br>  <code>/Users/hc/Library/Caches/CocoaPods/Pods/Release/AFNetworking/3.1.0-5e0e1</code> to<br>  <code>Pods/AFNetworking</code></p>\n</blockquote>\n<p>-&gt; Installing Masonry (1.0.2)</p>\n<blockquote>\n<p>Copying Masonry from<br>  <code>/Users/hc/Library/Caches/CocoaPods/Pods/Release/Masonry/1.0.2-7c429</code> to<br>  <code>Pods/Masonry</code></p>\n</blockquote>\n<p>-&gt; Installing SDWebImage (4.1.0)</p>\n<blockquote>\n<p>Copying SDWebImage from<br>  <code>/Users/hc/Library/Caches/CocoaPods/Pods/Release/SDWebImage/4.1.0-0e435</code> to<br>  <code>Pods/SDWebImage</code></p>\n<ul>\n<li>Running pre install hooks</li>\n</ul>\n</blockquote>\n<p>Generating Pods project</p>\n<ul>\n<li>Creating Pods project</li>\n<li>Adding source files to Pods project</li>\n<li>Adding frameworks to Pods project</li>\n<li>Adding libraries to Pods project</li>\n<li>Adding resources to Pods project</li>\n<li>Linking headers</li>\n<li>Installing targets<ul>\n<li>Installing target <code>AFNetworking</code> iOS 8.0<ul>\n<li>Generating Info.plist file at <code>Pods/Target Support\nFiles/AFNetworking/Info.plist</code></li>\n<li>Generating module map file at <code>Pods/Target Support\nFiles/AFNetworking/AFNetworking.modulemap</code></li>\n<li>Generating umbrella header at <code>Pods/Target Support\nFiles/AFNetworking/AFNetworking-umbrella.h</code></li>\n</ul>\n</li>\n<li>Installing target <code>Masonry</code> iOS 8.0<ul>\n<li>Generating Info.plist file at <code>Pods/Target Support\nFiles/Masonry/Info.plist</code></li>\n<li>Generating module map file at <code>Pods/Target Support\nFiles/Masonry/Masonry.modulemap</code></li>\n<li>Generating umbrella header at <code>Pods/Target Support\nFiles/Masonry/Masonry-umbrella.h</code></li>\n</ul>\n</li>\n<li>Installing target <code>SDWebImage</code> iOS 8.0<ul>\n<li>Generating Info.plist file at <code>Pods/Target Support\nFiles/SDWebImage/Info.plist</code></li>\n<li>Generating module map file at <code>Pods/Target Support\nFiles/SDWebImage/SDWebImage.modulemap</code></li>\n<li>Generating umbrella header at <code>Pods/Target Support\nFiles/SDWebImage/SDWebImage-umbrella.h</code></li>\n</ul>\n</li>\n<li>Installing target <code>Pods-CarMall</code> iOS 8.0<ul>\n<li>Generating Info.plist file at <code>Pods/Target Support\nFiles/Pods-CarMall/Info.plist</code></li>\n<li>Generating module map file at <code>Pods/Target Support\nFiles/Pods-CarMall/Pods-CarMall.modulemap</code></li>\n<li>Generating umbrella header at <code>Pods/Target Support\nFiles/Pods-CarMall/Pods-CarMall-umbrella.h</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Running post install hooks</li>\n<li>Writing Xcode project file to <code>Pods/Pods.xcodeproj</code><ul>\n<li>Generating deterministic UUIDs</li>\n</ul>\n</li>\n<li>Writing Lockfile in <code>Podfile.lock</code></li>\n<li>Writing Manifest in <code>Pods/Manifest.lock</code></li>\n</ul>\n<p>Integrating client project</p>\n<p>[!] Please close any current Xcode sessions and use <code>CarMall.xcworkspace</code> for this project from now on.</p>\n<p>Integrating target <code>Pods-CarMall</code> (<code>CarMall.xcodeproj</code> project)</p>\n<ul>\n<li>Running post install hooks<ul>\n<li>cocoapods-stats from<br><code>/Users/hc/.rvm/gems/ruby-2.4.1/gems/cocoapods-stats-1.0.0/lib/cocoapods_plugin.rb</code></li>\n</ul>\n</li>\n</ul>\n<p>Sending stats</p>\n<pre><code>- AFNetworking, 3.1.0\n- Masonry, 1.0.2\n- SDWebImage, 4.1.0\n</code></pre><p>-&gt; Pod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">先看我们工程的变化, 可以发现工程里面多了三个文件, 一个`XXX.xcworkspace`文件, 一个`Podfile.lock`文件, 还有一个`Pods`文件夹. 我们在通过终端输出的命令来分析, 为什么会生成这几个文件, 以及他们的作用.</div><div class=\"line\"></div><div class=\"line\">1. Analyzing dependencies. 弄清楚声明了哪些第三方库.在加载 `podspecs` 过程中，`CocoaPods` 就建立了包括版本信息在内的所有的第三方库的列表。`Podspecs` 被存储在本地路径 `~/.cocoapods` 中.</div><div class=\"line\">2. Inspecting targets to integrate. 检查目标集成.</div><div class=\"line\">3. Resolving dependencies of `Podfile` 和 Comparing resolved specification to the sandbox manifest. 分析`Podfile`文件的依赖和将已经解析的Pod与缓存过的Pod进行比对, 是添加还是删除, 还是更新.</div><div class=\"line\">4. Downloading dependencies. 根据第三部的分析结果来下载依赖到`Pods`文件夹下面.</div><div class=\"line\">5. Generating Pods project. 生成Pods的工程. 这一步还包含了许多其他的步骤.</div><div class=\"line\">\t* Creating Pods project</div><div class=\"line\">\t* Adding source files to Pods project</div><div class=\"line\">\t* Adding frameworks to Pods project</div><div class=\"line\">\t* Adding libraries to Pods project</div><div class=\"line\">\t* Adding resources to Pods project</div><div class=\"line\">\t* Linking headers</div><div class=\"line\">\t* Installing targets</div><div class=\"line\">\t* Running post install hooks</div><div class=\"line\">\t* Writing Xcode project file to `Pods/Pods.xcodeproj` 如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 Pods.xcodeproj 进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中.</div><div class=\"line\">\t* Writing Lockfile in `Podfile.lock`. 记录各个Pod的版本号和之家你的依赖关系.</div><div class=\"line\">\t* Writing Manifest in `Pods/Manifest.lock`</div><div class=\"line\">  </div><div class=\"line\"></div><div class=\"line\">### pod install vs pod update</div><div class=\"line\"></div><div class=\"line\">引用官方的文档[https://guides.cocoapods.org/using/pod-install-vs-update.html](https://guides.cocoapods.org/using/pod-install-vs-update.html)来说明一下二者的区别, 以及使用场景.</div><div class=\"line\"></div><div class=\"line\">You will only use pod update when you want to update the version of a specific pod (or all the pods).</div><div class=\"line\"></div><div class=\"line\">* `pod install`主要用在第一次安装pods时, 如果后面你新增, 修改, 删除你的`Podfile`文件时也可以使用该命令. 每次执行`pod install`命令会把每一个安装的pod的版本写进`Podfile.lock`文件中, 来记录和lock这些已经安装Pod的版本. 当执行`Pod install`. 如果是新增Pod, 那么会搜索与Podfile中描述的匹配的版本; 如果已经存在, 他会下载`Podfile.lock`文件中明确的版本, 但不会去检查有没有可用的最新版本.</div><div class=\"line\">* `pod update`会不关注`Podfile.lock`中的版本而直接更新到符合`Podfile`中定义的最新版本.</div><div class=\"line\"></div><div class=\"line\">## 使用CocoaPods创建私有Pod</div><div class=\"line\"></div><div class=\"line\">上面我们已经介绍过如何使用CocoaPods了, 下面要讲解的就是如何创建Pod来供别人使用. 在创建私有Pod之前我们需要两个git地址:</div><div class=\"line\"></div><div class=\"line\">* 用来保存Spec Repo的内容的Git地址</div><div class=\"line\">* 用来保存具体Pod内容的Git地址</div><div class=\"line\"></div><div class=\"line\">### 创建一个Spec Repo</div><div class=\"line\"></div><div class=\"line\">在这一步, 我们主要创建第一个Git地址, 并且关联到本地.</div><div class=\"line\"></div><div class=\"line\">`Spec Repo`是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端. 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的:</div></pre></td></tr></table></figure></p>\n<p>.<br>├── Specs<br>    └── [SPEC_NAME]<br>        └── [VERSION]<br>            └── [SPEC_NAME].podspec<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">如果你要创建私有Pod, 那么你的`Spec Repo`的远端地址就必须是私有的. 反之如果你要创建一个公有的Pod, 那么就可以使用GitHub来托管你的代码. 当你创建好远端的仓库之后, 执行`pod repo add [Spec Repo的仓库名] [Spec Repo的git地址]`来把远端的仓库clone到本地. 注意, 这里`[Spec Repo的仓库名]`不一定是远端Git仓库的名字, 而是clone到本地后, 本地文件加的名字, 但是这个名字会在后面提交`PodSpec`文件时用到.</div><div class=\"line\"></div><div class=\"line\">### 创建Pod工程文件</div><div class=\"line\"></div><div class=\"line\">我们在你需要创建Pod的目录下使用`pod lib create [Pod名称]`来创建对应的Pod模板.  实际上该命令行隐藏了默认参数, 参数补全后应该是`pod lib create ProjectName --template-url=https://github.com/CocoaPods/pod-template.git`. </div><div class=\"line\"></div><div class=\"line\">接下来会问你四个问题:</div><div class=\"line\">1. What language do you want to use?? [ Swift / ObjC ]. 使用什么语言</div><div class=\"line\">2. Would you like to include a demo application with your library?. 是否需要一个例子工程, 一般选择YES</div><div class=\"line\">3. Which testing frameworks will you use? [ Specta / Kiwi / None ]. 选择一个测试框架</div><div class=\"line\">4. Would you like to do view based testing? [ Yes / No ]. 是否基于View测试</div><div class=\"line\">5. What is your class prefix?. 类的前缀</div><div class=\"line\"></div><div class=\"line\">根据自己的实际需要来选择后, 就会自动执行`Pod install`命令来创建项目并且生成依赖. 这是这个Pod的没目录结构应该是这样的:</div></pre></td></tr></table></figure></p>\n<p>  MyLib<br>  ├── .travis.yml<br>  ├── _Pods.xcproject<br>  ├── Example<br>  │   ├── MyLib<br>  │   ├── MyLib.xcodeproj<br>  │   ├── MyLib.xcworkspace<br>  │   ├── Podfile<br>  │   ├── Podfile.lock<br>  │   ├── Pods<br>  │   └── Tests<br>  ├── LICENSE<br>  ├── MyLib.podspec<br>  ├── Pod<br>  │   ├── Assets<br>  │   └── Classes<br>  │     └── RemoveMe.[swift/m]<br>  └── README.md<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">接下来, 我们需要创建第二个Git地址, 用来保存Pod的实现代码. 我们进入到Pod文件夹的根目录下, 使用如下代码来关联Pod到远端仓库:</div></pre></td></tr></table></figure></p>\n<p>$ git add .<br>$ git commit -s -m “Initial Commit of Library”<br>$ git remote add origin [Pod的远端地址]           #添加远端仓库<br>$ git push origin master     #提交到远端仓库<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 编辑Pod文件</div><div class=\"line\"></div><div class=\"line\">Pod文件就是这个Pod要实现功能的具体逻辑, 在主工程根目录下面有一个和Pod同名的文件夹, 里面有两个子文件夹. 一个是`Assets`, 一个是`Classes`.</div><div class=\"line\"></div><div class=\"line\">* Assets文件主要用来存放资源文件, 例如图片资源和XIB文件.</div><div class=\"line\">* Classes则存放主要的功能代码, 类.</div><div class=\"line\"></div><div class=\"line\">在这里需要注意两个地方:</div><div class=\"line\">1. 当我们要使用`Pod`中的资源时, 以图片为例, 我们通过`[UIImage imageWithName:@&quot;xxx.png&quot;]`是取不到Pod中的图片的, 因为`imageWithName:`方法默认是从`mainBundle`中来取的, 而Pod不属于`mainBundle`的范畴, 我们需要先根据`class`来拿到当前类所在的`bundle`, 再取该`Bundle`中的资源.</div><div class=\"line\">2. 每次在Pod文件夹中添加新的文件或者资源时, 都需要在根目录的Example目录下执行`pod update`命令来重新建立索引.</div><div class=\"line\"></div><div class=\"line\">### 编辑Podspec文件</div><div class=\"line\"></div><div class=\"line\">关于`Podspec`文件[官方](http://guides.cocoapods.org/syntax/podspec.html)是这样描述的:</div><div class=\"line\"></div><div class=\"line\">&gt; A specification describes a version of Pod library. It includes details about where the source should be fetched from, what files to use, the build settings to apply, and other general metadata such as its name, version, and description.</div><div class=\"line\"></div><div class=\"line\">`pod lib create XXX`创建出来的Pod, 初始时的`Podspec`文件包含了各种信息, 详细的说明我们可以看[官方文档](http://guides.cocoapods.org/syntax/podspec.html), 这里贴上最基础的用法代码:</div></pre></td></tr></table></figure></p>\n<p>Pod::Spec.new do |s|<br>  s.name             = ‘HCPods’</p>\n<p>  #Pod的版本<br>  s.version          = ‘0.1.0’<br>  s.summary          = ‘你在搜索时会呈现’</p>\n<p>  s.description      = &lt;&lt;-DESC<br>    这里是关于你Pod功能的描述<br>                       DESC</p>\n<p>  s.homepage         = ‘<a href=\"https://github.com/HChong3210/HCPods\" target=\"_blank\" rel=\"noopener\">https://github.com/HChong3210/HCPods</a>‘<br>  s.license          = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ }<br>  s.author           = { ‘HChong3210’ =&gt; ‘hchong7557@gmail.com’ }</p>\n<p>  #Pod的远端仓库地址<br>  s.source           = { :git =&gt; ‘<a href=\"https://github.com/HChong3210/HCPods.git\" target=\"_blank\" rel=\"noopener\">https://github.com/HChong3210/HCPods.git</a>‘, :tag =&gt; s.version.to_s }</p>\n<pre><code>#Pod支持的最低版本\n</code></pre><p>  s.ios.deployment_target = ‘8.0’</p>\n<pre><code>#Pod源文件的位置\n</code></pre><p>  s.source_files = ‘HCPods/Classes/<em>*/</em>‘</p>\n<p>  #Pod中资源文件的位置<br>  s.resource_bundles = {<br>    ‘DFCForms’ =&gt; [‘HCPods/Assets/*.{png,xib,plist}’]<br>  }</p>\n<p>  #对外公开的类<br>  s.public_header_files = ‘DFCForms/Classes/<em>*/</em>.h’</p>\n<p>  #Pod中用到的第三方库<br>  s.frameworks = ‘UIKit’<br>  s.dependency ‘AFNetworking’, ‘~&gt; 2.3’<br>  s.dependency ‘SDWebImage’</p>\n<p>end<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 提交Pod文件</div><div class=\"line\"></div><div class=\"line\">Pod文件编辑好后, 我们要把代码提交到远端服务器, 我们就使用正常的方式来提交代码, 并且给代码打上Tag, * 注意, 这里的Tag必须和`Podspec`文件中的Pod版本号一致 *, 因为Podspec会根据Tag从远端来找相应的代码, 否则会出现版本和代码不匹配的现象.</div><div class=\"line\"></div><div class=\"line\">如果不使用Sourcetree这样的GUI工具, 可以参考下面的Git代码:</div></pre></td></tr></table></figure></p>\n<h1 id=\"在根目录下\"><a href=\"#在根目录下\" class=\"headerlink\" title=\"在根目录下\"></a>在根目录下</h1><p>git status<br>git add .<br>git tag -m ‘备注’ 版本号<br>git commit -s -m ‘备注’<br>git push origin master —tags<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">### 提交Podspec文件</div><div class=\"line\"></div><div class=\"line\">提交完Pod文件后, 我们只用把`Podspec`文件也提交上去, 这样就可以在Cocoapods中简历起来索引, 找到自己的Pod了. </div><div class=\"line\"></div><div class=\"line\">在提交之前我们可以在根目录下使用`pod lib lint`命令来验证是否编译通过. 也可以直接提交`pod repo push [你clone到本地的Spec Repo的仓库名] [Pod名称].podspec      --use-libraries --allow-warnings --sources=&apos;[Podspec远端地址],https://github.com/CocoaPods/Specs&apos; --verbose`</div><div class=\"line\"></div><div class=\"line\">### subspec的使用</div><div class=\"line\"></div><div class=\"line\">有时一个Pod太大了, 而我们又用不到全部的内容, 这时我们就可以使用subspec来解决这个问题. 我们可以在Pod文件夹中, 使用文件夹来分割各个子Pod, 然后在`Podspec`文件中这样设置:</div></pre></td></tr></table></figure></p>\n<p>  s.subspec ‘[子Pod名称]’ do |pod1|<br>      pod1.source_files = ‘SCCQRCode/Classes/[子文件夹名]/<em>*/</em>‘<br>  end</p>\n<p>  s.subspec ‘[子Pod名称]’ do |pod2|<br>            pod2.source_files = ‘SCCQRCode/Classes/[子文件夹名]/<em>*/</em>‘<br>  end<br>```</p>\n<p>我们也可以在各个子Pod中分别设置他们的资源路径, 对外暴露的header路径, 以及dependency.</p>\n<p>我们在外面引用该Pod的时候就可以使用<code>pod [Pod/子Pod]</code>的方式来只引用一个子Pod. </p>\n<h2 id=\"cocoapods的相关知识\"><a href=\"#cocoapods的相关知识\" class=\"headerlink\" title=\"cocoapods的相关知识\"></a>cocoapods的相关知识</h2><p>这里是CocoaPods的其他相关知识, 做一个备忘.</p>\n<h3 id=\"Pod的版本说明\"><a href=\"#Pod的版本说明\" class=\"headerlink\" title=\"Pod的版本说明\"></a>Pod的版本说明</h3><p>CocoaPods 使用<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener\">语义版本控制 - Semantic Versioning</a>命名约定来解决对版本的依赖. 常见的版本说明符号有以下这些.</p>\n<ul>\n<li>= 0.1 Version 0.1.</li>\n<li>0.1 Any version higher than 0.1.</li>\n<li><blockquote>\n<p>= 0.1 Version 0.1 and any higher version.</p>\n</blockquote>\n</li>\n<li>&lt; 0.1 Any version lower than 0.1.</li>\n<li>&lt;= 0.1 Version 0.1 and any lower version.</li>\n<li>~&gt; 0.1.2 Version 0.1.2 and the versions up to 0.2, not including 0.2. </li>\n</ul>\n<h3 id=\"常见Pod依赖的几种写法\"><a href=\"#常见Pod依赖的几种写法\" class=\"headerlink\" title=\"常见Pod依赖的几种写法\"></a>常见Pod依赖的几种写法</h3><ul>\n<li>pod ‘AFNetworking’, :configurations =&gt; [‘Debug’, ‘Beta’]</li>\n<li>pod ‘QueryKit/Attribute’</li>\n<li>pod ‘QueryKit’, :subspecs =&gt; [‘Attribute’, ‘QuerySet’]</li>\n<li>pod ‘AFNetworking’, :path =&gt; ‘~/Documents/AFNetworking’</li>\n<li>pod ‘AFNetworking’, :git =&gt; ‘<a href=\"https://github.com/gowalla/AFNetworking.git\" target=\"_blank\" rel=\"noopener\">https://github.com/gowalla/AFNetworking.git</a>‘</li>\n<li>pod ‘JSONKit’, :podspec =&gt; ‘<a href=\"https://example.com/JSONKit.podspec\" target=\"_blank\" rel=\"noopener\">https://example.com/JSONKit.podspec</a>‘</li>\n</ul>\n<hr>\n<p>参考文章:<br>1.<a href=\"https://swiftcafe.io/2015/10/25/swift-daily-carthage-package/\" target=\"_blank\" rel=\"noopener\">Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验</a>.</p>\n<p>2.<a href=\"https://bestswifter.com/cocoapods/\" target=\"_blank\" rel=\"noopener\">细聊Cocoapods与Xcode工程配置</a>.</p>\n<p>3.<a href=\"http://guides.cocoapods.org/making/using-pod-lib-create.html\" target=\"_blank\" rel=\"noopener\">Cocoapods官方文档</a>.</p>\n<p>4.<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"noopener\">使用Cocoapods创建私有podspec</a></p>\n<p>5.<a href=\"http://draveness.me/cocoapods.html\" target=\"_blank\" rel=\"noopener\">CocoaPods 都做了什么？</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/d6a592d6fced\" target=\"_blank\" rel=\"noopener\">使用私有Cocoapods仓库中引用.a库</a></p>\n<p>7.<a href=\"https://objccn.io/issue-6-4/\" target=\"_blank\" rel=\"noopener\">深入理解CocoaPods</a></p>\n<p>8.<a href=\"https://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"noopener\">podspec官方文档</a></p>\n<p>9.<a href=\"https://guides.cocoapods.org/syntax/Podfile.html\" target=\"_blank\" rel=\"noopener\">Podfile官方文档</a></p>\n","categories":["模块化"],"tags":["基础知识","模块化"]},{"title":"iOS的组件化实践","url":"http://hchong.net/2017/05/23/iOS的模块化实践/","content":"<h1 id=\"iOS的组件化实践\"><a href=\"#iOS的组件化实践\" class=\"headerlink\" title=\"iOS的组件化实践\"></a>iOS的组件化实践</h1><p>随着工程的变大, 业务的复杂, 开发人员的增多, 如何提高成员间的开发效率和最大程度的复用代码, 成为了亟待解决的问题. 除了更加清晰的结构目录外, 模块化, 应该是一种比较优雅解决方案. 关于组件化我们要达成的一个目标就是<em>重用高度抽象化的代码单元</em>.</p>\n<p>参考文章系列基本上可以代表业界目前对组件化的一些思考, 建议按照顺序阅读. 下面是我结合我司项目中的一些实际应用, 谈一下我对组件化的理解.</p>\n<p>我司的组件化之路, 大致可以分为几个阶段, 下面我就项目的变化历程来分析我司的组件化之路.</p>\n<h2 id=\"大杂烩\"><a href=\"#大杂烩\" class=\"headerlink\" title=\"大杂烩\"></a>大杂烩</h2><p>最开始, 我们的项目所有代码都在工程里面, 每个具体的业务使用独立的文件夹进行分割, 看似十分整洁, 但是也有很多不便之处. 各个模块之间耦合性很强, 责任人不明确. 这个时候可以说完全没有组件化的概念, 十分混乱. </p>\n<p>组件化的引入, 源于和另外一个项目的代码复用. 当时在做一个营销相关的业务, 由于效果十分好, 所以决定在另外一个项目中也接入这块业务. 然而, 并没有想象的那么简单. 由于跨项目, 后台完全不同, 牵涉到网络库调用, 公共组件的使用, 要想把这个业务单独拆分出去, 就必须把这个业务用到的网络库, 公共组件库也拆分出去, 难度非常之大. 这时候, 就想到了使用Cocoapods来管理一些工具类和公共组件, 于是就有了第二阶段.</p>\n<h2 id=\"非业务代码组件化\"><a href=\"#非业务代码组件化\" class=\"headerlink\" title=\"非业务代码组件化\"></a>非业务代码组件化</h2><p>在这一阶段, 我们充分使用Cocoapods的模块化功能, 将一些通用的类, 工具类, 封装成私有的Pod(<a href=\"http://hchong.net/2017/05/24/Cocoapods%E5%AE%9E%E8%B7%B5/\">参考这里</a>). 这样一来, 就把基础代码从项目中抽离出来, 其他的项目要想使用, 只需依赖我们的私有Pod就可以了. 那么上面想要拆分公共业务组件的想法就可以实现了.</p>\n<p>然而, 随着业务的打通. 不同的项目之间需要调用的共同组件越来越多, 组件与组件之间如何进行交互, 组件与项目之间又如何进行交互, 这些问题又出来了. 于是, 又有了现在的完全组件化方案.</p>\n<h2 id=\"完全组件化\"><a href=\"#完全组件化\" class=\"headerlink\" title=\"完全组件化\"></a>完全组件化</h2><p>称之为完全组件化方案, 是因为我司目前采用的就是这样的解决方案, 并且暂时也找不到更加好的解决方案. 完全组件化方案, 实际还是在<em>非业务代码组件化</em>的基础上, 通过引入<a href=\"http://hchong.net/2017/05/23/iOS%E7%9A%84%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AE%9E%E8%B7%B5/\">路由协议</a>来实现的.</p>\n<p>通过路由协议, 相当于我们通过一个中间层来转发我们组件与组件之间的通信, 这样就实现了组件之间的解耦, 而组件内部又是完整的业务逻辑, 属于高内聚, 低耦合.</p>\n<p>至此, 就完成了我们的组件化之路, 解除组件之间相互引用的代码硬依赖, 规范了组件之间的通信接口, 各个组件本身就相当于一个黑盒, 可以独立开发.</p>\n<h2 id=\"其他组件化方案\"><a href=\"#其他组件化方案\" class=\"headerlink\" title=\"其他组件化方案\"></a>其他组件化方案</h2><p>可以将需要封装的代码打包成静态库, 静态库中把需要暴露出来的头文件选择性的暴露出来, 不过这样各个模块之间的耦合性还是比较高的.</p>\n<hr>\n<p>参考文章:<br>1.<a href=\"http://limboy.me/tech/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"noopener\">蘑菇街App的组件化之路</a>.</p>\n<p>2.<a href=\"https://casatwy.com/iOS-Modulization.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈 组件化方案</a>.</p>\n<p>3.<a href=\"http://limboy.me/tech/2016/03/14/mgj-components-continued.html\" target=\"_blank\" rel=\"noopener\">蘑菇街App的组件化之路.续</a>.</p>\n<p>4.<a href=\"http://blog.cnbang.net/tech/3080/\" target=\"_blank\" rel=\"noopener\">iOS组件化方案探讨</a>.</p>\n","categories":["模块化"],"tags":["模块化","cocoapods"]},{"title":"iOS的路由协议实践","url":"http://hchong.net/2017/05/23/iOS的路由协议实践/","content":"<h1 id=\"iOS的路由协议实践\"><a href=\"#iOS的路由协议实践\" class=\"headerlink\" title=\"iOS的路由协议实践\"></a>iOS的路由协议实践</h1><p>路由协议, 是组件化的核心所在. 组件化, 实际就会把代码拆分为一个一个的模块, 无论采用Pod的方式,  文件夹分割的方式, 还是静态库的方式, 实质都是把代码分为一个个的模块. 如何在模块之间和应用之间通信, 就是路由协议需要考虑的问题.</p>\n<p>关于路由协议, 冰霜的<a href=\"https://halfrost.com/ios_router/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>写的实在是太详细了, 看得是男默女泪, 简直是业界良心. 简单说来, 路由协议跳转主要解决这几类问题:</p>\n<ol>\n<li>外部跳转到App内部一个很深层次的一个界面.</li>\n<li>App之间的相互跳转.</li>\n<li>解除App组件之间和App页面之间的耦合性.</li>\n<li>统一iOS和Android两端的页面跳转逻辑, 统一三端的请求资源的方式.</li>\n<li>iOS和Android两边只要共用一套动态下发配置文件来配置App的跳转逻辑.</li>\n<li>在App任何界面都可以调用任意一个界面或者任意一个组件.</li>\n</ol>\n<h2 id=\"应用间路由跳转\"><a href=\"#应用间路由跳转\" class=\"headerlink\" title=\"应用间路由跳转\"></a>应用间路由跳转</h2><p>应用间路由跳转主要有以下几种常见的使用场景: </p>\n<ol>\n<li>使用第三方用户登录，跳转到需授权的App或跳转到分享app的对应页面.</li>\n<li>应用程序推广, 跳转到另一个应用程序(本机已经安装).</li>\n<li>跳转到iTunes并显示应用程序下载页面(本机没有安装).</li>\n<li>第三方支付, 跳转到第三方支付App, 如支付宝支付, 微信支付.</li>\n<li>使用系统内置程序, 如跳转到打电话, 发短信, 发邮件, Safari等.</li>\n</ol>\n<p>应用间的跳转主要有两种方式: URL Scheme和Universal Links. 这两种实现方式并不冲突, 可以共存.</p>\n<h3 id=\"URL-Scheme方式跳转\"><a href=\"#URL-Scheme方式跳转\" class=\"headerlink\" title=\"URL Scheme方式跳转\"></a>URL Scheme方式跳转</h3><p>以A-&gt;B为例, 来说明下如何跳转.<br>首先我们需要分别在两个App的info.plist里面添加对应的URL types - URL Schemes, 如图所示:</p>\n<p><img src=\"http://img.souche.com/f2e/2b762dfb368b3b50621cd5c39b51a86e.png\" alt=\"添加URL types\"></p>\n<p>A的URL Schemes是APPA, B的URL Schemes是APPB. 由于iOS9引入了白名单的概念,<br>如果使用 canOpenURL:方法, 该方法所涉及到的 URL Schemes 必须在”Info.plist”中将它们列为白名单, 否则<code>canOpenURL</code>返回<code>NO</code>, 不能正常跳转. 所以要在A中添加B的URL Schemes, B中添加A的Schemes. key叫做<code>LSApplicationQueriesSchemes</code>, 键值内容是上一步对应应用程序的URL Schemes. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- jumpToAppB:(id)sender &#123;</div><div class=\"line\">   // 1.获取应用程序App-B的URL Scheme</div><div class=\"line\">   NSURL *appBUrl = [NSURL URLWithString:@&quot;zacharyB1://&quot;];</div><div class=\"line\">   // 2.判断手机中是否安装了对应程序</div><div class=\"line\">   if ([[UIApplication sharedApplication] canOpenURL:appBUrl]) &#123;</div><div class=\"line\">       // 3. 打开应用程序App-B</div><div class=\"line\">       //[[UIApplication sharedApplication] openURL:appBUrl];//iOS 9之后被废弃</div><div class=\"line\">       [[UIApplication sharedApplication] openURL:appBUrl options:@&#123;UIApplicationOpenURLOptionUniversalLinksOnly : @YES&#125; completionHandler:^(BOOL success) &#123;</div><div class=\"line\">            </div><div class=\"line\">        &#125;];</div><div class=\"line\">   &#125; else &#123;</div><div class=\"line\">       NSLog(@&quot;没有安装&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>options目前可传入参数Key在UIApplication头文件只有一个:UIApplicationOpenURLOptionUniversalLinksOnly, 其对应的Value为布尔值, 默认为False. 如该Key对应的Value为True, 那么打开所传入的Universal Link时, 只允许通过这个Link所代表的iOS应用跳转的方式打开这个链接, 否则就会返回success为false, 也就是说只有安装了Link所对应的App的情况下才能打开这个Universal Link, 而不是通过启动Safari方式打开这个Link的代表的网站. </p>\n<p>至此, 就可以正常跳转了, 如果我们不希望某个APP通过URL Scheme的方式打开我们的应用, 我们可以在<code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code>方法中判断指定的Scheme然后返回<code>NO</code>, 如下所示, 只有<code>com.tencent.weixin</code>的Scheme才能打开我们的APP. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation &#123;</div><div class=\"line\">    NSLog(@&quot;sourceApplication: %@&quot;, sourceApplication);</div><div class=\"line\">    NSLog(@&quot;URL scheme:%@&quot;, [url scheme]);</div><div class=\"line\">    NSLog(@&quot;URL query: %@&quot;, [url query]);</div><div class=\"line\"></div><div class=\"line\">    if ([sourceApplication isEqualToString:@&quot;com.tencent.weixin&quot;])&#123;</div><div class=\"line\">        // 允许打开</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Universal-Links方式跳转\"><a href=\"#Universal-Links方式跳转\" class=\"headerlink\" title=\"Universal Links方式跳转\"></a>Universal Links方式跳转</h3><p>使用这个功能可以使我们的App通过HTTP链接来启动App, 通用链接就是HTTP协议的普通URL, 通过在服务器上配置一些文件, 配合应用. 实现客户点击网页链接之后直接打开应用. 客户在微信\\QQ中点击链接时不再需要点击右上’在Safari浏览器打开’才能打开软件, 实现客户操作的无缝跳转, 让客户体验更加连贯, 更顺畅. </p>\n<ol>\n<li><p>如果安装过App, 不管在微信里面http链接还是在Safari浏览器, 还是其他第三方浏览器, 都可以打开App. </p>\n</li>\n<li><p>如果没有安装过App, 就会打开网页. </p>\n</li>\n</ol>\n<p>具体设置需要3步: </p>\n<ol>\n<li><p>App需要开启Associated Domains服务, 并设置Domains, 注意必须要applinks：开头. 这里需要在APP使用的证书中设置这个选项, 否则在APP设置中看不到Associated Domains服务. </p>\n</li>\n<li><p>域名必须要支持HTTPS. </p>\n</li>\n<li><p>上传内容是Json格式的文件, 文件名为apple-app-site-association到自己域名的根目录下, 或者.well-known目录下. iOS自动会去读取这个文件. 具体的文件内容请查看<a href=\"https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>. </p>\n</li>\n</ol>\n<p><a href=\"http://www.jianshu.com/p/c83164c2aec2\" target=\"_blank\" rel=\"noopener\">参考文章一</a></p>\n<p><a href=\"http://www.jianshu.com/p/1970fd59de12\" target=\"_blank\" rel=\"noopener\">参考文章二</a></p>\n<h2 id=\"应用内路由协议设计思路\"><a href=\"#应用内路由协议设计思路\" class=\"headerlink\" title=\"应用内路由协议设计思路\"></a>应用内路由协议设计思路</h2><p><em>页面间跳转</em> 和 <em>组件间调用</em>, 是应用内路由协议要解决的两大问题, 举个例子来说明一下:</p>\n<ul>\n<li><em>页面跳转</em>, 如果以传统的Push来说, 我们怎么才能从任一界面push到另外任一界面, 各个界面之间的跳转必然要相互<code>Import</code>, 这些怎么解决.</li>\n<li><em>组件见调用</em>, 随着业务的模块化拆分, 各个模块之间有业务调用怎么办, 本身独立的模块, 为了相互调用必然又增加接口供外部调用, 本身相对独立的业务模块, 瞬间又变得相互耦合了.</li>\n</ul>\n<p>而路由协议正是为了解决这一类问题, 现在比较流行的路由协议有如下几种:</p>\n<ul>\n<li><a href=\"https://github.com/joeldev/JLRoutes\" target=\"_blank\" rel=\"noopener\">JLRouts</a></li>\n<li><a href=\"https://github.com/clayallsopp/routable-ios\" target=\"_blank\" rel=\"noopener\">Routable</a></li>\n<li><a href=\"https://github.com/lightory/HHRouter\" target=\"_blank\" rel=\"noopener\">HHRouter</a></li>\n<li><a href=\"https://github.com/meili/MGJRouter\" target=\"_blank\" rel=\"noopener\">MGJRouter</a></li>\n<li><a href=\"https://github.com/casatwy/CTMediator\" target=\"_blank\" rel=\"noopener\">CTMediator</a></li>\n</ul>\n<p><img src=\"https://ob6mci30g.qnssl.com/Blog/ArticleImage/40_15.png\" alt=\"URL资源\"></p>\n<p>通过上面应用间的跳转, 我们可以发现iOS 系统里面使用的是URL Scheme方式. 对于一个资源的访问，苹果也是用URL的方式来访问的, 那么我们就可以想办法通过URL来统一三端的跳转. 一段标准的URL的格式, 每一部分都代表不同的含义. 我们可以按照规则来解析接受到的URL, 从而获得有用的信息. 下面说一下我的解决方案. </p>\n<p>大致的解决思路如下:</p>\n<ol>\n<li><p>在APP开始加载时设置Module的<code>Scheme</code>, 并且初始化Module的核心类<code>HCModuleCore</code>.</p>\n<p> <code>Scheme</code>是用来标记当前APP, 每个APP的<code>Scheme</code>不尽相同, 他和应用间跳转时设置的<code>Scheme</code>是一个东西. <code>HCModuleCore</code>是个单例, 它存在于整个APP的生命周期中. </p>\n</li>\n<li><p>有一个<code>HCModuleProtocol</code>协议, 里面有几个必须要实现的方法.</p>\n<p> 如果某个类想要通过协议被跳转就必须实现该协议, 并且实现协议中的<code>@required</code>方法. <code>@optional</code>方法根据实际需要选择实现.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">   HCModuleProtocol.h</div><div class=\"line\">   </div><div class=\"line\">   @required</div><div class=\"line\">   /**</div><div class=\"line\">   该方法返回当前类的标签, 该标签是当前类的唯一标识, 不可重复</div><div class=\"line\">   @return 字符串类型</div><div class=\"line\">   */</div><div class=\"line\">   + (NSString *)moduleName;</div><div class=\"line\"></div><div class=\"line\">   @optional</div><div class=\"line\">   /**</div><div class=\"line\">   如果是通过push方式打开, 就实现该方法, 返回当前类的self</div><div class=\"line\">   </div><div class=\"line\">   @param params 传入的参数</div><div class=\"line\">   @param callback 传入的block回调</div><div class=\"line\">   @return 实现跳转协议类的self</div><div class=\"line\">   */</div><div class=\"line\">   - (id)open:(NSDictionary *)params callback:(void(^)(NSDictionary *))callback;</div><div class=\"line\">   </div><div class=\"line\">   /**</div><div class=\"line\">如果是通过present方式打开, 就实现该方法, 返回当前类的self</div><div class=\"line\">      </div><div class=\"line\">   @param params 传入的参数</div><div class=\"line\">   @param callback 传入的block回调</div><div class=\"line\">   @return 实现跳转协议类的self</div><div class=\"line\">   */</div><div class=\"line\">   - (id)open_present:(NSDictionary *)params callback:(void(^)(NSDictionary *))callback;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>HCModuleCore</code>是个单例, 在初始化的时候, 通过runtime提供的方法把遵守``的类名缓存起来, 缓存信息存储在单例中, 存在于整个APP的生命周期中.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">    HCModuleCore.m</div><div class=\"line\">    </div><div class=\"line\">    + (instancetype)moduleCore &#123;</div><div class=\"line\">        static HCModuleCore *moduleCore;</div><div class=\"line\">        static dispatch_once_t onceToken;</div><div class=\"line\">        dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">            moduleCore = [[HCModuleCore alloc] init];</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return moduleCore;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    - (instancetype)init &#123;</div><div class=\"line\">        self = [super init];</div><div class=\"line\">        if (self) &#123;</div><div class=\"line\">            [self cacheModuleProrocolClasses];</div><div class=\"line\">        &#125;</div><div class=\"line\">        return self;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /**</div><div class=\"line\">    把遵守HCModuleProtocol的类缓存起来</div><div class=\"line\">    */</div><div class=\"line\">    - (void)cacheModuleProrocolClasses &#123;</div><div class=\"line\">        if (_cache.count != 0) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        NSMutableDictionary *tmpCache = [NSMutableDictionary dictionary];</div><div class=\"line\">        Class *classes;</div><div class=\"line\">        unsigned int outCount;</div><div class=\"line\">        classes = objc_copyClassList(&amp;outCount);//获取全部类</div><div class=\"line\">        for (int i = 0; i &lt; outCount; i++) &#123;</div><div class=\"line\">            Class class = classes[i];</div><div class=\"line\">        </div><div class=\"line\">            //实现了HCModuleProtocol的类</div><div class=\"line\">            if (class_conformsToProtocol(class, @protocol(HCModuleProtocol))) &#123;</div><div class=\"line\">                NSString *moduleName = [class moduleName];</div><div class=\"line\">                //重复检查</div><div class=\"line\">                NSCAssert([tmpCache objectForKey:moduleName] == nil, @&quot;in class %@, module %@ has defined, please check!&quot;, NSStringFromClass(class), moduleName);</div><div class=\"line\">                [tmpCache setObject:NSStringFromClass(class) forKey:moduleName];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(classes);</div><div class=\"line\">        self.cache = [tmpCache copy];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>主要是通过传入的moduleName或者URl来获取到被打开页面的唯一标识, 再通过唯一标识从单例中缓存的遵守跳转协议的类中去找. 如果找到的话, <code>performSelector:withObject:withObject:</code>方法的返回值是响应的方法的返回值, 通过该函数获取到被跳转的类的实例. </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">    HCModuleCore.m</div><div class=\"line\">    </div><div class=\"line\">    //根据moduleName返回对应注册的类</div><div class=\"line\">    - (id)moduleName:(NSString *)moduleName openWithParams:(NSDictionary *)params callback:(void(^)(NSDictionary *moduleInfo))callback &#123;</div><div class=\"line\">        NSCAssert(moduleName != nil, @&quot;moduleName can not be nil!&quot;);</div><div class=\"line\">        id module = [self moduleName:moduleName performSelectorName:@&quot;open:callback:&quot; withParams:params callback:callback];</div><div class=\"line\">        if (module == nil) &#123;</div><div class=\"line\">            module = [self moduleName:moduleName performSelectorName:@&quot;open_present:callback:&quot; withParams:params callback:callback];</div><div class=\"line\">        &#125;</div><div class=\"line\">        return module;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //获取缓存起来的响应相应协议方法的类</div><div class=\"line\">    - (id)moduleName:(NSString *)moduleName performSelectorName:(NSString *)selectorName withParams:(NSDictionary *)params callback:(void(^)(NSDictionary *moduleInfo))callback &#123;</div><div class=\"line\">        NSCAssert(moduleName != nil &amp;&amp; selectorName != nil, @&quot;moduleName and selectorName can not be nil!&quot;);</div><div class=\"line\">        id module;</div><div class=\"line\">        NSString *clsName = self.cache[moduleName];</div><div class=\"line\">        if (clsName.length) &#123;</div><div class=\"line\">            Class class = NSClassFromString(clsName);//根据缓存的类名字创建类</div><div class=\"line\">            SEL selec = NSSelectorFromString(selectorName);</div><div class=\"line\">            if (class) &#123;</div><div class=\"line\">                id target = [[class alloc] init];//初始化一个类的对象</div><div class=\"line\">                if ([target respondsToSelector:selec]) &#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class=\"line\">                    //performSelector:withObject:withObject:的返回值是响应的方法的返回值</div><div class=\"line\">                    module = [target performSelector:selec withObject:params withObject:callback];</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return module;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li>然后有两个category, 分别是<code>UINavigationController+HCModuleCore</code>和<code>UIViewController+HCModuleCore</code>. 分别对应push和present的情况. 因为上面已经拿到了要跳转到的页面的实例, 这里就可以通过push或者present的方法跳转过去.   </li>\n</ol>\n<hr>\n<p>参考文章:<br>1.<a href=\"https://halfrost.com/ios_router/\" target=\"_blank\" rel=\"noopener\">iOS 组件化 —— 路由设计思路分析</a></p>\n<p>2.<a href=\"http://awhisper.github.io/2016/06/12/%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%80%9D%E8%80%83/\" target=\"_blank\" rel=\"noopener\">路由跳转的思考</a></p>\n<p>3.<a href=\"http://wereadteam.github.io/2016/03/19/iOS-Component/\" target=\"_blank\" rel=\"noopener\">iOS组件化方案探讨</a></p>\n<p>4.<a href=\"https://casatwy.com/iOS-Modulization.html\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈-组件化方案</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/bb3f42fdbc31\" target=\"_blank\" rel=\"noopener\">iOS10跳转系统设置的正确姿势</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/32ca4bcda3d1\" target=\"_blank\" rel=\"noopener\">关于 iOS 系统功能的 URL 汇总列表</a></p>\n<p>7.<a href=\"http://www.jianshu.com/p/b5e8ef8c76a3\" target=\"_blank\" rel=\"noopener\">iOS应用间相互跳转</a></p>\n<p>8.<a href=\"http://www.jianshu.com/p/c83164c2aec2\" target=\"_blank\" rel=\"noopener\">从微信直接跳转到我们的APP</a></p>\n<p>9.<a href=\"http://www.jianshu.com/p/1970fd59de12\" target=\"_blank\" rel=\"noopener\">iOS Universal Links(通用链接)的使用</a></p>\n","categories":["模块化"],"tags":["模块化","路由"]},{"title":"Xcode自动化打包脚本","url":"http://hchong.net/2017/05/17/Xcode自动化打包脚本/","content":"<h1 id=\"Xcode自动化打包脚本\"><a href=\"#Xcode自动化打包脚本\" class=\"headerlink\" title=\"Xcode自动化打包脚本\"></a>Xcode自动化打包脚本</h1><p>自动化打包脚本是配合<a href=\"http://hchong.net/2017/03/12/%E5%A4%9ATarget%E5%AE%9E%E7%8E%B0/\">多渠道包和多环境包的自动化实现</a>使用的, 实际上脚本语言都可以做到, 我这里选用了Shell和Python两种实现方式. 对比下来发现, Python更好懂一点, 但是Shell更加简洁.</p>\n<h2 id=\"打包的基本思路\"><a href=\"#打包的基本思路\" class=\"headerlink\" title=\"打包的基本思路\"></a>打包的基本思路</h2><p>这里说一下打包脚本的基本实现思路:</p>\n<ol>\n<li>需要传入的参数有Scheme(用来指定打哪个环境的包), 如果使用Fir来作为内测分发工具的话, 还需要传入Fir的Token.</li>\n<li>在脚本内需要指定工程的路径, 工程名, Archive包的路径, IPA包的路径.</li>\n<li>通过Xcodebuild命令行生成Archive包.</li>\n<li>根据生成的Archive包导出IPA包.</li>\n<li>上传IPA包到Fir.</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>Xcode8.3后, 需要一个打包参数配置的plist文件, 生成Archive包时会用到.</li>\n<li>shell脚本需要给权限<code>chomd 777 xx.sh</code>.</li>\n<li>Archive导出为IPA有时会报错<code>Code=14 &quot;No applicable devices found.&quot;</code>, 这个多少是Ruby的路径没有指定导致, 找了一大圈有两个解决方案:<ol>\n<li>通过<code>sudo gem install CFPropertyList</code>, <code>rvm list</code>, <code>rvm use system</code>来解决, Python或者Shell都可以使用这种方式.</li>\n<li>Shell下还有另外的解决方案, 在shell脚本前加入如下代码, 指定路径.<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot;</div><div class=\"line\">rvm use system</div><div class=\"line\">xcodebuild &quot;$@&quot;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Xcode8-3后的plist文件\"><a href=\"#Xcode8-3后的plist文件\" class=\"headerlink\" title=\"Xcode8.3后的plist文件\"></a>Xcode8.3后的plist文件</h2><p>使用<code>xcodebuild -help</code> 可以查看Xcodebuild相关介绍</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Available keys for -exportOptionsPlist:</div><div class=\"line\"></div><div class=\"line\">\tcompileBitcode : Bool</div><div class=\"line\"></div><div class=\"line\">\t\tFor non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.</div><div class=\"line\"></div><div class=\"line\">\tembedOnDemandResourcesAssetPacksInBundle : Bool</div><div class=\"line\"></div><div class=\"line\">\t\tFor non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.</div><div class=\"line\"></div><div class=\"line\">\tiCloudContainerEnvironment</div><div class=\"line\"></div><div class=\"line\">\t\tFor non-App Store exports, if the app is using CloudKit, this configures the &quot;com.apple.developer.icloud-container-environment&quot; entitlement. Available options: Development and Production. Defaults to Development.</div><div class=\"line\"></div><div class=\"line\">\tmanifest : Dictionary</div><div class=\"line\"></div><div class=\"line\">\t\tFor non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.</div><div class=\"line\"></div><div class=\"line\">\tmethod : String</div><div class=\"line\"></div><div class=\"line\">\t\tDescribes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.</div><div class=\"line\"></div><div class=\"line\">\tonDemandResourcesAssetPacksBaseURL : String</div><div class=\"line\"></div><div class=\"line\">\t\tFor non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn&apos;t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.</div><div class=\"line\"></div><div class=\"line\">\tteamID : String</div><div class=\"line\"></div><div class=\"line\">\t\tThe Developer Portal team to use for this export. Defaults to the team used to build the archive.</div><div class=\"line\"></div><div class=\"line\">\tthinning : String</div><div class=\"line\"></div><div class=\"line\">\t\tFor non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. &quot;iPhone7,1&quot;). Defaults to &lt;none&gt;.</div><div class=\"line\"></div><div class=\"line\">\tuploadBitcode : Bool</div><div class=\"line\"></div><div class=\"line\">\t\tFor App Store exports, should the package include bitcode? Defaults to YES.</div><div class=\"line\"></div><div class=\"line\">\tuploadSymbols : Bool</div><div class=\"line\"></div><div class=\"line\">\t\tFor App Store exports, should the package include symbols? Defaults to YES.</div></pre></td></tr></table></figure>\n<p>我们在工程中新建一个plist文件, 可以看出, 大部分是有默认值的, 所以我们不用每个选项都填, 只写一些必填的就可以. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</div><div class=\"line\">    &lt;dict&gt;</div><div class=\"line\">        &lt;key&gt;method&lt;/key&gt;</div><div class=\"line\">        &lt;string&gt;enterprise&lt;/string&gt;</div><div class=\"line\">        &lt;key&gt;uploadSymbols&lt;/key&gt;</div><div class=\"line\">        &lt;true/&gt;</div><div class=\"line\">        &lt;key&gt;uploadBitcode&lt;/key&gt;</div><div class=\"line\">        &lt;false/&gt;</div><div class=\"line\">    &lt;/dict&gt;</div><div class=\"line\">&lt;/plist&gt;</div></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/HChong3210/buildScript.git\" target=\"_blank\" rel=\"noopener\">附件下载</a></p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"https://diaojunxian.github.io/2016/10/21/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%B8%83/\" target=\"_blank\" rel=\"noopener\">自动化测试-持续集成(7)</a></p>\n<p>2.<a href=\"http://stackoverflow.com/questions/33041109/xcodebuild-no-applicable-devices-found-when-exporting-archive\" target=\"_blank\" rel=\"noopener\">xcodebuild: “No applicable devices found.” when exporting archive</a></p>\n<p>3.<a href=\"\"></a></p>\n","categories":["自动化打包"],"tags":["自动化打包","Target","解决方案"]},{"title":"Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系","url":"http://hchong.net/2017/05/16/Settings关系/","content":"<h1 id=\"Xcode中的Workspace-Scheme-Project-Target和Build-Settings的关系\"><a href=\"#Xcode中的Workspace-Scheme-Project-Target和Build-Settings的关系\" class=\"headerlink\" title=\"Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系\"></a>Xcode中的Workspace, Scheme, Project, Target和Build Settings的关系</h1><h2 id=\"Xcode-Workspace\"><a href=\"#Xcode-Workspace\" class=\"headerlink\" title=\"Xcode Workspace\"></a>Xcode Workspace</h2><p>官方文档如下: </p>\n<blockquote>\n<p>A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets.</p>\n</blockquote>\n<p>workspace是Xcode的一种文件，用来管理工程和里面的文件，一个workspace可以包含若干个工程，甚至可以添加任何你想添加的文件。workspace提供了工程和工程里面的target之间隐式和显式依赖关系，用来管理和组织工程里面的所有文件.</p>\n<p> 一个workspace可以管理多个Project, <code>pod install</code>的过程就是生成了一个workspace和一个全是Pod组件的Project, 然后我们通过生成的workspace来管理新生成的Project和原本的Project.</p>\n<h2 id=\"Xcode-Project\"><a href=\"#Xcode-Project\" class=\"headerlink\" title=\"Xcode Project\"></a>Xcode Project</h2><p>官方文档如下:</p>\n<blockquote>\n<p>An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings).</p>\n</blockquote>\n<p>project就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。</p>\n<p>Xcode中的 project里面包含了所有的源文件，资源文件和构建一个或者多个product的信息。project利用他们去编译我们所需的product，也帮我们组织它们之间的关系。一个project可以包含一个或者多个target。project定义了一些基本的编译设置，每个target都继承了project的默认设置，每个target可以通过重新设置target的编译选项来定义自己的特殊编译选项。</p>\n<p>project包含了以下信息：</p>\n<ul>\n<li>源文件<ul>\n<li>代码的头文件和实现文件</li>\n<li>静态库，动态库，</li>\n<li>资源文件(如文本，xml，plist等)</li>\n<li>图片资源</li>\n<li>界面资源文件(xib， storyboard等)</li>\n</ul>\n</li>\n<li>在文件结构的导航中，采用group去组织文件(实际开发中，尽量使用实体文件夹)</li>\n<li>project的编译级别配置文件如(debug， release)</li>\n<li>target</li>\n<li>运行环境如：debug，test</li>\n</ul>\n<p>project可以单独存在，或者存在于一个workspace中.<br>​    </p>\n<h2 id=\"Xcode-Target\"><a href=\"#Xcode-Target\" class=\"headerlink\" title=\"Xcode Target\"></a>Xcode Target</h2><p>官方文档如下:</p>\n<blockquote>\n<p>A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.</p>\n</blockquote>\n<p>target 定义了生成的唯一 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product.</p>\n<p>这些指令以 build setting 和 build phases 的形式存在，你可在 Xcode 的项目编辑器(TARGETS-&gt;Build Setting, TARGETS-&gt;Build Phases)中进行查看和编辑。target 中的 build setting 参数继承自 project 的 build settings, 但是你可以在 target 中修改任意 settings 来重写 project settings，这样，最终生效的 settings 参数以在 target 中设置的为准. Project 可包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效.</p>\n<p>target 和其生成的 product 可与另一个 target 有关，如果一个 target 的 build 依赖于另一个 target 的输出，那么我们就说前一个 target 依赖于后一个 target .如果这些 target 在同一个 workspace 中，那么 Xcode 能够发现这种依赖关系，从而使其以我们期望的顺序生成 products.这种关系被称为隐式依赖关系。同时，你可以显示指定 targets 之间的依赖关系，并且这种依赖关系会覆盖 Xcode 推测出的隐式依赖关系。</p>\n<p>指定 targets 之间的依赖关系的地方在 Project Editor-&gt;TRAGETS-&gt;Build Phases-&gt;Target Dependencies 处设置.</p>\n<h2 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h2><p>官方文档如下:</p>\n<blockquote>\n<p>An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.</p>\n</blockquote>\n<p>一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。指定了编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等。可以通过scheme editor来编辑scheme.</p>\n<blockquote>\n<p>You can have as many schemes as you want, but only one can be active at a time. You can specify whether a scheme should be stored in a project—in which case it’s available in every workspace that includes that project, or in the workspace—in which case it’s available only in that workspace. When you select an active scheme, you also select a run destination (that is, the architecture of the hardware for which the products are built).</p>\n</blockquote>\n<p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>\n<h2 id=\"Build-Settings\"><a href=\"#Build-Settings\" class=\"headerlink\" title=\"Build Settings\"></a>Build Settings</h2><p>官方文档如下:</p>\n<blockquote>\n<p>A build setting is a variable that contains information about how a particular aspect of a product’s build process should be performed. For example, the information in a build setting can specify which options Xcode passes to the compiler.</p>\n</blockquote>\n<p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>\n<p>build setting 中包含了 product 生成过程中所需的参数信息。你可以在 project-level 和 target-level 层指定 build settings。project-level 的 build settings 适用于 project 中的所有targets，但是当 target-level 的 build settings 重写了 project-level 的 build settings，以 target-level 中的 build settings 中的值为准</p>\n<p>一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如，在 Xcode 创建项目时默认就有两套独立的 build configarations, 分别用于生成 debug 和 release 模式下的 product。</p>\n<p>除了创建工程时生成的默认 build settings，你也可以自定义 project-level 或者 target-level 的 build settings.</p>\n<p>关于继承关系，<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html#BuildSettingInheritance\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a> 这里也有详细的说明，强烈建议阅读。</p>\n<p>动态环境配置就是使用自定义的 build settings 来实现的.</p>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/\" target=\"_blank\" rel=\"noopener\">Xcode使用xcconfig文件配置环境</a>.<br>​<br>2.<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html\" target=\"_blank\" rel=\"noopener\">Apple官方文档</a>.</p>\n<p>3.<a href=\"https://xiuchundao.me/post/xcode-scheme-and-build-configuration\" target=\"_blank\" rel=\"noopener\">Xcode中的Scheme和Build Configuration</a>.</p>\n<p>4.<a href=\"http://www.jianshu.com/p/1f312abafeff\" target=\"_blank\" rel=\"noopener\">Xcode workSpace 多个project联编</a></p>\n<p>5.<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html#BuildSettingInheritance\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a></p>\n","categories":["基础知识"],"tags":["基础知识","Target"]},{"title":"通讯录数据的读取和性能优化","url":"http://hchong.net/2017/04/23/通讯录数据的读取和性能优化/","content":"<h1 id=\"通讯录数据的读取和性能优化\"><a href=\"#通讯录数据的读取和性能优化\" class=\"headerlink\" title=\"通讯录数据的读取和性能优化\"></a>通讯录数据的读取和性能优化</h1><p>前段时间再做一个关于通讯录相关的项目, 记录一下通讯录相关的基础和读取优化的部分. 在本篇文章中, 我主要侧重读取通讯录数据方面, 至于调用原生的界面在这里则不做阐述. 关于通讯录的API, 在iOS9之后做了较大的调整, 使用<code>Contacts Framework</code>替代<code>AddressBookFramework</code>. 下面我将就iOS9和iOS8两种API进行分析.</p>\n<h2 id=\"通讯录的授权\"><a href=\"#通讯录的授权\" class=\"headerlink\" title=\"通讯录的授权\"></a>通讯录的授权</h2><p>既然要读取通讯录, 那么通讯录授权状态的查询, 要放在在前面, 这里也区分iOS9和iOS8系统.</p>\n<h3 id=\"iOS8查询通讯录授权状态\"><a href=\"#iOS8查询通讯录授权状态\" class=\"headerlink\" title=\"iOS8查询通讯录授权状态\"></a>iOS8查询通讯录授权状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (void)checkAddressBookAuthorization:(void (^)(bool isAuthorized))block &#123;</div><div class=\"line\">    ABAddressBookRef addressBookRef =  ABAddressBookCreateWithOptions(NULL, NULL);</div><div class=\"line\">    switch (ABAddressBookGetAuthorizationStatus()) &#123;</div><div class=\"line\">        case kABAuthorizationStatusNotDetermined: &#123;</div><div class=\"line\">            NSLog(@&quot;未询问用户是否授权&quot;);</div><div class=\"line\">            ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123;</div><div class=\"line\">                if (granted) &#123;</div><div class=\"line\">                    NSLog(@&quot;授权可以读取&quot;);</div><div class=\"line\">                    block(YES);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    NSLog(@&quot;授权不能读取&quot;);</div><div class=\"line\">                    block(NO);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; break;</div><div class=\"line\">        case kABAuthorizationStatusAuthorized: &#123;</div><div class=\"line\">            NSLog(@&quot;同意授权通讯录&quot;);</div><div class=\"line\">            block(YES);</div><div class=\"line\">        &#125; break;</div><div class=\"line\">        case kABAuthorizationStatusDenied: &#123;</div><div class=\"line\">            block(NO);</div><div class=\"line\">            NSLog(@&quot;未授权，用户拒绝造成的&quot;);</div><div class=\"line\">        &#125; break;</div><div class=\"line\">        case kABAuthorizationStatusRestricted: &#123;</div><div class=\"line\">            block(NO);</div><div class=\"line\">            NSLog(@&quot;未授权，例如家长控制&quot;);</div><div class=\"line\">        &#125; break;</div><div class=\"line\">        default: &#123;</div><div class=\"line\">        &#125; break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"iOS9查询通讯录授权状态\"><a href=\"#iOS9查询通讯录授权状态\" class=\"headerlink\" title=\"iOS9查询通讯录授权状态\"></a>iOS9查询通讯录授权状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)addressBookEmpowerCheck &#123;</div><div class=\"line\">    CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts];</div><div class=\"line\">    switch (status) &#123;</div><div class=\"line\">        case CNAuthorizationStatusNotDetermined: &#123;</div><div class=\"line\">            [[[CNContactStore alloc]init] requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</div><div class=\"line\">                NSLog(@&quot;还没问&quot;);</div><div class=\"line\">                if (granted) &#123;</div><div class=\"line\">                    NSLog(@&quot;点击了同意&quot;);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    NSLog(@&quot;点击了拒绝&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;];</div><div class=\"line\">        &#125;</div><div class=\"line\">        break;</div><div class=\"line\">        case CNAuthorizationStatusRestricted: &#123;</div><div class=\"line\">            NSLog(@&quot;未授权, 例如家长控制&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        break;</div><div class=\"line\">        case CNAuthorizationStatusDenied: &#123;</div><div class=\"line\">            NSLog(@&quot;未授权, 用户拒绝所致&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        break;</div><div class=\"line\">        case CNAuthorizationStatusAuthorized: &#123;</div><div class=\"line\">            NSLog(@&quot;已经授权&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        break;</div><div class=\"line\">        default: &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意: 如果是iOS10的系统需要在<code>Info.plist</code>配置<code>NSContactsUsageDescription</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;key&gt;NSContactsUsageDescription&lt;/key&gt;</div><div class=\"line\">&lt;string&gt;请求访问通讯录&lt;/string&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"通讯录数据写入和删除\"><a href=\"#通讯录数据写入和删除\" class=\"headerlink\" title=\"通讯录数据写入和删除\"></a>通讯录数据写入和删除</h2><p>当通讯录数据少时, 数据的读取耗时较少, 为了更好地测试大量数据下的性能问题, 我们先写入大量的数据来进行测试. </p>\n<h3 id=\"iOS8写入联系人\"><a href=\"#iOS8写入联系人\" class=\"headerlink\" title=\"iOS8写入联系人\"></a>iOS8写入联系人</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone &#123;</div><div class=\"line\">    if((name.length &lt; 1)||(phone.length &lt; 1))&#123;</div><div class=\"line\">        NSLog(@&quot;输入属性不能为空&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CFErrorRef error = NULL;</div><div class=\"line\">    </div><div class=\"line\">    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, &amp;error);</div><div class=\"line\">    ABRecordRef newRecord = ABPersonCreate();</div><div class=\"line\">    ABRecordSetValue(newRecord, kABPersonFirstNameProperty, (__bridge CFTypeRef)name, &amp;error);</div><div class=\"line\">    </div><div class=\"line\">    ABMutableMultiValueRef multi = ABMultiValueCreateMutable(kABMultiStringPropertyType);</div><div class=\"line\">    ABMultiValueAddValueAndLabel(multi, (__bridge CFTypeRef)name, kABPersonPhoneMobileLabel, NULL);</div><div class=\"line\">    </div><div class=\"line\">    ABRecordSetValue(newRecord, kABPersonPhoneProperty, multi, &amp;error);</div><div class=\"line\">    CFRelease(multi);</div><div class=\"line\">    </div><div class=\"line\">    ABAddressBookAddRecord(addressBook, newRecord, &amp;error);</div><div class=\"line\">    CFRelease(newRecord);</div><div class=\"line\">    CFRelease(addressBook);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是, 在本例中, 只填写了<code>FirstName</code>和<code>phone</code>, 实际还有许多其他属性可供选择, 具体参照<code>ABAddressBookRef</code>和<code>ABRecordRef</code>需要调用<code>CFRelease</code>来释放内存.</p>\n<h3 id=\"iOS9写入联系人\"><a href=\"#iOS9写入联系人\" class=\"headerlink\" title=\"iOS9写入联系人\"></a>iOS9写入联系人</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)creatItemWithName:(NSString *)name phone:(NSString *)phone &#123;</div><div class=\"line\">    // 创建对象</div><div class=\"line\">    CNMutableContact * contact = [[CNMutableContact alloc]init];</div><div class=\"line\">    contact.givenName = name?:@&quot;defaultname&quot;;</div><div class=\"line\">    CNLabeledValue *phoneNumber = [CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberMobile value:[CNPhoneNumber phoneNumberWithStringValue:phone?:@&quot;10086&quot;]];</div><div class=\"line\">    contact.phoneNumbers = @[phoneNumber];</div><div class=\"line\">     </div><div class=\"line\">    // 把对象加到请求中</div><div class=\"line\">    CNSaveRequest * saveRequest = [[CNSaveRequest alloc]init];</div><div class=\"line\">    [saveRequest addContact:contact toContainerWithIdentifier:nil];</div><div class=\"line\">     </div><div class=\"line\">    // 执行请求</div><div class=\"line\">    CNContactStore * store = [[CNContactStore alloc]init];</div><div class=\"line\">    [store executeSaveRequest:saveRequest error:nil];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>更稳健一点的写法, 是可以把请求放在通讯录授权判断的block中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CNContactStore *store = [[CNContactStore alloc] init];</div><div class=\"line\">[store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</div><div class=\"line\">    if (!granted) &#123;</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            //失败原因</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //do something</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>使用下面这种方式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"> - (void)addContactWithName:(NSString *)name &#123;</div><div class=\"line\">    </div><div class=\"line\">    CNContactStore *store = [[CNContactStore alloc] init];</div><div class=\"line\">    [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</div><div class=\"line\">        if (!granted) &#123;</div><div class=\"line\">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">                //失败原因</div><div class=\"line\">            &#125;);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        CNMutableContact *contact = [[CNMutableContact alloc] init];</div><div class=\"line\">        contact.familyName = @&quot;Doe&quot;;</div><div class=\"line\">        contact.givenName = @&quot;John&quot;;</div><div class=\"line\">        </div><div class=\"line\">        CNLabeledValue *homePhone = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:[CNPhoneNumber phoneNumberWithStringValue:@&quot;312-555-1212&quot;]];</div><div class=\"line\">        contact.phoneNumbers = @[homePhone];</div><div class=\"line\">        </div><div class=\"line\">        CNSaveRequest *request = [[CNSaveRequest alloc] init];</div><div class=\"line\">        [request addContact:contact toContainerWithIdentifier:nil];</div><div class=\"line\">        </div><div class=\"line\">        // save it</div><div class=\"line\">        NSError *saveError;</div><div class=\"line\">        if (![store executeSaveRequest:request error:&amp;saveError]) &#123;</div><div class=\"line\">            NSLog(@&quot;error = %@&quot;, saveError);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"iOS8删除联系人\"><a href=\"#iOS8删除联系人\" class=\"headerlink\" title=\"iOS8删除联系人\"></a>iOS8删除联系人</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)removeItemWithName:(NSString *)name phone:(NSString *)phone &#123;</div><div class=\"line\">    ABAddressBookRef addressbook = ABAddressBookCreate();</div><div class=\"line\">    CFStringRef nameRef = (__bridge CFStringRef) name;</div><div class=\"line\">    CFArrayRef  allSearchRecords = ABAddressBookCopyPeopleWithName(addressbook, nameRef);</div><div class=\"line\">    if (allSearchRecords != NULL)</div><div class=\"line\">    &#123;</div><div class=\"line\">        CFIndex count = CFArrayGetCount(allSearchRecords);</div><div class=\"line\">        for (int i = 0; i &lt; count; ++i)</div><div class=\"line\">        &#123;</div><div class=\"line\">            ABRecordRef contact = CFArrayGetValueAtIndex(allSearchRecords, i);</div><div class=\"line\">            ABAddressBookRemoveRecord(addressbook, contact, nil);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ABAddressBookSave(addressbook, nil);</div><div class=\"line\">    CFRelease(addressbook);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"iOS9删除联系人\"><a href=\"#iOS9删除联系人\" class=\"headerlink\" title=\"iOS9删除联系人\"></a>iOS9删除联系人</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (void)removeContactWithName:(NSString *)name &#123;</div><div class=\"line\">    CNContactStore *store = [[CNContactStore alloc] init];</div><div class=\"line\">    NSPredicate *predicate = [CNContact predicateForContactsMatchingName:name];</div><div class=\"line\">    NSArray *contacts = [store unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey, CNContactFamilyNameKey] error:nil];</div><div class=\"line\">    </div><div class=\"line\">    for (CNMutableContact *contact in contacts) &#123;</div><div class=\"line\">        CNSaveRequest *request = [[CNSaveRequest alloc] init];</div><div class=\"line\">        [request deleteContact:contact];</div><div class=\"line\">        // save it</div><div class=\"line\">        NSError *saveError;</div><div class=\"line\">        if (![store executeSaveRequest:request error:&amp;saveError]) &#123;</div><div class=\"line\">            NSLog(@&quot;error = %@&quot;, saveError);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"通讯录数据读取\"><a href=\"#通讯录数据读取\" class=\"headerlink\" title=\"通讯录数据读取\"></a>通讯录数据读取</h2><p>通过上面的一通操作, 我们已经可以创建和删除通讯录了, 那么我们就通过批量写入通讯录数据, 来进行通讯录数据的读取, 并且按照姓名和首字母分组排序. 相应的, 此处我们也区分<code>iOS8</code>和<code>iOS9</code>下面两个不同的框架.</p>\n<h3 id=\"iOS8读取联系人\"><a href=\"#iOS8读取联系人\" class=\"headerlink\" title=\"iOS8读取联系人\"></a>iOS8读取联系人</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (NSArray *)getAllContact &#123;</div><div class=\"line\">    NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];</div><div class=\"line\">    </div><div class=\"line\">    CFErrorRef *error = NULL;</div><div class=\"line\">    ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, error);</div><div class=\"line\">    </div><div class=\"line\">    CFIndex numberOfPeople = ABAddressBookGetPersonCount(addressBook);</div><div class=\"line\">    CFArrayRef people = ABAddressBookCopyArrayOfAllPeople(addressBook);</div><div class=\"line\">    if (numberOfPeople == 0) &#123;</div><div class=\"line\">        CFRelease(people);</div><div class=\"line\">        CFRelease(addressBook);</div><div class=\"line\">        return @[];</div><div class=\"line\">    &#125;</div><div class=\"line\">    for ( int i = 0; i &lt; numberOfPeople; i++)&#123;</div><div class=\"line\">        AddressBookContact *contact = [[AddressBookContact alloc] init];</div><div class=\"line\">        </div><div class=\"line\">        ABRecordRef person = CFArrayGetValueAtIndex(people, i);</div><div class=\"line\">        </div><div class=\"line\">        //姓名</div><div class=\"line\">        NSString *firstName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonFirstNameProperty));</div><div class=\"line\">        NSString *lastName = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonLastNameProperty));</div><div class=\"line\">        NSString *name = [NSString stringWithFormat:@&quot;%@%@&quot;, lastName, firstName;</div><div class=\"line\">        contact.name = name;</div><div class=\"line\">        </div><div class=\"line\">        //第一次添加该条记录的时间戳</div><div class=\"line\">        NSDate *createDate = (NSDate *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonCreationDateProperty));</div><div class=\"line\">        NSTimeInterval timeIn = [createDate timeIntervalSince1970];</div><div class=\"line\">        NSInteger createTime = round(timeIn);</div><div class=\"line\">        contact.createTime = [NSString stringWithFormat:@&quot;%010ld&quot;, (long)createTime];</div><div class=\"line\">        </div><div class=\"line\">        //读取电话多值</div><div class=\"line\">        ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty);</div><div class=\"line\">        NSArray *arr = (NSArray *)CFBridgingRelease(ABMultiValueCopyArrayOfAllValues(phone));</div><div class=\"line\">        contact.phone = [AddressBookData filterPhoneFormate:[arr lastObject]];</div><div class=\"line\">        </div><div class=\"line\">        if (contact.phone.length &gt; 0) &#123;</div><div class=\"line\">            [array addObject:contact];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CFRelease(people);</div><div class=\"line\">    CFRelease(addressBook);</div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//剔除手机号中的特殊字符</div><div class=\"line\">+ (NSString *)filterPhoneFormate:(NSString *)phoneNumber &#123;</div><div class=\"line\">    NSCharacterSet *notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];</div><div class=\"line\">    NSString *resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@&quot;&quot;];</div><div class=\"line\">    return resultString;</div><div class=\"line\">&#125;</div><div class=\"line\">```    </div><div class=\"line\">### iOS9读取联系人</div></pre></td></tr></table></figure>\n<pre><code>// 创建通信录对象\nCNContactStore *contactStore = [[CNContactStore alloc] init];\n\n// 创建获取通信录的请求对象\n// 拿到所有打算获取的属性对应的key\nNSArray *keys = @[CNContactGivenNameKey, CNContactFamilyNameKey, CNContactPhoneNumbersKey];\n\n// 创建CNContactFetchRequest对象\nCNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:keys];\n\n// 遍历所有的联系人\n[contactStore enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) {\n    // 获取联系人的姓名\n    NSString *lastname = contact.familyName;\n    NSString *firstname = contact.givenName;\n    NSLog(@&quot;%@ %@&quot;, lastname, firstname);\n\n    // 获取联系人的电话号码\n    NSArray *phoneNums = contact.phoneNumbers;\n    for (CNLabeledValue *labeledValue in phoneNums) {\n        // 获取电话号码的KEY\n        NSString *phoneLabel = labeledValue.label;\n\n        // 获取电话号码\n        CNPhoneNumber *phoneNumer = labeledValue.value;\n        NSString *phoneValue = phoneNumer.stringValue;\n\n        NSLog(@&quot;%@ %@&quot;, phoneLabel, phoneValue);\n        AddressBookContact *contact = [[AddressBookContact alloc] init];\n        contact.name = [NSString stringWithFormat:@&quot;%@%@&quot;,lastname,firstname];\n        person.phone = phoneValue;\n        [_addressBookArray addObject:contact];\n    }\n}];\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">我们通过上面的方法拿到的数据是一个元素是我们自定义数据模型`AddressBookContact`的数组, 所有的数据都在这一个数组里面, 没有分组, 相同首字母的联系人按照创建时间来排序.显然这样的数据是不能满足我们业务需求的. 常见的是按照首字母来分组, 下面我们就以iOS8为例来对数据进行分组排序和展示, 类似于系统通讯录列表.</div><div class=\"line\">### 通讯录分组</div></pre></td></tr></table></figure>\n<p>//返回包含分组信息和分组后通讯录数据的字典</p>\n<ul>\n<li><p>(NSDictionary <em>)dealDataWithArray:(NSArray </em>)array {<br>  if (array.count == 0) {</p>\n<pre><code>return nil;\n</code></pre><p>  }<br>  NSMutableArray <em>titleArray = [NSMutableArray arrayWithCapacity:0];<br>  NSMutableArray </em>data = [NSMutableArray arrayWithCapacity:0];<br>  NSMutableArray * tmpArray = [[NSMutableArray alloc]init];<br>  for (NSInteger i =0; i &lt;27; i++) {</p>\n<pre><code>//给临时数组创建27个数组作为元素，用来存放A-Z和#开头的联系人\nNSMutableArray * array = [[NSMutableArray alloc]init];\n[tmpArray addObject:array];\n</code></pre><p>  }</p>\n<p>  for (AddressBookContact * model in array) {</p>\n<pre><code>//AddressMode是联系人的数据模型\n//转化为首拼音并取首字母\nNSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\nif (nickName.length == 0) {\n    //如果不是，就放到最后一个代表#的数组\n    NSMutableArray * array =[tmpArray lastObject];\n    [array addObject:model];\n} else {\n    int firstWord = [nickName characterAtIndex:0];\n    //把字典放到对应的数组中去\n\n    if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n        //如果首字母是A-Z，直接放到对应数组\n        NSMutableArray * array = tmpArray[firstWord - 65];\n        [array addObject:model];\n\n    } else {\n        //如果不是，就放到最后一个代表#的数组\n        NSMutableArray * array =[tmpArray lastObject];\n        [array addObject:model];\n    }\n}\n</code></pre><p>  }</p>\n<p>  //此时数据已按首字母排序并分组<br>  //遍历数组，删掉空数组<br>  for (NSMutableArray * mutArr in tmpArray) {</p>\n<pre><code>//如果数组不为空就添加到数据源当中\nif (mutArr.count != 0) {\n    [data addObject:mutArr];\n    AddressBookContact * model = mutArr[0];\n    NSString * nickName = [AddressBookDataManager returnFirstWordWithString:model.name];\n\n    if (nickName.length != 0) {\n        int firstWord = [nickName characterAtIndex:0];\n        //取出其中的首字母放入到标题数组，暂时不考虑非A-Z的情况\n        if (firstWord &gt;= 65 &amp;&amp; firstWord &lt;= 90) {\n            [titleArray addObject:nickName];\n        }\n    }\n}\n</code></pre><p>  }</p>\n<p>  //判断是否需要加#<br>  if (titleArray.count != data.count) {</p>\n<pre><code>[titleArray addObject:@&quot;#&quot;];\n</code></pre><p>  }</p>\n<p>  NSDictionary *dic = @{@”source”: [AddressBookDataManager sortedArray:data],</p>\n<pre><code>@&quot;title&quot;: titleArray};\n</code></pre><p>  return dic;<br>}</p>\n</li>\n<li><p>(NSArray <em>)sortedArray:(NSArray </em>)data {<br>  NSMutableArray *sortedArray = [NSMutableArray array];<br>  for (NSInteger index = 0; index &lt; data.count; index++) {</p>\n<pre><code>NSMutableArray *personArrayForSection = data[index];\nNSArray *temp = [personArrayForSection sortedArrayUsingComparator:^NSComparisonResult(AddressBookContact * contact1, AddressBookContact * contact2) {\n    return [contact1.name compare:contact2.name];\n}];\nsortedArray[index] = temp;\n</code></pre><p>  }<br>  return sortedArray;<br>}</p>\n</li>\n</ul>\n<p>#pragma mark - Tool</p>\n<ul>\n<li><p>(BOOL)objectIsNull:(id)obj{<br>  return ([obj isKindOfClass:[NSNull class]] || obj == nil) ? YES : NO;<br>}</p>\n</li>\n<li><p>(NSString*)strNoNull:(id)str{<br>  if ([AddressBookDataManager objectIsNull:str]) {</p>\n<pre><code>str = @&quot;&quot;;\n</code></pre><p>  }<br>  return str;<br>}</p>\n</li>\n</ul>\n<p>//汉字转拼音并取得关键字</p>\n<ul>\n<li><p>(NSString <em>)returnFirstWordWithString:(NSString </em>)str {<br>  NSMutableString * mutStr = [NSMutableString stringWithString:str];</p>\n<p>  //将mutStr中的汉字转化为带音标的拼音（如果是汉字就转换，如果不是则保持原样）<br>  CFStringTransform((<strong>bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformMandarinLatin, NO);<br>  //将带有音标的拼音转换成不带音标的拼音（这一步是从上一步的基础上来的，所以这两句话一句也不能少）<br>  CFStringTransform((</strong>bridge CFMutableStringRef)mutStr, NULL, kCFStringTransformStripCombiningMarks, NO);<br>  if (mutStr.length &gt; 0) {</p>\n<pre><code>//全部转换为大写    取出首字母并返回\nNSString * res = [[mutStr uppercaseString] substringToIndex:1];\nreturn res;\n</code></pre><p>  } else {</p>\n<pre><code>return @&quot;&quot;;\n</code></pre><p>  }<br>}</p>\n</li>\n</ul>\n<p>//剔除手机号中的特殊字符</p>\n<ul>\n<li>(NSString <em>)filterPhoneFormate:(NSString </em>)phoneNumber {<br>  NSCharacterSet <em>notAllowedChars = [[NSCharacterSet characterSetWithCharactersInString:@”0123456789”] invertedSet];<br>  NSString </em>resultString = [[phoneNumber componentsSeparatedByCharactersInSet:notAllowedChars] componentsJoinedByString:@””];<br>  return resultString;<br>}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">![数据截图](http://ohjcp7fjy.bkt.clouddn.com/IMG_0277.PNG)</div><div class=\"line\">至此, 我们可以得到符合业务需求的通讯录页面, 已经按照姓名首字母分组, 并且实现了快速索引. 我的通讯录测试数据有2700+条数据, 每次通讯录打开都要耗时特别久, 为了更好的用户体验, 这时就会想到要优化一下代码了.</div><div class=\"line\"></div><div class=\"line\">### 性能优化</div><div class=\"line\">说道性能优化, 首先就要进行性能分析, 知道我们需要优化的地方在哪里. Xcode提供了一个强大的分析工具Instruments, 具体一些常见的分析可以参考[这里](http://hchong.net/2017/04/13/Xcode%E7%A5%9E%E5%99%A8-Instruments%E5%A4%A7%E6%B3%95/).</div><div class=\"line\">我们主要使用Instruments的Time ProFiler来分析一下, 究竟耗时的代码在哪里, 并且做一下优化.</div><div class=\"line\">![耗时操作](http://ww1.sinaimg.cn/large/006tNc79gy1ffevnuzt0zj30pg0e2wfj.jpg)</div><div class=\"line\">![耗时操作的具体代码](http://ww2.sinaimg.cn/large/006tNc79gy1ffevnwtfovj317m0q440f.jpg)</div><div class=\"line\">通过分析可以发现, 目前的瓶颈主要出现在汉字转拼音取首字母的方法上, 可以发现我们使用的是`CFStringTransform`类, 我们先对这个进行一些优化</div></pre></td></tr></table></figure>\n<p>//汉字首字母</p>\n<ul>\n<li>(NSString <em>)returnFirstWordWithString:(NSString </em>)str {<br>  NSMutableString <em>mutableString = [NSMutableString stringWithString:str];<br>  CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);<br>  mutableString = (NSMutableString </em>)[mutableString stringByFoldingWithOptions:NSDiacriticInsensitiveSearch locale:[NSLocale currentLocale]];<br>  NSString *string = [mutableString stringByReplacingOccurrencesOfString:@”‘“ withString:@””];<br>  return [[string uppercaseString] substringToIndex:1];<br>}<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">再使用Instruments分析发现, 并没有什么太大的效果. 分析一下发现, 发现我们取首字母主要有两个用途.一个是把全部通讯录按照首字母的方式进行分组, 另一个用途就是为了在列表页生成索引数组. </div><div class=\"line\"></div><div class=\"line\">#### 方案一</div><div class=\"line\">一番查找发现, 系统针对这种情况已经有API可供我们调用了(贴心的Apple).下面就要介绍本次优化的关键类`UILocalizedIndexedCollation`.</div><div class=\"line\"></div><div class=\"line\">&gt; 返回传入object对象指定selector在[UILocalizedIndexedCollation currentCollation]中的匹配的索引</div><div class=\"line\">// Returns the index of the section that will contain the object.</div><div class=\"line\">// selector must not take any arguments and return an NSString.</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>(NSInteger)sectionForObject:(id)object collationStringSelector:(SEL)selector;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt; 返回传入object对象指定selector在[UILocalizedIndexedCollation currentCollation]中的匹配的索引</div><div class=\"line\">// Returns the index of the section that will contain the object.</div><div class=\"line\">// selector must not take any arguments and return an NSString.</div></pre></td></tr></table></figure>\n</li>\n<li><p>(NSInteger)sectionForObject:(id)object collationStringSelector:(SEL)selector;</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>(NSDictionary <em>)dealDataWithArray:(NSArray </em>)array {</p>\n<p>  // 1.初始化一个索引，根据不同国家语言，会初始化出不同的索引，中文的是“A~Z,#”<br>  UILocalizedIndexedCollation <em>collation = [UILocalizedIndexedCollation currentCollation];<br>  // 2.获取索引的数量，并初始化对应数量的空数组，用于存放筛选数据<br>  NSInteger sectionTitlesCount = [[collation sectionTitles] count];<br>  NSMutableArray </em>sectionArrays = [NSMutableArray arrayWithCapacity:sectionTitlesCount];<br>  for (int i = 0; i &lt; sectionTitlesCount; i++) {</p>\n<pre><code>NSMutableArray *sectionArray = [NSMutableArray arrayWithCapacity:1];\n[sectionArrays addObject:sectionArray];\n</code></pre><p>  }<br>  // 3.排序的方法<br>  SEL sorter = ABPersonGetSortOrdering() == kABPersonSortByFirstName ? NSSelectorFromString(@”name”) : NSSelectorFromString(@”name”);<br>  // 4.分组<br>  for (AddressBookContact *contact in array) {</p>\n<pre><code>//获取name属性的值所在的位置，比如&quot;小白鼠&quot;，首字母是X，在A~Z中排第23（第一位是0），sectionNumber就为23\nNSInteger sectionNumber = [collation sectionForObject:contact collationStringSelector:sorter];\n//把name为“小白鼠”的contact加入newSectionsArray中的第23个数组中去\nNSMutableArray *sectionNames = sectionArrays[sectionNumber];\n[sectionNames addObject:contact];\n</code></pre><p>  }<br>  //5.排序<br>  for (NSInteger i = 0; i &lt; sectionTitlesCount; i++) {</p>\n<pre><code>NSMutableArray *personArrayForSection = sectionArrays[i];\nNSArray *sortedPersonArrayForSection = [collation sortedArrayFromArray:personArrayForSection collationStringSelector:@selector(name)];\nsectionArrays[i] = sortedPersonArrayForSection;\n</code></pre><p>  }</p>\n<p>  NSArray <em>titleArray = [[[UILocalizedIndexedCollation currentCollation] sectionTitles] copy];<br>  NSDictionary </em>dic = @{@”source”: sectionArrays,</p>\n<pre><code>@&quot;title&quot;: titleArray};\n</code></pre><p>  return dic;<br>  }</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">分析一下上面的代码, 我们使用`UILocalizedIndexedCollation`提供的方法, 按照A-Z来快读数据进行分组, 并且排序. 索引数组也直接使用`UILocalizedIndexedCollation`自带的方法.这样就避免了大量的循环遍历和取姓名拼音首字母造成的开销.</div><div class=\"line\"></div><div class=\"line\">相应的, 列表展示页面的title和索引也要做调整</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{<br>  if ([self.dataArray[section] count] == 0 || self.dataArray.count == 0) {<pre><code>return 0.01;\n</code></pre>  }<br>  return 22;<br>}</li>\n</ul>\n<p>// 按照索引个数配置tableview区数</p>\n<ul>\n<li>(NSString <em>)tableView:(UITableView </em>)tableView titleForHeaderInSection:(NSInteger)section {<br>  if ([self.dataArray[section] count] == 0 || self.dataArray.count == 0) {<pre><code>return @&quot;&quot;;\n</code></pre>  }<br>  return [[UILocalizedIndexedCollation currentCollation] sectionTitles][section];<br>}</li>\n</ul>\n<p>// 配置索引内容，就是通讯录中右侧的那一列“A~Z、#”</p>\n<ul>\n<li>(NSArray <em>)sectionIndexTitlesForTableView:(UITableView </em>)tableView {<br>  return [[UILocalizedIndexedCollation currentCollation] sectionIndexTitles];<br>}</li>\n</ul>\n<p>// 索引点击响应</p>\n<ul>\n<li>(NSInteger)tableView:(UITableView <em>)tableView sectionForSectionIndexTitle:(NSString </em>)title atIndex:(NSInteger)index {<br>  return [[UILocalizedIndexedCollation currentCollation] sectionForSectionIndexTitleAtIndex:index];<br>}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">至此优化结束, 再通过Time Profiler来分析下发现时间已经从5.8s到2.6s, 优化效果还是很明显的. 2.6s中数组排序大概耗时1.7s, 我们使用的已经是系统推荐的排序方法, 除非采用复杂度更低的排序算法, 这里已经没办法再优化了.</div><div class=\"line\"></div><div class=\"line\">这里有三种不同实现的排序方法, 测试了下, 优化效果都不明显</div></pre></td></tr></table></figure>\n<ul>\n<li>(NSArray <em>)sortedArray:(NSArray </em>)data {<br>  //        NSMutableArray <em>sortedArray = [NSMutableArray array];<br>  //        //对每个section中的数组按照name属性排序<br>  //        for (NSInteger index = 0; index &lt; data.count; index++) {<br>  //            NSMutableArray </em>personArrayForSection = data[index];<br>  //            NSSortDescriptor <em>nameDesc    = [NSSortDescriptor sortDescriptorWithKey:@”name”<br>  //                                                                          ascending:YES];<br>  //            NSArray </em>descriptorArray = @[nameDesc];//此处可以按照多个排序规则, 顺序比较, 比较的顺序就是数组里面元素的顺序<br>  //<br>  //            NSArray *temp = [personArrayForSection sortedArrayUsingDescriptors: descriptorArray];<br>  //            sortedArray[index] = temp;<br>  //        }</li>\n</ul>\n<pre><code>NSMutableArray *sortedArray = [NSMutableArray array];\nfor (NSInteger index = 0; index &lt; data.count; index++) {\n    NSMutableArray *personArrayForSection = data[index];\n    NSArray *temp = [personArrayForSection sortedArrayUsingComparator:^NSComparisonResult(AddressBookContact * contact1, AddressBookContact * contact2) {\n        return [contact1.name compare:contact2.name];\n    }];\n    sortedArray[index] = temp;\n}\n\n\n\n//    UILocalizedIndexedCollation *collation = [UILocalizedIndexedCollation currentCollation];\n//    NSMutableArray *sortedArray = [NSMutableArray array];\n//    //对每个section中的数组按照name属性排序\n//    for (NSInteger index = 0; index &lt; data.count; index++) {\n//        NSMutableArray *personArrayForSection = data[index];\n//        NSArray *sortedPersonArrayForSection = [collation sortedArrayFromArray:personArrayForSection collationStringSelector:@selector(name)];\n//        sortedArray[index] = sortedPersonArrayForSection;\n//    }\nreturn sortedArray;\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 方案二</div><div class=\"line\">至于第二种优化方案, 我们需要借助本地化存储SQL来实现. 当然如果没有本地化存储的需求, 则方案一就够用了.</div><div class=\"line\"></div><div class=\"line\">因为主要耗时的操作在分组和排序上, 我么你可以利用SQL的快速查找和排序来实现.在3000条左右数据时和方案一的效果差不多, 此处就不再贴代码了, 只提供一下思路.</div><div class=\"line\"></div><div class=\"line\">## 监听通讯录数据变化</div><div class=\"line\">此处仍然区分iOS8和iOS9的API, 但是需要注意监听规则:</div><div class=\"line\">1.当App活跃（前台+后台包活期间）的时候, 当通讯录修改的时候, 会收到通知.</div><div class=\"line\">2.当App不活跃的时候(挂起的时候), App收不到通知; 而是, 当App到前台的时候收到延迟的通知.</div><div class=\"line\">3.当App被杀掉进程后, App收不到通知; 当再次进入App时依然没有通知.</div><div class=\"line\">### ios8监听通讯录变化</div></pre></td></tr></table></figure></p>\n<p>@property (nonatomic, assign) ABAddressBookRef addresBook;</p>\n<ul>\n<li>(instancetype)init {<br>  self = [super init];<br>  if (self) {<pre><code>_addresBook = ABAddressBookCreateWithOptions(NULL, NULL);\nABAddressBookRegisterExternalChangeCallback(_addresBook, addressBookChanged, nil);\n</code></pre>  }<br>  return self;<br>}</li>\n</ul>\n<p>//监听通讯录变化<br>void addressBookChanged(ABAddressBookRef addressBook, CFDictionaryRef info, void <em>context) {<br>    NSLog(@”通讯录变化啦….”);<br>    //    VC1 </em>myVC = (__bridge VC1 *)context;<br>    //    [myVC getPersonOutOfAddressBook];<br>}</p>\n<ul>\n<li>(void)dealloc {<br>  NSLog(@”%@——————-dealloc”, self);<br>  ABAddressBookUnregisterExternalChangeCallback(_addresBook, addressBookChanged, nil);<br>}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">### ios9监听通讯录变化</div></pre></td></tr></table></figure>\n<ul>\n<li><p>(instancetype)init {<br>  self = [super init];<br>  if (self) {</p>\n<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(addressBookDidChange:) name:CNContactStoreDidChangeNotification object:nil];\n</code></pre><p>  }<br>  return self;<br>}</p>\n</li>\n</ul>\n<ul>\n<li><p>(void)dealloc {<br>  NSLog(@”%@——————-dealloc”, self);<br>  [[NSNotificationCenter defaultCenter] removeObserver:self name:CNContactStoreDidChangeNotification object:nil];<br>}</p>\n</li>\n<li><p>(void)addressBookDidChange:(NSNotification*)notification{<br>  NSLog(@”通讯录变化啦….”);<br>}<br>```</p>\n</li>\n</ul>\n<p>参考文档:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/47189c71543b\" target=\"_blank\" rel=\"noopener\">iOS9下全新的通讯录框架</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/94e8444f1ad6\" target=\"_blank\" rel=\"noopener\">iOS学习笔记29-系统服务(二)通讯录</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/6acad14cf3c9\" target=\"_blank\" rel=\"noopener\">iOS通讯录开发</a></p>\n<p>4.<a href=\"https://developer.apple.com/reference/contacts/cncontact\" target=\"_blank\" rel=\"noopener\">CNContact官方文档</a></p>\n<p>5.<a href=\"https://developer.apple.com/reference/addressbook\" target=\"_blank\" rel=\"noopener\">AddressBook官方文档</a></p>\n<p>6.<a href=\"http://www.bijishequ.com/detail/320846?p=\" target=\"_blank\" rel=\"noopener\">UILocalizedIndexedCollation——本地化索引排序</a></p>\n<p>7.<a href=\"http://www.olinone.com/?p=131\" target=\"_blank\" rel=\"noopener\">iOS开发中如何快速的实现汉字转拼音</a></p>\n<p>8.<a href=\"http://www.jianshu.com/p/d0a752bcda3f\" target=\"_blank\" rel=\"noopener\">iOS通讯录数据变化监听</a></p>\n","categories":["基础知识","性能优化"],"tags":["通讯录"]},{"title":"Xcode神器-Instruments大法","url":"http://hchong.net/2017/04/13/Xcode神器-Instruments大法/","content":"<h1 id=\"Xcode调试神器-Instruments大法\"><a href=\"#Xcode调试神器-Instruments大法\" class=\"headerlink\" title=\"Xcode调试神器-Instruments大法\"></a>Xcode调试神器-Instruments大法</h1><p>用户体验, 是每个App开发很重要的点, 是每个程序猿都应该时刻被想到的点. 好的用户体验就必然要有好的性能. Xcode给我们提供了强大的性能分析工具Instruments.</p>\n<p>打开Xcode, 选择Xcode -&gt; Open Developer Tool打开如下界面<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1ffevnub9j1j316s0q2wfd.jpg\" alt=\"Instruments首界面\"><br>这里我们主要介绍三个常用的工具Core Animation(检测帧率), Leaks(内存泄漏), Time Profiler(检查耗时操作)</p>\n<h2 id=\"Core-Animation\"><a href=\"#Core-Animation\" class=\"headerlink\" title=\"Core Animation\"></a>Core Animation</h2><p>Core Animation主要用来评估屏幕渲染时的帧率, 帧率一般来说越接近60就越流畅, 当低于40时, 就会感觉到明显的卡顿.<br><img src=\"http://ww1.sinaimg.cn/large/006tNbRwgy1ffffmifexvj310w0nxwfn.jpg\" alt=\"帧率\"><br>在屏幕的下方有一个Debug Options按钮, 点击展开菜单中可以选择一些更加具体的UI性能的检测,<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffffp2z37cj30xk0i474v.jpg\" alt=\"选项\"><br>我们可以使用这些选项，来监测更加具体的图形性能, 具体参考如下:</p>\n<ul>\n<li><code>Color Blended Layers</code>，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，越红表示性能越差，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。</li>\n<li><code>Color Hits Green and Misses Red</code>，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。红色越多，性能越差。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。</li>\n<li><code>Color Copied Images</code>，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。蓝色越多，性能越差。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。</li>\n<li><code>Color Non-Standard Surface Formats</code>, 不标准的表面颜色格式.</li>\n<li><code>Color Immediately</code>，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</li>\n<li><code>Color Misaligned Images</code>，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。</li>\n<li><code>Color Offscreen-Rendered Yellow</code>，这个选项会把那些离屏渲染的图层显示为黄色。黄色越多，性能越差。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。</li>\n<li><code>Color Compositing Fast Path Blue</code>，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。</li>\n<li><code>Flash Updated Regions</code>，这个选项会把重绘的内容显示为黄色。不该出现的黄色越多，性能越差。通常我们希望只是更新的部分被标记完黄色。</li>\n</ul>\n<p>使用时要注意Xcode和手机系统的版本号匹配, 否则会出现设备off line 无法被选中的情况.</p>\n<h2 id=\"Leaks\"><a href=\"#Leaks\" class=\"headerlink\" title=\"Leaks\"></a>Leaks</h2><p>关于内存方面的监控, 有<code>Leaks</code>用来检测内存泄漏, <code>Zombies</code>用来检测僵尸对象. 关于内存泄漏常见的几种情况, <a href=\"http://www.jianshu.com/p/d465831aebbf\" target=\"_blank\" rel=\"noopener\">这里</a>讲的特别清晰和全面.</p>\n<h2 id=\"Time-Profiler\"><a href=\"#Time-Profiler\" class=\"headerlink\" title=\"Time Profiler\"></a>Time Profiler</h2><p>这个主要是用来统计各个方法消耗的时间.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1fffhjy18vij31kw0zi44c.jpg\" alt=\"Time Profiler\"><br>如图所示, 展示各个方法占比和消耗的时间, 以ms为单位. 右侧菜单栏一般会显示最耗时的一些操作, 如果一般前面的小图片是黑色的话, 那就说明这部分代码, 占用了大量的系统时间, 是需要迫切优化的.</p>\n<p>在下方的call Tree中有一些选项菜单, 选择不同的菜单, 可以查看不同的状态, 具体如下:</p>\n<ul>\n<li><code>Separate byt Thread</code>（建议选择）：通过线程分类来查看那些纯种占用CPU最多。</li>\n<li><code>Invert Call Tree</code>（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。</li>\n<li><code>Hide Missing Symbols</code>（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。</li>\n<li><code>Hide System Libraries</code>（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。</li>\n<li><code>Flatten Recursion</code>（一般不选）：选上它会将调用栈里递归函数作为一个入口。</li>\n<li><code>Top Functions</code>（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><p>在调试过程中也遇到一些问题, 记录下来.</p>\n<h3 id=\"设备灰色不可选\"><a href=\"#设备灰色不可选\" class=\"headerlink\" title=\"设备灰色不可选\"></a>设备灰色不可选</h3><p>解决方案：重启<br>我最终的解决步骤：<br>1.拔掉iPhone的USB线，重启iPhone<br>2.关闭Xcode和Instruments<br>3.重新连接iPhone到Mac上<br>4.重启Xcode并启动Profile<br>5.成功</p>\n<p>参考这个<a href=\"http://stackoverflow.com/questions/32878283/unable-to-profile-app-on-device-with-ios-9-0-1-using-xcode-7-7-0-1-or-7-1-beta\" target=\"_blank\" rel=\"noopener\">帖子</a>.</p>\n<h3 id=\"Time-Profiler无法定位到代码\"><a href=\"#Time-Profiler无法定位到代码\" class=\"headerlink\" title=\"Time Profiler无法定位到代码\"></a>Time Profiler无法定位到代码</h3><p>Time Profliter 都是地址符号，往深里也一直是地址符号，根本没法判断是哪些代码的执行时间, 无法定位代码</p>\n<p>解决方法:</p>\n<ol>\n<li>Project-&gt;Build Settings-&gt;Debug Information Format 选择DWARF with dSYM File</li>\n<li>Profile要在debug模式下运行, BuildConfiguration要选择debug.</li>\n</ol>\n<hr>\n<p>参考资料:</p>\n<p>1.<a href=\"https://blog.leancloud.cn/2835/\" target=\"_blank\" rel=\"noopener\">iOS 性能优化：Instruments 工具的救命三招</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/439e158b44de\" target=\"_blank\" rel=\"noopener\">Instruments性能优化-Core Animation</a></p>\n<p>3.<a href=\"http://www.samirchen.com/use-instruments/\" target=\"_blank\" rel=\"noopener\">使用 Instruments 做 iOS 程序性能调试</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/d465831aebbf\" target=\"_blank\" rel=\"noopener\">关于内存泄漏，还有哪些是你不知道的？</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/c0aa12d91f05\" target=\"_blank\" rel=\"noopener\">使用Instruments定位iOS应用的Memory Leaks</a></p>\n<p>6.<a href=\"http://www.jianshu.com/p/21d29be26479\" target=\"_blank\" rel=\"noopener\">instrument Time Profiler总结</a></p>\n<p>7.<a href=\"http://stackoverflow.com/questions/32878283/unable-to-profile-app-on-device-with-ios-9-0-1-using-xcode-7-7-0-1-or-7-1-beta\" target=\"_blank\" rel=\"noopener\">Unable to profile app on device with iOS 9.0.1 using Xcode 7, 7.0.1 or 7.1 beta</a></p>\n","categories":["基础知识"],"tags":["基础知识","调试"]},{"title":"iOS逆向-下载历史版本","url":"http://hchong.net/2017/04/06/iOS逆向-下载历史版本/","content":"<h1 id=\"iOS逆向-下载历史版本\"><a href=\"#iOS逆向-下载历史版本\" class=\"headerlink\" title=\"iOS逆向-下载历史版本\"></a>iOS逆向-下载历史版本</h1><p>目前App Store默认只能下载最新版, 而我们的目的是要能够下载到App Store中的历史版, 那就要借助一些其他工具来实现.<br>原理如下:</p>\n<blockquote>\n<p>通过Charles来获取下载链接, 通过分析来得到每个版本在连接中所对应的字段, 再通过Charles来截取和替换下载链接中的参数, 来达到下载特定版本App的目的.</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装Charles.</li>\n<li>为了Charles能够抓取HTTPS类型的链接, 需要安装Charles的证书, 参考这里<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.</li>\n</ol>\n</blockquote>\n<h2 id=\"开始抓包\"><a href=\"#开始抓包\" class=\"headerlink\" title=\"开始抓包\"></a>开始抓包</h2><p>安装了Charles之后, 我们就可以获取App的下载链接了, 并且从中分析出我们需要的参数.</p>\n<h3 id=\"获取APP的下载链接和版本号对应的参数\"><a href=\"#获取APP的下载链接和版本号对应的参数\" class=\"headerlink\" title=\"获取APP的下载链接和版本号对应的参数\"></a>获取APP的下载链接和版本号对应的参数</h3><p>下面我们以iOS上一款比较好用的看书软件<em>追书神器</em>为例来说明.</p>\n<ol>\n<li>首先打开ITunes来下载软件, 点击下载, 通过Charles来确定下载软件的链接.<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4m4udoqj30zo0iwdhx.jpg\" alt=\"点击下载\"></li>\n<li>在Charles中观察发现, ITunes使用的是HTTPS链接, 无法直接查看request内容.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4n5nyodj30f707e74h.jpg\" alt=\"无法直接查看HTTPS\"></li>\n<li>我们通过添加SSL Proxying来查看request内容, 并且通过给链接加断点来详细分析请求的参数.</li>\n</ol>\n<p><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fel4nt57ykj30b60jr74v.jpg\" alt=\"添加SSL Proxy\"><br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4ogb7edj30bg0lkab0.jpg\" alt=\"添加断点\"></p>\n<h3 id=\"推断控制版本的关键字段\"><a href=\"#推断控制版本的关键字段\" class=\"headerlink\" title=\"推断控制版本的关键字段\"></a>推断控制版本的关键字段</h3><p>观察response, 推断<code>softwareVersionExternalIdentifiers</code>展示的是全部的APP对应的版本, <code>softwareVersionExternalIdentifier</code>是用来标记当前版本.<em>追书神器</em>目前的版本标记是<code>820420814</code><br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4pltv74j310w0qjq5r.jpg\" alt=\"字段分析\"><br>通过在request中搜索<code>820420814</code>发现,<code>appExtVrsId</code>是来标记要下载哪个版本.<br><img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fel4p2c1jqj30be08wwew.jpg\" alt=\"推断关键字\"></p>\n<h3 id=\"修改Request参数下载历史版本\"><a href=\"#修改Request参数下载历史版本\" class=\"headerlink\" title=\"修改Request参数下载历史版本\"></a>修改Request参数下载历史版本</h3><p>我们在<code>softwareVersionExternalIdentifiers</code>中任选一个版本号, 此处我以<code>819147298</code>为例</p>\n<ol>\n<li>删除刚才下载好的软件, 重新下载.</li>\n<li>因为我们在下载链接中加的有断点, 再次下载时Charles会停在断点的位置</li>\n<li>点击<code>Edit Request</code>来编辑<code>appExtVrsId</code>字段<br><img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fel4qg1avyj30yf0o60v0.jpg\" alt=\"Edit Request\"></li>\n<li>执行断点, 继续下载.</li>\n<li>在ITunes中看到更新的标志说明下载成功<br><img src=\"https://ww1.sinaimg.cn/large/006tNbRwgy1fel4komzx2j30p00c8t9i.jpg\" alt=\"下载成功\"></li>\n</ol>\n<h2 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h2><p>通过ITunes来安装下载好的软件到手机.</p>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://hchong.net/2017/02/28/Charles%E6%8A%93%E5%8C%85Https%E8%AF%B7%E6%B1%82/\">Charles抓包HTTPS请求</a>.<br>2.<a href=\"http://www.jianshu.com/p/edfed1b1822c\" target=\"_blank\" rel=\"noopener\">iOS秘籍-下载历史版本App超详细教程</a>.</p>\n","categories":["iOS逆向"],"tags":["Charles","iOS逆向"]},{"title":"使用Jenkins实现持续集成","url":"http://hchong.net/2017/03/23/Jenkins自动化打包/","content":"<h1 id=\"使用Jenkins实现持续集成\"><a href=\"#使用Jenkins实现持续集成\" class=\"headerlink\" title=\"使用Jenkins实现持续集成\"></a>使用Jenkins实现持续集成</h1><p>什么是持续集成, 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>\n<p>常见的持续集成的工具有<a href=\"http://jenkins-ci.org/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>  <a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis</a>  <a href=\"http://hudson-ci.org/\" target=\"_blank\" rel=\"noopener\">Hudson</a>  <a href=\"https://circleci.com/\" target=\"_blank\" rel=\"noopener\">Circle</a>. 然而好多我并没有实践过, 😂. <a href=\"http://www.infoq.com/cn/articles/ios-code-server-jenkins-travis-fastlane\" target=\"_blank\" rel=\"noopener\">这里</a>有一篇文章, 对比讲解了主流iOS持续化集成方案, 包括了Xcode Server.</p>\n<p>Code review, 单元测试, 打包与分发, 这些构成了一个APP开发生命周期. 所以一个完整持续化集成应该包含以上的而全部信息, 这里我们主要讲解一下打包与分发的持续化集成方案. 关于我们为什么选择Jenkins, 而不使用其他的持续化方案, <a href=\"http://www.infoq.com/cn/articles/ios-code-server-jenkins-travis-fastlane\" target=\"_blank\" rel=\"noopener\">这篇文章</a>已经讲解的很清楚了. 下面就跟随我一步步的搭建Jenkins, 实现一个简单但强大的持续化集成方案. 本文均以Jenkins2.35为例.</p>\n<h2 id=\"安装Jenkins\"><a href=\"#安装Jenkins\" class=\"headerlink\" title=\"安装Jenkins\"></a>安装Jenkins</h2><p>首先, 我们要安装Jenkins. 安装Jenkins一般有两种方式. </p>\n<p>第一种我们可以从<a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">官网</a>上下载最新的pkg安装包。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vhnmh9bj30h80c7dgr.jpg\" alt=\"安装步骤1\"></p>\n<p>一路点击继续, 直到安装成功为止.</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vikplwxj30hb0c5q35.jpg\" alt=\"安装完成\"></p>\n<p>第二种方式也可以下载<code>brew install jenkins</code>, 切换到切换到 <code>cd /usr/local/Cellar/jenkins/版本号/libexec/jenkins.war</code>,  然后运行Java -jar jenkins.war，进行安装.<br>注意: 如果brew无效要先安装homebrew, <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>\n<p>安装完成后, 重启电脑, 你会发现多了一个Jenkins的用户, 但是他的登录密码我们并不知道. 我们应该打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>, 此时可以看到Jenkins的初始界面. </p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fh5vod9epvj30yg0jet93.jpg\" alt=\"Jenkins初始界面\"><br>注意, 由于Jenkins是由Java开发的, 所以Jenkins的运行必须是在Java环境下, 如果你打开界面为空白的话, 那就说明你需要安装Java环境了.</p>\n<p>按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录, 由于非Jenkins用户没有查看权限, 所以需要我们右键 -&gt; 显示简介, 给这个文件夹赋予读写权限. 按照提示找到<em>initialAdminPassword</em>文件, 复制出密码，就可以填到网页上去重置密码了.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fh5vsrxh73j30yg0je0t5.jpg\" alt=\"重置密码\"></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fh5vt9bk89j30yg0jemxk.jpg\" alt=\"开始安装\"></p>\n<p>然后一路安装下去, 输入用户名，密码，邮件这些，就算安装完成了。</p>\n<h2 id=\"Jenkins插件配置-amp-系统设置\"><a href=\"#Jenkins插件配置-amp-系统设置\" class=\"headerlink\" title=\"Jenkins插件配置&amp;系统设置\"></a>Jenkins插件配置&amp;系统设置</h2><p>打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>页面, 我们需要安装一些辅助插件, 选择<em>系统管理</em> -&gt; <em>管理插件</em>. 下面我列一下我安装到的一些常用的插件: </p>\n<ul>\n<li><p>GitLab Plugin, Gitlab Hook Plugin. 用于连接到GitLab, 如果你的源码在Gitlab上托管, 这连个插件必须要安装.</p>\n</li>\n<li><p>Xcode integration. 这个看名字就知道必须安装了.</p>\n</li>\n<li><p>Environment Injector Plugin. 自定义全局变量的插件, 必须安装.</p>\n</li>\n<li><p>Keychains and Provisioning Profiles Management. 用于管理钥匙串和描述文件, 必须安装.</p>\n</li>\n<li><p>build timeout plugin. 如果构建超时, 自动停止Jenkins当前的构建, 可选.</p>\n</li>\n<li><p>Email Extension Plugin. 用于发邮件, 可选.</p>\n<h2 id=\"Jenkins打包配置准备工作\"><a href=\"#Jenkins打包配置准备工作\" class=\"headerlink\" title=\"Jenkins打包配置准备工作\"></a>Jenkins打包配置准备工作</h2></li>\n</ul>\n<p>首先, 我们需要明确在这一步我们的目的: 把指定代码的指定分支打包为签名过的IPA包, 并且生成一个可供下载的链接. 那么明确了我们的目的, 接下来就一步一步的来实现它. 打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>页面, 接下来我们开始新建一个打包项目. 点击左侧工具栏<em>新建</em>, 选择<em>构建一个自由风格的软件项目</em>, 注意这里最好使用英文, 不要出现中文和特殊字符.</p>\n<p>进入项目配置页面, 接下来我将从<em>General</em>, <em>源码管理</em>, <em>构建触发器</em>, <em>构建环境</em>, <em>构建</em>, 和<em>构建后操作</em>几个方面来配置打包项目.</p>\n<p>在项目配置之前, 我们需要先配置一些其他全局的变量, 这些变量在项目的配置中会使用到.</p>\n<h3 id=\"gitlab代码地址配置\"><a href=\"#gitlab代码地址配置\" class=\"headerlink\" title=\"gitlab代码地址配置\"></a>gitlab代码地址配置</h3><p>Jenkins系统管理 -&gt; 系统设置 -&gt; Gitlab选项, 因为我们的代码托管在gitlab上面, 所以在这里需要配置相关信息. 点击<em>增加</em>. 填写相关信息.<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fh93xkbelyj31ei0qk75f.jpg\" alt=\"gitlab地址配置\"></p>\n<p>注: 这里会报一个<em>API Token for Gitlab access required</em>的错误, 可以暂时忽略, 是因为gitlab一般都是私有的仓库, Jenkins没有连接的权限导致的.</p>\n<h3 id=\"添加与gitlab连接的证书\"><a href=\"#添加与gitlab连接的证书\" class=\"headerlink\" title=\"添加与gitlab连接的证书\"></a>添加与gitlab连接的证书</h3><p>Jenkins -&gt; Credentials -&gt; Add Credentials, <a href=\"http://localhost:8080/credentials/store/system/domain/_/newCredentials\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/credentials/store/system/domain/_/newCredentials</a>增加一个新的证书, 用来连接gitlab. </p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fh94ryjjgvj31kw0qngml.jpg\" alt=\"连接gitlab的证书\"></p>\n<p><em>kind</em> , <em>Scope</em> 和 <em>Private Key</em> 就按照如图所示选择好. <em>UserName</em> 表示这个证书的名字, <em>ID</em> 自动生成, 用来标记这个证书. <em>Description</em>是关于这个证书的描述. <em>key</em> 那里填写SSH的Private Key, <em>Passphrase</em> 那里填写生成SSH时填写的密码.  <a href=\"https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5\" target=\"_blank\" rel=\"noopener\">关于SSH的申请</a>.</p>\n<p>注意: 这里记得要在你的gitlab的Profile Settings -&gt; SSH Keys中添加上一步生成的Public Key, </p>\n<h3 id=\"添加钥匙串和描述文件\"><a href=\"#添加钥匙串和描述文件\" class=\"headerlink\" title=\"添加钥匙串和描述文件\"></a>添加钥匙串和描述文件</h3><p>在Jenkins -&gt; 系统管理 -&gt; KeyChain and Provisioning Profiles Management 中添加 keychains 和 Provisioning Profile文件.<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fha7tvmt2uj30yg08ljrq.jpg\" alt=\"添加钥匙串和描述文件\"></p>\n<p>分别上传keychains 和 Provisioning Profile.</p>\n<ul>\n<li><p>keychains的路径在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。</p>\n</li>\n<li><p>Provisioning Profiles文件在~/Library/MobileDevice/Provisioning Profiles 目录下, 这里面可能会有许多描述文件, 找到我们需要的, 上传并且拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下.</p>\n</li>\n</ul>\n<p>注: 如果 Jenkins 下保存 keychain 和 Provision profile 的目录不存在可以手动创建. 我们可以邮件查看要打包工程*.xcodeproj的包内容, 查看project.pbxproj文件, 通过搜索找到描述文件的ID, 再在~/Library/MobileDevice/Provisioning Profiles文件夹中根据ID来找到具体的描述文件.</p>\n<h3 id=\"Xcode-Builder\"><a href=\"#Xcode-Builder\" class=\"headerlink\" title=\"Xcode Builder\"></a>Xcode Builder</h3><p>在Jenkins -&gt; 系统设置 -&gt; Xcode Builder -&gt; 新增, 如下图所示.<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fha9gi02fyj30nu0fz74v.jpg\" alt=\"Xcode Builder\"></p>\n<p>Keychain Name是要打包的证书的名字, 在钥匙串中找到该证书, 点击右键 显示简介, 复制过来就好.</p>\n<p>Keychain password是开机密码.</p>\n<h2 id=\"Jenkins打包配置\"><a href=\"#Jenkins打包配置\" class=\"headerlink\" title=\"Jenkins打包配置\"></a>Jenkins打包配置</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fha9o70e7wj31kw0t4758.jpg\" alt=\"Jenkins打包工程的配置\"></p>\n<h3 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h3><p>配置一些通用的选项. 项目名称和项目描述如其字面意思一样. <code>GitLab connection</code>是源码的地址, 在外面配置好的选项, 在这里可选.</p>\n<ul>\n<li><p>节流构建，通过设置时间段内允许并发的次数来实现构建的控制</p>\n</li>\n<li><p>丢弃旧的构建, 按需选择.</p>\n</li>\n<li><p>参数化构建过程, 在Jenkins开始打包之前, 填写需要你传入的参数.</p>\n</li>\n<li><p>关闭构建, 在必要的时候并发构建. 可选</p>\n</li>\n</ul>\n<h2 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h2><p>根据自己的实际需求, 不管是SVN或者Git. 因为我使用的是Git, 在一开始安装了Git管理的插件, 所以这里选择Git.<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fhab3vad6rj30tm0f3q3d.jpg\" alt=\"\"></p>\n<ol>\n<li><p>这里的 <em>Credentials</em> 如果使用的是SSH模式, 那上面的 <em>Repository URL</em>就要使用SSH类型的地址. 如果是账号密码模式, 那上面的源码就要使用HTTP形式的地址. 两者必须保持一致.</p>\n</li>\n<li><p>指定代码, 我们可以拉取指定git地址的代码. 因为分支是个变量, 它不像git地址那样一成不变, 所以最好是外部传入, 那就用到了全局环境变量. </p>\n</li>\n</ol>\n<h2 id=\"构建触发器\"><a href=\"#构建触发器\" class=\"headerlink\" title=\"构建触发器\"></a>构建触发器</h2><p>构建触发器是设置自动化构建的地方, 如果想设置自动化构建, 例如监测到git有更新就打包, 或者每隔固定时间就打一次包.</p>\n<ul>\n<li><p>Poll SCM (poll source code management) 轮询源码管理. 需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次</p>\n</li>\n<li><p>Build periodically (定时build) 一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的.</p>\n</li>\n</ul>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fhfrpjn2twj31kw0cegma.jpg\" alt=\"构建触发器\"></p>\n<h2 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h2><p>构建环境, 主要是对构建时一些环境变量的配置.<br><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fhgvjboomwj31a60eujrv.jpg\" alt=\"构建环境\"></p>\n<p>在该模块中 主要设置 xcode build 打包时需要的 keychains 和 Provision Profiles 配置文件。<br>如果不配置 就会使用 xcode 自动的配置，来去系统中查找相应的配置，不过有一点需要注意,就是钥匙串中，登陆钥匙串中的证书 要复制到 系统钥匙串中，因为jenkins 访问的是系统中的钥匙串 这样在第一次打包的时候，会提示 是否授权访问钥匙串，点击始终允许就可以了。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1fhjnx3dnwvj31gg0jo755.jpg\" alt=\"Keychains and Code Signing Identities\"><br><em>Keychains and Code Signing Identities</em> 中的选项, 因为在前面已经选择过了 <em> Keychain </em> 和 <em>Code Signing Identity</em>在前面已经填写过, 此处只用根据当前工程来选择正确的选项.</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fhjo37irdyj31g20hojs1.jpg\" alt=\"Mobile Provisioning Profiles\"></p>\n<p><em>Mobile Provisioning Profiles</em>由于前面已经填写过描述文件, 此处只需要选择与当前打包工程相匹配的描述文件.</p>\n<h2 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h2><p>在这里才进入了自动化集成的关键步骤, 前面的都是一些准备工作. 我们选择<em>增加构建步骤</em>, 按照自己的实际需求, 选择打包脚本的类型. 因为Jenkins自带Shell脚本集成, 所以此处我选择<em>Execute shell</em>, 使用shell脚本来进行构建.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">export PATH</div><div class=\"line\">#######执行脚本命令#######</div><div class=\"line\">rm -rf Users/Shared/Jenkins/Library/ipa/JenkinsTest/JenkinsTest.ipa</div><div class=\"line\">security unlock-keychain  -p &quot;HChong&quot; ~/Library/Keychains/login.keychain</div><div class=\"line\">sh /Users/Shared/Jenkins/Library/BuildScript/build.sh JenkinsTest 4c86cf7c8b4d00013c59b30b0c8d5e77</div><div class=\"line\">fir p /Users/Shared/Jenkins/Library/ipa/JenkinsTest/JenkinsTest.ipa -T 4c86cf7c8b4d00013c59b30b0c8d5e77</div></pre></td></tr></table></figure>\n<p>shell脚本的具体内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">#=================项目路径配置===============</div><div class=\"line\">PROJECT_PATH=&apos;/Users/Shared/Jenkins/Home/workspace/iOSPackage&apos;</div><div class=\"line\">WORKSPACE_NAME=&apos;JenkinsTest.xcworkspace&apos;</div><div class=\"line\">Archive_PATH=&apos;/Users/Shared/Jenkins/Library/archive&apos;</div><div class=\"line\">IPA_PATH=&apos;/Users/Shared/Jenkins/Library/ipa&apos;</div><div class=\"line\">PLIST_PATH=&apos;/Users/Shared/Jenkins/Home/workspace/iOSPackage/exportArchive.plist&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#===================================脚本开始=================================================</div><div class=\"line\">#使用帮助</div><div class=\"line\">if [ $# == 0 ];then</div><div class=\"line\">echo &quot;===========================如何使用=============================&quot;</div><div class=\"line\">echo &quot; eg: ./build [scheme] [token] &apos;版本描述中间不要留空格&apos;, 不传token默认用当前已经登录的fir token&quot;</div><div class=\"line\">echo &quot; scheme list:&quot;</div><div class=\"line\">echo &quot; JenkinsTest&quot;</div><div class=\"line\">echo &quot; token list:&quot;</div><div class=\"line\">echo &quot;================================================================&quot;</div><div class=\"line\">exit</div><div class=\"line\">fi</div><div class=\"line\"></div><div class=\"line\">#update code from gitlab</div><div class=\"line\">cd $PROJECT_PATH</div><div class=\"line\">#git pull</div><div class=\"line\"></div><div class=\"line\">#update pod</div><div class=\"line\">#pod install --repo-update</div><div class=\"line\">#pod update</div><div class=\"line\"></div><div class=\"line\">#删除旧的编译目录</div><div class=\"line\">APP_BUILD_LOCATION=$&#123;PROJECT_PATH&#125;/Build/</div><div class=\"line\">rm -rf $&#123;APP_BUILD_LOCATION&#125;</div><div class=\"line\">#创建dfc目录</div><div class=\"line\"></div><div class=\"line\">#key auth</div><div class=\"line\">security unlock-keychain &quot;-p&quot; &quot;钥匙串密码&quot; &quot;/Users/hc/Library/Keychains/login.keychain&quot;</div><div class=\"line\"></div><div class=\"line\">#创建ARCHIVE目录</div><div class=\"line\">mkdir -p IPA_PATH</div><div class=\"line\">#Archive_NAME = $1.xcarchive</div><div class=\"line\"></div><div class=\"line\">#开始打包</div><div class=\"line\">cd $&#123;PROJECT_PATH&#125;</div><div class=\"line\">pwd</div><div class=\"line\"></div><div class=\"line\">XCCONFIG_PATH=$&#123;PROJECT_PATH&#125;/dfc_v2/appconfig</div><div class=\"line\"></div><div class=\"line\">#xcodebuild -workspace $&#123;WORKSPACE_NAME&#125; -scheme Enterprise -xcconfig $&#123;XCCONFIG_PATH&#125;/$1.xcconfig -archivePath $&#123;Archive_PATH&#125;/$1.xcarchive archive</div><div class=\"line\">xcodebuild -workspace $&#123;WORKSPACE_NAME&#125; -scheme $1 -config $1 -archivePath $&#123;Archive_PATH&#125;/$1.xcarchive archive</div><div class=\"line\">echo &quot;--------------------------------------------&quot;$&#123;Archive_PATH&#125;/$1.xcarchive</div><div class=\"line\"></div><div class=\"line\">#创建ipa</div><div class=\"line\">IPA_LOCATION=$&#123;IPA_PATH&#125;/$1</div><div class=\"line\"></div><div class=\"line\">#删除旧的ipa</div><div class=\"line\">rm -rf IPA_LOCATION</div><div class=\"line\">mkdir -p $&#123;IPA_PATH&#125;/$1</div><div class=\"line\">xcodebuild -exportArchive -exportOptionsPlist $&#123;PLIST_PATH&#125; -archivePath $&#123;Archive_PATH&#125;/$1.xcarchive -exportPath $&#123;IPA_LOCATION&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">IPA_FILE_LOCATION=$&#123;IPA_PATH&#125;/$1/$1.ipa</div><div class=\"line\"></div><div class=\"line\">#检查ipa是否创建成功</div><div class=\"line\">if [ -f $IPA_FILE_LOCATION ]; then</div><div class=\"line\">echo &quot;ipa已经创建:&quot;$&#123;IPA_FILE_LOCATION&#125;</div><div class=\"line\">else</div><div class=\"line\">echo &quot;打包失败&quot;</div><div class=\"line\">exit 0</div><div class=\"line\">fi</div></pre></td></tr></table></figure></p>\n<h2 id=\"构建后的操作\"><a href=\"#构建后的操作\" class=\"headerlink\" title=\"构建后的操作\"></a>构建后的操作</h2><p>顾名思义, 就是构建之后进行的操作. 在这里我们可以选择<em>Execute a set of scripts</em>, 通过脚本来实现构建后的操作. 常见的是将构建的结果, 上传到内测平台或者内部下载地址. 但是如果构建操作的脚本中包含有这一项, 这一个步骤也就可以忽略掉了.</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><h3 id=\"找不到Fir命令\"><a href=\"#找不到Fir命令\" class=\"headerlink\" title=\"找不到Fir命令\"></a>找不到Fir命令</h3><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fhjsalg3fej31b80cewfp.jpg\" alt=\"找不到Fir命令\"><br>出现如图所示的Error, 一般是由于没有安装fit-cli命令导致, 通过安装<code>gem install fir-cli -V --no-ri --no-rdoc</code>来解决. 如果提示安装成功, 但是还是报错的话, 那就在安装命令前加上<code>sudo</code>, 覆盖安装即可.</p>\n<h3 id=\"fir-cli-jenkins-fir-command-not-found\"><a href=\"#fir-cli-jenkins-fir-command-not-found\" class=\"headerlink\" title=\"fir-cli jenkins fir:command not found\"></a>fir-cli jenkins fir:command not found</h3><p>这个错误是由于没有导入fir-cli安装目录导致的, 可以先在终端输入<code>echo $PATH</code>, 然后把输出结果复制下来, 在Jenkins -&gt; 系统管理 -&gt; 添加全局变量. 然后在工程构建步骤, 先引入全局变量<code>export ${PATH}</code>. 如果没有设置全局变量的话, 也可以直接使用<code>export PATH=</code>echo $PATH 的输出结果``</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79gy1fhk9pyt7nsj31dg0cmwen.jpg\" alt=\"添加Path全局变量\"></p>\n<h3 id=\"证书配置文件没有找到\"><a href=\"#证书配置文件没有找到\" class=\"headerlink\" title=\"证书配置文件没有找到\"></a>证书配置文件没有找到</h3><p>No iOS profile matching ‘xxxxxx/xxxxxxx’ found:Xcode couldn’t find a profile<br>matching ‘xxxxxx/xxxxxxx’.<br>Install the profile (by dragging and dropping it onto Xcode’s dock item)<br>or select a different one in the General tab of the target editor.<br>Code signing is required for product type ‘Application’ in SDK ‘iOS 10.3’ </p>\n<p>是因为Archive时没有找到profile导致的. 解决办法是, 把系统的<code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code>整个Provisioning Profiles文件夹复制到<code>/Users/Shared/Jenkins/Library/MobileDevice</code>目录下, 并且在Jenkins -&gt; Keychains and Provisioning Profiles Management 的Provisioning Profiles Directory Path中, 设置好profile的存放目录.</p>\n<h3 id=\"Command-usr-bin-codesign-failed-with-exit-code-1\"><a href=\"#Command-usr-bin-codesign-failed-with-exit-code-1\" class=\"headerlink\" title=\"Command/usr/bin/codesign failed with exit code 1\"></a>Command/usr/bin/codesign failed with exit code 1</h3><h2 id=\"这个是由于没有给钥匙串开锁权限导致-编译之前添加-security-unlock-keychain-p-quot-你的密码-quot-quot-path-to-keychain-login-keychain-quot-解决\"><a href=\"#这个是由于没有给钥匙串开锁权限导致-编译之前添加-security-unlock-keychain-p-quot-你的密码-quot-quot-path-to-keychain-login-keychain-quot-解决\" class=\"headerlink\" title=\"这个是由于没有给钥匙串开锁权限导致, 编译之前添加 security unlock-keychain -p &quot;你的密码&quot; &quot;path to keychain/login.keychain&quot;解决.\"></a>这个是由于没有给钥匙串开锁权限导致, 编译之前添加 <code>security unlock-keychain -p &quot;你的密码&quot; &quot;path to keychain/login.keychain&quot;</code>解决.</h2><h2 id=\"待解决\"><a href=\"#待解决\" class=\"headerlink\" title=\"待解决\"></a>待解决</h2><p>使用Tomcat, 把Jenkins发布出去, 这个是下一步要解决的问题.<br>参考文章:</p>\n<p>1.<a href=\"https://runningyoung.github.io/2016/04/01/2016-04-05-jenkins2/\" target=\"_blank\" rel=\"noopener\">iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 2)</a></p>\n<p>2.<a href=\"http://www.jianshu.com/p/c69deb29720d\" target=\"_blank\" rel=\"noopener\">一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e19c8327b167\" target=\"_blank\" rel=\"noopener\">Jenkins/git/KeyChains &amp; Provisioning, 记录CI中的一些坑</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/e19c8327b167\" target=\"_blank\" rel=\"noopener\">使用 Jenkins 持续集成 iOS 项目时碰到的一些问题</a></p>\n<p>5.<a href=\"http://www.jianshu.com/p/41ecb06ae95f\" target=\"_blank\" rel=\"noopener\">手把手教你利用Jenkins持续集成iOS项目</a></p>\n","categories":["自动化打包","持续集成"],"tags":["自动化打包","Jenkins","持续集成"]},{"title":"多渠道包和多环境包的自动化实现","url":"http://hchong.net/2017/03/12/多Target实现/","content":"<h1 id=\"多渠道包和多环境包的自动化实现\"><a href=\"#多渠道包和多环境包的自动化实现\" class=\"headerlink\" title=\"多渠道包和多环境包的自动化实现\"></a>多渠道包和多环境包的自动化实现</h1><p>在App的开发过程中, 肯定会有很多后台环境的区分. 例如开发时, 我们用的是开发环境. 测试时使用的是测试环境. 在预发布之前肯定要有个缓冲的环境, 也就是预发布环境. 最后还有一个线上的环境, 也称为生产环境. 那么这么多环境, 问题就来了, 该怎么在各个环境之间无缝切换呢?  </p>\n<p>首先我们会想到在代码中建一个单独的类, 把用到的所有服务按照环境列一个遍, 每次需要运行什么环境就按照什么环境从类里面去取相关环境代码. 于是有了方案一.</p>\n<h2 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h2><p>方案一的伪代码, 大概是这个样子的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (void)getHttpHostWithStatus:(NSInteger)status &#123;</div><div class=\"line\">    switch (status) &#123;</div><div class=\"line\">        case 0: &#123;</div><div class=\"line\">            Host1 = @&quot;开发环境&quot;;</div><div class=\"line\">            Host2 = @&quot;开发环境&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        case 1: &#123;</div><div class=\"line\">            Host1 = @&quot;测试环境&quot;;</div><div class=\"line\">            Host2 = @&quot;测试环境&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        case 2: &#123;</div><div class=\"line\">            Host1 = @&quot;预发布环境&quot;;</div><div class=\"line\">            Host2 = @&quot;预发布环境&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        case 3: &#123;</div><div class=\"line\">            Host1 = @&quot;线上环境&quot;;</div><div class=\"line\">            Host2 = @&quot;线上环境&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在App每次启动时调用这个方法, 来获取各个Host的地址, 完美解决. </p>\n<p>测试每次想要个新的包来测试, 都会有如下对话, “帮我打个包吧”, “你要什么环境的”, “预发环境”, “好的”. 于是 ,我们一同操作, 传入预发的status, 调用动态取Host的方法, 然后Product-&gt;Archive, 等个十几二十分钟, 打包完毕, 生成一个IPA文件, 自己拿ITunes安装. 嗯, 虽然辛苦点, 但是目前看来, 一切都很完美嘛, 打包的时候还能喝个茶.</p>\n<p>然而, 随着我司测试流程的规范化, 逐渐推进使用<a href=\"\">Jenkins持续集成</a>来打包, 那么问题就来了. 你让测试也装个Xcode, 每次切换一下环境, 手动Archive吗, 呵呵. 于是我们有了方案二.</p>\n<h2 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h2><p>我们先来理一下方案二主要解决的问题: <em>测试要能够在不改代码的前提下使用Jenkins打不同环境的包</em>. 听起来有点复杂呢, 我们来逐个分析下.</p>\n<ol>\n<li>使用Jenkins来打包, 那就是跑脚本嘛, xcodebuild已经寂寞难耐.</li>\n<li>既然搞Jenkins了, 不能再用IPA自己安装的方式了, Low, 蒲公英和Fir简直不要太方便.</li>\n<li>既然要用脚本来打包了, 那不能每次跑脚本之前, 先改一下代码吧, 于是想到我们应该有一个参数来在工程中区分不同的环境, </li>\n</ol>\n<p>以上就是我们方案二要解决的主要问题, 下面我们来逐个分析和解决.</p>\n<h3 id=\"打包脚本\"><a href=\"#打包脚本\" class=\"headerlink\" title=\"打包脚本\"></a>打包脚本</h3><p>关于打包的脚本, 版本很多, 有Python流, 有Shell流, 可以<a href=\"\">参考这里</a>. 但说到底, 无非用的是xcodebuild来实现的, 在终端中输入<code>xcodebuild -help</code>可以查看xcodebuild的相关操作<a href=\"http://www.jianshu.com/p/4f4d16326152\" target=\"_blank\" rel=\"noopener\">这篇文章</a>将的也比较全面, 可以参考下.</p>\n<p>在这里, 我们主要用到的命令有两个.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//编译</div><div class=\"line\">xcodebuild -workspace &lt;workspacename&gt; -scheme &lt;schemeName&gt; [-destination &lt;destinationspecifier&gt;]... [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...</div><div class=\"line\"></div><div class=\"line\">//生成IPA</div><div class=\"line\">xcodebuild -exportArchive -archivePath &lt;xcarchivepath&gt; -exportPath &lt;destinationpath&gt; -exportOptionsPlist &lt;plistpath&gt;</div></pre></td></tr></table></figure>\n<p>到这一步, 我们的打包脚本仅仅完成了第一步, 生成了IPA文件. </p>\n<h3 id=\"内测分发平台\"><a href=\"#内测分发平台\" class=\"headerlink\" title=\"内测分发平台\"></a>内测分发平台</h3><p>生成IPA之后, 我们要提供一个可供下载安装的链接. 此处我们使用的是<a href=\"https://fir.im/\" target=\"_blank\" rel=\"noopener\">Fir</a>, 它提供的也有<a href=\"https://github.com/FIRHQ/fir-cli/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">命令行操作</a>, 可以直接上传IPA文件, 生成可供下载的二维码.👍</p>\n<p>当然有条件的公司也可以自己搭建一个下载地址, 制作一个管理后台, 用来管理自己的内测.</p>\n<h3 id=\"APP配置多个环境变量\"><a href=\"#APP配置多个环境变量\" class=\"headerlink\" title=\"APP配置多个环境变量\"></a>APP配置多个环境变量</h3><p>接下来这个, 才是本次解决方案的重点, 明确了我们的目的, 就是配置多环境变量, 那么我们就开始吧. 关于多环境变量的配置, 冰霜大神的<a href=\"http://www.jianshu.com/p/83b6e781eb51\" target=\"_blank\" rel=\"noopener\">这篇文章</a>讲解的比较详细. 但是我们采用的方案和他的又略有区别, 一开始我们使用的是多Target的方式, 后来感觉不够轻量化, 并且每个Target的Seeting也基本你没有大的不同, 于是就采用了多Scheme的方式来解决.</p>\n<p>具体步骤如下:<br>1.新建Scheme. 注意这里一定要把Scheme的名字和编译方式区分开，选择了一个Scheme，只是相当于选择了一个环境，并不是代表这Debug还是Release, 此处以<code>PrePublish</code>为例.<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8ovbi6rj318o0aq0t6.jpg\" alt=\"新建Scheme\"></p>\n<p>2.新建xcconfig文件, 名字与Scheme对应. 在新建时, 一定要在Target那里勾选上(默认是非勾选状态).<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8qe5nx2j313k13umy6.jpg\" alt=\"新建xcconfig\"></p>\n<p>3.Project -&gt; Info -&gt; Configurations 新建Configurations文件. 注意, 如果有使用Pod的话, 此处需要立马执行<code>pod install</code>, 生成对应的Pod的xcconfig文件<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl8s76f92j318u0h2aap.jpg\" alt=\"新建Configurations\"></p>\n<p>4.修改Configurations文件, 使之与对应的Scheme相关联.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1ffl8vld5eyj31c00g4mxp.jpg\" alt=\"修改Configurations\"></p>\n<p>5.Edit Scheme<br><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgy1ffl92zbnlhj31ds0s0q3p.jpg\" alt=\"Edit Scheme\"></p>\n<p>6.编辑PrePublish.xcconfig文件, 设置自定义字段. 具体如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#include &quot;Pods/Target Support Files/Pods-MultipleChannel/Pods-MultipleChannel.prepublish.xcconfig&quot;</div><div class=\"line\"></div><div class=\"line\">HOST1 = @&quot;HOST1/PrePublish&quot;</div><div class=\"line\"></div><div class=\"line\">HOST2 = @&quot;HOST2/PrePublish&quot;</div><div class=\"line\"></div><div class=\"line\">GCC_PREPROCESSOR_DEFINITIONS = $(inherited) HOST2=&apos;$(HOST2)&apos; HOST1=&apos;$(HOST1)&apos;</div></pre></td></tr></table></figure>\n<p>注意, 此处必须要引入<code>pod install</code>生成的对应的Pod的xcconfig, 否则会报错.<br><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgy1ffl9102hzij30ji0aoglq.jpg\" alt=\"报错\"><br>7.Manage Schemes</p>\n<p>因为一般是多人合作开发, 所以此处的Scheme需要设置为Share状态<br><img src=\"http://ww1.sinaimg.cn/large/006tNbRwgy1ffl969kivwj316o0o0jrt.jpg\" alt=\"\"></p>\n<p>至此, 已经可以在工程中使用我们在xcconfig中自定义的字段了. 因为我们使用了<code>GCC_PREPROCESSOR_DEFINITIONS</code>, 他会在编译时生成一个宏定义, 所以我们可以直接使用宏定义<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSLog(@&quot;----------%@&quot;, HOST1);</div><div class=\"line\">NSLog(@&quot;----------%@&quot;, HOST2);</div></pre></td></tr></table></figure></p>\n<p>注: 此外, 还有另外一种使用方式. 我们可以每个Scheme新建一个plist(也可使用Info.plist)文件与之对应, 在plist文件中新增<code>key-value</code>来与xcconfig中的自定义字段对应.</p>\n<p>使用方法如下:</p>\n<p>1.在plist中新增与xcconfig中自定义字段对应的<code>key-value</code><br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgy1ffl9dzmseoj310y0nqjsm.jpg\" alt=\"plist文件新增\"></p>\n<p>2.使用方式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</div><div class=\"line\">NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithContentsOfFile:bundlePath];</div><div class=\"line\">NSLog(@&quot;----------%@&quot;, [dict objectForKey:@&quot;HOST1&quot;]);</div><div class=\"line\">NSLog(@&quot;----------%@&quot;, [dict objectForKey:@&quot;HOST2&quot;]);</div></pre></td></tr></table></figure>\n<p>至此, 我们已经实现不同Scheme下, 参数的动态化配置的两种方案, 下面我们分析下原理:</p>\n<p>首先, 我们先来区分一下Xcode Workspace、Xcode Scheme、Xcode Project、Xcode Target、Build Settings 这5者的关系, 由于篇幅较长, <a href=\"http://hchong.net/2017/05/16/Settings%E5%85%B3%E7%B3%BB/\">另开一文</a>.<br>这5者的关系在苹果官方文档上其实都已经说明的很清楚了。详情见文档<a href=\"https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html\" target=\"_blank\" rel=\"noopener\">Xcode Concepts</a>。 </p>\n<p>总结起来, 一个Workspace可以包含多个Project,一个Project可以包含多个Target，Scheme包含了所有的Target集合，这个集合指定了，编译哪个target，使用哪个build configuration去编译target，提供运行target的执行环境等等.</p>\n<p>xcconfig文件是一个用来保存Build Settings键值对的纯文本文件, 这些键值对会覆盖Build Settings中的值. xcconifg支持可以根据不同的Configuration选项配置不同的文件. 不同的xcconfig可以指定不同的Build Settings里的属性值.</p>\n<h2 id=\"方案三\"><a href=\"#方案三\" class=\"headerlink\" title=\"方案三\"></a>方案三</h2><p>我们的初衷是用这个来动态配置App的环境. 既然已经可以通过xcconfig和Scheme来配合修改Build Seetings的值, 那么就会有一些更加高级的玩法. 例如我们可以在<code>Images.xcassets</code>中新建新的icon和launch Image的分类, 通过<code>ASSETCATALOG_COMPILER_APPICON_NAME</code>和<code>ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME</code>中的设置, 以及<code>Display Name</code>,<code>Bundle Identifier</code>, <code>Provisioning Profile</code>等一些配置(此处Build Settings中的值可以直接<code>command + C</code>来copy)来管理大量的相似APP.</p>\n<p>Info.plist中的值, 需要在Value中使用${Value}来动态配置, 参考域名的配置.</p>\n<p>xcconfig还能动态配置Build Settings里面的很多参数。这其实类似于cocopods的做法。但是有一个大神的做法很优雅。值得大家感兴趣的人去学习学习。iOS大神Justin Spahr-Summers的开源库提供了一个类权威的<a href=\"https://github.com/jspahrsummers/xcconfigs\" target=\"_blank\" rel=\"noopener\">模板</a>.</p>\n<p>那么伴随着业务的发展, 就有有问题了. 如果我想管理大量相似的APP, 每次发布新版本, 我就要打N多个新包. 每次跑脚本, 数量多了时间也很长, 那这就不是一杯茶的功夫了, 甚至要一两个小时. 并且我还要管理N多个Scheme, 这些Scheme明明只有很少的差别, 真的好烦啊. 有没有更加优雅的解决方案呢, 来看下方案四.</p>\n<h2 id=\"方案四\"><a href=\"#方案四\" class=\"headerlink\" title=\"方案四\"></a>方案四</h2><p>首先, 还是先来明确下我们这个方案要解决的问题:</p>\n<ol>\n<li>Scheme太多, 每个渠道一个Scheme, 管理起来费劲.</li>\n<li>新版本发布时, 各个渠道的包, 跑脚本跑到手软.</li>\n</ol>\n<hr>\n<p>附件下载地址:</p>\n<p>1.<a href=\"\">打包脚本</a>    </p>\n<p>2.<a href=\"https://github.com/HChong3210/MultipleChannel\" target=\"_blank\" rel=\"noopener\">Demo</a>    </p>\n<hr>\n<p>参考文章:</p>\n<p>1.<a href=\"http://www.jianshu.com/p/4f4d16326152\" target=\"_blank\" rel=\"noopener\">xcodebuild命令说明</a></p>\n<p>2.<a href=\"https://fir.im/\" target=\"_blank\" rel=\"noopener\">Fir.im</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/83b6e781eb51\" target=\"_blank\" rel=\"noopener\">手把手教你给一个iOS app配置多个环境变量</a></p>\n<p>4.<a href=\"http://www.jianshu.com/p/9a6f3019d81f\" target=\"_blank\" rel=\"noopener\">Xcode 配置文件 xcconfig</a></p>\n<p>5.<a href=\"http://liumh.com/2016/05/22/use-xcconfig-config-specific-variable/\" target=\"_blank\" rel=\"noopener\">Xcode使用xcconfig文件配置环境</a></p>\n<p>6.<a href=\"http://blog.csdn.net/vbirdbest/article/details/53454014\" target=\"_blank\" rel=\"noopener\">iOS Xcode使用xcconfig配置环境参数(Debug&amp;Release)</a></p>\n<p>7.<a href=\"https://pewpewthespells.com/blog/xcconfig_guide.html\" target=\"_blank\" rel=\"noopener\">The Unofficial Guide to xcconfig files</a></p>\n","categories":["自动化打包"],"tags":["自动化打包","Target"]},{"title":"Charles抓包Https请求","url":"http://hchong.net/2017/02/28/Charles抓包Https请求/","content":"<h1 id=\"Charles抓包HTTPS请求\"><a href=\"#Charles抓包HTTPS请求\" class=\"headerlink\" title=\"Charles抓包HTTPS请求\"></a>Charles抓包HTTPS请求</h1><p>有时我们会对手机里面的App进行一些分析, 产看App的请求包, 这时我们就需要祭出神器<a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">Charles</a>了.<br>下面跟着我来教你从零开始抓取App的请求包.</p>\n<h2 id=\"安装Charles\"><a href=\"#安装Charles\" class=\"headerlink\" title=\"安装Charles\"></a>安装Charles</h2><p>这个纯属占坑(废话).</p>\n<h2 id=\"抓取HTTP请求\"><a href=\"#抓取HTTP请求\" class=\"headerlink\" title=\"抓取HTTP请求\"></a>抓取HTTP请求</h2><p>我们先拿一个简单的HTTP请求来练一下手.</p>\n<h3 id=\"查看本地IP地址和Charles端口号\"><a href=\"#查看本地IP地址和Charles端口号\" class=\"headerlink\" title=\"查看本地IP地址和Charles端口号\"></a>查看本地IP地址和Charles端口号</h3><p>查看IP地址的方法比较多, 这里只介绍两种比较常用的:</p>\n<ol>\n<li>可以在网络偏好设置-&gt;高级-&gt;TCP/IP下查看对应网络的IP.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd5z8oku1vj311a0lwgpb.jpg\" alt=\"网络偏好设置中查看\"></li>\n<li>option+左键单击屏幕上方的WiFi标志也可以查看.<br> <img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65kx0mjhj308c0eft9q.jpg\" alt=\"option+左键查看\"></li>\n</ol>\n<h3 id=\"查看Charles的端口号\"><a href=\"#查看Charles的端口号\" class=\"headerlink\" title=\"查看Charles的端口号\"></a>查看Charles的端口号</h3><p>打开Charles-&gt;Proxy-&gt;Proxy Settings查看端口号, 默认一般是<code>8888</code>. 注意不要随意修改端口号, 以避免被占用.</p>\n<h3 id=\"在iPhone中设置\"><a href=\"#在iPhone中设置\" class=\"headerlink\" title=\"在iPhone中设置\"></a>在iPhone中设置</h3><p>打开手机, 连上WiFi, 注意此处的WiFi最好和Mac连接的WiFi是同一个, 避免出现不在一个网段的情况.<br>打开设置-&gt;无线局域网-&gt;点击对应WiFi后的更多.<br><img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd65mobyrjj30b40jrq3k.jpg\" alt=\"WiFi列表\"><br>点击手动, 设置HTTP代理地址(与Mac的IP地址一致)和端口号(与Charles中代理的端口号一致)<br><img src=\"https://ww3.sinaimg.cn/large/006tKfTcgy1fd65mo3y0aj30b40jrmxm.jpg\" alt=\"设置HTTP代理地址和端口号\"></p>\n<p>至此, 就可以轻松的抓取App中的HTTP请求啦.</p>\n<h2 id=\"抓取HTTPS请求\"><a href=\"#抓取HTTPS请求\" class=\"headerlink\" title=\"抓取HTTPS请求\"></a>抓取HTTPS请求</h2><p>HTTPS的请求抓取, 略微复杂, 他的原理大致是这样的.</p>\n<blockquote>\n<p>Charles能进行https协议抓包分析，是使用了中间人代理的方法（man-in-the-middle，也常作为一个黑客攻击手段）。Charles代替你的app接受server的证书，然后使用这个证书通过SSL和server通信；同时，Charles会动态的生成一个对应的证书（用Charles的CA证书签名），然后使用这个证书和你的app通信，这样就完成了一个中间人代理，从而可以把app和server的https包给抓到和解码出来。</p>\n</blockquote>\n<p>从里面我们可以看到一些关键字: <code>证书</code>, <code>代理</code>, 等. 那么我们就通过这些手段来抓取HTTPS的请求.</p>\n<h3 id=\"设置代理地址和端口号\"><a href=\"#设置代理地址和端口号\" class=\"headerlink\" title=\"设置代理地址和端口号\"></a>设置代理地址和端口号</h3><p>这一步骤, 和抓取HTTP的方法一样, 这里不再赘述, 需要设置端口号和IP地址.</p>\n<h3 id=\"Mac安装证书\"><a href=\"#Mac安装证书\" class=\"headerlink\" title=\"Mac安装证书\"></a>Mac安装证书</h3><p>安装Charles的证书到Mac, 信任该证书, 以便Charles能够通过该证书进行通信. 具体步骤如下: </p>\n<ol>\n<li>打开Charles, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd607vw0k6j30pk094gmj.jpg\" alt=\"安装根证书\"></li>\n<li>信任该证书<br><img src=\"http://upload-images.jianshu.io/upload_images/1552510-461959c476a2d9d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书不被信任时\"></li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1552510-8c43e95be0a35b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"信任Charles证书\"></p>\n<h3 id=\"iPhone安装证书\"><a href=\"#iPhone安装证书\" class=\"headerlink\" title=\"iPhone安装证书\"></a>iPhone安装证书</h3><p>安装Charles证书到手机, 信任该证书, 以便Charles能够截获网络请求. 具体步骤如下:</p>\n<ol>\n<li>在Charles中, 点击Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate on a Mobile Device or Remote Browser, 来查看当前IP地址下, 手机下载证书的网址.<br> <img src=\"https://ww2.sinaimg.cn/large/006tKfTcgy1fd60jpjcgvj30nx094my0.jpg\" alt=\"步骤一:选择生成手机下载证书的网址\"></li>\n<li>在手机中用Safari打开网址(如图所示的网址)<br> <img src=\"https://ww4.sinaimg.cn/large/006tKfTcgy1fd60l2cz81j30nz06t3yl.jpg\" alt=\"步骤二:输入生成的网址\"></li>\n<li>打开网址后自动跳转到证书安装界面, 安装并信任该证书.<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd65rnpokjj30b40jrgly.jpg\" alt=\"步骤三:安装并信任该证书\"></li>\n<li>打开Charles选择Proxy-&gt;SSL Proxying Settings-&gt;SSL Proxying(因为Charles默认是不会抓取任何域名下的HTTPS, 所以需要我们添加域名到Location下)勾选Enable SSL Proxying, 单击Add, 添加域名和端口(用*来表示所有).<br> <img src=\"https://ww1.sinaimg.cn/large/006tKfTcgy1fd60zndgejj30gj0cb0st.jpg\" alt=\"步骤四:设置抓取的域名和端口\"></li>\n</ol>\n<p>至此, 我们再打开手机App就会发现, 之前<code>Unknown</code>的HTTPS接口, 就都可以正常现实啦.</p>\n<p>参考资料:<br>1.<a href=\"http://www.jianshu.com/p/a0215dd2047f\" target=\"_blank\" rel=\"noopener\">HTTP/HTTPS抓包工具Charles</a><br>2.<a href=\"http://www.jianshu.com/p/a83b19a36a8b\" target=\"_blank\" rel=\"noopener\">使用Charles进行https抓包</a><br>3.<a href=\"http://blog.devtang.com/2015/11/14/charles-introduction/\" target=\"_blank\" rel=\"noopener\">Charles 从入门到精通</a></p>\n","categories":["iOS逆向"],"tags":["逆向","安全","Charles"]},{"title":"统计打点的AOP实现","url":"http://hchong.net/2017/02/13/统计打点的AOP实现/","content":"<h1 id=\"统计打点的AOP实现\"><a href=\"#统计打点的AOP实现\" class=\"headerlink\" title=\"统计打点的AOP实现\"></a>统计打点的AOP实现</h1><p>每一个App, 必然会有大量的分析数据来统计用户行为. 而这些统计对应在客户端就是, 统计打点, 又称埋点.<br>关于埋点的本质, 我理解的就是用户出发一个行为后, 调用一个特定的接口. 服务端拿到我们的请求后, 根据客户端传的参数也就是事件ID来区分是什么操作(注意, 这里的事件ID是具有唯一性的, 不同的ID对应用户不同的操作). 有时也可能会需要其他的信息, 比如操作人的ID等. 服务端拿到这些信息之后, 再整理筛选, 通过视图, 报表的形式展现出来.<br>因为埋点是和业务紧密相连的, 所以一般我们的埋点代码(就是调用特定网络接口的代码)分散在整个项目的各个地方. 当业务越来越复杂, 工程越来越大时, 我们的埋点代码就会变得很难维护, 埋点事件分散在各个地方, 很难有个清晰的逻辑. 并且把埋点事件和业务代码高度耦合在一起, 也不是一个明智的选择.<br>这个时候, 就会想到, 要是能用AOP的方式来解决埋点的实现, 把埋点事件和业务代码解耦开来, 那我们维护起来就会方便好多.</p>\n<blockquote>\n<p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP与OOP是面向不同领域的两种设计思想。<br>OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。<br>AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。<br>AOP可以用在日志记录，性能统计，安全控制，事务处理，异常处理等等，本篇文章主要讲的是埋点也就是日志记录</p>\n</blockquote>\n<p>在Objective-C中使用AOP主要指的是使用Objective-C的Runtime特性, 给指定的方法添加自定义代码. 有很多方式来实现AOP, MethodSwizzling只是其中之一.而又有一些第三方库, 将Runtime进行了很好地封装, 让我们不用了解Runtime的知识, 就能很好地使用AOP.<br>我们主要使用的是<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a>这个第三方库, 关于Aspects的内部实现, 可以参考这篇博文<a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"noopener\">iOS 如何实现Aspect Oriented Programming</a>.<br>由以上的解释, 可以基本了解, 我们主要是通过Aspect来Hook对应事件的方法, 传递事件唯一的ID给服务端来标记此事件响应过一次.所以, 我们的代码大致应该是这样.<br>首先有一个类用来记录埋点事件ID和需要Hook的类和方法, 并且将他们一一对应.</p>\n<p>根据记录埋点事件的复杂程度, 我们大致可以将埋点分为简单埋点和复杂埋点两种:</p>\n<ol>\n<li>简单埋点: 只用记录某个操作事件响应次数</li>\n<li>复杂埋点:<ul>\n<li>需要传除了事件ID外的参数</li>\n<li>需要根据服务端返回的数据来响应不同的事件</li>\n<li>埋点事件ID放在服务端返回的字段中</li>\n</ul>\n</li>\n</ol>\n<p>我们新建两个类, 一个用来记录Hook的类<code>HYZTrackList</code>, Hook的方法和与之对应的事件ID. 另外一个类<code>HYZTrackManager</code>, 用来实现埋点事件的具体操作方法.</p>\n<h2 id=\"简单埋点的实现\"><a href=\"#简单埋点的实现\" class=\"headerlink\" title=\"简单埋点的实现\"></a>简单埋点的实现</h2><p>我们在<code>HYZTrackList</code>中实现<code>trackList</code>方法, 返回一个数组. 数组的元素是一个个的字典, 用对记录每一个事件的相关信息.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (NSArray *)trackList &#123;</div><div class=\"line\">    NSArray *trackList = @[</div><div class=\"line\">  //=======================================简单埋点==========================================</div><div class=\"line\">                           //HYZViewController1简单埋点点击事件</div><div class=\"line\">                           @&#123;kClassName:@&quot;HYZViewController1&quot;,</div><div class=\"line\">                             kHookFunction:@&quot;simpleTrack:para2:&quot;,</div><div class=\"line\">                             kEventType:HYZViewController1SimpleButtonClick,</div><div class=\"line\">                             kIsLightEvent:@(YES)&#125;,</div><div class=\"line\">                           //HYZViewController1复杂埋点点击事件</div><div class=\"line\">                           @&#123;kClassName:@&quot;HYZViewController1&quot;,</div><div class=\"line\">                             kHookFunction:@&quot;blockButtonAction:&quot;,</div><div class=\"line\">                             kEventType:HYZViewController1BlockButtonClick,</div><div class=\"line\">                             kIsLightEvent:@(YES)&#125;,</div><div class=\"line\">                           //HYZViewController1block埋点点击事件</div><div class=\"line\">                           @&#123;kClassName:@&quot;HYZViewController1&quot;,</div><div class=\"line\">                             kHookFunction:@&quot;complexButtonAction:&quot;,</div><div class=\"line\">                             kEventType:HYZViewController1ComplexButtonClick,</div><div class=\"line\">                             kIsLightEvent:@(YES)&#125;,</div><div class=\"line\">                           </div><div class=\"line\">//=======================================复杂埋点==========================================</div><div class=\"line\">                           @&#123;kClassName:@&quot;HYZViewController3&quot;,</div><div class=\"line\">                             kHookFunction:@&quot;trackWithTag:&quot;,</div><div class=\"line\">                             kHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,</div><div class=\"line\">                             kIsLightEvent:@(NO)&#125;];</div><div class=\"line\">    return trackList;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上所示, 我们是要记录<code>HYZViewController1</code>类里面的<code>simpleTrack:para2:</code>方法的点击事件, 事件ID是<code>HYZViewController1SimpleButtonClick</code>.<br>我们在<code>APPDelegate</code>的<code>application:didFinishLaunchingWithOptions:</code>方法中, 来hook所有的在<code>trackList</code>中记录的方法.<br>在``中, 实现如下相关代码.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (void)setup &#123;</div><div class=\"line\">    //实现和替换hook的block方法</div><div class=\"line\">    NSMutableDictionary *blockDict = [[NSMutableDictionary alloc] init];</div><div class=\"line\">    [HYZTrackManager weightEventEntry:blockDict];</div><div class=\"line\">    </div><div class=\"line\">    [[HYZTrackList trackList] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class=\"line\">        BOOL isLightEvent = [obj[kIsLightEvent] boolValue];</div><div class=\"line\">        NSString *className = obj[kClassName];</div><div class=\"line\">        NSString *functionName = obj[kHookFunction];</div><div class=\"line\">        NSString *eventName = obj[kEventType];</div><div class=\"line\">        Class class = NSClassFromString(className);</div><div class=\"line\">        SEL selector = NSSelectorFromString(functionName);</div><div class=\"line\">        if (isLightEvent == YES) &#123;</div><div class=\"line\">            if (!functionName) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            [HYZTrackManager lightTrackTarget:class selector:selector functionName:functionName trackId:eventName];</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            NSString *blockName = obj[kHandlerBlock];</div><div class=\"line\">            id handleBlock = [blockDict objectForKey:blockName];</div><div class=\"line\">            if (!handleBlock) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            [HYZTrackManager complexTrackTarget:class selector:selector usingBlock:handleBlock];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>针对简单埋点, 我们直接使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//简单埋点虽然可以拿到对应方法的参数, 但是如果需要把该参数传到埋点请求的网络事件中的话, 必须使用复杂埋点来处理</div><div class=\"line\">+ (void)lightTrackTarget:(Class)target selector:(SEL)selector functionName:(NSString *)functionName trackId:(NSString *)trackId &#123;</div><div class=\"line\">    NSError *error;</div><div class=\"line\">    NSInteger functionParamCount = [[functionName componentsSeparatedByString:@&quot;:&quot;] count] - 1;</div><div class=\"line\">    switch (functionParamCount) &#123;</div><div class=\"line\">        case 0: &#123;</div><div class=\"line\">            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo)&#123;</div><div class=\"line\">                [HYZTrackManager trackRequestWithTrackId:trackId, nil];</div><div class=\"line\">            &#125;error:&amp;error];</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        case 1: &#123;</div><div class=\"line\">            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1)&#123;</div><div class=\"line\">                [HYZTrackManager trackRequestWithTrackId:trackId, p1, nil];</div><div class=\"line\">            &#125;error:&amp;error];</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        case 2: &#123;</div><div class=\"line\">            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2)&#123;</div><div class=\"line\">                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, nil];</div><div class=\"line\">            &#125;error:&amp;error];</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        case 3: &#123;</div><div class=\"line\">            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3)&#123;</div><div class=\"line\">                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, nil];</div><div class=\"line\">            &#125;error:&amp;error];</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        case 4: &#123;</div><div class=\"line\">            [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, id p1, id p2, id p3, id p4)&#123;</div><div class=\"line\">                [HYZTrackManager trackRequestWithTrackId:trackId, p1, p2, p3, p4, nil];</div><div class=\"line\">            &#125;error:&amp;error];</div><div class=\"line\">        &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简单埋点虽然也可以拿到Hook的方法的参数, 但是由于通用性, 所以不能用来传递可变的参数.</p>\n<p>真正的埋点请求是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ (void)trackRequestWithTrackId:(NSString *)trackId, ... NS_REQUIRES_NIL_TERMINATION&#123;</div><div class=\"line\">    // 定义一个指向个数可变的参数列表指针；</div><div class=\"line\">    va_list args;</div><div class=\"line\">    // 用于存放取出的参数</div><div class=\"line\">    NSString *arg;</div><div class=\"line\">    // 初始化变量刚定义的va_list变量，这个宏的第二个参数是第一个可变参数的前一个参数，是一个固定的参数</div><div class=\"line\">    va_start(args, trackId);</div><div class=\"line\">    // 遍历全部参数 va_arg返回可变的参数(a_arg的第二个参数是你要返回的参数的类型)</div><div class=\"line\">    while ((arg = va_arg(args, NSString *))) &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, arg);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 清空参数列表，并置参数指针args无效</div><div class=\"line\">    va_end(args);</div><div class=\"line\">    NSLog(@&quot;此处用来实现埋点事件记录%@的网络请求&quot;, trackId);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此, 实现了简单埋点的方法Hook.</p>\n<h2 id=\"复杂埋点\"><a href=\"#复杂埋点\" class=\"headerlink\" title=\"复杂埋点\"></a>复杂埋点</h2><p>复杂埋点, 因为要传参数进来, 所以我们利用<code>+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;</code>可以传block参数来实现.<br>首先, 我们在<code>HYZTrackList</code>中把类名, 方法名和需要定义的Block关联起来,如下所示.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;kClassName:@&quot;HYZViewController3&quot;,</div><div class=\"line\">kHookFunction:@&quot;trackWithTag:&quot;,</div><div class=\"line\">kHandlerBlock:@&quot;HYZViewController3TrackHandleBlock&quot;,</div><div class=\"line\">kIsLightEvent:@(NO)&#125;</div><div class=\"line\">``` </div><div class=\"line\">在`APPDelegate`中初始化时, 需要在`HYZTrackManager`中实现Block的定义,</div></pre></td></tr></table></figure>\n<p>//hook的block在这里定义和实现</p>\n<ul>\n<li>(void)weightEventEntry:(NSMutableDictionary*)blockDict{<br>  [HYZTrackManager trackButtonAction:blockDict];<br>}</li>\n</ul>\n<p>//block的内部实现</p>\n<ul>\n<li>(void)trackButtonAction:(NSMutableDictionary *)blockDict {<br>  void(^HYZViewController3TrackHandleBlock)(id, NSInteger tag) = ^(id <aspectinfo>aspectInfo, NSInteger tag) {<pre><code>switch (tag) {\n        case 1: {\n            [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n        }\n        break;\n        case 2: {\n            [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n        }\n        break;\n        case 3: {\n            [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n        }\n        break;\n        case 4: {\n            [HYZTrackManager trackRequestWithTrackId:[NSString stringWithFormat:@&quot;%ld&quot;, tag], nil];\n        }\n        break;\n    default:\n        break;\n}\n</code></pre>  };<br>  [blockDict setObject:[HYZViewController3TrackHandleBlock copy] forKey:@”HYZViewController3TrackHandleBlock”];<br>}<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后Hook原方法;</div></pre></td></tr></table></figure>\n</aspectinfo></li>\n</ul>\n<p>//复杂的埋点,</p>\n<ul>\n<li>(void)complexTrackTarget:(Class)target selector:(SEL)selector usingBlock:(id)block {<br>  NSError *error;<br>  [target aspect_hookSelector:selector withOptions:AspectPositionAfter usingBlock:block error:&amp;error];<br>}<br>```</li>\n</ul>\n<p><a href=\"https://github.com/HChong3210/AOPTrack\" target=\"_blank\" rel=\"noopener\">Demo</a><br>参考资料: </p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/dc9dca24d5de\" target=\"_blank\" rel=\"noopener\">iOS 如何实现Aspect Oriented Programming</a></li>\n<li><a href=\"http://www.vienta.me/2016/09/21/AOP%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%80%E7%BB%9F%E8%AE%A1%E5%9F%8B%E7%82%B9/\" target=\"_blank\" rel=\"noopener\">AOP在iOS中的实践——统计埋点</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20160421/15912.html\" target=\"_blank\" rel=\"noopener\">可复用且高度解耦的iOS用户统计实现</a></li>\n<li><a href=\"http://www.cocoachina.com/ios/20150120/10959.html\" target=\"_blank\" rel=\"noopener\">Method Swizzling和AOP(面向切面编程)实践</a></li>\n</ol>\n","categories":["统计打点"],"tags":["解决方案","AOP","统计打点"]},{"title":"设计模式-工厂模式","url":"http://hchong.net/2017/02/08/设计模式-工厂模式/","content":"<h1 id=\"设计模式-工厂模式\"><a href=\"#设计模式-工厂模式\" class=\"headerlink\" title=\"设计模式-工厂模式\"></a>设计模式-工厂模式</h1><p>下面有一个case, 要编写一个简单的计算器程序, 用来实现加减乘除的运算操作, 并且展示出来.我们就拿这个最简单的例子来一步一步见识一下”工厂模式”的魅力.</p>\n<h2 id=\"版本一\"><a href=\"#版本一\" class=\"headerlink\" title=\"版本一\"></a>版本一</h2><p>版本一:我们首先想到的最简单的模式就是我们先从业务上来拆分, 把计算器程序分成两部分<em>计算</em>和<em>展示</em>两个类来写代码.OC作为一门面向对象的语言, 在这里我们已经可以清楚地意识到我们已经使用了<em>封装</em>这面向对象语言的一大特性.但是随着业务的发展, 我们发现可能会增加其他的业务(例如增加其他的运算操作),这是我们每次都要修改<em>计算</em>这个类, 慢慢的代码就会越来越多, 不利于维护.而且在新加逻辑的过程中有可能会修改到老的代码, 维护成本很高.这是我们就会想到其他两个特性<em>继承</em>和<em>多态</em>.于是, 就有了版本二.</p>\n<h2 id=\"版本二\"><a href=\"#版本二\" class=\"headerlink\" title=\"版本二\"></a>版本二</h2><p>这时我们发现,把所有的运算写到一个类中是有些不妥当的, 那么要怎么来修改呢.我们自然地想到, 每一种运算可以单独度的封装为一个类, 只用于实现固定的计算.于是我们可以得到<em>加</em>,<em>减</em>,<em>乘</em>,<em>除</em>四个类, 每个类都三个属性, 分别是<em>操作数</em>和<em>结果</em>.哪里怪怪的呢, 有没有一丝”坏代码”的味道呢.通过提炼我们发现四个类都有相同的三个属性,那么我们可以这样做新建一个<code>Operation</code>操作类, 包含三个<code>Public</code>属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface Operation : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, assign) CGFloat numberA;</div><div class=\"line\">@property (nonatomic, assign) CGFloat numberB;</div><div class=\"line\">@property (nonatomic, assign) CGFloat numberResult;</div><div class=\"line\"></div><div class=\"line\">- (CGFloat)getResult;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这样的话, 只需要每一个单独的计算类继承于<code>Operation</code>类, 就会自带父类的三个属性, 只用在他们内部实现自己独有的计算方法, 返回计算结果就可以了.到这里, 我们会发现代码变得更加有意思了.<br>但是我们又发现了一个新的问题, 那就是我们该何时初始化哪个类呢, 毕竟我们现在有了四个计算子类.我们只好计算结果的地方写<code>Switch</code>条件来判断到底要初始化那一个子类.</p>\n<p>可是仍然感觉哪里还是怪怪的.我们不是还有<em>多态</em>这种特性没有使用的嘛.仔细一想, 于是又有了版本三.</p>\n<h2 id=\"版本三\"><a href=\"#版本三\" class=\"headerlink\" title=\"版本三\"></a>版本三</h2><blockquote>\n<p>多态:多态表示不同的对象可以执行相同的操作, 但要通过他们自己的实现代码来执行.<br>这是我们需要增加一个工厂类<code>OperationFactory</code>, 用来判断要初始化哪一个子类.</p>\n</blockquote>\n<p><code>OperationFactory.h</code>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@class Operation;</div><div class=\"line\">@interface OperationFactory : NSObject</div><div class=\"line\"></div><div class=\"line\">+ (Operation *)createOperationWithOperate:(NSString *)operate;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>OperationFactory.m</code>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@implementation OperationFactory</div><div class=\"line\"></div><div class=\"line\">//传入计算符号, 初始化不同的子类</div><div class=\"line\">+ (Operation *)createOperationWithOperate:(NSString *)operate &#123;</div><div class=\"line\">    if ([operate isEqualToString:@&quot;+&quot;]) &#123;</div><div class=\"line\">        OperationAdd *add = [[OperationAdd alloc] init];</div><div class=\"line\">        return add;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if ([operate isEqualToString:@&quot;-&quot;]) &#123;</div><div class=\"line\">        OperationSubtraction *subtraction = [[OperationSubtraction alloc] init];</div><div class=\"line\">        return subtraction;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>此时展示的地方, 代码就变得很简单了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    // Do any additional setup after loading the view, typically from a nib.</div><div class=\"line\">    Operation *operation = [OperationFactory createOperationWithOperate:@&quot;-&quot;];//子类以父类的身份出现</div><div class=\"line\">    operation.numberA = 3;</div><div class=\"line\">    operation.numberB = 5;</div><div class=\"line\">    CGFloat result = [operation getResult];//子类在工作时以自己的方式实现</div><div class=\"line\">    NSLog(@&quot;%f&quot;, result);</div><div class=\"line\">    NSLog(@&quot;%f&quot;, operation.numberResult);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如上我们可以发现, 整个工厂模式的关键就在于<code>OperationFactory</code>这个工厂类的实现.我们在调用的时候不用关心我们要实现哪一个类, <code>CGFloat result = [operation getResult];</code>, 只用调用父类的方法就可以, 而内部则是子类自己的实现.<br>这里面还有几点要注意:</p>\n<blockquote>\n<ol>\n<li>子类以父类的身份出现</li>\n<li>子类在工作时以自己的方式实现</li>\n<li>子类独有的方法和属性不可以使用</li>\n</ol>\n</blockquote>\n<p>在这里解释一下就是, 我们在展示的时候初始化的实际上是父类<code>Operation</code>.但是在获取计算结果时, 我们使用的是子类的计算方法<code>CGFloat result = [operation getResult];</code>, 因为我们在子类里面复写了父类的方法, 所以实际上走的还是子类各自自己的方法.</p>\n","categories":["设计模式"],"tags":["架构","设计模式"]},{"title":"常见的代码\"坏味道\"","url":"http://hchong.net/2016/12/28/常见的代码坏味道/","content":"<h1 id=\"常见的代码”坏味道”\"><a href=\"#常见的代码”坏味道”\" class=\"headerlink\" title=\"常见的代码”坏味道”\"></a><strong>常见的代码”坏味道”</strong></h1><p>正所谓优雅的代码是相似的, 不优雅的代码却各有各的丑. 最近在拜读&lt;重构- 改善既有代码的设计&gt;一书, 虽然书中大量示例是用Java编写的, 但是也给了我很多启发.<br>见贤思齐, 耗时把感想记录下来, 督促自己的成长. </p>\n<h2 id=\"重复代码\"><a href=\"#重复代码\" class=\"headerlink\" title=\"重复代码\"></a><strong>重复代码</strong></h2><p>坏味道行列中 ,最常见的就是Duplicated Code. 如果你在一个以上的地点看到相同的程序结构, 那么可以肯定: 把他们合而为一, 会使得代码变得更好.</p>\n<ol>\n<li><p>最单纯的Duplicated Code就是”同一个类的两个函数有相同的表达式”, 解决办法就是:</p>\n<ul>\n<li>采用Extract Method(提炼函数)提炼出重复的代码, 然后这两个地方都调用提炼出来的那一段代码.</li>\n</ul>\n</li>\n<li><p>两个互为兄弟的子类内包含相同的表达式, 解决办法就是:</p>\n<ul>\n<li>对两个类都是用Extract Method(提炼函数), 再对提炼出来的代码使用Pull Up Method(函数上移)</li>\n<li>如果代码只是类似而不完全相同, 那就要先使用Extract Method(提炼函数)将相似和差异的代码分隔开, 构造成一个单独的函数, 然后再<em>塑造模板函数</em></li>\n</ul>\n</li>\n<li><p>如果两个毫不相关的类出现Duplicated Code, 应该把重复代码提炼到一个独立类中, 然后再另一个类中使用这个新类</p>\n</li>\n</ol>\n<blockquote>\n<p>函数上移(Pull Up Method): 若干个身处子类中的函数, 他们又可以通过某种形式的参数调整成为相同的函数. 这时候, 最简单的方法就是首先分别调整这些函数的参数, 然后再将他们概括到父类中去. 特殊情况: 当子类的函数覆写了父类的函数, 但却仍然做相同的工作.</p>\n<p>塑造模板函数(Form Template Method): 两个函数以相同顺序执行大致相近的操作, 但是各操作不完全相同. 这种情况下我们可以将执行操作的序列移至父类, 并借助多态保证各操仍得以保持差异性.</p>\n</blockquote>\n<h2 id=\"过长函数-Long-Method\"><a href=\"#过长函数-Long-Method\" class=\"headerlink\" title=\"过长函数(Long Method)\"></a><strong>过长函数(Long Method)</strong></h2><p>程序愈长愈难理解.<br>我们应该积极地分解函数, 只要你感觉需要在一个地方加注释, 我们就要把需要说明的东西写进一个独立函数, 并以其用途(而非实现手法)命名. 哪怕替换后的函数调用动作比函数自身还长, 只要函数名称能够解释其用途, 我们就应该毫不犹豫地那么做, 关键不在于函数的长度, 而在于”做什么”和”如何做”之间的语义距离.</p>\n<ol>\n<li>大多数场合, 把函数变小, 只需使用Extract Method(提炼函数). 找到函数中适合集中在一起的部分, 将他们提炼出来一个新函数.</li>\n<li>如果函数中有大量的参数和临时变量, 他们会对你的函数提炼形成阻碍. 如果</li>\n</ol>\n<h2 id=\"过大的类-Large-Class\"><a href=\"#过大的类-Large-Class\" class=\"headerlink\" title=\"过大的类(Large Class)\"></a><strong>过大的类(Large Class)</strong></h2><h2 id=\"过长参数列-Long-Parameter-List\"><a href=\"#过长参数列-Long-Parameter-List\" class=\"headerlink\" title=\"过长参数列(Long Parameter List)\"></a><strong>过长参数列(Long Parameter List)</strong></h2><h2 id=\"发散式变化-Divergent-Change\"><a href=\"#发散式变化-Divergent-Change\" class=\"headerlink\" title=\"发散式变化(Divergent Change)\"></a><strong>发散式变化(Divergent Change)</strong></h2><h2 id=\"霰弹式修改-Shotgun-Surgery\"><a href=\"#霰弹式修改-Shotgun-Surgery\" class=\"headerlink\" title=\"霰弹式修改(Shotgun Surgery)\"></a><strong>霰弹式修改(Shotgun Surgery)</strong></h2><h2 id=\"依恋情结-Feature-Envy\"><a href=\"#依恋情结-Feature-Envy\" class=\"headerlink\" title=\"依恋情结(Feature Envy)\"></a><strong>依恋情结(Feature Envy)</strong></h2><h2 id=\"数据泥团-Data-Clumps\"><a href=\"#数据泥团-Data-Clumps\" class=\"headerlink\" title=\"数据泥团(Data Clumps)\"></a><strong>数据泥团(Data Clumps)</strong></h2><h2 id=\"基本类型偏执-Primitive-Obsession\"><a href=\"#基本类型偏执-Primitive-Obsession\" class=\"headerlink\" title=\"基本类型偏执(Primitive Obsession)\"></a><strong>基本类型偏执(Primitive Obsession)</strong></h2><h2 id=\"Switch-惊悚现身-Switch-Statements\"><a href=\"#Switch-惊悚现身-Switch-Statements\" class=\"headerlink\" title=\"Switch 惊悚现身(Switch Statements)\"></a><strong>Switch 惊悚现身(Switch Statements)</strong></h2><h2 id=\"平行继承体系-Parallel-Inheritance-Hierarchies\"><a href=\"#平行继承体系-Parallel-Inheritance-Hierarchies\" class=\"headerlink\" title=\"平行继承体系(Parallel Inheritance Hierarchies)\"></a><strong>平行继承体系(Parallel Inheritance Hierarchies)</strong></h2><h2 id=\"冗赘类-Lazy-Class\"><a href=\"#冗赘类-Lazy-Class\" class=\"headerlink\" title=\"冗赘类(Lazy Class)\"></a><strong>冗赘类(Lazy Class)</strong></h2><h2 id=\"夸夸其谈未来性-Speculative-Generatlity\"><a href=\"#夸夸其谈未来性-Speculative-Generatlity\" class=\"headerlink\" title=\"夸夸其谈未来性(Speculative Generatlity)\"></a><strong>夸夸其谈未来性(Speculative Generatlity)</strong></h2><h2 id=\"令人迷惑的暂时字段-Temporary-Field\"><a href=\"#令人迷惑的暂时字段-Temporary-Field\" class=\"headerlink\" title=\"令人迷惑的暂时字段(Temporary Field)\"></a><strong>令人迷惑的暂时字段(Temporary Field)</strong></h2><h2 id=\"过度耦合的消息链-Message-Chains\"><a href=\"#过度耦合的消息链-Message-Chains\" class=\"headerlink\" title=\"过度耦合的消息链(Message Chains)\"></a><strong>过度耦合的消息链(Message Chains)</strong></h2><h2 id=\"中间人-Middle-Man\"><a href=\"#中间人-Middle-Man\" class=\"headerlink\" title=\"中间人(Middle Man)\"></a><strong>中间人(Middle Man)</strong></h2><h2 id=\"狎昵关系-Inappropriate-Intimacy\"><a href=\"#狎昵关系-Inappropriate-Intimacy\" class=\"headerlink\" title=\"狎昵关系(Inappropriate Intimacy)\"></a><strong>狎昵关系(Inappropriate Intimacy)</strong></h2><h2 id=\"异曲同工的类-AlertNative-Classes-with-Different-Interfaces\"><a href=\"#异曲同工的类-AlertNative-Classes-with-Different-Interfaces\" class=\"headerlink\" title=\"异曲同工的类(AlertNative Classes with Different Interfaces)\"></a><strong>异曲同工的类(AlertNative Classes with Different Interfaces)</strong></h2><h2 id=\"不完美的库类-Incomplete-Library-Class\"><a href=\"#不完美的库类-Incomplete-Library-Class\" class=\"headerlink\" title=\"不完美的库类(Incomplete Library Class)\"></a><strong>不完美的库类(Incomplete Library Class)</strong></h2><h2 id=\"纯稚的数据类-Data-Class\"><a href=\"#纯稚的数据类-Data-Class\" class=\"headerlink\" title=\"纯稚的数据类(Data Class)\"></a><strong>纯稚的数据类(Data Class)</strong></h2><h2 id=\"被拒绝的遗赠-Refused-Bequest\"><a href=\"#被拒绝的遗赠-Refused-Bequest\" class=\"headerlink\" title=\"被拒绝的遗赠(Refused Bequest)\"></a><strong>被拒绝的遗赠(Refused Bequest)</strong></h2><h2 id=\"过多的注释-COmments\"><a href=\"#过多的注释-COmments\" class=\"headerlink\" title=\"过多的注释(COmments)\"></a><strong>过多的注释(COmments)</strong></h2>","categories":["架构"],"tags":["重构","架构"]},{"title":"代码重构与拆分","url":"http://hchong.net/2016/12/26/代码重构与拆分/","content":"<h1 id=\"代码的重构与拆分\"><a href=\"#代码的重构与拆分\" class=\"headerlink\" title=\"代码的重构与拆分\"></a><strong>代码的重构与拆分</strong></h1><p>最近项目中有一块代码, 几经人手, 流落到我这里. 代码的业务逻辑十分复杂, 而且随着业务的扩张, 被不同的人加入而不同风格的代码, 最初的架构已经不适合现有业务的发展了, 维护起来也是相当的困难. 于是, 我就走上了重构和拆分之路.</p>\n<p>实际上来讲, 重构和拆分是两个不同的概念, 但是又都是相辅相成, 下面我简单讲一下我的理解.</p>\n<blockquote>\n<p>重构: 对软件内部结构的一种调整, 目的是在不改变软件可观察行为的前提下, 提高其可理解性, 降低其修改成本.</p>\n</blockquote>\n<ul>\n<li>拆分: 整体项目的架构, 降低代码的耦合性, 使得团队中的成员协作使用起来更加容易.</li>\n</ul>\n<p>不管重构还是拆分, 都是为了让代码能够跟上业务发展的水平, 不至于变得一团乱麻, 让团队之间的协作开发更加有效.</p>\n","categories":["架构"],"tags":["重构","拆分"]},{"title":"hexo常见问题","url":"http://hchong.net/2016/12/21/hexo常见问题/","content":"<h1 id=\"hexo常见问题\"><a href=\"#hexo常见问题\" class=\"headerlink\" title=\"hexo常见问题\"></a><strong>hexo常见问题</strong></h1><p>在使用hexo的过程中遇到了一些问题, 在这里列出来, 做一个记录.</p>\n<h2 id=\"hexo的常见发布流程\"><a href=\"#hexo的常见发布流程\" class=\"headerlink\" title=\"hexo的常见发布流程\"></a><strong>hexo的常见发布流程</strong></h2><ul>\n<li>hexo新建一篇文章使用<code>hexo new type name</code>, <code>type</code>有三种, 最常使用的是<code>post</code>, <code>name</code>是新建文档的名字.</li>\n<li><p>hexo新建完成, 编辑之后发布会经常使用到下面几个命令:</p>\n<ul>\n<li><code>hexo clean</code>清除之前缓存的一些信息, 例如主题之类的, 不是每次都必须执行.</li>\n<li><code>hexo g</code>相当于编译.</li>\n<li><code>hexo s</code>发布到本地服务器, 把<em>.md</em>文件生成讲台html用于展示, 也可做调试用.</li>\n<li><code>hexo d</code>推本地的文件到服务器, 这里指的是github上面, 如果绑定的有域名, 就直接发布到Internet. 每次推送前, 要确保<code>hexo g</code>和<code>hexo s</code>没有问题, 否则可造成Internet上面无法正常显示.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"hexo目录结构分析\"><a href=\"#hexo目录结构分析\" class=\"headerlink\" title=\"hexo目录结构分析\"></a><strong>hexo目录结构分析</strong></h2><h3 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a><strong>根目录</strong></h3><ul>\n<li>_config.yml: 位于本地博客的根目录下, 在这里面对整个博客的内容进行一些设置.</li>\n<li>source文件夹: 里面存储一些博客使用的文件资源, 例如<em>category(分类)</em>, <em>tag(标签)</em>, <em>link(链接)</em>, <em>about(关于)</em>, <em>project(工程)</em>, <em>search(搜索)</em>, *_posts(使用post格式新建的文章.md文件存储在这里).需要说明一下的是, 这些文件夹的名称和数量不固定, 要看你使用的主题里面的模块大概有几个 ,我使用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"noopener\">fexo</a>.还有一些坑, 后面再详述.</li>\n<li>public文件夹: 里面存储的是之前发布过得一些归档数据, 如果要删除之前的测试数据的话, 记得清理里面响应的内容.</li>\n<li>scaffolds文件夹: 存储.md文档的类型.</li>\n<li>themes文件夹: 里面是你下载的主题内容, 如果有多个主题, 就会有多个文件夹, 但只能同时使用一种样式的主题.这个后面会着重分析一下.</li>\n</ul>\n<h3 id=\"themes文件夹\"><a href=\"#themes文件夹\" class=\"headerlink\" title=\"themes文件夹\"></a><strong>themes文件夹</strong></h3><p>这里面主要会进行一些主题相关的设置.</p>\n<ul>\n<li>_config.yml: 位于主题目录下, 在这里面对当前只用主题的内容进行一些配置, 不同主题的配置可能不太一样, 我是用的是<a href=\"http://forsigner.com/2016/03/10/fexo-doc-zh-cn/\" target=\"_blank\" rel=\"noopener\">fexo</a></li>\n</ul>\n<ul>\n<li>source文件夹: 该文件夹下面是该主题相关的一些资源, 例如一些静态的图片之类的.</li>\n<li>layout文件夹: 该文件夹下面是静态页面显示的相关配置. 代码高亮的设置也是在该文件夹下面. 其他的例如静态页面的展示, 可以修改相关的js文件.</li>\n</ul>\n<h2 id=\"修改代码高亮\"><a href=\"#修改代码高亮\" class=\"headerlink\" title=\"修改代码高亮\"></a><strong>修改代码高亮</strong></h2><p>代码高亮的展示, 不同的主题有不同的使用方式, 但是代码高亮的theme可以参考这里, 我使用的是<a href=\"https://highlightjs.org/static/demo/\" target=\"_blank\" rel=\"noopener\">HighLight</a>, 它提供了多种Theme, 基本上能满足各种需求.</p>\n<p>修改步骤如下:</p>\n<p>1.修改博客根目录下的<em>_config.yml</em>文件, 关闭hexo自带的代码高亮.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">highlight:</div><div class=\"line\">  enable: <span class=\"literal\">false</span></div><div class=\"line\">  line_number: <span class=\"literal\">false</span></div><div class=\"line\">  auto_detect: <span class=\"literal\">false</span></div><div class=\"line\">  tab_replace:</div></pre></td></tr></table></figure>\n<p>2.<code>cd 博客根目录/themes/fexo/layout/_partial</code>打开<em>head.ejs</em>文件, 最好是在<code>&lt;head&gt;&lt;/head&gt;</code>之间开头处插入代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css&quot;&gt;</div><div class=\"line\">&lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>也可以使用下面的写法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/styles/default.css&quot;&gt;</div><div class=\"line\">&lt;script src=&quot;/path/to/highlight.pack.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>二者的区别在于, 第一种写法使用的是CDN创建的<a href=\"http://www.bootcdn.cn/?\" target=\"_blank\" rel=\"noopener\">在线文档地址</a>, 该地址还保存了其他一些常见的文档, 非常强大.而第二种写法则是把文件下载到本地, 从本地读取代码高亮的配置.</p>\n<hr>\n<p>修改过程中, 我参考了以下两篇博文, 还趟过不少坑, 贴上博文的地址:</p>\n<ol>\n<li><a href=\"http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-highlight/\" target=\"_blank\" rel=\"noopener\">地址一</a></li>\n<li><a href=\"http://jumpbyte.cn/2016/07/02/use-and-install-prettify/\" target=\"_blank\" rel=\"noopener\">地址二</a></li>\n</ol>\n","categories":["hexo"],"tags":["hexo","个人博客"]},{"title":"属性修饰符之copy和strong","url":"http://hchong.net/2016/09/21/属性修饰符之copy和strong/","content":"<h1 id=\"属性修饰符之copy和strong\"><a href=\"#属性修饰符之copy和strong\" class=\"headerlink\" title=\"属性修饰符之copy和strong\"></a>属性修饰符之copy和strong</h1><p>在了解属性修饰符的copy和strong的区分之前, 我们先来了解下浅拷贝和深拷贝的区别.</p>\n<h2 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h2><p>浅复制并不是拷贝对象本身, 仅仅是拷贝指向对象的指针; 深复制是直接拷贝整个对象内存到另一块内存中. 简单地说:</p>\n<ul>\n<li><strong>浅复制就是指针拷贝,  不会产生新的对象，指向的是同一个对象; </strong></li>\n<li><strong>深复制就是内容拷贝，会产生新的对象, 不同的对象, 内容相同.</strong></li>\n</ul>\n<p><img src=\"http://7s1ssm.com1.z0.glb.clouddn.com/image_note50592_1.png\" alt=\"浅复制和深复制\"></p>\n<h2 id=\"copy和mutableCopy\"><a href=\"#copy和mutableCopy\" class=\"headerlink\" title=\"copy和mutableCopy\"></a>copy和mutableCopy</h2><p><code>copy</code>就是复制了一个imutable对象, <code>mutableCopy</code>就是复制了一个mutable对象.</p>\n<p>一个<code>NSObject</code>对象要想使用这两个函数, 必须实现<code>NSCopying</code>协议和<code>NSMutableCopying</code>协议, 并且分别实现<code>- (id)copyWithZone:(nullable NSZone *)zone;</code>和<code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code>方法.但是常见的<code>NSString</code>, <code>NSArray</code>, <code>NADictionary</code>等常用的系统提供的结构体都已经实现. </p>\n<h3 id=\"系统的非容器类对象\"><a href=\"#系统的非容器类对象\" class=\"headerlink\" title=\"系统的非容器类对象\"></a>系统的非容器类对象</h3><p>这里指的是<code>NSString</code>, <code>NSNumber</code>等等一类的对象.下面以<code>NSString</code>为例.</p>\n<p>对<code>NSString</code>进行copy和mutableCop操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSString *originString = @&quot;origin&quot;;</div><div class=\"line\">NSString *originStringCopy = [originString copy];</div><div class=\"line\">NSMutableString *originStringMutableCopy = [originString mutableCopy];</div><div class=\"line\">NSLog(@&quot;%p, %p, %p&quot;, originString, originStringCopy, originStringMutableCopy);</div></pre></td></tr></table></figure>\n<p>内存地址分别是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(lldb) p originString</div><div class=\"line\">(__NSCFConstantString *) $0 = 0x0000000108dd8190 @&quot;origin&quot;</div><div class=\"line\">(lldb) p originStringCopy</div><div class=\"line\">(__NSCFConstantString *) $1 = 0x0000000108dd8190 @&quot;origin&quot;</div><div class=\"line\">(lldb) p originStringMutableCopy</div><div class=\"line\">(__NSCFString *) $2 = 0x0000608000262800 @&quot;origin&quot;</div></pre></td></tr></table></figure>\n<hr>\n<p>对<code>NSMutableString</code>进行copy和mutableCopy操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSMutableString *mutableOriginString = [NSMutableString stringWithString:@&quot;mutableOrigin&quot;];</div><div class=\"line\">NSString *mutableOriginStringCopy = [mutableOriginString copy];</div><div class=\"line\">NSMutableString *mutableOriginStringMutableCopy = [mutableOriginString mutableCopy];</div></pre></td></tr></table></figure>\n<p>内存地址分别是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(lldb) p mutableOriginString</div><div class=\"line\">(__NSCFString *) $0 = 0x000060800026aa40 @&quot;mutableOrigin&quot;</div><div class=\"line\">(lldb) p mutableOriginStringCopy</div><div class=\"line\">(__NSCFString *) $1 = 0x0000608000222340 @&quot;mutableOrigin&quot;</div><div class=\"line\">(lldb) p mutableOriginStringMutableCopy</div><div class=\"line\">(__NSCFString *) $2 = 0x000060800026a700 @&quot;mutableOrigin&quot;</div></pre></td></tr></table></figure>\n<p>这里要注意的是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSMutableString *mutableOriginStringCopy = [mutableOriginString copy];</div><div class=\"line\">[mutableOriginStringCopy appendString:@&quot;123&quot;];</div></pre></td></tr></table></figure>\n<p>这样写是会crash的, 因为copy生成的是imutable对象, 不管声明是什么样的, 依旧是imutable的.</p>\n<p><strong>综上, 对于系统的非容器类对象:</strong></p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n</ul>\n<h3 id=\"系统的容器类对象\"><a href=\"#系统的容器类对象\" class=\"headerlink\" title=\"系统的容器类对象\"></a>系统的容器类对象</h3><p>容器类对象指的是<code>NSArray</code>, <code>NSDictionary</code>, <code>NSSet</code>等系统提供的结构体, 下面以<code>NSArray</code>为例.</p>\n<p>对<code>NSArray</code>进行copy操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSArray *originArray = [NSArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,nil];</div><div class=\"line\">NSArray *originArrayCopy = [originArray copy];</div><div class=\"line\">NSMutableArray *originArrayMutableCopy = [originArray mutableCopy];</div><div class=\"line\">for (NSInteger i = 0; i &lt; originArray.count; i++) &#123;</div><div class=\"line\">    NSLog(@&quot;originArray--%p&quot;, originArray[i]);</div><div class=\"line\">    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);</div><div class=\"line\">    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内存地址分别是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(lldb) p originArray</div><div class=\"line\">(__NSArrayI *) $0 = 0x00006080002405a0 @&quot;3 elements&quot;</div><div class=\"line\">(lldb) p originArrayCopy</div><div class=\"line\">(__NSArrayI *) $1 = 0x00006080002405a0 @&quot;3 elements&quot;</div><div class=\"line\">(lldb) p originArrayMutableCopy</div><div class=\"line\">(__NSArrayM *) $2 = 0x00006080002403c0 @&quot;3 elements&quot;</div></pre></td></tr></table></figure>\n<p>可以看出, copy是浅复制, mutableCopy是深复制. 需要注意的是,mutableCopy的对象是一个可变对象,  数组内元素全都是浅复制.</p>\n<hr>\n<p>对<code>NSMutableArray</code>进行copy和mutableCopy操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];</div><div class=\"line\">NSArray *originArrayCopy = [originArray copy];</div><div class=\"line\">NSMutableArray *originArrayMutableCopy = [originArray mutableCopy];</div><div class=\"line\">for (NSInteger i = 0; i &lt; originArray.count; i++) &#123;</div><div class=\"line\">    NSLog(@&quot;originArray--%p&quot;, originArray[i]);</div><div class=\"line\">    NSLog(@&quot;originArrayCopy--%p&quot;, originArrayCopy[i]);</div><div class=\"line\">    NSLog(@&quot;originArrayMutableCopy--%p&quot;, originArrayMutableCopy[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印内存地址如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(lldb) p originArray</div><div class=\"line\">(__NSArrayM *) $0 = 0x000060800005eae0 @&quot;3 elements&quot;</div><div class=\"line\">(lldb) p originArrayCopy</div><div class=\"line\">(__NSArrayI *) $1 = 0x000060800005e9f0 @&quot;3 elements&quot;</div><div class=\"line\">(lldb) p originArrayMutableCopy</div><div class=\"line\">(__NSArrayM *) $2 = 0x000060800005e900 @&quot;3 elements&quot;</div></pre></td></tr></table></figure>\n<p>可以发现可以看出, copy是浅复制, mutableCopy是深复制. 数组内元素都是浅复制.</p>\n<p>需要注意的是, mutable对象copy的对象是imutable对象, 如果当做可变对象来用是会崩溃的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSMutableArray *originArray = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;, nil];</div><div class=\"line\">NSMutableArray *originArrayCopy1 = [originArray copy];</div><div class=\"line\">[originArrayCopy1 addObject:@&quot;d&quot;];//crash</div></pre></td></tr></table></figure>\n<p>综上, 对于容器类对象:</p>\n<ul>\n<li><strong>如果对一不可变对象复制, copy是指针复制(浅复制), mutableCopy是内容复制(深复制).</strong></li>\n<li><strong>如果对一可变对象复制, 都是深复制, 但是copy返回的对象是不可变的.</strong></li>\n<li><strong>元素对象是浅复制.</strong></li>\n</ul>\n<h3 id=\"系统类对象的完全深复制\"><a href=\"#系统类对象的完全深复制\" class=\"headerlink\" title=\"系统类对象的完全深复制\"></a>系统类对象的完全深复制</h3><p>对于容器类对象而言, 元素对象始终是浅复制, 要想深复制可通过如下方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">NSArray *array = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],[NSString stringWithString:@&quot;b&quot;],@&quot;c&quot;,nil];</div><div class=\"line\">NSArray *deepCopyArray=[[NSArray alloc] initWithArray: array copyItems: YES];</div><div class=\"line\">NSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject: array]];</div></pre></td></tr></table></figure>\n<p>打印元素内存地址可以发现, trueDeepCopyArray的元素都是深复制, 而deepCopyArray由于第一个元素是可变对象, 所以是深复制, 其他的元素都是浅复制.</p>\n<p><strong>综上, 要想实现容器对象所有元素的深复制, 只能通过归档来实现.</strong></p>\n<blockquote>\n<p>If you need a true deep copy, such as when you have an array of arrays, you can archive and then unarchive the collection, provided the contents all conform to the <code>NSCoding</code> protocol</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">@protocol NSCoding</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder;</div><div class=\"line\">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"自定义对象\"><a href=\"#自定义对象\" class=\"headerlink\" title=\"自定义对象\"></a>自定义对象</h3><p>对于自定义对象, 我们要实现<code>NSCopying</code>, <code>NSMutableCopying</code>协议, 这样我们就能调用copy和mutableCopy了.假设有一个<code>Person</code>类, 继承于<code>NSObject</code>.</p>\n<p><code>person.h</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">@interface Person : NSobject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, assign) NSInteger age;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>person.m</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#import &quot;Person.h&quot;</div><div class=\"line\">@interface Person()&lt;NSCopying&gt;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation Person</div><div class=\"line\">  </div><div class=\"line\">- (id)copyWithZone:(NSZone *)zone &#123;</div><div class=\"line\">\tPerson *person = [[Person allocWithZone:zone] init];</div><div class=\"line\">  \tperson.age = self.age;</div><div class=\"line\">    return person;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这样当我们在外面调用的时候:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person *p = [[Person alloc] init];</div><div class=\"line\">p.age = 20;</div><div class=\"line\"></div><div class=\"line\">Person *copyP = [p copy];</div><div class=\"line\">NSLog(@&quot;p = %p copyP = %p&quot;, p, copyP);</div><div class=\"line\">NSLog(@&quot;age = %ld&quot;, copyP.age);</div></pre></td></tr></table></figure>\n<p>通过打印地址:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(lldb) p p</div><div class=\"line\">(Person *) $0 = 0x000060800002a1e0</div><div class=\"line\">(lldb) p copyP</div><div class=\"line\">(Person *) $1 = 0x000060800002a2e0</div><div class=\"line\">(lldb) p p.age</div><div class=\"line\">(NSInteger) $2 = 20</div><div class=\"line\">(lldb) p copyP.age</div><div class=\"line\">(NSInteger) $4 = 20</div></pre></td></tr></table></figure>\n<p>我们可以发现, 自定义对象内部的属性都被浅拷贝, 自定义对象本身被深拷贝.</p>\n<p>需要注意的是, 如果我们的自定义对象不实现<code>NSCopying</code>协议而直接copy时, 是会crash的.</p>\n<h2 id=\"属性修饰之copy与strong\"><a href=\"#属性修饰之copy与strong\" class=\"headerlink\" title=\"属性修饰之copy与strong\"></a>属性修饰之copy与strong</h2><p>我们新建一个<code>Person</code>类, 添加几个属性来看一下copy和strong对属性使用的影响.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface Person : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, strong) NSString *strongName;</div><div class=\"line\">@property (nonatomic, copy) NSString *copyName;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在外面调用<code>Person</code>类, 代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Person *person = [[Person alloc] init];</div><div class=\"line\">NSMutableString *testString = [NSMutableString stringWithString:@&quot;test&quot;];</div><div class=\"line\">person.nameCopy = testString;</div><div class=\"line\">person.nameStrong = testString;</div><div class=\"line\">[testString appendString:@&quot;copy&amp;&amp;strong&quot;];</div></pre></td></tr></table></figure>\n<p>打印<code>testString</code>改变前后属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//testString改变前</div><div class=\"line\">(lldb) p person.nameCopy</div><div class=\"line\">(NSTaggedPointerString *) $1 = 0xa000000747365744 @&quot;test&quot;</div><div class=\"line\">(lldb) p person.nameStrong</div><div class=\"line\">(__NSCFString *) $2 = 0x0000600000260540 @&quot;test&quot;</div><div class=\"line\">//testString改变后</div><div class=\"line\">(lldb) p person.nameCopy</div><div class=\"line\">(NSTaggedPointerString *) $3 = 0xa000000747365744 @&quot;test&quot;</div><div class=\"line\">(lldb) p person.nameStrong</div><div class=\"line\">(__NSCFString *) $4 = 0x0000600000260540 @&quot;testcopy&amp;&amp;strong&quot;</div></pre></td></tr></table></figure>\n<p>由以上可以看出:</p>\n<p>对源头是<code>NSMutableString</code>的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的，它也会跟着改变, 相当于浅拷贝; 而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>\n<p>当源字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>\n<p>这里还有一个性能问题，即在源字符串是<code>NSMutableString</code>，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是<code>NSString</code>时，则没有这个问题。</p>\n<p>综上可以发现, 如果property是<code>NSString</code>或者<code>NSArray</code>及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。</p>\n<p>参考文档:</p>\n<p>1.<a href=\"http://www.fanliugen.com/?p=278\" target=\"_blank\" rel=\"noopener\">copy与mutableCopy</a></p>\n<p>2.<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3\" target=\"_blank\" rel=\"noopener\">Copying Collections</a></p>\n<p>3.<a href=\"http://www.jianshu.com/p/e6a7cdcc705d\" target=\"_blank\" rel=\"noopener\">iOS浅谈: 深.浅拷贝与copy.strong</a></p>\n<p>4.<a href=\"http://www.cocoachina.com/ios/20150512/11805.html\" target=\"_blank\" rel=\"noopener\">NSString属性什么时候用copy，什么时候用strong?</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"内存分配","url":"http://hchong.net/2016/09/18/内存分配/","content":"<h1 id=\"iOS开发的内存分配\"><a href=\"#iOS开发的内存分配\" class=\"headerlink\" title=\"iOS开发的内存分配\"></a>iOS开发的内存分配</h1><p>计算机系统中, 应用程序的数据都保存在内存中, 不同类型的数据, 保存的区域不同.</p>\n<h2 id=\"RAM-ROM\"><a href=\"#RAM-ROM\" class=\"headerlink\" title=\"RAM ROM\"></a>RAM ROM</h2><blockquote>\n<p>RAM: 运行内存, 不能掉电存储.ROM: 存储型内存, 可以掉电存储, 例如内存卡, FLash.<br>    由于RAM类型不具备掉电存储的能力, 所以App程序一般存放在RMO中. RAM的访问速度和价格都高于ROM.</p>\n</blockquote>\n<h2 id=\"App程序启动\"><a href=\"#App程序启动\" class=\"headerlink\" title=\"App程序启动\"></a>App程序启动</h2><blockquote>\n<p>App程序启动, 系统会把开启的那个App程序从Flash或ROM里面拷贝到内存(RAM)中, 然后从内存里面执行代码.<br>    另外一个原因是CPU不能直接从内存卡里面读取指令(需要Flash驱动等等)</p>\n</blockquote>\n<h2 id=\"内存分区\"><a href=\"#内存分区\" class=\"headerlink\" title=\"内存分区\"></a>内存分区</h2><h3 id=\"栈区-stack\"><a href=\"#栈区-stack\" class=\"headerlink\" title=\"栈区(stack)\"></a>栈区(stack)</h3><p>栈区由编译器自动分配并且释放, 存放局部变量, 函数的参数值, 函数跳转地址, 现场保护等.栈是系统数据结构, 对应线程/进程是唯一的. iPhone的栈区大小是512K.</p>\n<p>栈空间分配分为静态分配和动态分配两种.</p>\n<ul>\n<li>静态分配是由便一起完成, 比如自动变量<code>auto</code>的分配. 动态分配由<code>alloca</code>函数完成.</li>\n<li>栈的动态分配无需释放, 系统会自动释放, 没有释放函数. 系统不鼓励栈的动态分配.</li>\n</ul>\n<p>关于栈还需要注意:</p>\n<ul>\n<li>不需要我们管理栈区变量的内存</li>\n<li>栈区地址从高到低分配</li>\n<li>先进后出</li>\n</ul>\n<h3 id=\"堆区-heap\"><a href=\"#堆区-heap\" class=\"headerlink\" title=\"堆区(heap)\"></a>堆区(heap)</h3><p>堆区由我们分配(iOS下的<code>alloc</code>)和释放, 如果不释放, 在程序结束时, 可能会由系统回收(iOS的ARC下). 灵活方便, 数据适应面广, 但是因为顺序随意, 所以效率有一定降低.<br>关于堆还需要注意:</p>\n<ul>\n<li>堆区的内存分配使用<code>alloc</code>.</li>\n<li>需要程序猿管理.</li>\n<li>ARC下的内存管理由编译器自动添加<code>retain</code>, <code>release</code>, <code>autorelease</code>等关键字.</li>\n<li>堆区的地址由低到高分配.</li>\n<li>不同堆分配的内存无法互相互操作(不同App之间内存无法相互管理).</li>\n<li>堆空间的分配总是动态的.</li>\n</ul>\n<h3 id=\"全局区-static\"><a href=\"#全局区-static\" class=\"headerlink\" title=\"全局区(static)\"></a>全局区(static)</h3><p>全局区也叫作静态区. 全局变量和静态变量在内存中是放在一起的, 初始化的全局变量和静态变量放在一块区域, 未初始化的全局变量和静态变量放在相邻的另一块区域. 程序结束后由系统释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">int a;//未初始化的</div><div class=\"line\">int b = 10;//初始化的</div></pre></td></tr></table></figure>\n<h3 id=\"常量区\"><a href=\"#常量区\" class=\"headerlink\" title=\"常量区\"></a>常量区</h3><p>常量字符串就存放在这里, 程序结束后由系统自己释放.</p>\n<h3 id=\"代码区\"><a href=\"#代码区\" class=\"headerlink\" title=\"代码区\"></a>代码区</h3><p>代码区也叫作函数区, 存放函数的二进制代码, App的代码. 程序结束后由系统释放</p>\n<h2 id=\"内存申请后的系统响应\"><a href=\"#内存申请后的系统响应\" class=\"headerlink\" title=\"内存申请后的系统响应\"></a>内存申请后的系统响应</h2><p>1.栈: 存储的函数在执行的时候都会向操作系统索要资源, 栈区就是函数运行时的内训, 栈区中的变量由编译器负责释放和分配, 内存随着函数的运行和结束而分配和释放, 由系统完成. 只要剩余的栈空间大于申请空间, 系统将会为程序提供内存, 否则将报异常提示栈溢出.<br>2.堆: 操作系统有一个记录空闲地址的链表, 当系统收到程序申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序. 由于找到的堆节点大小不一定正合适, 系统会将多余的那部分重新放入空闲链表.</p>\n<h2 id=\"申请内存后系统的响应\"><a href=\"#申请内存后系统的响应\" class=\"headerlink\" title=\"申请内存后系统的响应\"></a>申请内存后系统的响应</h2><ol>\n<li><p>栈: 栈是向低内存扩展的数据结构, 是一块连续的内存, 栈顶地址和栈的最大容量是事先规定好的, 如果申请的空间超过栈的剩余空间, 将会提示overflow.</p>\n</li>\n<li><p>堆: 操作系统有一个记录空闲内存地址的链表. 当系统收到申请时, 会遍历该链表, 寻找第一个空间大于所申请空间的堆结点, 然后将该结点从链表中删除, 并将该结点的空间分配给程序. 由于找到的堆结点不一定和申请的大小刚好一致, 系统会将多余的那一部分重新放回到链表中去.  堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储的空闲内存地址, 自然是不连续的, 而链表的遍历方向是由低地址向高地址. 堆的大小受限于计算机系统中有效的虚拟内存.</p>\n</li>\n</ol>\n<h2 id=\"申请大小的限制\"><a href=\"#申请大小的限制\" class=\"headerlink\" title=\"申请大小的限制\"></a>申请大小的限制</h2><ol>\n<li><p>栈: 栈是向低地址扩展的数据结构, 是一块儿连续的内存区域. 栈顶的地址和栈的最大容量是系统预先规定好的, 栈的大小是2M(也有的说是1M, 总之是一个编译时就确定的常数), 如果申请的空间超过栈的剩余空间时, 将提示overflow. 因此, 能从栈获得的空间较小.</p>\n</li>\n<li><p>堆: 堆是向高地址扩展的数据结构, 是不连续的内存区域. 这是由于系统是用链表来存储空闲的内存地址的, 自然是不连续的, 而链表的遍历是由低地址到高地址. 堆的大小受限于计算机系统中有效的虚拟内存. 堆获得的空间比较灵活, 也比较大. </p>\n</li>\n</ol>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>如图所示: 代码区的地址最低, 栈区最高. 但是区与区之间的地址不连续.<br><img src=\"http://upload-images.jianshu.io/upload_images/1156719-1d0de5ca1edc35af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"内存地址示意图\"></p>\n<ul>\n<li>栈：由系统自动分配, 速度较快, 不会产生内存碎片. 堆：是由alloc分配的内存, 速度比较慢, 而且容易产生内存碎片, 不过用起来最方便.</li>\n<li>在iOS中, 堆区的内存是程序间共享, 堆区的内存分配是系统负责的.</li>\n<li>系统使用一个链表来维护已分配的内存空间(仅仅记录, 不管理具体的内容).</li>\n<li>变量使用结束后, 需要释放内存, OC中是当引用计数==0, 就说明没有任何变量使用这块空间, 系统将直接收回.</li>\n<li>当一个app启动时, 代码区, 常量区, 全局区的大小实际已经固定, 因此指向这些区域的内存不会产生崩溃性错误. 堆区和栈区的内存是时刻变化的, 使用一个已经被释放的内存, 很容易产生野指针崩溃.</li>\n<li>栈由系统自动分配, 速度快, 不会产生内存碎片, 先进后出.</li>\n<li>堆由<code>alloc</code>分配内存, 速度慢, 而且容易产生碎片, FIFO, 不过使用起来方便.</li>\n</ul>\n<hr>\n<p>参考文献:<br>1.<a href=\"http://www.jianshu.com/p/f3c1b920e8eb\" target=\"_blank\" rel=\"noopener\">iOS程序中的内存分配</a><br>2.<a href=\"http://www.jianshu.com/p/7bbbe5d55440\" target=\"_blank\" rel=\"noopener\">深入浅出-iOS内存分配</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"属性的修饰符解析","url":"http://hchong.net/2016/09/16/属性的修饰符解析/","content":"<h1 id=\"属性的修饰符解析\"><a href=\"#属性的修饰符解析\" class=\"headerlink\" title=\"属性的修饰符解析\"></a>属性的修饰符解析</h1><h2 id=\"属性的修饰符\"><a href=\"#属性的修饰符\" class=\"headerlink\" title=\"属性的修饰符\"></a>属性的修饰符</h2><ol>\n<li>线程安全的: atomic, nonatomic </li>\n<li>访问权限的: readonly， readwrite </li>\n<li>内存管理（ARC）: assign，strong，weak，copy </li>\n<li>内存管理（MRC）:assign， retain，copy </li>\n<li>指定方法名称: setter= getter=</li>\n</ol>\n<hr>\n<p>默认的修饰符是:</p>\n<ul>\n<li>基本数据类型使用<code>atomic</code>, <code>readwrite</code>, <code>assign</code>.</li>\n<li>对于普通的Objective-C对象使用<code>atomic</code>, <code>readwrite</code>, <code>strong</code>.</li>\n</ul>\n<h2 id=\"weak-amp-assign\"><a href=\"#weak-amp-assign\" class=\"headerlink\" title=\"weak &amp; assign\"></a>weak &amp; assign</h2><p>assign修饰基本数据类型和结构体, weak修饰一个对象</p>\n<hr>\n<p>assign修饰的对象编译时会产生一个警告:Assigning retained object to unsafe_unretained variable; object will be released after assignment(Assign修饰的对象无法被保留). 并且在释放之后指针的地址还是存在的, 也就是说指针并没有被置为nil, 造成野指针. 对象分配一般分配在堆上的某块内存(详见<a href=\"http://hchong.net/2016/09/18/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/\">内存分配</a>), 如果在后续的内存分配中, 刚好分到了这块地址, 程序就会导致EXC_BAD_ACCESS(调用已释放的内存空间)崩溃掉.</p>\n<p>assign修饰的基本数据类型或者结构体因为技术数据类型和结构体一般分配在栈上, 栈的内存会由系统自己自动处理, 不会造成野指针.</p>\n<hr>\n<p>weak修饰的对象在释放之后, 指针会被置为nil, 所以一般弱引用指的就是用weak.</p>\n<p>weak主要使用在以下两个方面:</p>\n<ul>\n<li>在ARC下, 有可能出现循环引用的地方, 比如delegate<br><code>@property (nonatomic, weak) id XXXDelegate;</code></li>\n<li>自身已经被强引用过一次, 比如xib文件汇总的属性<br><code>@property (nonatomic, weak) IBOutlet UIButton *button;</code></li>\n</ul>\n<hr>\n<h2 id=\"copy关键字的使用\"><a href=\"#copy关键字的使用\" class=\"headerlink\" title=\"copy关键字的使用\"></a>copy关键字的使用</h2><p>copy和strong一样都会使引用计数加1, 但是strong是两个指针指向同一个内训地址, copy则会在内存里拷贝一份对象, 两个指针指向不同的内存地址.</p>\n<p>copy关键字主要有以下使用场景:</p>\n<ul>\n<li>不确定赋值过程中用的是可变还是不可变的变量. 例如NSString, NSArray, NSDictionary等等常使用关键字copy, 因为他们有对应的可变类型.<a href=\"http://hchong.net/2016/09/21/%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B9%8Bcopy%E5%92%8Cstrong/\">关于copy和strong的详解</a></li>\n<li>block也经常使用copy关键字. 用copy修饰block时要知道是在ARC还是MRC.<ul>\n<li>ARC下只要block访问了外部局部变量, block就会放到堆区里面, 使用strong或者copy都可以, 但是strong的性能可能会更好.</li>\n<li>MRC下, 如果block访问外部局部变量, block是在栈区的. 如果block访问了一个整个APP生命周期都存在的变量, 那他肯定在全局区. 只有使用copy属性才能把block放到堆区.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>参考内容:<br>1.<a href=\"http://www.jianshu.com/p/3e0f12e5faaa\" target=\"_blank\" rel=\"noopener\">@property 关键字的区别详解</a><br>2.<a href=\"http://bihongbo.com/2014/05/20/IOSassignandweak/\" target=\"_blank\" rel=\"noopener\">iOS开发中ARC下的assign和weak区别</a><br>3.<a href=\"http://www.jianshu.com/p/3aa1c650a967\" target=\"_blank\" rel=\"noopener\">整理一下OC中的那些属性修饰符</a><br>4.<a href=\"http://blog.csdn.net/qq_32744055/article/details/53443805\" target=\"_blank\" rel=\"noopener\">@property 后面可以有哪些修饰符</a></p>\n","categories":["基础知识"],"tags":["基础知识"]},{"title":"Hello World","url":"http://hchong.net/2016/08/16/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"Wiki","url":"http://hchong.net/Wiki/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://hchong.net/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://hchong.net/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://hchong.net/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://hchong.net/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://hchong.net/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://hchong.net/tag/index.html","content":"","categories":[],"tags":[]}]